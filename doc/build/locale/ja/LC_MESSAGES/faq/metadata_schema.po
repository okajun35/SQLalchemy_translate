# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../faq/metadata_schema.rst:3
msgid "MetaData / Schema"
msgstr "メタデータ/スキーマ"

#: ../../faq/metadata_schema.rst:13
msgid ""
"My program is hanging when I say ``table.drop()`` / "
"``metadata.drop_all()``"
msgstr "私のプログラムは `` table.drop（） `` / `` metadata.drop_all（） ``"

#: ../../faq/metadata_schema.rst:15
msgid ""
"This usually corresponds to two conditions: 1. using PostgreSQL, which is"
" really strict about table locks, and 2. you have a connection still open"
" which contains locks on the table and is distinct from the connection "
"being used for the DROP statement.  Heres the most minimal version of the"
" pattern::"
msgstr "これは、通常、次の2つの条件に対応します。1. PostgreSQLを使用する。これはテーブルロックについて厳密に厳密なものである。2. DROPステートメントで使用されている接続とは異なる、テーブルのロックを含む接続がまだ開いている。パターンの最小限のバージョンを得ます::"

#: ../../faq/metadata_schema.rst:25
msgid ""
"Above, a connection pool connection is still checked out; furthermore, "
"the result object above also maintains a link to this connection.  If "
"\"implicit execution\" is used, the result will hold this connection "
"opened until the result object is closed or all rows are exhausted."
msgstr "上記の場合、接続プールの接続はまだチェックアウトされています。さらに、上記の結果オブジェクトは、この接続へのリンクも保持します。 \ &quot;暗黙の実行\&quot;が使用されている場合、結果は、結果オブジェクトがクローズされるまで、またはすべての行が使い果たされるまで、この接続を保持します。"

#: ../../faq/metadata_schema.rst:30
msgid ""
"The call to ``mytable.drop(engine)`` attempts to emit DROP TABLE on a "
"second connection procured from the :class:`.Engine` which will lock."
msgstr "`` mytable.drop（engine） ``の呼び出しは、ロックされる：class： `.Engine`から調達された2番目の接続でDROP TABLEを送出しようとします。"

#: ../../faq/metadata_schema.rst:33
msgid "The solution is to close out all connections before emitting DROP TABLE::"
msgstr "解決策は、すべての接続を閉じてからDROP TABLE ::を発行することです"

#: ../../faq/metadata_schema.rst:48
msgid ""
"Does SQLAlchemy support ALTER TABLE, CREATE VIEW, CREATE TRIGGER, Schema "
"Upgrade Functionality?"
msgstr "SQLAlchemyは、ALTER TABLE、CREATE VIEW、CREATE TRIGGER、Schema Upgrade Functionalityをサポートしていますか？"

#: ../../faq/metadata_schema.rst:51
msgid ""
"General ALTER support isn't present in SQLAlchemy directly.  For special "
"DDL on an ad-hoc basis, the :class:`.DDL` and related constructs can be "
"used. See :doc:`core/ddl` for a discussion on this subject."
msgstr "一般的なALTERサポートは、SQLAlchemyには直接存在しません。アドホックベースの特別なDDLの場合、：class： `.DDL`とそれに関連する構造体を使用できます。この件に関する議論については、doc： `core / ddl`を参照してください。"

#: ../../faq/metadata_schema.rst:55
msgid ""
"A more comprehensive option is to use schema migration tools, such as "
"Alembic or SQLAlchemy-Migrate; see :ref:`schema_migrations` for "
"discussion on this."
msgstr "より包括的なオプションは、AlembicやSQLAlchemy-Migrateなどのスキーマ移行ツールを使用することです。これについての議論は：ref： `schema_migrations`を参照してください。"

#: ../../faq/metadata_schema.rst:59
msgid "How can I sort Table objects in order of their dependency?"
msgstr "依存関係の順序でテーブルオブジェクトをどのようにソートできますか？"

#: ../../faq/metadata_schema.rst:61
msgid "This is available via the :attr:`.MetaData.sorted_tables` function::"
msgstr "これは：attr： `.MetaData.sorted_tables`関数で利用できます::"

#: ../../faq/metadata_schema.rst:70
msgid "How can I get the CREATE TABLE/ DROP TABLE output as a string?"
msgstr "CREATE TABLE / DROP TABLEの出力を文字列として取得するにはどうすればよいですか？"

#: ../../faq/metadata_schema.rst:72
msgid ""
"Modern SQLAlchemy has clause constructs which represent DDL operations. "
"These can be rendered to strings like any other SQL expression::"
msgstr "現代のSQLAlchemyには、DDL操作を表す節構造があります。これらは他のSQL式のように文字列にレンダリングすることができます::"

#: ../../faq/metadata_schema.rst:79
msgid "To get the string specific to a certain engine::"
msgstr "特定のエンジン固有の文字列を取得する::"

#: ../../faq/metadata_schema.rst:83
msgid ""
"There's also a special form of :class:`.Engine` that can let you dump an "
"entire metadata creation sequence, using this recipe::"
msgstr "このレシピを使用してメタデータ作成シーケンス全体をダンプできる特別な形式の：class： `.Engine`もあります::"

#: ../../faq/metadata_schema.rst:91
msgid ""
"The `Alembic <https://bitbucket.org/zzzeek/alembic>`_ tool also supports "
"an \"offline\" SQL generation mode that renders database migrations as "
"SQL scripts."
msgstr "「アレムビア<https://bitbucket.org/zzzeek/alembic> `_ toolは、データベース移行をSQL​​スクリプトとしてレンダリングする\&quot;オフライン\ &quot;SQL生成モードもサポートしています。"

#: ../../faq/metadata_schema.rst:95
msgid ""
"How can I subclass Table/Column to provide certain "
"behaviors/configurations?"
msgstr "特定の動作/構成を提供するために、テーブル/列をサブクラス化するにはどうすればよいですか？"

#: ../../faq/metadata_schema.rst:97
msgid ""
":class:`.Table` and :class:`.Column` are not good targets for direct "
"subclassing. However, there are simple ways to get on-construction "
"behaviors using creation functions, and behaviors related to the linkages"
" between schema objects such as constraint conventions or naming "
"conventions using attachment events. An example of many of these "
"techniques can be seen at `Naming Conventions "
"<http://www.sqlalchemy.org/trac/wiki/UsageRecipes/NamingConventions>`_."
msgstr "：class： `.Table`と：class：` .Column`は直接サブクラス化の良いターゲットではありません。ただし、作成関数を使用して構築時のビヘイビアを取得する簡単な方法や、スキーマ・オブジェクト間のリンケージに関連するビヘイビア（アタッチ・イベントを使用した命名規則など）があります。これらの技術の多くの例は、「命名規則」 <http://www.sqlalchemy.org/trac/wiki/UsageRecipes/NamingConventions> `_。"


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../faq/connections.rst:2
msgid "Connections / Engines"
msgstr "接続/エンジン"

#: ../../faq/connections.rst:11
msgid "How do I configure logging?"
msgstr "どのようにログを設定するのですか？"

#: ../../faq/connections.rst:13
msgid "See :ref:`dbengine_logging`."
msgstr "参照：ref： `dbengine_logging`を参照してください。"

#: ../../faq/connections.rst:16
msgid "How do I pool database connections?   Are my connections pooled?"
msgstr "データベース接続をプールするにはどうすればいいですか？私の接続はプールされていますか？"

#: ../../faq/connections.rst:18
msgid ""
"SQLAlchemy performs application-level connection pooling automatically in"
" most cases.  With the exception of SQLite, a :class:`.Engine` object "
"refers to a :class:`.QueuePool` as a source of connectivity."
msgstr "ほとんどの場合、SQLAlchemyはアプリケーションレベルの接続プーリングを自動的に実行します。 SQLiteを除いて、：class： `.Engine`オブジェクトは接続のソースとして：class：` .QueuePool`を参照します。"

#: ../../faq/connections.rst:22
msgid "For more detail, see :ref:`engines_toplevel` and :ref:`pooling_toplevel`."
msgstr "詳細は、ref： `engines_toplevel`と：ref：` pooling_toplevel`を参照してください。"

#: ../../faq/connections.rst:25
msgid "How do I pass custom connect arguments to my database API?"
msgstr "データベースAPIにカスタム接続引数を渡すにはどうすればよいですか？"

#: ../../faq/connections.rst:27
msgid ""
"The :func:`.create_engine` call accepts additional arguments either "
"directly via the ``connect_args`` keyword argument::"
msgstr "：func： `.create_engine`呼び出しは、` `connect_args``キーワード引数を介して直接的に追加の引数を受け取ります::"

#: ../../faq/connections.rst:33
msgid ""
"Or for basic string and integer arguments, they can usually be specified "
"in the query string of the URL::"
msgstr "基本的な文字列と整数の引数については、通常、URLのクエリ文字列で指定することができます::"

#: ../../faq/connections.rst:40
msgid ":ref:`custom_dbapi_args`"
msgstr "：ref： `custom_dbapi_args`"

#: ../../faq/connections.rst:43
msgid "\"MySQL Server has gone away\""
msgstr "\ &quot;MySQLサーバーがなくなった\"

#: ../../faq/connections.rst:45
msgid ""
"The primary cause of this error is that the MySQL connection has timed "
"out and has been closed by the server.   The MySQL server closes "
"connections which have been idle a period of time which defaults to eight"
" hours. To accommodate this, the immediate setting is to enable the "
":paramref:`.create_engine.pool_recycle` setting, which will ensure that a"
" connection which is older than a set amount of seconds will be discarded"
" and replaced with a new connection when it is next checked out."
msgstr "このエラーの主な原因は、MySQL接続がタイムアウトしてサーバーによって閉じられていることです。 MySQLサーバは、アイドル状態の接続をデフォルトで8時間閉鎖します。これに対処するために、直ちに設定することは：paramref： `.create_engine.pool_recycle`設定を有効にすることです。これにより、設定された秒数よりも古い接続が破棄され、次の接続時に新しい接続に置き換えられますチェックアウトされた。"

#: ../../faq/connections.rst:53
msgid ""
"For the more general case of accommodating database restarts and other "
"temporary loss of connectivity due to network issues, connections that "
"are in the pool may be recycled in response to more generalized "
"disconnect detection techniques.  The section :ref:`pool_disconnects` "
"provides background on both \"pessimistic\" (e.g. pre-ping) and "
"\"optimistic\" (e.g. graceful recovery) techniques.   Modern SQLAlchemy "
"tends to favor the \"pessimistic\" approach."
msgstr "データベースの再起動やネットワークの問題による一時的な接続喪失に対処するより一般的なケースでは、プール内の接続は、より一般化された切断検出テクニックに対応してリサイクルされる可能性があります。セクション：ref： `pool_disconnects`は、\&quot;悲観的な\ &quot;（例：プレping）と\&quot;楽観的\ &quot;（例：優雅な回復）の両方のテクニックについての背景を提供します。現代のSQLAlchemyは、「悲観的な」アプローチを支持する傾向があります。"

#: ../../faq/connections.rst:63
msgid ":ref:`pool_disconnects`"
msgstr "：ref： `pool_disconnects`"

#: ../../faq/connections.rst:68
msgid ""
"\"Commands out of sync; you can't run this command now\" / \"This result "
"object does not return rows. It has been closed automatically\""
msgstr "\ &quot;コマンドが同期していない;このコマンドを現在実行できません\&quot; / \ &quot;この結果オブジェクトは行を返しません。"

#: ../../faq/connections.rst:70
msgid ""
"The MySQL drivers have a fairly wide class of failure modes whereby the "
"state of the connection to the server is in an invalid state.  Typically,"
" when the connection is used again, one of these two error messages will "
"occur.    The reason is because the state of the server has been changed "
"to one in which the client library does not expect, such that when the "
"client library emits a new statement on the connection, the server does "
"not respond as expected."
msgstr "MySQLドライバにはかなりの種類の障害モードがあり、それによってサーバへの接続状態が無効な状態になります。通常、接続を再度使用すると、これら2つのエラーメッセージのいずれかが発生します。理由は、サーバーの状態がクライアント・ライブラリーが予期しないものに変更されたためです。そのため、クライアント・ライブラリーが接続で新しいステートメントを発行すると、サーバーは期待どおりに応答しません。"

#: ../../faq/connections.rst:77
msgid ""
"In SQLAlchemy, because database connections are pooled, the issue of the "
"messaging being out of sync on a connection becomes more important, since"
" when an operation fails, if the connection itself is in an unusable "
"state, if it goes back into the connection pool, it will malfunction when"
" checked out again.  The mitigation for this issue is that the connection"
" is **invalidated** when such a failure mode occurs so that the "
"underlying database connection to MySQL is discarded. This invalidation "
"occurs automatically for many known failure modes and can also be called "
"explicitly via the :meth:`.Connection.invalidate` method."
msgstr "SQLAlchemyでは、データベース接続がプールされているため、接続でメッセージが同期しなくなる問題がより重要になります。操作が失敗した場合、接続自体が使用不可能な状態になった場合、接続プールに戻った場合、再度チェックアウトすると誤動作します。この問題の軽減策は、そのような障害モードが発生したときに接続が**無効化され**、MySQLへのデータベース接続が破棄されることです。この無効化は多くの既知の障害モードで自動的に発生し、また：meth： `.Connection.invalidate`メソッドを介して明示的に呼び出すこともできます。"

#: ../../faq/connections.rst:86
msgid ""
"There is also a second class of failure modes within this category where "
"a context manager such as ``with session.begin_nested():`` wants to "
"\"roll back\" the transaction when an error occurs; however within some "
"failure modes of the connection, the rollback itself (which can also be a"
" RELEASE SAVEPOINT operation) also fails, causing misleading stack "
"traces."
msgstr "このカテゴリには、 `` with session.begin_nested（）： ``などのコンテキストマネージャが、エラーが発生したときにトランザクションをロールバックしたいという第2のクラスの失敗モードもあります。しかし、接続のいくつかの障害モードでは、ロールバック自体（リリースSAVEPOINT操作でもあり得る）も失敗し、誤ったスタックトレースを引き起こします。"

#: ../../faq/connections.rst:92
msgid ""
"Originally, the cause of this error used to be fairly simple, it meant "
"that a multithreaded program was invoking commands on a single connection"
" from more than one thread.   This applied to the original \"MySQLdb\" "
"native-C driver that was pretty much the only driver in use.   However, "
"with the introduction of pure Python drivers like PyMySQL and MySQL-"
"connector-Python, as well as increased use of tools such as "
"gevent/eventlet, multiprocessing (often with Celery), and others, there "
"is a whole series of factors that has been known to cause this problem, "
"some of which have been improved across SQLAlchemy versions but others "
"which are unavoidable:"
msgstr "もともと、このエラーの原因はかなり単純でしたが、それはマルチスレッドプログラムが複数のスレッドからの単一の接続でコマンドを呼び出すことを意味していました。これは、使用されている唯一のドライバであった元の\ &quot;MySQLdb \&quot;ネイティブCドライバに適用されます。しかし、PyMySQLやMySQL-connector-Pythonのような純粋なPythonドライバの導入や、gevent / eventlet、マルチプロセッシング（しばしばCelery）などのツールの使用の増加とともに、この問題を引き起こすことが知られていますが、その中にはSQLAlchemyのバージョン間で改善されているものもあれば、避けられないものもあります。"

#: ../../faq/connections.rst:101
msgid ""
"**Sharing a connection among threads** - This is the original reason "
"these kinds of errors occurred.  A program used the same connection in "
"two or more threads at the same time, meaning multiple sets of messages "
"got mixed up on the connection, putting the server-side session into a "
"state that the client no longer knows how to interpret.   However, other "
"causes are usually more likely today."
msgstr "**スレッド間の接続の共有**  - これが、この種のエラーが発生した元の理由です。プログラムは2つ以上のスレッドで同時に同じ接続を使用しました。これは、複数のメッセージセットが接続上で混在していることを意味し、クライアントがもはや解釈する方法を知らない状態にサーバー側セッションを置きます。しかし、今日は通常、他の原因が考えられます。"

#: ../../faq/connections.rst:107
msgid ""
"**Sharing the filehandle for the connection among processes** - This "
"usually occurs when a program uses ``os.fork()`` to spawn a new process, "
"and a TCP connection that is present in th parent process gets shared "
"into one or more child processes. As multiple processes are now emitting "
"messages to essentially the same filehandle, the server receives "
"interleaved messages and breaks the state of the connection."
msgstr "**プロセス間の接続のためのファイルハンドルの共有**  - これは通常、プログラムが `` os.fork（） ``を使用して新しいプロセスを生成し、親プロセスに存在するTCP接続が1つのプロセスに共有されるまたはそれ以上の子プロセス。複数のプロセスが本質的に同じファイルハンドルにメッセージを発信しているので、サーバーはインターリーブされたメッセージを受信し、接続の状態を解除します。"

#: ../../faq/connections.rst:113
msgid ""
"This scenario can occur very easily if a program uses Python's "
"\"multiprocessing\" module and makes use of an :class:`.Engine` that was "
"created in the parent process.  It's common that \"multiprocessing\" is "
"in use when using tools like Celery.  The correct approach should be "
"either that a new :class:`.Engine` is produced when a child process first"
" starts, discarding any :class:`.Engine` that came down from the parent "
"process; or, the :class:`.Engine` that's inherited from the parent "
"process can have it's internal pool of connections disposed by calling "
":meth:`.Engine.dispose`."
msgstr "このシナリオは、プログラムがPythonの\ &quot;マルチプロセッシング\&quot;モジュールを使用し、親プロセスで作成された：class： `.Engine`を使用すると非常に簡単に発生します。 Celeryのようなツールを使うときは、\ &quot;マルチプロセッシング\&quot;が使われているのが一般的です。正しいアプローチは、新しい：class： `.Engine`が子プロセスが最初に起動するときに生成され、親プロセスから来たclass：` .Engine`を破棄するか、親プロセスから継承された：class： `.Engine`は、：meth：` .Engine.dispose`を呼び出すことで、内部接続プールを持つことができます。"

#: ../../faq/connections.rst:122
msgid ""
"**Greenlet Monkeypatching w/ Exits** - When using a library like gevent "
"or eventlet that monkeypatches the Python networking API, libraries like "
"PyMySQL are now working in an asynchronous mode of operation, even though"
" they are not developed explicitly against this model.  A common issue is"
" that a greenthread is interrupted, often due to timeout logic in the "
"application.  This results in the ``GreenletExit`` exception being "
"raised, and the pure-Python MySQL driver is interrupted from its work, "
"which may have been that it was receiving a response from the server or "
"preparing to otherwise reset the state of the connection.   When the "
"exception cuts all that work short, the conversation between client and "
"server is now out of sync and subsequent usage of the connection may "
"fail.   SQLAlchemy as of version 1.1.0 knows how to guard against this, "
"as if a database operation is interrupted by a so-called \"exit "
"exception\", which includes ``GreenletExit`` and any other subclass of "
"Python ``BaseException`` that is not also a subclass of ``Exception``, "
"the connection is invalidated."
msgstr "PythonのネットワーキングAPIをmonkeypatchesするgeventやeventletのようなライブラリを使うとき、PyMySQLのようなライブラリは、このモデルに対して明示的に開発されていなくても非同期操作モードで動作するようになりました。一般的な問題は、アプリケーションのタイムアウトロジックのために、greenthreadが中断されることです。この結果、 `` GreenletExit``例外が発生し、純粋なPython MySQLドライバは、サーバからの応答を受け取っていたか、そうでなければ接続の状態をリセットする準備ができている可能性があります。例外がすべての作業を短くすると、クライアントとサーバーの間の会話が同期しなくなり、その後の接続の使用が失敗する可能性があります。バージョン1.1.0のSQLAlchemyは、データベース操作が、いわゆる &quot;終了例外&quot;によって中断されたかのように、これを防ぐ方法を知っています。これには、 &quot;GreenletExit&quot;とPythonの &quot;BaseException&quot; `それは` `Exception``のサブクラスでもないので、接続は無効になります。"

#: ../../faq/connections.rst:137
msgid ""
"**Rollbacks / SAVEPOINT releases failing** - Some classes of error cause "
"the connection to be unusable within the context of a transaction, as "
"well as when operating in a \"SAVEPOINT\" block.  In these cases, the "
"failure on the connection has rendered any SAVEPOINT as no longer "
"existing, yet when SQLAlchemy, or the application, attempts to \"roll "
"back\" this savepoint, the \"RELEASE SAVEPOINT\" operation fails, "
"typically with a message like \"savepoint does not exist\".   In this "
"case, under Python 3 there will be a chain of exceptions output, where "
"the ultimate \"cause\" of the error will be displayed as well.  Under "
"Python 2, there are no \"chained\" exceptions, however recent versions of"
" SQLAlchemy will attempt to emit a warning illustrating the original "
"failure cause, while still throwing the immediate error which is the "
"failure of the ROLLBACK."
msgstr "** Rollbacks / SAVEPOINTリリースの失敗**  - いくつかのクラスのエラーは、トランザクションが「SAVEPOINT」ブロックで動作しているときだけでなく、そのコンテキスト内でも接続を使用できないようにします。このような場合、接続の失敗によりSAVEPOINTは存在しなくなりましたが、SQLAlchemyまたはアプリケーションがこのセーブポイントを &quot;ロールバック&quot;しようとすると、\ &quot;RELEASE SAVEPOINT \&quot;操作は失敗します。 \ &quot;セーブポイントが存在しません\&quot;のようなメッセージです。この場合、Python 3では、エラーの最終的な &quot;原因&quot;も表示される一連の例外出力があります。 Python 2では、\ &quot;連鎖\&quot;例外はありませんが、SQLAlchemyの最近のバージョンでは、元のエラーの原因を示す警告を出そうとしますが、ROLLBACKの失敗である即時のエラーをスローします。"

#: ../../faq/connections.rst:152
msgid "Why does SQLAlchemy issue so many ROLLBACKs?"
msgstr "なぜSQLAlchemyは非常に多くのROLLBACKを発行しますか？"

#: ../../faq/connections.rst:154
msgid ""
"SQLAlchemy currently assumes DBAPI connections are in \"non-autocommit\" "
"mode - this is the default behavior of the Python database API, meaning "
"it must be assumed that a transaction is always in progress. The "
"connection pool issues ``connection.rollback()`` when a connection is "
"returned. This is so that any transactional resources remaining on the "
"connection are released. On a database like PostgreSQL or MSSQL where "
"table resources are aggressively locked, this is critical so that rows "
"and tables don't remain locked within connections that are no longer in "
"use. An application can otherwise hang. It's not just for locks, however,"
" and is equally critical on any database that has any kind of transaction"
" isolation, including MySQL with InnoDB. Any connection that is still "
"inside an old transaction will return stale data, if that data was "
"already queried on that connection within isolation. For background on "
"why you might see stale data even on MySQL, see "
"http://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html"
msgstr "SQLAlchemyは現在、DBAPI接続が\ &quot;非自動コミット\&quot;モードであると想定しています。これはPythonデータベースAPIのデフォルトの動作です。つまり、トランザクションが常に進行中であることが前提です。接続プールは、接続が返されたときに `` connection.rollback（） ``を発行します。これは、接続に残っているトランザクションリソースがすべて解放されるようにするためです。 PostgreSQLやMSSQLのようなテーブルリソースが積極的にロックされているデータベースでは、使用されなくなった接続内で行やテーブルがロックされないようにすることが重要です。それ以外の場合は、アプリケーションがハングアップする可能しかし、ロックだけでなく、MySQLを含むInnoDBを含むあらゆる種類のトランザクション分離を持つデータベースでも同様に重要です。古いトランザクション内にまだ存在する接続は、そのデータがすでに分離内で照会されていた場合は失効したデータを返します。 MySQLで古いデータが表示される理由については、http：//dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.htmlを参照してください。"

#: ../../faq/connections.rst:170
msgid "I'm on MyISAM - how do I turn it off?"
msgstr "私はMyISAMにいます - どうすればいいですか？"

#: ../../faq/connections.rst:172
msgid ""
"The behavior of the connection pool's connection return behavior can be "
"configured using ``reset_on_return``::"
msgstr "接続プールの接続戻り動作の動作は、 `` reset_on_return`` ::"

#: ../../faq/connections.rst:181
msgid "I'm on SQL Server - how do I turn those ROLLBACKs into COMMITs?"
msgstr "SQL Serverを使用しています。これらのROLLBACKをCOMMITに変換するにはどうすればよいですか？"

#: ../../faq/connections.rst:183
msgid ""
"``reset_on_return`` accepts the values ``commit``, ``rollback`` in "
"addition to ``True``, ``False``, and ``None``.   Setting to ``commit`` "
"will cause a COMMIT as any connection is returned to the pool::"
msgstr "`` reset_on_return``は `` True`````````````````````````````````````````に加えて `` commit````、 `` rollback``を受け入れます。 `` commit``に設定すると、プールに接続が返されるたびにCOMMITが発生します::"

#: ../../faq/connections.rst:191
msgid ""
"I am using multiple connections with a SQLite database (typically to test"
" transaction operation), and my test program is not working!"
msgstr "SQLiteデータベースで複数の接続を使用しています（通常はトランザクション操作をテストします）、テストプログラムが動作していません。"

#: ../../faq/connections.rst:193
msgid ""
"If using a SQLite ``:memory:`` database, or a version of SQLAlchemy prior"
" to version 0.7, the default connection pool is the "
":class:`.SingletonThreadPool`, which maintains exactly one SQLite "
"connection per thread.  So two connections in use in the same thread will"
" actually be the same SQLite connection.   Make sure you're not using a "
":memory: database and use :class:`.NullPool`, which is the default for "
"non-memory databases in current SQLAlchemy versions."
msgstr "SQLiteの ``：memory： ``データベース、またはバージョン0.7より前のバージョンのSQLAlchemyを使用している場合、デフォルトの接続プールは：class： `.SingletonThreadPool`です。スレッドごとに1つのSQLite接続を維持します。したがって、同じスレッドで使用されている2つの接続は、実際には同じSQLite接続になります。 ：memory：データベースを使用せずに、：class： `.NullPool`を使用してください。これは、現在のSQLAlchemyバージョンの非メモリデータベースのデフォルトです。"

#: ../../faq/connections.rst:203
msgid ":ref:`pysqlite_threading_pooling` - info on PySQLite's behavior."
msgstr "：ref： `pysqlite_threading_pooling`  -  PySQLiteの動作に関する情報です。"

#: ../../faq/connections.rst:206
msgid "How do I get at the raw DBAPI connection when using an Engine?"
msgstr "エンジンを使用している場合、未処理のDBAPI接続を取得するにはどうすればよいですか？"

#: ../../faq/connections.rst:208
msgid ""
"With a regular SA engine-level Connection, you can get at a pool-proxied "
"version of the DBAPI connection via the :attr:`.Connection.connection` "
"attribute on :class:`.Connection`, and for the really-real DBAPI "
"connection you can call the :attr:`.ConnectionFairy.connection` attribute"
" on that - but there should never be any need to access the non-pool-"
"proxied DBAPI connection, as all methods are proxied through::"
msgstr "通常のSAエンジンレベルのConnectionでは、：class： `.Connection`の：attr：` .Connection.connection`属性を使用してDBAPI接続のプールプロキシバージョンを取得できます。実際のDBAPI接続には：attr： `.ConnectionFairy.connection`属性を呼び出すことができますが、プールされていないDBAPI接続にはアクセスする必要がありません。すべてのメソッドは、"

#: ../../faq/connections.rst:219
msgid ""
"You must ensure that you revert any isolation level settings or other "
"operation-specific settings on the connection back to normal before "
"returning it to the pool."
msgstr "プールに戻す前に、分離レベル設定または接続の他の操作固有の設定を通常に戻す必要があります。"

#: ../../faq/connections.rst:223
msgid ""
"As an alternative to reverting settings, you can call the "
":meth:`.Connection.detach` method on either :class:`.Connection` or the "
"proxied connection, which will de-associate the connection from the pool "
"such that it will be closed and discarded when :meth:`.Connection.close` "
"is called::"
msgstr "設定を元に戻す代わりに、：class： `.Connection`またはプロキシ接続のどちらかで：meth：` .Connection.detach`メソッドを呼び出すことができます。閉じられ、破棄されたとき：meth： `.Connection.close`が呼び出される::"

#: ../../faq/connections.rst:234
msgid ""
"How do I use engines / connections / sessions with Python "
"multiprocessing, or os.fork()?"
msgstr "Pythonのマルチプロセッシング、またはos.fork（）でエンジン/接続/セッションを使用するにはどうすればよいですか？"

#: ../../faq/connections.rst:236
msgid ""
"The key goal with multiple python processes is to prevent any database "
"connections from being shared across processes.   Depending on specifics "
"of the driver and OS, the issues that arise here range from non-working "
"connections to socket connections that are used by multiple processes "
"concurrently, leading to broken messaging (the latter case is typically "
"the most common)."
msgstr "複数のPythonプロセスの重要な目標は、データベース接続がプロセス間で共有されないようにすることです。ドライバやOSの仕様によっては、動作しない接続から複数のプロセスで同時に使用されるソケット接続に至るまでの問題があり、メッセージングが壊れています（後者の場合が一般的です）。"

#: ../../faq/connections.rst:242
msgid ""
"The SQLAlchemy :class:`.Engine` object refers to a connection pool of "
"existing database connections.  So when this object is replicated to a "
"child process, the goal is to ensure that no database connections are "
"carried over.  There are three general approaches to this:"
msgstr "SQLAlchemy：class： `.Engine`オブジェクトは、既存のデータベース接続の接続プールを参照します。したがって、このオブジェクトが子プロセスに複製されるとき、目標はデータベース接続が引き継がれないようにすることです。これには3つの一般的なアプローチがあります："

#: ../../faq/connections.rst:247
msgid ""
"Disable pooling using :class:`.NullPool`.  This is the most simplistic, "
"one shot system that prevents the :class:`.Engine` from using any "
"connection more than once."
msgstr "：class： `.NullPool`を使用してプールを無効にします。これは：class： `.Engine`が何度も何らかの接続を使用するのを防ぐ最もシンプルなワンショットシステムです。"

#: ../../faq/connections.rst:251
msgid ""
"Call :meth:`.Engine.dispose` on any given :class:`.Engine` as soon one is"
" within the new process.  In Python multiprocessing, constructs such as "
"``multiprocessing.Pool`` include \"initializer\" hooks which are a place "
"that this can be performed; otherwise at the top of where ``os.fork()`` "
"or where the ``Process`` object begins the child fork, a single call to "
":meth:`.Engine.dispose` will ensure any remaining connections are "
"flushed."
msgstr "`` .Engine``を新しいプロセスの中に入れたらすぐに：meth： `.Engine.dispose`：class：` .Engine`を呼び出してください。 Pythonのマルチプロセッシングでは、 `` multiprocessing.Pool``のような構造体には、これを実行できる場所である &quot;初期化子&quot;フックが含まれています。そうでなければ、 `` os.fork（） ``のどこか、または `` Process``オブジェクトが子のforkを開始するところで、：meth： `.Engine.dispose`を一回呼び出すことで残りの接続が確実にフラッシュされます。"

#: ../../faq/connections.rst:258
msgid ""
"An event handler can be applied to the connection pool that tests for "
"connections being shared across process boundaries, and invalidates them."
"  This looks like the following::"
msgstr "イベントハンドラは、プロセス境界で共有される接続をテストし、無効にする接続プールに適用できます。これは次のようになります::"

#: ../../faq/connections.rst:297
msgid "These events are applied to an :class:`.Engine` as soon as its created::"
msgstr "これらのイベントは、作成されるとすぐに：class： `.Engine`に適用されます。"

#: ../../faq/connections.rst:303
msgid ""
"The above strategies will accommodate the case of an :class:`.Engine` "
"being shared among processes.  However, for the case of a transaction-"
"active :class:`.Session` or :class:`.Connection` being shared, there's no"
" automatic fix for this; an application needs to ensure a new child "
"process only initiate new :class:`.Connection` objects and transactions, "
"as well as ORM :class:`.Session` objects.  For a :class:`.Session` "
"object, technically this is only needed if the session is currently "
"transaction-bound, however the scope of a single :class:`.Session` is in "
"any case intended to be kept within a single call stack in any case (e.g."
" not a global object, not shared between processes or threads)."
msgstr "上記の戦略は：class： `.Engine`がプロセス間で共有されるケースに対応します。しかし、transaction-active：class： `.Session`や：class：` .Connection`が共有されている場合は、このための自動修正はありません。アプリケーションは新しい子プロセスがORM：class： `.Session`オブジェクトだけでなく、新しい：class：` .Connection`オブジェクトとトランザクションを開始するようにする必要があります。 a：class： `.Session`オブジェクトの場合、これは技術的にはセッションが現在トランザクションにバインドされている場合にのみ必要ですが、class：` .Session`のスコープはいずれの場合でも単一の呼び出し（グローバルオブジェクトではなく、プロセスやスレッド間で共有されていないなど）。"


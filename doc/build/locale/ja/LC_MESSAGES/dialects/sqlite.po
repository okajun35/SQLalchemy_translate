# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../dialects/sqlite.rst:4
msgid "SQLite"
msgstr "SQLite"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:7
msgid "Date and Time Types"
msgstr "日付と時刻の種類"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:9
msgid ""
"SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite"
" does not provide out of the box functionality for translating values "
"between Python `datetime` objects and a SQLite-supported format. "
"SQLAlchemy's own :class:`~sqlalchemy.types.DateTime` and related types "
"provide date formatting and parsing functionality when SQlite is used. "
"The implementation classes are :class:`~.sqlite.DATETIME`, "
":class:`~.sqlite.DATE` and :class:`~.sqlite.TIME`. These types represent "
"dates and times as ISO formatted strings, which also nicely support "
"ordering. There's no reliance on typical \"libc\" internals for these "
"functions so historical dates are fully supported."
msgstr "SQLiteにはDATE、TIME、またはDATETIME型が組み込まれておらず、Pythonの `datetime`オブジェクトとSQLiteでサポートされている形式の間で値を変換する機能は用意されていません。 SQLAlchemy自身の：class： `〜sqlalchemy.types.DateTime`および関連する型は、SQliteが使用されているときに日付の書式設定と解析機能を提供します。実装クラスは、class： `〜.sqlite.DATETIME`、：class：`〜.sqlite.DATE`、：class： `〜.sqlite.TIME`です。これらのタイプは日付と時刻をISO形式の文字列として表し、順序付けもうまくサポートします。典型的な\ &quot;libc \&quot;内部関数には依存していないので、歴史的日付が完全にサポートされています。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:20
msgid "Ensuring Text affinity"
msgstr "テキストの親和性の確保"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:22
msgid ""
"The DDL rendered for these types is the standard ``DATE``, ``TIME`` and "
"``DATETIME`` indicators.    However, custom storage formats can also be "
"applied to these types.   When the storage format is detected as "
"containing no alpha characters, the DDL for these types is rendered as "
"``DATE_CHAR``, ``TIME_CHAR``, and ``DATETIME_CHAR``, so that the column "
"continues to have textual affinity."
msgstr "これらの型に対してレンダリングされるDDLは、標準の `` DATE``、 `` TIME``、および `DATETIME`のインジケータです。ただし、カスタム記憶域形式をこれらの種類に適用することもできます。格納形式がアルファベット文字を含まないものとして検出されると、これらの型のDDLは `` DATE_CHAR``、 `` TIME_CHAR``、および `` DATETIME_CHAR``としてレンダリングされ、列は引き続きテキストの親和性を持ちます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:31
msgid ""
"`Type Affinity <http://www.sqlite.org/datatype3.html#affinity>`_ - in the"
" SQLite documentation"
msgstr "`タイプアフィニティー<http://www.sqlite.org/datatype3.html#affinity> `_  -  SQLiteのドキュメント"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:36
msgid "SQLite Auto Incrementing Behavior"
msgstr "SQLite自動インクリメント動作"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:38
msgid "Background on SQLite's autoincrement is at: http://sqlite.org/autoinc.html"
msgstr "SQLiteの自動インクリメントの背景はhttp://sqlite.org/autoinc.htmlです。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:40
msgid "Key concepts:"
msgstr "主なコンセプト："

#: ../../docstring of sqlalchemy.dialects.sqlite.base:42
msgid ""
"SQLite has an implicit \"auto increment\" feature that takes place for "
"any non-composite primary-key column that is specifically created using "
"\"INTEGER PRIMARY KEY\" for the type + primary key."
msgstr "SQLiteには、タイプ+プライマリキーに &quot;INTEGER PRIMARY KEY&quot;を使用して作成された非複合プライマリキーカラムに対して暗黙の\ &quot;自動インクリメント\&quot;機能があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:46
msgid ""
"SQLite also has an explicit \"AUTOINCREMENT\" keyword, that is **not** "
"equivalent to the implicit autoincrement feature; this keyword is not "
"recommended for general use.  SQLAlchemy does not render this keyword "
"unless a special SQLite-specific directive is used (see below).  However,"
" it still requires that the column's type is named \"INTEGER\"."
msgstr "SQLiteには明示的な\ &quot;AUTOINCREMENT \&quot;キーワードがあります。**は暗黙の自動インクリメント機能と同等ではありません**。このキーワードは一般的な使用には推奨されません。 SQLAlchemyは特別なSQLite特有の指令が使われていない限り、このキーワードを表示しません（下記参照）。ただし、列の型は\ &quot;INTEGER \&quot;という名前でなければなりません。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:53
msgid "Using the AUTOINCREMENT Keyword"
msgstr "AUTOINCREMENTキーワードの使用"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:55
msgid ""
"To specifically render the AUTOINCREMENT keyword on the primary key "
"column when rendering DDL, add the flag ``sqlite_autoincrement=True`` to "
"the Table construct::"
msgstr "DDLをレンダリングするときに主キー列のAUTOINCREMENTキーワードを特にレンダリングするには、フラグ `` sqlite_autoincrement = True``を表の構造体::に追加します"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:64
msgid ""
"Allowing autoincrement behavior SQLAlchemy types other than "
"Integer/INTEGER"
msgstr "自動インクリメントの動作を許可するInteger / INTEGER以外のSQLAlchemy型"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:66
msgid ""
"SQLite's typing model is based on naming conventions.  Among other "
"things, this means that any type name which contains the substring "
"``\"INT\"`` will be determined to be of \"integer affinity\".  A type "
"named ``\"BIGINT\"``, ``\"SPECIAL_INT\"`` or even ``\"XYZINTQPR\"``, will"
" be considered by SQLite to be of \"integer\" affinity.  However, **the "
"SQLite autoincrement feature, whether implicitly or explicitly enabled, "
"requires that the name of the column's type is exactly the string "
"\"INTEGER\"**.  Therefore, if an application uses a type like "
":class:`.BigInteger` for a primary key, on SQLite this type will need to "
"be rendered as the name ``\"INTEGER\"`` when emitting the initial "
"``CREATE TABLE`` statement in order for the autoincrement behavior to be "
"available."
msgstr "SQLiteの型定義モデルは命名規則に基づいています。とりわけ、これは部分文字列 `` \ &quot;INT \&quot; `&quot;を含む型名は\ &quot;整数類似性\&quot;であると判断されることを意味します。 &quot;\&quot; BIGINT \ &quot;` `、` `\&quot; SPECIAL_INT \ &quot;` `または` `\&quot; XYZINTQPR \ &quot;` `という名前の型は、SQLiteによって\&quot;整数\ &quot;親和性であるとみなされます。ただし、**暗黙的または明示的に有効になっているSQLite自動インクリメント機能は、列の型名が文字列\ &quot;INTEGER \&quot; **であることを必要とします。したがって、アプリケーションが主キーに：class： `.BigInteger`のような型を使用する場合、SQLiteではこの型は最初の` `CREATE TABLE &#39;を発行するときに` `\&quot; INTEGER \ &quot;` `という名前でレンダリングする必要があります``ステートメントを使用して、自動インクリメントの動作を利用できるようにします。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:79
msgid ""
"One approach to achieve this is to use :class:`.Integer` on SQLite only "
"using :meth:`.TypeEngine.with_variant`::"
msgstr "これを達成するための1つのアプローチは、：meth： `.TypeEngine.with_variant` ::を使用してSQLite上で：class：` .Integer`を使用することです。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:87
msgid ""
"Another is to use a subclass of :class:`.BigInteger` that overrides its "
"DDL name to be ``INTEGER`` when compiled against SQLite::"
msgstr "もう1つは：class： `.BigInteger`のサブクラスを使用して、DDL名をSQLiteに対してコンパイルするときに` `INTEGER``にオーバーライドすることです::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:112
msgid ":meth:`.TypeEngine.with_variant`"
msgstr "：meth： `.TypeEngine.with_variant`"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:114
msgid ":ref:`sqlalchemy.ext.compiler_toplevel`"
msgstr "：ref： `sqlalchemy.ext.compiler_toplevel`"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:116
msgid "`Datatypes In SQLite Version 3 <http://sqlite.org/datatype3.html>`_"
msgstr "`SQLiteバージョン3のデータ型<http://sqlite.org/datatype3.html> `_"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:121
msgid "Database Locking Behavior / Concurrency"
msgstr "データベースのロック動作/同時実行性"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:123
msgid ""
"SQLite is not designed for a high level of write concurrency. The "
"database itself, being a file, is locked completely during write "
"operations within transactions, meaning exactly one \"connection\" (in "
"reality a file handle) has exclusive access to the database during this "
"period - all other \"connections\" will be blocked during this time."
msgstr "SQLiteは、高いレベルの書き込み同時実行性のために設計されていません。データベースそのものはファイルであり、トランザクション内の書き込み操作中に完全にロックされます。つまり、正確に1つの &quot;接続&quot;（実際にはファイルハンドル）はこの期間中にデータベースへの排他的アクセス権を持ちます。この間にブロックされます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:129
msgid ""
"The Python DBAPI specification also calls for a connection model that is "
"always in a transaction; there is no ``connection.begin()`` method, only "
"``connection.commit()`` and ``connection.rollback()``, upon which a new "
"transaction is to be begun immediately.  This may seem to imply that the "
"SQLite driver would in theory allow only a single filehandle on a "
"particular database file at any time; however, there are several factors "
"both within SQlite itself as well as within the pysqlite driver which "
"loosen this restriction significantly."
msgstr "Python DBAPI仕様では、常にトランザクション内にある接続モデルも必要です。 `` connection.begin（） ``メソッドはなく、すぐに新しいトランザクションを開始する `` connection.commit（） ``と `` connection.rollback（） ``だけがあります。これは、SQLiteドライバが理論的にはいつでも特定のデータベースファイルに対して1つのファイルハンドルしか許可しないことを意味するように見えるかもしれません。しかし、SQlite自体とpysqliteドライバ内には、この制限を大幅に緩和するいくつかの要因があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:138
msgid ""
"However, no matter what locking modes are used, SQLite will still always "
"lock the database file once a transaction is started and DML (e.g. "
"INSERT, UPDATE, DELETE) has at least been emitted, and this will block "
"other transactions at least at the point that they also attempt to emit "
"DML. By default, the length of time on this block is very short before it"
" times out with an error."
msgstr "しかし、ロックモードが使用されていても、トランザクションが開始され、DML（INSERT、UPDATE、DELETEなど）が少なくとも発行されると、SQLiteは常にデータベースファイルをロックし、少なくともその時点で他のトランザクションをブロックしますまた、DMLを発行しようとしています。デフォルトでは、このブロックの時間の長さは非常に短くなってからタイムアウトになり、エラーが発生します。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:145
msgid ""
"This behavior becomes more critical when used in conjunction with the "
"SQLAlchemy ORM.  SQLAlchemy's :class:`.Session` object by default runs "
"within a transaction, and with its autoflush model, may emit DML "
"preceding any SELECT statement.   This may lead to a SQLite database that"
" locks more quickly than is expected.   The locking mode of SQLite and "
"the pysqlite driver can be manipulated to some degree, however it should "
"be noted that achieving a high degree of write-concurrency with SQLite is"
" a losing battle."
msgstr "この動作は、SQLAlchemy ORMと組み合わせて使用​​するとより重要になります。 SQLAlchemyの：class： `.Session`オブジェクトは、デフォルトでトランザクション内で実行され、その自動フラッシュモデルでは、SELECT文の前にDMLを発行することができます。これは、予想よりも早くロックするSQLiteデータベースにつながる可能性があります。 SQLiteとpysqliteドライバのロックモードはある程度操作できますが、SQLiteで高度な書き込み同時実行を実現することは失われた戦いであることに注意してください。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:153
msgid ""
"For more information on SQLite's lack of write concurrency by design, "
"please see `Situations Where Another RDBMS May Work Better - High "
"Concurrency <http://www.sqlite.org/whentouse.html>`_ near the bottom of "
"the page."
msgstr "SQLiteの設計による書き込み同時実行性の欠如の詳細については、「別のRDBMSがうまくいく状況 - 高い並行性」を参照してください。 <http://www.sqlite.org/whentouse.html> `_ページの一番下にあります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:158
msgid ""
"The following subsections introduce areas that are impacted by SQLite's "
"file-based architecture and additionally will usually require workarounds"
" to work when using the pysqlite driver."
msgstr "以下のサブセクションでは、SQLiteのファイルベースアーキテクチャの影響を受ける領域について説明します。通常、pysqliteドライバを使用する場合は、回避策が必要です。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:165
msgid "Transaction Isolation Level"
msgstr "トランザクション分離レベル"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:167
msgid ""
"SQLite supports \"transaction isolation\" in a non-standard way, along "
"two axes.  One is that of the `PRAGMA read_uncommitted "
"<http://www.sqlite.org/pragma.html#pragma_read_uncommitted>`_ "
"instruction.   This setting can essentially switch SQLite between its "
"default mode of ``SERIALIZABLE`` isolation, and a \"dirty read\" "
"isolation mode normally referred to as ``READ UNCOMMITTED``."
msgstr "SQLiteは、2つの軸に沿って非標準的な方法で\ &quot;トランザクション分離\&quot;をサポートしています。 1つは `PRAGMA read_uncommitted <http://www.sqlite.org/pragma.html#pragma_read_uncommitted> `_命令。この設定は、基本的に `` SERIALIZABLE``分離のデフォルトモードと通常 `` READ UNCOMMITTED``と呼ばれる\ &quot;ダーティー読み込み\&quot;分離モードの間でSQLiteを切り替えることができます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:173
msgid ""
"SQLAlchemy ties into this PRAGMA statement using the "
":paramref:`.create_engine.isolation_level` parameter of "
":func:`.create_engine`. Valid values for this parameter when used with "
"SQLite are ``\"SERIALIZABLE\"`` and ``\"READ UNCOMMITTED\"`` "
"corresponding to a value of 0 and 1, respectively. SQLite defaults to "
"``SERIALIZABLE``, however its behavior is impacted by the pysqlite "
"driver's default behavior."
msgstr "SQLAlchemyは、：func： `.create_engine`の：paramref：` .create_engine.isolation_level`パラメータを使用して、このPRAGMA文に結びつきます。このパラメータの有効な値は、SQLiteと一緒に使用するときは、それぞれ0と1の値に対応する `` \ &quot;SERIALIZABLE \&quot; ``と `` \ &quot;READ UNCOMMITTED \&quot; `&quot;です。 SQLiteのデフォルトは `` SERIALIZABLE``ですが、動作はpysqliteドライバのデフォルト動作の影響を受けます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:180
msgid ""
"The other axis along which SQLite's transactional locking is impacted is "
"via the nature of the ``BEGIN`` statement used.   The three varieties are"
" \"deferred\", \"immediate\", and \"exclusive\", as described at `BEGIN "
"TRANSACTION <http://sqlite.org/lang_transaction.html>`_.   A straight "
"``BEGIN`` statement uses the \"deferred\" mode, where the the database "
"file is not locked until the first read or write operation, and read "
"access remains open to other transactions until the first write "
"operation.  But again, it is critical to note that the pysqlite driver "
"interferes with this behavior by *not even emitting BEGIN* until the "
"first write operation."
msgstr "SQLiteのトランザクションロックが影響を受けるもう1つの軸は、使用される `` BEGIN``ステートメントの性質によるものです。 `BEGIN TRANSACTION &#39;で説明されているように、3つの変種は\&quot;遅延\ &quot;、&quot;即時\ &quot;、および\&quot;排他\ &quot;です。 <http://sqlite.org/lang_transaction.html> `_。ストレート `` BEGIN`ステートメントは、データベースファイルが最初の読み取りまたは書き込み操作までロックされておらず、読み取りアクセスが最初の書き込み操作まで他のトランザクションに対して開いたままである\ &quot;遅延\&quot;モードを使用します。しかし、再び、pysqliteドライバは、最初の書き込み操作までBEGIN *を出さないことによってこの動作に干渉することに注意することが重要です。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:192
msgid ""
"SQLite's transactional scope is impacted by unresolved issues in the "
"pysqlite driver, which defers BEGIN statements to a greater degree than "
"is often feasible. See the section :ref:`pysqlite_serializable` for "
"techniques to work around this behavior."
msgstr "SQLiteのトランザクションスコープは、pysqliteドライバの未解決の問題によって影響を受けます。この問題は、BEGIN文を実行する可能性があるよりもはるかに高いです。この動作を回避するテクニックについては、ref： `pysqlite_serializable`の節を参照してください。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:198
msgid "SAVEPOINT Support"
msgstr "SAVEPOINTのサポート"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:200
msgid ""
"SQLite supports SAVEPOINTs, which only function once a transaction is "
"begun.   SQLAlchemy's SAVEPOINT support is available using the "
":meth:`.Connection.begin_nested` method at the Core level, and "
":meth:`.Session.begin_nested` at the ORM level.   However, SAVEPOINTs "
"won't work at all with pysqlite unless workarounds are taken."
msgstr "SQLiteはSAVEPOINTをサポートしています.SAVEPOINTは、トランザクションが開始されると機能します。 SQLAlchemyのSAVEPOINTサポートは、コアレベルで：meth： `.Connection.begin_nested`メソッドを使用し、ORMレベルで：meth：` .Session.begin_nested`を使用して使用できます。ただし、回避策が講じられない限り、SAVEPOINTはpysqliteではまったく動作しません。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:208
msgid ""
"SQLite's SAVEPOINT feature is impacted by unresolved issues in the "
"pysqlite driver, which defers BEGIN statements to a greater degree than "
"is often feasible. See the section :ref:`pysqlite_serializable` for "
"techniques to work around this behavior."
msgstr "SQLiteのSAVEPOINT機能は、pysqliteドライバの未解決の問題によって影響を受けます。これは、BEGIN文をしばしば実現可能な程度よりも大きくします。この動作を回避するテクニックについては、ref： `pysqlite_serializable`の節を参照してください。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:214
msgid "Transactional DDL"
msgstr "トランザクションDDL"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:216
msgid ""
"The SQLite database supports transactional :term:`DDL` as well. In this "
"case, the pysqlite driver is not only failing to start transactions, it "
"also is ending any existing transction when DDL is detected, so again, "
"workarounds are required."
msgstr "SQLiteデータベースはtransactional：term： `DDL`もサポートしています。この場合、pysqliteドライバはトランザクションの開始に失敗するだけでなく、DDLが検出されたときに既存のトランザクションも終了するため、回避策も必要です。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:223
msgid ""
"SQLite's transactional DDL is impacted by unresolved issues in the "
"pysqlite driver, which fails to emit BEGIN and additionally forces a "
"COMMIT to cancel any transaction when DDL is encountered. See the section"
" :ref:`pysqlite_serializable` for techniques to work around this "
"behavior."
msgstr "SQLiteのトランザクションDDLは、BEGINを発行できず、さらにDDLに遭遇したときにCOMMITにトランザクションをキャンセルさせるpysqliteドライバの未解決の問題の影響を受けます。この動作を回避するテクニックについては、ref： `pysqlite_serializable`の節を参照してください。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:232
msgid "Foreign Key Support"
msgstr "外部キーのサポート"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:234
msgid ""
"SQLite supports FOREIGN KEY syntax when emitting CREATE statements for "
"tables, however by default these constraints have no effect on the "
"operation of the table."
msgstr "SQLiteは、テーブルのCREATE文を発行する際にFOREIGN KEY構文をサポートしていますが、デフォルトではこれらの制約はテーブルの操作には影響しません。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:238
msgid "Constraint checking on SQLite has three prerequisites:"
msgstr "SQLiteの制約チェックには、次の3つの前提条件があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:240
msgid "At least version 3.6.19 of SQLite must be in use"
msgstr "SQLiteのバージョン3.6.19以上が使用されている必要があります"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:241
msgid ""
"The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY"
" or SQLITE_OMIT_TRIGGER symbols enabled."
msgstr "SQLiteライブラリは、SQLITE_OMIT_FOREIGN_KEYまたはSQLITE_OMIT_TRIGGERシンボルを有効にしないで*コンパイルする必要があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:243
msgid ""
"The ``PRAGMA foreign_keys = ON`` statement must be emitted on all "
"connections before use."
msgstr "`` PRAGMA foreign_keys = ON``ステートメントは、使用する前にすべてのコネクションで発行する必要があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:246
msgid ""
"SQLAlchemy allows for the ``PRAGMA`` statement to be emitted "
"automatically for new connections through the usage of events::"
msgstr "SQLAlchemyはイベントの使用を通して新しい接続のために `` PRAGMA``文が自動的に出力されるようにします::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:260
msgid ""
"When SQLite foreign keys are enabled, it is **not possible** to emit "
"CREATE or DROP statements for tables that contain mutually-dependent "
"foreign key constraints; to emit the DDL for these tables requires that "
"ALTER TABLE be used to create or drop these constraints separately, for "
"which SQLite has no support."
msgstr "SQLiteの外部キーが有効な場合、相互に依存する外部キー制約を含むテーブルに対してCREATEまたはDROPステートメントを発行することはできません**。これらのテーブルに対してDDLを発行するには、ALTER TABLEを使用してこれらの制約を個別に作成または削除する必要があります。そのためにはSQLiteはサポートしていません。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:269
msgid ""
"`SQLite Foreign Key Support <http://www.sqlite.org/foreignkeys.html>`_ - "
"on the SQLite web site."
msgstr "`SQLite外部キーサポート<http://www.sqlite.org/foreignkeys.html> `_  -  SQLiteのWebサイトにあります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:272
msgid ":ref:`event_toplevel` - SQLAlchemy event API."
msgstr "：ref： `event_toplevel`  -  SQLAlchemyイベントAPI。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:274
msgid ""
":ref:`use_alter` - more information on SQLAlchemy's facilities for "
"handling"
msgstr "：ref： `use_alter`  - 処理のためのSQLAlchemyの機能の詳細"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:275
msgid "mutually-dependent foreign key constraints."
msgstr "相互に依存する外部キー制約。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:280
msgid "Type Reflection"
msgstr "タイプリフレクション"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:282
msgid ""
"SQLite types are unlike those of most other database backends, in that "
"the string name of the type usually does not correspond to a \"type\" in "
"a one-to-one fashion.  Instead, SQLite links per-column typing behavior "
"to one of five so-called \"type affinities\" based on a string matching "
"pattern for the type."
msgstr "SQLite型は、他のほとんどのデータベースバックエンドとは異なります。通常、型の文字列名は1対1の方法で\ &quot;型\&quot;に対応しません。その代わりに、SQLiteは、型ごとの文字列一致パターンに基づいて、列ごとの型付き動作を5つのいわゆる\ &quot;型類似性\&quot;のいずれかにリンクします。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:288
msgid ""
"SQLAlchemy's reflection process, when inspecting types, uses a simple "
"lookup table to link the keywords returned to provided SQLAlchemy types. "
"This lookup table is present within the SQLite dialect as it is for all "
"other dialects.  However, the SQLite dialect has a different \"fallback\""
" routine for when a particular type name is not located in the lookup "
"map; it instead implements the SQLite \"type affinity\" scheme located at"
" http://www.sqlite.org/datatype3.html section 2.1."
msgstr "SQLAlchemyのリフレクションプロセスは、タイプを検査するときに、単純なルックアップテーブルを使用して、提供されたSQLAlchemyタイプに返されたキーワードをリンクします。このルックアップテーブルは、他のすべての方言の場合と同様に、SQLiteダイアレクト内に存在します。しかし、SQLiteの方言は、特定の型名がルックアップマップにないときには\ &quot;フォールバック\&quot;ルーチンを持っています;代わりにhttp://www.sqlite.orgにあるSQLite \ &quot;type affinity \&quot;スキームを実装します/datatype3.htmlセクション2.1。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:296
msgid ""
"The provided typemap will make direct associations from an exact string "
"name match for the following types:"
msgstr "指定されたタイプマップは、以下のタイプの文字列名との直接の関連付けを行います："

#: ../../docstring of sqlalchemy.dialects.sqlite.base:299
msgid ""
":class:`~.types.BIGINT`, :class:`~.types.BLOB`, :class:`~.types.BOOLEAN`,"
" :class:`~.types.BOOLEAN`, :class:`~.types.CHAR`, :class:`~.types.DATE`, "
":class:`~.types.DATETIME`, :class:`~.types.FLOAT`, "
":class:`~.types.DECIMAL`, :class:`~.types.FLOAT`, "
":class:`~.types.INTEGER`, :class:`~.types.INTEGER`, "
":class:`~.types.NUMERIC`, :class:`~.types.REAL`, "
":class:`~.types.SMALLINT`, :class:`~.types.TEXT`, :class:`~.types.TIME`, "
":class:`~.types.TIMESTAMP`, :class:`~.types.VARCHAR`, "
":class:`~.types.NVARCHAR`, :class:`~.types.NCHAR`"
msgstr "：class： `〜.types.BIGLE`、：class：`〜.types.BLOB`、：class： `〜.types.BOOLEAN`、：class：`〜.types.BOOLEAN`、：class： `〜。 ：class： `〜.types.DATE &#39;、：class：`〜.types.FLOAT`、：class： `〜.types.DECIMAL`、：：クラス： `〜.types.FLOAT`、：class：`〜.types.INTEGER`、：class： `〜.types.INTEGER`、：class：`〜.types.NUMERIC`、：class： `〜.typesクラス： `〜.types.SMALLINT`、：class：`〜.types.TEXT`、：class： `〜.types.TIME`、：class：`〜.types.TIMESTAMP`、：class ： `〜.types.VARCHAR`、：class：`〜.types.NVARCHAR`、：クラス： `〜.types.NCHAR`"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:311
msgid ""
"When a type name does not match one of the above types, the \"type "
"affinity\" lookup is used instead:"
msgstr "型名が上記の型のいずれかと一致しない場合、代わりに\ &quot;型類義語\&quot;の参照が使用されます："

#: ../../docstring of sqlalchemy.dialects.sqlite.base:314
msgid ""
":class:`~.types.INTEGER` is returned if the type name includes the string"
" ``INT``"
msgstr "：型名に文字列 `` INT``が含まれている場合、クラス： `〜.types.INTEGER`が返されます"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:316
msgid ""
":class:`~.types.TEXT` is returned if the type name includes the string "
"``CHAR``, ``CLOB`` or ``TEXT``"
msgstr "：型名に文字列 `` CHAR``、 `` CLOB``または `` TEXT``が含まれている場合、クラス： `〜.types.TEXT`が返されます"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:318
msgid ""
":class:`~.types.NullType` is returned if the type name includes the "
"string ``BLOB``"
msgstr "：型名に文字列 `` BLOB``が含まれている場合、クラス： `〜.types.NullType`が返されます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:320
msgid ""
":class:`~.types.REAL` is returned if the type name includes the string "
"``REAL``, ``FLOA`` or ``DOUB``."
msgstr "：class： `` REAL``、 `` FLOA``または `` DOUB``の文字列が型名に含まれている場合、 `〜.types.REAL`が返されます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:322
msgid "Otherwise, the :class:`~.types.NUMERIC` type is used."
msgstr "それ以外の場合は：class： `〜.types.NUMERIC`型が使用されます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:324
msgid "Support for SQLite type affinity rules when reflecting columns."
msgstr "列を反映させる際のSQLite型親和性ルールのサポート"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:331
msgid "Partial Indexes"
msgstr "部分インデックス"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:333
msgid ""
"A partial index, e.g. one which uses a WHERE clause, can be specified "
"with the DDL system using the argument ``sqlite_where``::"
msgstr "DDLシステムでは、 `` sqlite_where`` ::引数を使用して部分インデックス（例：WHERE句を使用するインデックス）を指定できます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:340
msgid "The index will be rendered at create time as::"
msgstr "作成時にインデックスがレンダリングされます::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:350
msgid "Dotted Column Names"
msgstr "点列名"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:352
msgid ""
"Using table or column names that explicitly have periods in them is **not"
" recommended**.   While this is generally a bad idea for relational "
"databases in general, as the dot is a syntactically significant "
"character, the SQLite driver up until version **3.10.0** of SQLite has a "
"bug which requires that SQLAlchemy filter out these dots in result sets."
msgstr "明示的にピリオドを含む表名または列名を使用することは推奨されません**。これは一般的にリレーショナルデータベースでは一般的に悪い考えですが、ドットが構文的に重要な文字であるため、SQLiteのバージョン** 3.10.0 **までのSQLiteドライバにはバグがあり、SQLAlchemyはこれらの点を結果セット。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:360
msgid ""
"The following SQLite issue has been resolved as of version 3.10.0 of "
"SQLite.  SQLAlchemy as of **1.1** automatically disables its internal "
"workarounds based on detection of this version."
msgstr "次のSQLiteの問題は、SQLiteのバージョン3.10.0で解決されています。 ** 1.1 **のSQLAlchemyは、このバージョンの検出に基づいて内部的な回避策を自動的に無効にします。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:364
msgid "The bug, entirely outside of SQLAlchemy, can be illustrated thusly::"
msgstr "このバグは、SQLAlchemyの外部にあります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:388
msgid "The second assertion fails::"
msgstr "2番目のアサーションは失敗します::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:395
msgid ""
"Where above, the driver incorrectly reports the names of the columns "
"including the name of the table, which is entirely inconsistent vs. when "
"the UNION is not present."
msgstr "上記の場合、ドライバはテーブルの名前を含む列の名前を間違って報告します。これは、UNIONが存在しない場合とまったく矛盾しています。"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:399
msgid ""
"SQLAlchemy relies upon column names being predictable in how they match "
"to the original statement, so the SQLAlchemy dialect has no choice but to"
" filter these out::"
msgstr "SQLAlchemyは、元の文とどのように一致するか予測可能なカラム名に依存しているため、SQLAlchemy方言はこれらをフィルタリングするだけではありません::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:423
msgid ""
"Note that above, even though SQLAlchemy filters out the dots, *both names"
" are still addressable*::"
msgstr "上記のように、SQLAlchemyがドットをフィルタリングしても、*両方の名前はまだアドレス可能です*："

#: ../../docstring of sqlalchemy.dialects.sqlite.base:436
msgid ""
"Therefore, the workaround applied by SQLAlchemy only impacts "
":meth:`.ResultProxy.keys` and :meth:`.RowProxy.keys()` in the public API."
" In the very specific case where an application is forced to use column "
"names that contain dots, and the functionality of "
":meth:`.ResultProxy.keys` and :meth:`.RowProxy.keys()` is required to "
"return these dotted names unmodified, the ``sqlite_raw_colnames`` "
"execution option may be provided, either on a per-:class:`.Connection` "
"basis::"
msgstr "したがって、SQLAlchemyによって適用される回避策は、パブリックAPIの：meth： `.ResultProxy.keys`および：meth：` .RowProxy.keys（） `にのみ影響します。アプリケーションがドットを含む列名を使用するように強制され、これらのドット付きの名前を返すには：meth： `.ResultProxy.keys`と：meth：` .RowProxy.keys（） `の機能が必要な非常に特殊なケースでは、 `` sqlite_raw_colnames``実行オプションは、per-：class： `.Connection`の基礎で提供されるかもしれません::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:451
msgid "or on a per-:class:`.Engine` basis::"
msgstr "またはper-：class： `.Engine` basis ::"

#: ../../docstring of sqlalchemy.dialects.sqlite.base:455
msgid ""
"When using the per-:class:`.Engine` execution option, note that **Core "
"and ORM queries that use UNION may not function properly**."
msgstr "per-：class： `.Engine`実行オプションを使用する場合、UNIONを使用する**コアクエリとORMクエリは正しく機能しない可能性があります**。"

#: ../../dialects/sqlite.rst:9
msgid "SQLite Data Types"
msgstr "SQLiteデータ型"

#: ../../dialects/sqlite.rst:11
msgid ""
"As with all SQLAlchemy dialects, all UPPERCASE types that are known to be"
" valid with SQLite are importable from the top level dialect, whether "
"they originate from :mod:`sqlalchemy.types` or from the local dialect::"
msgstr "すべてのSQLAlchemyの方言と同様に、SQLiteで有効であることが知られているすべてのUPPERCASE型は、from：mod： `sqlalchemy.types`またはローカルの方言から上位の方言からインポートできます::"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATETIME:1
msgid "Represent a Python datetime object in SQLite using a string."
msgstr "文字列を使用してSQLiteでPython datetimeオブジェクトを表します。"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:3
#: sqlalchemy.dialects.sqlite.DATETIME:3 sqlalchemy.dialects.sqlite.TIME:3
msgid "The default string storage format is::"
msgstr "デフォルトの文字列格納形式は::"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:7
#: sqlalchemy.dialects.sqlite.DATETIME:7 sqlalchemy.dialects.sqlite.TIME:7
msgid "e.g.::"
msgstr "例えば：："

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:11
#: sqlalchemy.dialects.sqlite.DATETIME:11 sqlalchemy.dialects.sqlite.TIME:11
msgid ""
"The storage format can be customized to some degree using the "
"``storage_format`` and ``regexp`` parameters, such as::"
msgstr "ストレージフォーマットは、 `` storage_format``と `` regexp``パラメータを使ってある程度カスタマイズすることができます："

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE
#: sqlalchemy.dialects.sqlite.DATETIME sqlalchemy.dialects.sqlite.TIME
msgid "パラメータ"
msgstr "パラメータ"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATETIME:22
msgid ""
"format string which will be applied to the dict with keys year, month, "
"day, hour, minute, second, and microsecond."
msgstr "年、月、日、時、分、秒、マイクロ秒のキーで辞書に適用される書式文字列。"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATETIME:25
msgid ""
"regular expression which will be applied to incoming result rows. If the "
"regexp contains named groups, the resulting match dict is applied to the "
"Python datetime() constructor as keyword arguments. Otherwise, if "
"positional groups are used, the datetime() constructor is called with "
"positional arguments via ``*map(int, match_obj.groups(0))``."
msgstr "着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのdatetime（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、datetime（）コンストラクタは `` * map（int、match_obj.groups（0）） `&#39;を介して位置引数で呼び出されます。"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:1
msgid "Represent a Python date object in SQLite using a string."
msgstr "文字列を使用してSQLiteでPythonの日付オブジェクトを表します。"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:22
msgid ""
"format string which will be applied to the dict with keys year, month, "
"and day."
msgstr "年、月、日のキーを使って辞書に適用されるフォーマット文字列。"

#: ../../docstring of sqlalchemy.dialects.sqlite.DATE:25
msgid ""
"regular expression which will be applied to incoming result rows. If the "
"regexp contains named groups, the resulting match dict is applied to the "
"Python date() constructor as keyword arguments. Otherwise, if positional "
"groups are used, the date() constructor is called with positional "
"arguments via ``*map(int, match_obj.groups(0))``."
msgstr "着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのdate（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、date（）コンストラクタは `` * map（int、match_obj.groups（0）） `&#39;を介して位置引数で呼び出されます。"

#: of sqlalchemy.dialects.sqlite.JSON:1
msgid "SQLite JSON type."
msgstr "SQLite JSONタイプ。"

#: of sqlalchemy.dialects.sqlite.JSON:3
msgid ""
"SQLite supports JSON as of version 3.9 through its JSON1_ extension. Note"
" that JSON1_ is a `loadable extension "
"<https://www.sqlite.org/loadext.html>`_ and as such may not be available,"
" or may require run-time loading."
msgstr "SQLiteは、JSON1_拡張を介してバージョン3.9のJSONをサポートしています。 JSON1_はロード可能な拡張機能です<https://www.sqlite.org/loadext.html> `_そのようなものが利用できないか、実行時の読み込みが必要な場合があります。"

#: of sqlalchemy.dialects.sqlite.JSON:8
msgid ""
"The :class:`.sqlite.JSON` type supports persistence of JSON values as "
"well as the core index operations provided by :class:`.types.JSON` "
"datatype, by adapting the operations to render the ``JSON_EXTRACT`` "
"function wrapped in the ``JSON_QUOTE`` function at the database level. "
"Extracted values are quoted in order to ensure that the results are "
"always JSON string values."
msgstr "：class： `.sqlite.JSON`型はJSON値の永続性と、class：` .types.JSON`データ型によって提供されるコアインデックス操作をサポートします。これは、 `` JSON_EXTRACT``関数をラップするデータベースレベルの `` JSON_QUOTE``関数の中で実行されます。結果が常にJSON文字列値であることを保証するために、抽出された値が引用されます。"

#: of sqlalchemy.dialects.sqlite.JSON:19
msgid "JSON1_"
msgstr "JSON1_"

#: ../../docstring of sqlalchemy.dialects.sqlite.TIME:1
msgid "Represent a Python time object in SQLite using a string."
msgstr "文字列を使用してSQLiteでPythonの時間オブジェクトを表します。"

#: ../../docstring of sqlalchemy.dialects.sqlite.TIME:22
msgid ""
"format string which will be applied to the dict with keys hour, minute, "
"second, and microsecond."
msgstr "日付、時間、分、秒、マイクロ秒のキーで適用されるフォーマット文字列。"

#: ../../docstring of sqlalchemy.dialects.sqlite.TIME:25
msgid ""
"regular expression which will be applied to incoming result rows. If the "
"regexp contains named groups, the resulting match dict is applied to the "
"Python time() constructor as keyword arguments. Otherwise, if positional "
"groups are used, the time() constructor is called with positional "
"arguments via ``*map(int, match_obj.groups(0))``."
msgstr "着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのtime（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、time（）コンストラクタが `` * map（int、match_obj.groups（0）） `&#39;を介して位置引数で呼び出されます。"

#: ../../dialects/sqlite.rst:31
msgid "Pysqlite"
msgstr "Pysqlite"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:18
#: sqlalchemy.dialects.sqlite.pysqlite:11
msgid "Driver"
msgstr "ドライバ"

#: of sqlalchemy.dialects.sqlite.pysqlite:13
msgid ""
"When using Python 2.5 and above, the built in ``sqlite3`` driver is "
"already installed and no additional installation is needed.  Otherwise, "
"the ``pysqlite2`` driver needs to be present.  This is the same driver as"
" ``sqlite3``, just with a different name."
msgstr "Python 2.5以上を使用する場合、組み込みの `` sqlite3``ドライバは既にインストールされており、追加のインストールは必要ありません。それ以外の場合は、 `` pysqlite2``ドライバが必要です。これは `` sqlite3``と同じドライバで、名前が違うだけです。"

#: of sqlalchemy.dialects.sqlite.pysqlite:18
msgid ""
"The ``pysqlite2`` driver will be loaded first, and if not found, "
"``sqlite3`` is loaded.  This allows an explicitly installed pysqlite "
"driver to take precedence over the built in one.   As with all dialects, "
"a specific DBAPI module may be provided to "
":func:`~sqlalchemy.create_engine()` to control this explicitly::"
msgstr "`` pysqlite2``ドライバが最初にロードされ、見つからなければ `` sqlite3``がロードされます。これにより、明示的にインストールされたpysqliteドライバが組み込みドライバよりも優先されます。すべての方言と同様に、特定のDBAPIモジュールを次のように提供することができます：func： `〜sqlalchemy.create_engine（）`これを明示的に制御する::"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:30
#: sqlalchemy.dialects.sqlite.pysqlite:29
msgid "Connect Strings"
msgstr "文字列を接続する"

#: of sqlalchemy.dialects.sqlite.pysqlite:31
msgid ""
"The file specification for the SQLite database is taken as the "
"\"database\" portion of the URL.  Note that the format of a SQLAlchemy "
"url is::"
msgstr "SQLiteデータベースのファイル指定は、URLの &quot;データベース&quot;部分とみなされます。 SQLAlchemyのURLのフォーマットは::"

#: of sqlalchemy.dialects.sqlite.pysqlite:36
msgid ""
"This means that the actual filename to be used starts with the characters"
" to the **right** of the third slash.   So connecting to a relative "
"filepath looks like::"
msgstr "つまり、実際に使用されるファイル名は、3番目のスラッシュの** right **の文字で始まります。相対ファイルパスに接続すると、次のようになります::"

#: of sqlalchemy.dialects.sqlite.pysqlite:43
msgid ""
"An absolute path, which is denoted by starting with a slash, means you "
"need **four** slashes::"
msgstr "スラッシュで始まる絶対パスは、**四つのスラッシュが必要です::"

#: of sqlalchemy.dialects.sqlite.pysqlite:49
msgid ""
"To use a Windows path, regular drive specifications and backslashes can "
"be used. Double backslashes are probably needed::"
msgstr "Windowsパスを使用するには、通常のドライブ指定とバックスラッシュを使用できます。ダブルバックスラッシュはおそらく必要です::"

#: of sqlalchemy.dialects.sqlite.pysqlite:55
msgid ""
"The sqlite ``:memory:`` identifier is the default if no filepath is "
"present.  Specify ``sqlite://`` and nothing else::"
msgstr "ファイルパスが存在しない場合、sqlite ``：memory： ``識別子がデフォルトです。 `` sqlite：// ``を指定し、他には何も指定しないでください::"

#: of sqlalchemy.dialects.sqlite.pysqlite:62
msgid "Compatibility with sqlite3 \"native\" date and datetime types"
msgstr "sqlite3 \ &quot;native \&quot;の日付と日時の型との互換性"

#: of sqlalchemy.dialects.sqlite.pysqlite:64
msgid ""
"The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and "
"sqlite3.PARSE_COLNAMES options, which have the effect of any column or "
"expression explicitly cast as \"date\" or \"timestamp\" will be converted"
" to a Python date or datetime object.  The date and datetime types "
"provided with the pysqlite dialect are not currently compatible with "
"these options, since they render the ISO date/datetime including "
"microseconds, which pysqlite's driver does not.   Additionally, "
"SQLAlchemy does not at this time automatically render the \"cast\" syntax"
" required for the freestanding functions \"current_timestamp\" and "
"\"current_date\" to return datetime/date types natively.   Unfortunately,"
" pysqlite does not provide the standard DBAPI types in "
"``cursor.description``, leaving SQLAlchemy with no way to detect these "
"types on the fly without expensive per-row type checks."
msgstr "pysqliteドライバには、sqlite3.PARSE_DECLTYPESおよびsqlite3.PARSE_COLNAMESオプションが含まれています。これらのオプションは、\ &quot;日付\&quot;または\ &quot;タイムスタンプ\&quot;として明示的にキャストされる列または式の影響をPythonの日付または日時オブジェクトに変換します。 pysqliteの方言で提供されているdate型とdatetime型は、pysqliteのドライバではないマイクロ秒を含むISOの日付/時刻をレンダリングするため、これらのオプションと現在互換性がありません。さらに、SQLAlchemyは現在、フリースタンディング関数\ &quot;current_timestamp \&quot;と\ &quot;current_date \&quot;に必要な\ &quot;キャスト\&quot;構文をネイティブにdatetime / date型を返すように自動的にレンダリングしません。残念ながら、pysqliteは標準のDBAPI型を `` cursor.description``に提供していないため、SQLAlchemyに高価な行単位のチェックを行わずにこれらの型を即座に検出することはできません。"

#: of sqlalchemy.dialects.sqlite.pysqlite:78
msgid ""
"Keeping in mind that pysqlite's parsing option is not recommended, nor "
"should be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES "
"can be forced if one configures \"native_datetime=True\" on "
"create_engine()::"
msgstr "SQLAlchemyで使用するには、pysqliteの解析オプションは推奨されておらず、また必要であることに留意してください。create_engine（）で\ &quot;native_datetime = True \&quot;を設定すると、PARSE_DECLTYPESの使用を強制できます。"

#: of sqlalchemy.dialects.sqlite.pysqlite:88
msgid ""
"With this flag enabled, the DATE and TIMESTAMP types (but note - not the "
"DATETIME or TIME types...confused yet ?) will not perform any bind "
"parameter or result processing. Execution of \"func.current_date()\" will"
" return a string. \"func.current_timestamp()\" is registered as returning"
" a DATETIME type in SQLAlchemy, so this function still receives "
"SQLAlchemy-level result processing."
msgstr "このフラグを有効にすると、DATETIME型やTIMESTAMP型（ただし、DATETIME型やTIME型ではありませんが、まだ混乱していません）は、バインドパラメータや結果処理を実行しません。 \ &quot;func.current_date（）\&quot;の実行は文字列を返します。 \ &quot;func.current_timestamp（）\&quot;はSQLAlchemyにDATETIME型を返すように登録されているので、この関数はSQLAlchemyレベルの結果処理を受け取ります。"

#: of sqlalchemy.dialects.sqlite.pysqlite:98
msgid "Threading/Pooling Behavior"
msgstr "スレッド/プーリングの動作"

#: of sqlalchemy.dialects.sqlite.pysqlite:100
msgid ""
"Pysqlite's default behavior is to prohibit the usage of a single "
"connection in more than one thread.   This is originally intended to work"
" with older versions of SQLite that did not support multithreaded "
"operation under various circumstances.  In particular, older SQLite "
"versions did not allow a ``:memory:`` database to be used in multiple "
"threads under any circumstances."
msgstr "Pysqliteのデフォルトの動作は、複数のスレッドで単一の接続の使用を禁止することです。これはもともと、さまざまな状況下でマルチスレッド処理をサポートしていなかった古いバージョンのSQLiteで動作するように意図されています。特に、以前のSQLiteのバージョンでは、どんな状況下でも `` memory： ``データベースを複数のスレッドで使用することができませんでした。"

#: of sqlalchemy.dialects.sqlite.pysqlite:107
msgid ""
"Pysqlite does include a now-undocumented flag known as "
"``check_same_thread`` which will disable this check, however note that "
"pysqlite connections are still not safe to use in concurrently in "
"multiple threads.  In particular, any statement execution calls would "
"need to be externally mutexed, as Pysqlite does not provide for thread-"
"safe propagation of error messages among other things.   So while even "
"``:memory:`` databases can be shared among threads in modern SQLite, "
"Pysqlite doesn't provide enough thread-safety to make this usage worth "
"it."
msgstr "Pysqliteには、このチェックを無効にする `` check_same_thread``というフラグがありますが、pysqliteの接続は複数のスレッドで同時に使用することは安全ではありません。特に、Pysqliteはスレッドセーフなエラーメッセージの伝播を提供しないため、ステートメント実行呼び出しは外部的に相互排除する必要があります。そのため、現代のSQLiteではスレッド間で ``：memory： ``のデータベースを共有することができますが、Pysqliteはスレッドセーフではありません。"

#: of sqlalchemy.dialects.sqlite.pysqlite:116
msgid "SQLAlchemy sets up pooling to work with Pysqlite's default behavior:"
msgstr "SQLAlchemyは、Pysqliteのデフォルト動作で動作するようにプーリングを設定します。"

#: of sqlalchemy.dialects.sqlite.pysqlite:118
msgid ""
"When a ``:memory:`` SQLite database is specified, the dialect by default "
"will use :class:`.SingletonThreadPool`. This pool maintains a single "
"connection per thread, so that all access to the engine within the "
"current thread use the same ``:memory:`` database - other threads would "
"access a different ``:memory:`` database."
msgstr "`` memory： `` SQLiteデータベースが指定されている場合、デフォルトでは：class： `.SingletonThreadPool`が使用されます。このプールはスレッドごとに1つの接続を維持するので、現在のスレッド内のエンジンへのすべてのアクセスは同じ `` memory： ``データベースを使用し、他のスレッドは別の `` memory： ``データベースにアクセスします。"

#: of sqlalchemy.dialects.sqlite.pysqlite:123
msgid ""
"When a file-based database is specified, the dialect will use "
":class:`.NullPool` as the source of connections. This pool closes and "
"discards connections which are returned to the pool immediately. SQLite "
"file-based connections have extremely low overhead, so pooling is not "
"necessary. The scheme also prevents a connection from being used again in"
" a different thread and works best with SQLite's coarse-grained file "
"locking."
msgstr "ファイルベースのデータベースが指定されると、方言は：class： `.NullPool`を接続のソースとして使用します。このプールは、すぐにプールに返される接続を閉じて破棄します。 SQLiteのファイルベースの接続は非常にオーバーヘッドが少ないため、プールする必要はありません。このスキームはまた、接続が別のスレッドで再び使用されることを防ぎ、SQLiteの粗いファイルロックで最も効果的です。"

#: of sqlalchemy.dialects.sqlite.pysqlite:130
msgid ""
"Default selection of :class:`.NullPool` for SQLite file-based databases. "
"Previous versions select :class:`.SingletonThreadPool` by default for all"
" SQLite databases."
msgstr "デフォルト選択：class：SQLiteファイルベースのデータベースの `.NullPool`。以前のバージョンでは、すべてのSQLiteデータベースに対して、class： `.SingletonThreadPool`がデフォルトで選択されていました。"

#: of sqlalchemy.dialects.sqlite.pysqlite:137
msgid "Using a Memory Database in Multiple Threads"
msgstr "複数のスレッドでのメモリデータベースの使用"

#: of sqlalchemy.dialects.sqlite.pysqlite:139
msgid ""
"To use a ``:memory:`` database in a multithreaded scenario, the same "
"connection object must be shared among threads, since the database exists"
" only within the scope of that connection.   The :class:`.StaticPool` "
"implementation will maintain a single connection globally, and the "
"``check_same_thread`` flag can be passed to Pysqlite as ``False``::"
msgstr "マルチスレッドのシナリオで `` memory： ``データベースを使用するには、データベースがその接続のスコープ内にしか存在しないため、同じ接続オブジェクトをスレッド間で共有する必要があります。 ：class： `.StaticPool`実装はグローバルに単一の接続を維持し、` `check_same_thread``フラグをPysqliteに` `False`` ::として渡すことができます"

#: of sqlalchemy.dialects.sqlite.pysqlite:151
msgid ""
"Note that using a ``:memory:`` database in multiple threads requires a "
"recent version of SQLite."
msgstr "複数のスレッドで `` memory： ``データベースを使用するには、最近のバージョンのSQLiteが必要です。"

#: of sqlalchemy.dialects.sqlite.pysqlite:155
msgid "Using Temporary Tables with SQLite"
msgstr "SQLiteでのテンポラリテーブルの使用"

#: of sqlalchemy.dialects.sqlite.pysqlite:157
msgid ""
"Due to the way SQLite deals with temporary tables, if you wish to use a "
"temporary table in a file-based SQLite database across multiple checkouts"
" from the connection pool, such as when using an ORM :class:`.Session` "
"where the temporary table should continue to remain after "
":meth:`.Session.commit` or :meth:`.Session.rollback` is called, a pool "
"which maintains a single connection must be used.   Use "
":class:`.SingletonThreadPool` if the scope is only needed within the "
"current thread, or :class:`.StaticPool` is scope is needed within "
"multiple threads for this case::"
msgstr "SQLiteが一時テーブルを処理する方法のため、ORM：class： `.Session`を使用する場合など、接続プールからの複数のチェックアウトにわたってファイルベースのSQLiteデータベースで一時テーブルを使用する場合は、一時テーブル：meth： `.Session.commit`または：meth：` .Session.rollback`が呼び出された後も引き続き残る必要があります.1つの接続を維持するプールを使用する必要があります。スコープが現在のスレッド内でのみ必要な場合は、class： `.SingletonThreadPool`を使用するか、または：class：` .StaticPool` isスコープがこの場合複数のスレッド内で必要です::"

#: of sqlalchemy.dialects.sqlite.pysqlite:177
msgid ""
"Note that :class:`.SingletonThreadPool` should be configured for the "
"number of threads that are to be used; beyond that number, connections "
"will be closed out in a non deterministic way."
msgstr "注意：class： `.SingletonThreadPool`は、使用されるスレッドの数を設定する必要があります。その数を超えると、接続は非決定論的な方法でクローズされます。"

#: of sqlalchemy.dialects.sqlite.pysqlite:182
msgid "Unicode"
msgstr "Unicode"

#: of sqlalchemy.dialects.sqlite.pysqlite:184
msgid ""
"The pysqlite driver only returns Python ``unicode`` objects in result "
"sets, never plain strings, and accommodates ``unicode`` objects within "
"bound parameter values in all cases.   Regardless of the SQLAlchemy "
"string type in use, string-based result values will by Python ``unicode``"
" in Python 2. The :class:`.Unicode` type should still be used to indicate"
" those columns that require unicode, however, so that non-``unicode`` "
"values passed inadvertently will emit a warning.  Pysqlite will emit an "
"error if a non-``unicode`` string is passed containing non-ASCII "
"characters."
msgstr "pysqliteドライバは、結果セット内のPythonの `` unicode``オブジェクトだけを返すだけで、決してプレーンな文字列ではなく、すべての場合にバインドされたパラメータ値内の `` unicode``オブジェクトに対応します。使用されているSQLAlchemy文字列型にかかわらず、文字列ベースの結果値はPython 2のPythonの `` unicode``になります。：class： `.Unicode`型は、Unicodeを必要とする列を示すために使用されます。誤って渡された ``unicode``以外の値は警告を発します。 ASCII以外の文字を含む ``unicode``以外の文字列が渡された場合、Pysqliteはエラーを出力します。"

#: of sqlalchemy.dialects.sqlite.pysqlite:196
msgid "Serializable isolation / Savepoints / Transactional DDL"
msgstr "シリアライズ可能な分離/セーブポイント/トランザクションDDL"

#: of sqlalchemy.dialects.sqlite.pysqlite:198
msgid ""
"In the section :ref:`sqlite_concurrency`, we refer to the pysqlite "
"driver's assortment of issues that prevent several features of SQLite "
"from working correctly.  The pysqlite DBAPI driver has several long-"
"standing bugs which impact the correctness of its transactional behavior."
"   In its default mode of operation, SQLite features such as SERIALIZABLE"
" isolation, transactional DDL, and SAVEPOINT support are non-functional, "
"and in order to use these features, workarounds must be taken."
msgstr "セクション：ref： `sqlite_concurrency`では、SQLiteのいくつかの機能が正しく動作しないようにするpysqliteドライバのさまざまな問題を取り上げます。 pysqlite DBAPIドライバには、トランザクショナル動作の正確性に影響するいくつかの長年にわたるバグがあります。デフォルトの動作モードでは、SERIALIZABLE分離、トランザクションDDL、SAVEPOINTサポートなどのSQLite機能は機能しません。これらの機能を使用するには、回避策を講じる必要があります。"

#: of sqlalchemy.dialects.sqlite.pysqlite:207
msgid ""
"The issue is essentially that the driver attempts to second-guess the "
"user's intent, failing to start transactions and sometimes ending them "
"prematurely, in an effort to minimize the SQLite databases's file locking"
" behavior, even though SQLite itself uses \"shared\" locks for read-only "
"activities."
msgstr "問題は基本的に、ドライバがSQLiteデータベースのファイルロック動作を最小限に抑えるために、SQLite自体が\ &quot;共有\&quot;ロックを使用しているにもかかわらず、ユーザーの意図を第二に推測し、トランザクションを開始せず、読み取り専用アクティビティ"

#: of sqlalchemy.dialects.sqlite.pysqlite:212
msgid ""
"SQLAlchemy chooses to not alter this behavior by default, as it is the "
"long-expected behavior of the pysqlite driver; if and when the pysqlite "
"driver attempts to repair these issues, that will be more of a driver "
"towards defaults for SQLAlchemy."
msgstr "SQLAlchemyは、この動作をデフォルトで変更しないことを選択します。これは、pysqliteドライバの長い動作が期待される動作であるためです。 pysqliteドライバがこれらの問題を修復しようとすると、SQLAlchemyのデフォルトに近づくでしょう。"

#: of sqlalchemy.dialects.sqlite.pysqlite:217
msgid ""
"The good news is that with a few events, we can implement transactional "
"support fully, by disabling pysqlite's feature entirely and emitting "
"BEGIN ourselves. This is achieved using two event listeners::"
msgstr "良いニュースは、いくつかのイベントでは、pysqliteの機能を完全に無効にして自分自身を始動させることによって、トランザクションサポートを完全に実装できることです。これは、2つのイベントリスナーを使用して実現されます。"

#: of sqlalchemy.dialects.sqlite.pysqlite:236
msgid ""
"Above, we intercept a new pysqlite connection and disable any "
"transactional integration.   Then, at the point at which SQLAlchemy knows"
" that transaction scope is to begin, we emit ``\"BEGIN\"`` ourselves."
msgstr "上では、新しいpysqlite接続を傍受し、トランザクション統合を無効にします。次に、SQLAlchemyがトランザクションスコープを開始することを知っている時点で、私たちは `` \ &quot;BEGIN \&quot; ``を自分自身で発行します。"

#: of sqlalchemy.dialects.sqlite.pysqlite:240
msgid ""
"When we take control of ``\"BEGIN\"``, we can also control directly "
"SQLite's locking modes, introduced at `BEGIN TRANSACTION "
"<http://sqlite.org/lang_transaction.html>`_, by adding the desired "
"locking mode to our ``\"BEGIN\"``::"
msgstr "`` \ &quot;BEGIN \&quot; ``を制御すると、 `BEGIN TRANSACTION &#39;で導入されたSQLiteのロックモードを直接制御することもできます<http://sqlite.org/lang_transaction.html> `_ &#39;に、希望するロックモードを` `\&quot; BEGIN \ &quot;` `::に追加する"

#: of sqlalchemy.dialects.sqlite.pysqlite:250
msgid ""
"`BEGIN TRANSACTION <http://sqlite.org/lang_transaction.html>`_ - on the "
"SQLite site"
msgstr "`BEGIN TRANSACTION <http://sqlite.org/lang_transaction.html> `_  -  SQLiteサイトで"

#: of sqlalchemy.dialects.sqlite.pysqlite:252
msgid ""
"`sqlite3 SELECT does not BEGIN a transaction "
"<http://bugs.python.org/issue9924>`_ - on the Python bug tracker"
msgstr "`sqlite3 SELECTはトランザクションを開始しません<http://bugs.python.org/issue9924> `_  -  Pythonバグトラッカーで"

#: of sqlalchemy.dialects.sqlite.pysqlite:254
msgid ""
"`sqlite3 module breaks transactions and potentially corrupts data "
"<http://bugs.python.org/issue10740>`_ - on the Python bug tracker"
msgstr "`sqlite3モジュールがトランザクションを中断し、データを破壊する可能性がある<http://bugs.python.org/issue10740> `_  -  Pythonバグトラッカーで"

#: ../../dialects/sqlite.rst:36
msgid "Pysqlcipher"
msgstr "Pysqlcipher"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:20
msgid ""
"The driver here is the `pysqlcipher "
"<https://pypi.python.org/pypi/pysqlcipher>`_ driver, which makes use of "
"the SQLCipher engine.  This system essentially introduces new PRAGMA "
"commands to SQLite which allows the setting of a passphrase and other "
"encryption parameters, allowing the database file to be encrypted."
msgstr "ここのドライバは `pysqlcipher <https://pypi.python.org/pypi/pysqlcipher> `_ドライバ、SQLCipherエンジンを利用します。このシステムは基本的に新しいPRAGMAコマンドをSQLiteに導入し、パスフレーズや他の暗号化パラメータの設定を可能にし、データベースファイルを暗号化できるようにします。"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:26
msgid ""
"`pysqlcipher3` is a fork of `pysqlcipher` with support for Python 3, the "
"driver is the same."
msgstr "`pysqlcipher3`はPython 3をサポートする` pysqlcipher`のforkです。ドライバは同じです。"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:32
msgid ""
"The format of the connect string is in every way the same as that of the "
":mod:`~sqlalchemy.dialects.sqlite.pysqlite` driver, except that the "
"\"password\" field is now accepted, which should contain a passphrase::"
msgstr "接続文字列の形式は、mod： `〜sqlalchemy.dialects.sqlite.pysqlite`ドライバと同じように、パスフレーズを含む\&quot;パスワード\ &quot;フィールドが現在受け入れられています。 ："

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:38
msgid ""
"For an absolute file path, two leading slashes should be used for the "
"database name::"
msgstr "絶対ファイルパスの場合は、データベース名に2つの先頭スラッシュを使用する必要があります。"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:43
msgid ""
"A selection of additional encryption-related pragmas supported by "
"SQLCipher as documented at https://www.zetetic.net/sqlcipher/sqlcipher-"
"api/ can be passed in the query string, and will result in that PRAGMA "
"being called for each new connection.  Currently, ``cipher``, "
"``kdf_iter`` ``cipher_page_size`` and ``cipher_use_hmac`` are supported::"
msgstr "https://www.zetetic.net/sqlcipher/sqlcipher-api/で文書化されているようにSQLCipherでサポートされている追加の暗号化関連プラグマをクエリ文字列に渡すと、新しい接続ごとにPRAGMAが呼び出されます。現在、 `` cipher``、 `` kdf_iter``、 `` cipher_page_size``、 `` cipher_use_hmac``がサポートされています::"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:53
msgid "Pooling Behavior"
msgstr "プール動作"

#: ../../docstring of sqlalchemy.dialects.sqlite.pysqlcipher:55
msgid ""
"The driver makes a change to the default pool behavior of pysqlite as "
"described in :ref:`pysqlite_threading_pooling`.   The pysqlcipher driver "
"has been observed to be significantly slower on connection than the "
"pysqlite driver, most likely due to the encryption overhead, so the "
"dialect here defaults to using the :class:`.SingletonThreadPool` "
"implementation, instead of the :class:`.NullPool` pool used by pysqlite."
"  As always, the pool implementation is entirely configurable using the "
":paramref:`.create_engine.poolclass` parameter; the :class:`.StaticPool` "
"may be more feasible for single-threaded use, or :class:`.NullPool` may "
"be used to prevent unencrypted connections from being held open for long "
"periods of time, at the expense of slower startup time for new "
"connections."
msgstr "ドライバは、：ref： `pysqlite_threading_pooling`で説明されているように、pysqliteのデフォルトのプール動作を変更します。 pysqlcipherドライバはpysqliteドライバよりも接続がかなり遅いことが観測されています。おそらく暗号化のオーバーヘッドが原因です。したがって、ここでの方言は：class： `.SingletonThreadPool`実装の代わりに：class：`の代わりに使用されます。 pysqliteによって使用されるNullPoolプール。いつものように、プールの実装は：paramref： `.create_engine.poolclass`パラメータを使って完全に設定可能です。 ：class： `.StaticPool`は、シングルスレッドの場合にはより適しています：class：` .NullPool`は、暗号化されていない接続が長時間オープンされないようにするために使用されます。新しい接続のために。"


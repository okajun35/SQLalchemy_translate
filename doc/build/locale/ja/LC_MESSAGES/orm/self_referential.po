# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../orm/self_referential.rst:4
msgid "Adjacency List Relationships"
msgstr "隣接関係リストの関係"

#: ../../orm/self_referential.rst:6
msgid ""
"The **adjacency list** pattern is a common relational pattern whereby a "
"table contains a foreign key reference to itself. This is the most common"
" way to represent hierarchical data in flat tables.  Other methods "
"include **nested sets**, sometimes called \"modified preorder\", as well "
"as **materialized path**.  Despite the appeal that modified preorder has "
"when evaluated for its fluency within SQL queries, the adjacency list "
"model is probably the most appropriate pattern for the large majority of "
"hierarchical storage needs, for reasons of concurrency, reduced "
"complexity, and that modified preorder has little advantage over an "
"application which can fully load subtrees into the application space."
msgstr "**隣接関係リスト**パターンは、テーブルがそれ自身への外部キー参照を含む共通の関係パターンです。これは、フラットテーブルで階層データを表現する最も一般的な方法です。他のメソッドには**ネストされたセット**、時に\ &quot;修正された予約注文&quot;と呼ばれるもの、**マテリアライズドパス**があります。並行性、複雑さの軽減、および変更された予約注文の利点がほとんどないため、SQL照会内での流暢性を評価したときに変更された予約注文があったにもかかわらず、おそらく隣接リスト・モデルは大半の階層ストレージニーズにとって最も適切なパターンですサブツリーをアプリケーション空間に完全にロードすることができるアプリケーションに適用されます。"

#: ../../orm/self_referential.rst:17
msgid ""
"In this example, we'll work with a single mapped class called ``Node``, "
"representing a tree structure::"
msgstr "この例では、ツリー構造を表す `` Node``というマップされたクラスを1つ使用して作業します::"

#: ../../orm/self_referential.rst:27
msgid "With this structure, a graph such as the following::"
msgstr "このような構成により、以下のようなグラフが生成される。"

#: ../../orm/self_referential.rst:34
msgid "Would be represented with data such as::"
msgstr "::のようなデータで表されるでしょうか？"

#: ../../orm/self_referential.rst:45
msgid ""
"The :func:`.relationship` configuration here works in the same way as a "
"\"normal\" one-to-many relationship, with the exception that the "
"\"direction\", i.e. whether the relationship is one-to-many or many-to-"
"one, is assumed by default to be one-to-many.   To establish the "
"relationship as many-to-one, an extra directive is added known as "
":paramref:`~.relationship.remote_side`, which is a :class:`.Column` or "
"collection of :class:`.Column` objects that indicate those which should "
"be considered to be \"remote\"::"
msgstr "：func： `.relationship`の設定は\&quot;普通\ &quot;の1対多の関係と同じように動作しますが、\&quot;方向\ &quot;、つまり関係が1対多または多対1は、デフォルトでは1対多であるとみなされます。関係を多対1にするために、paramref： `〜.relationship.remote_side`という追加の指示文が追加されています。これは：class：` .Column`または：class： `.Column`オブジェクトのコレクションです。 \ &quot;リモート\&quot;と考えるべきものを示す："

#: ../../orm/self_referential.rst:61
msgid ""
"Where above, the ``id`` column is applied as the "
":paramref:`~.relationship.remote_side` of the ``parent`` "
":func:`.relationship`, thus establishing ``parent_id`` as the \"local\" "
"side, and the relationship then behaves as a many-to-one."
msgstr "上記のところでは、 `` id``カラムは `` parent``：func： `.relationship`の：paramref：`〜.relationship.remote_side`として適用され、 `` parent_id``を `ローカル側では、リレーションシップは多対1のように動作します。"

#: ../../orm/self_referential.rst:66
msgid ""
"As always, both directions can be combined into a bidirectional "
"relationship using the :func:`.backref` function::"
msgstr "いつものように、：func： `.backref`関数を使って両方向を双方向関係に結合することができます::"

#: ../../orm/self_referential.rst:78
msgid ""
"There are several examples included with SQLAlchemy illustrating self-"
"referential strategies; these include :ref:`examples_adjacencylist` and "
":ref:`examples_xmlpersistence`."
msgstr "自己参照戦略を示すSQLAlchemyには、いくつかの例があります。 ref： `examples_adjacencylist`と：ref：` examples_xmlpersistence`があります。"

#: ../../orm/self_referential.rst:83
msgid "Composite Adjacency Lists"
msgstr "複合隣接リスト"

#: ../../orm/self_referential.rst:85
msgid ""
"A sub-category of the adjacency list relationship is the rare case where "
"a particular column is present on both the \"local\" and \"remote\" side "
"of the join condition.  An example is the ``Folder`` class below; using a"
" composite primary key, the ``account_id`` column refers to itself, to "
"indicate sub folders which are within the same account as that of the "
"parent; while ``folder_id`` refers to a specific folder within that "
"account::"
msgstr "隣接リスト関係のサブカテゴリは、特定の列が結合条件の\ &quot;ローカル\&quot;と\ &quot;リモート\&quot;の両方に存在するまれなケースです。例は、以下の `` Folder``クラスです。複合主キーを使用する場合、 `` account_id``列は、それ自身を参照して、親アカウントと同じアカウント内にあるサブフォルダを示します。 `` folder_id``はそのアカウント内の特定のフォルダを参照しています::"

#: ../../orm/self_referential.rst:111
msgid ""
"Above, we pass ``account_id`` into the "
":paramref:`~.relationship.remote_side` list. :func:`.relationship` "
"recognizes that the ``account_id`` column here is on both sides, and "
"aligns the \"remote\" column along with the ``folder_id`` column, which "
"it recognizes as uniquely present on the \"remote\" side."
msgstr "上では、： `account_id``を：paramref：`〜.relationship.remote_side`リストに渡します。 ：func： `.relationship`は、ここにある` `account_id``カラムが両側にあることを認識し、\&quot; remote \ &quot;カラムと` `folder_id``カラムを整列させます。 &quot;リモート\&quot;側。"

#: ../../orm/self_referential.rst:117
msgid ""
"Support for self-referential composite keys in :func:`.relationship` "
"where a column points to itself."
msgstr "自己参照複合キーのサポート：func： `.relationship`カラムは、それ自身を指します。"

#: ../../orm/self_referential.rst:122
msgid "Self-Referential Query Strategies"
msgstr "自己参照クエリの戦略"

#: ../../orm/self_referential.rst:124
msgid "Querying of self-referential structures works like any other query::"
msgstr "自己参照構造の問合せは、他の問合せと同様に機能します。"

#: ../../orm/self_referential.rst:129
msgid ""
"However extra care is needed when attempting to join along the foreign "
"key from one level of the tree to the next.  In SQL, a join from a table "
"to itself requires that at least one side of the expression be "
"\"aliased\" so that it can be unambiguously referred to."
msgstr "ただし、ツリーの1つのレベルから次のレベルへの外部キーに沿って結合しようとすると、特別な注意が必要です。 SQLでは、テーブルからそれ自身への結合は、明示的に参照できるように、式の少なくとも片方を\ &quot;別名\&quot;にする必要があります。"

#: ../../orm/self_referential.rst:134
msgid ""
"Recall from :ref:`ormtutorial_aliases` in the ORM tutorial that the "
":func:`.orm.aliased` construct is normally used to provide an \"alias\" "
"of an ORM entity.  Joining from ``Node`` to itself using this technique "
"looks like:"
msgstr "ORMチュートリアルの：ref： `ormtutorial_aliases`を思い出してください。：func：` .orm.aliased`構文は通常、ORMエンティティの\ &quot;エイリアス\&quot;を提供するために使用されます。このテクニックを使って `` Node``から自分自身に参加すると以下のようになります："

#: ../../orm/self_referential.rst:157
msgid ""
":meth:`.Query.join` also includes a feature known as "
":paramref:`.Query.join.aliased` that can shorten the verbosity self- "
"referential joins, at the expense of query flexibility.  This feature "
"performs a similar \"aliasing\" step to that above, without the need for "
"an explicit entity.   Calls to :meth:`.Query.filter` and similar "
"subsequent to the aliased join will **adapt** the ``Node`` entity to be "
"that of the alias:"
msgstr "：meth： `.Query.join`には、クエリの柔軟性を犠牲にして、冗長自己参照結合を短縮できるparamref：` .Query.join.aliased`という機能も含まれています。この機能は、明示的なエンティティを必要とせずに、上記と同様のエイリアス処理を行います。 ：meth： `.Query.filter`などのエイリアス化された結合に続く呼び出しは、エイリアスのものになるように` `Node``エンティティを適応させます**："

#: ../../orm/self_referential.rst:179
msgid ""
"To add criterion to multiple points along a longer join, add "
":paramref:`.Query.join.from_joinpoint` to the additional "
":meth:`~.Query.join` calls:"
msgstr "より長い結合に沿って複数のポイントに基準を追加するには、paramref： `.Query.join.from_joinpoint`を追加：meth：`〜.Query.join`呼び出しに追加します："

#: ../../orm/self_referential.rst:205
msgid ""
":meth:`.Query.reset_joinpoint` will also remove the \"aliasing\" from "
"filtering calls::"
msgstr "：meth： `.Query.reset_joinpoint`はフィルタリング呼び出しから\&quot; aliasing \ &quot;も削除します::"

#: ../../orm/self_referential.rst:214
msgid ""
"For an example of using :paramref:`.Query.join.aliased` to arbitrarily "
"join along a chain of self-referential nodes, see "
":ref:`examples_xmlpersistence`."
msgstr "：paramref： `.Query.join.aliased`を使って、自己参照ノードのチェーンに沿って任意に結合する例については、：ref：` examples_xmlpersistence`を参照してください。"

#: ../../orm/self_referential.rst:221
msgid "Configuring Self-Referential Eager Loading"
msgstr "自己参照型eagerローディングのコンフィグレーション"

#: ../../orm/self_referential.rst:223
msgid ""
"Eager loading of relationships occurs using joins or outerjoins from "
"parent to child table during a normal query operation, such that the "
"parent and its immediate child collection or reference can be populated "
"from a single SQL statement, or a second statement for all immediate "
"child collections. SQLAlchemy's joined and subquery eager loading use "
"aliased tables in all cases when joining to related items, so are "
"compatible with self-referential joining. However, to use eager loading "
"with a self-referential relationship, SQLAlchemy needs to be told how "
"many levels deep it should join and/or query; otherwise the eager load "
"will not take place at all. This depth setting is configured via "
":paramref:`~.relationships.join_depth`:"
msgstr "通常の照会操作中に親から子表への結合または外部結合を使用して、親およびその直下の子のコレクションまたは参照に1つのSQL文またはすべての直接の子コレクションの2つ目の文を入れることができます。 SQLAlchemyの結合およびサブクエリeagerローディングは、関連項目への結合時にエイリアステーブルを使用するため、自己参照結合と互換性があります。しかし、自己参照関係を持つ熱心な読み込みを使用するには、SQLAlchemyにいくつのレベルの結合やクエリが必要かを伝える必要があります。そうでなければ熱心な負荷はまったく起こりません。この深度の設定は、paramref： `〜.relationships.join_depth`によって設定されます："


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../orm/join_conditions.rst:4
msgid "Configuring how Relationship Joins"
msgstr "リレーションシップの参加方法のコンフィグレーション"

#: ../../orm/join_conditions.rst:6
msgid ""
":func:`.relationship` will normally create a join between two tables by "
"examining the foreign key relationship between the two tables to "
"determine which columns should be compared.  There are a variety of "
"situations where this behavior needs to be customized."
msgstr "：func： `.relationship`は通常、2つのテーブル間の外部キーの関係を調べて、どちらのカラムを比較すべきかを判断することによって、2つのテーブル間の結合を作成します。この動作をカスタマイズする必要があるさまざまな状況があります。"

#: ../../orm/join_conditions.rst:14
msgid "Handling Multiple Join Paths"
msgstr "複数の結合パスの処理"

#: ../../orm/join_conditions.rst:16
msgid ""
"One of the most common situations to deal with is when there are more "
"than one foreign key path between two tables."
msgstr "対処する最も一般的な状況の1つは、2つのテーブルの間に複数の外部キーパスがある場合です。"

#: ../../orm/join_conditions.rst:19
msgid ""
"Consider a ``Customer`` class that contains two foreign keys to an "
"``Address`` class::"
msgstr "`` Address``クラスへの2つの外部キーを含む `` Customer``クラスを考えてみましょう::"

#: ../../orm/join_conditions.rst:47
msgid "The above mapping, when we attempt to use it, will produce the error::"
msgstr "上記のマッピングは、それを使用しようとすると、エラー::"

#: ../../orm/join_conditions.rst:56
msgid ""
"The above message is pretty long.  There are many potential messages that"
" :func:`.relationship` can return, which have been carefully tailored to "
"detect a variety of common configurational issues; most will suggest the "
"additional configuration that's needed to resolve the ambiguity or other "
"missing information."
msgstr "上記のメッセージはかなり長いです。次のような潜在的なメッセージがあります。func： `.relationship`が返ることができます。これは、さまざまな共通の設定上の問題を検出するために慎重に調整されています。ほとんどの場合、あいまいさやその他の不足している情報を解決するために必要な追加設定が必要です。"

#: ../../orm/join_conditions.rst:62
msgid ""
"In this case, the message wants us to qualify each :func:`.relationship` "
"by instructing for each one which foreign key column should be "
"considered, and the appropriate form is as follows::"
msgstr "この場合、メッセージは外部キー列を考慮する必要があるそれぞれについて指示することにより、それぞれ：func： `.relationship`を修飾することを希望し、適切な形式は次のとおりです。"

#: ../../orm/join_conditions.rst:77
msgid ""
"Above, we specify the ``foreign_keys`` argument, which is a "
":class:`.Column` or list of :class:`.Column` objects which indicate those"
" columns to be considered \"foreign\", or in other words, the columns "
"that contain a value referring to a parent table. Loading the "
"``Customer.billing_address`` relationship from a ``Customer`` object will"
" use the value present in ``billing_address_id`` in order to identify the"
" row in ``Address`` to be loaded; similarly, ``shipping_address_id`` is "
"used for the ``shipping_address`` relationship.   The linkage of the two "
"columns also plays a role during persistence; the newly generated primary"
" key of a just-inserted ``Address`` object will be copied into the "
"appropriate foreign key column of an associated ``Customer`` object "
"during a flush."
msgstr "上記では、foreign_keys`引数を指定しています。これは：class： `.Column`またはclass：` .Column`オブジェクトのリストで、これらの列は\ &quot;foreign \&quot;とみなされます。つまり、親テーブルを参照する値を含む列。 `` Customer``オブジェクトから `` Customer.billing_address``関係をロードすると、 `` billing_address_id``にある値を使用してロードされる `` Address``の行を識別します。同様に、 `` shipping_address_id``は `` shipping_address``関係のために使われます。 2つの列のリンケージは、永続性の際にも役割を果たします。新たに生成されたちょうど挿入された `` Address``オブジェクトの主キーは、フラッシュ中に関連する `` Customer``オブジェクトの適切な外部キー列にコピーされます。"

#: ../../orm/join_conditions.rst:88
msgid ""
"When specifying ``foreign_keys`` with Declarative, we can also use string"
" names to specify, however it is important that if using a list, the "
"**list is part of the string**::"
msgstr "Declarativeで `` foreign_keys``を指定するときは、文字列名を使用して指定することもできますが、リストを使用する場合、**リストは文字列** ::の一部です"

#: ../../orm/join_conditions.rst:94
msgid ""
"In this specific example, the list is not necessary in any case as "
"there's only one :class:`.Column` we need::"
msgstr "この特定の例では、リストは必要ではありません：class： `.Column`必要なもの::"

#: ../../orm/join_conditions.rst:99
msgid ""
":func:`.relationship` can resolve ambiguity between foreign key targets "
"on the basis of the ``foreign_keys`` argument alone; the "
":paramref:`~.relationship.primaryjoin` argument is no longer needed in "
"this situation."
msgstr "：func： `.relationship`は、` `foreign_keys``引数のみに基づいて、外部キーターゲット間のあいまいさを解決できます。この状況では：paramref： `〜.relationship.primaryjoin`引数は必要ありません。"

#: ../../orm/join_conditions.rst:107
msgid "Specifying Alternate Join Conditions"
msgstr "代替結合条件の指定"

#: ../../orm/join_conditions.rst:109
msgid ""
"The default behavior of :func:`.relationship` when constructing a join is"
" that it equates the value of primary key columns on one side to that of "
"foreign-key-referring columns on the other. We can change this criterion "
"to be anything we'd like using the :paramref:`~.relationship.primaryjoin`"
" argument, as well as the :paramref:`~.relationship.secondaryjoin` "
"argument in the case when a \"secondary\" table is used."
msgstr "結合を構築するときの：func： `.relationship`のデフォルトの動作は、一方の主キー列の値を他方の外部キー参照列の値と等しくすることです。 paramref： `〜.relationship.primaryjoin`の引数だけでなく、：paramref：`〜.relationship.secondaryjoin`引数を使って、この基準を変更して、 &quot;テーブルが使用されます。"

#: ../../orm/join_conditions.rst:117
msgid ""
"In the example below, using the ``User`` class as well as an ``Address`` "
"class which stores a street address,  we create a relationship "
"``boston_addresses`` which will only load those ``Address`` objects which"
" specify a city of \"Boston\"::"
msgstr "下記の例では、 `` User``クラスと住所を格納する `` Address``クラスを使用して、 `` boston_addresses``という関係を作成します。 \ &quot;ボストン\&quot;の都市を指定する::"

#: ../../orm/join_conditions.rst:146
msgid ""
"Within this string SQL expression, we made use of the :func:`.and_` "
"conjunction construct to establish two distinct predicates for the join "
"condition - joining both the ``User.id`` and ``Address.user_id`` columns "
"to each other, as well as limiting rows in ``Address`` to just "
"``city='Boston'``.   When using Declarative, rudimentary SQL functions "
"like :func:`.and_` are automatically available in the evaluated namespace"
" of a string :func:`.relationship` argument."
msgstr "この文字列のSQL式では、：func： `.and_`結合構文を使用して、結合条件の2つの異なる述語を確立しました。これは、` `User.id``と` `Address.user_id``列を`` Address``の行を単に `` city = &#39;Boston&#39;``に制限するだけです。 Declarativeを使用する場合、func： `.and_`のような基本的なSQL関数は、評価されたstring：func：` .relationship`引数の名前空間で自動的に使用できます。"

#: ../../orm/join_conditions.rst:153
msgid ""
"The custom criteria we use in a :paramref:`~.relationship.primaryjoin` is"
" generally only significant when SQLAlchemy is rendering SQL in order to "
"load or represent this relationship. That is, it's used in the SQL "
"statement that's emitted in order to perform a per-attribute lazy load, "
"or when a join is constructed at query time, such as via "
":meth:`.Query.join`, or via the eager \"joined\" or \"subquery\" styles "
"of loading.   When in-memory objects are being manipulated, we can place "
"any ``Address`` object we'd like into the ``boston_addresses`` "
"collection, regardless of what the value of the ``.city`` attribute is."
"   The objects will remain present in the collection until the attribute "
"is expired and re-loaded from the database where the criterion is "
"applied.   When a flush occurs, the objects inside of "
"``boston_addresses`` will be flushed unconditionally, assigning value of "
"the primary key ``user.id`` column onto the foreign-key-holding "
"``address.user_id`` column for each row.  The ``city`` criteria has no "
"effect here, as the flush process only cares about synchronizing primary "
"key values into referencing foreign key values."
msgstr "：paramref： `〜.relationship.primaryjoin`で使用するカスタム条件は、SQLAlchemyがSQLをレンダリングしてこの関係をロードまたは表現するときにのみ重要です。つまり、属性単位の遅延読み込みを実行するために、またはクエリ時に：meth： `.Query.join`などのように結合が構築されたとき、またはeager \ &quot;joined \&quot;または\ &quot;subquery \&quot;スタイルの読み込みです。メモリ内のオブジェクトが操作されている場合、 `` css``属性の値に関係なく、 `` boston_addresses``コレクションに必要な `` Address``オブジェクトを置くことができます。属性が期限切れになり、基準が適用されるデータベースから再ロードされるまで、オブジェクトはコレクション内に残ります。フラッシュが発生すると、 `` boston_addresses``の中のオブジェクトは、プライマリキー `` user.id``カラムの値をそれぞれの外部キーを保持する `` address.user_id``カラムに代入して無条件でフラッシュされます行。フラッシュ処理では、プライマリキー値を参照する外部キー値に同期させるだけでよいため、 `` city``の基準はここでは何の効果もありません。"

#: ../../orm/join_conditions.rst:174
msgid "Creating Custom Foreign Conditions"
msgstr "カスタム外来の作成"

#: ../../orm/join_conditions.rst:176
msgid ""
"Another element of the primary join condition is how those columns "
"considered \"foreign\" are determined.  Usually, some subset of "
":class:`.Column` objects will specify :class:`.ForeignKey`, or otherwise "
"be part of a :class:`.ForeignKeyConstraint` that's relevant to the join "
"condition. :func:`.relationship` looks to this foreign key status as it "
"decides how it should load and persist data for this relationship.   "
"However, the :paramref:`~.relationship.primaryjoin` argument can be used "
"to create a join condition that doesn't involve any \"schema\" level "
"foreign keys.  We can combine :paramref:`~.relationship.primaryjoin` "
"along with :paramref:`~.relationship.foreign_keys` and "
":paramref:`~.relationship.remote_side` explicitly in order to establish "
"such a join."
msgstr "プライマリ結合条件のもう1つの要素は、\ &quot;foreign \&quot;とみなされる列がどのように決定されるかです。通常、class： `.Column`オブジェクトのいくつかのサブセットは：class：` .ForeignKey`を指定します。そうでなければ、join条件に関連する：class： `.ForeignKeyConstraint`の一部です。 ：func： `.relationship`は、この外部キーステータスを調べ、この関係のデータをどのようにロードして保持するかを決定します。ただし、：paramref： `〜.relationship.primaryjoin`引数を使用して、\&quot;スキーマ\ &quot;レベルの外部キーを含まない結合条件を作成できます。 paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.foreign_keys`と：paramref： `〜.relationship.remote_side`を明示的に組み合わせて、このような結合を確立することができます。"

#: ../../orm/join_conditions.rst:187
msgid ""
"Below, a class ``HostEntry`` joins to itself, equating the string "
"``content`` column to the ``ip_address`` column, which is a PostgreSQL "
"type called ``INET``. We need to use :func:`.cast` in order to cast one "
"side of the join to the type of the other::"
msgstr "以下では、 `` HostEntry``というクラスが、 `` content``という文字列を `` INET``と呼ばれるPostgreSQL型の `` ip_address``列に対応させて自分自身に結合します。結合の片側を他の::の型にキャストするために：func： `.cast`を使う必要があります："

#: ../../orm/join_conditions.rst:214
msgid "The above relationship will produce a join like::"
msgstr "上記の関係は、::のような結合を生成します"

#: ../../orm/join_conditions.rst:220
msgid ""
"An alternative syntax to the above is to use the :func:`.foreign` and "
":func:`.remote` :term:`annotations`, inline within the "
":paramref:`~.relationship.primaryjoin` expression. This syntax represents"
" the annotations that :func:`.relationship` normally applies by itself to"
" the join condition given the :paramref:`~.relationship.foreign_keys` and"
" :paramref:`~.relationship.remote_side` arguments.  These functions may "
"be more succinct when an explicit join condition is present, and "
"additionally serve to mark exactly the column that is \"foreign\" or "
"\"remote\" independent of whether that column is stated multiple times or"
" within complex SQL expressions::"
msgstr "上記の別の構文は、：paramref： `〜.relationship.primaryjoin`式の中で、：func：` .foreign`と：func： `.remote`：term：` annotations`をインラインで使用することです。この構文は、以下のような注釈を表します。func： `.relationship`は通常：paramref：`〜.relationship.foreign_keys`と：paramref： `〜.relationship.remote_side`引数を指定して結合条件に適用されます。これらの関数は、明示的な結合条件が存在する場合にはより簡潔であり、さらに、その列が複数回指定されているか複雑なSQL式内にあるかに関係なく、\ &quot;foreign \&quot;または\ &quot;remote \ ："

#: ../../orm/join_conditions.rst:251
msgid "Using custom operators in join conditions"
msgstr "結合条件でカスタム演算子を使用する"

#: ../../orm/join_conditions.rst:253
msgid ""
"Another use case for relationships is the use of custom operators, such "
"as PostgreSQL's \"is contained within\" ``<<`` operator when joining with"
" types such as :class:`.postgresql.INET` and :class:`.postgresql.CIDR`. "
"For custom operators we use the :meth:`.Operators.op` function::"
msgstr "関係のもう1つの使用例は、class： `.postgresql.INET`と：class：`のような型で結合するときに、PostgreSQLの\ &quot;が&quot; &quot;&lt;&lt; &lt;&lt;` `演算子の中に含まれるようなカスタム演算子の使用です。 postgresql.CIDR`。カスタム演算子では、：meth： `.Operators.op`関数を使用します::"

#: ../../orm/join_conditions.rst:260
msgid ""
"However, if we construct a :paramref:`~.relationship.primaryjoin` using "
"this operator, :func:`.relationship` will still need more information.  "
"This is because when it examines our primaryjoin condition, it "
"specifically looks for operators used for **comparisons**, and this is "
"typically a fixed list containing known comparison operators such as "
"``==``, ``<``, etc.   So for our custom operator to participate in this "
"system, we need it to register as a comparison operator using the "
":paramref:`~.Operators.op.is_comparison` parameter::"
msgstr "しかし、この演算子を使って：paramref： `〜.relationship.primaryjoin`を構築すると、：func：` .relationship`はさらに情報が必要になります。なぜなら、私たちのprimaryjoin条件を調べると、特に**比較**のために使われる演算子が検索され、これは通常、 `` == ``、 `` &lt;``などの既知の比較演算子を含む固定リストです。したがって、カスタムオペレータがこのシステムに参加するには、：paramref： `〜.Operators.op.is_comparison`パラメータを使用して比較演算子として登録する必要があります。"

#: ../../orm/join_conditions.rst:270
msgid "A complete example::"
msgstr "完全な例::"

#: ../../orm/join_conditions.rst:289
msgid "Above, a query such as::"
msgstr "上記のように、::"

#: ../../orm/join_conditions.rst:293
msgid "Will render as::"
msgstr "レンダリングする::"

#: ../../orm/join_conditions.rst:298
msgid ""
"- Added the :paramref:`.Operators.op.is_comparison` flag to assist in the"
" creation of :func:`.relationship` constructs using custom operators."
msgstr "- ：paramref： `.Operators.op.is_comparison`フラグを追加しました。カスタムオペレータを使って：func：` .relationship`コンストラクトの作成を支援します。"

#: ../../orm/join_conditions.rst:305
msgid "Overlapping Foreign Keys"
msgstr "重複する外部キー"

#: ../../orm/join_conditions.rst:307
msgid ""
"A rare scenario can arise when composite foreign keys are used, such that"
" a single column may be the subject of more than one column referred to "
"via foreign key constraint."
msgstr "外部キー制約を使用して参照される複数の列の対象となるように、複合外部キーが使用される場合、まれなシナリオが発生する可能性があります。"

#: ../../orm/join_conditions.rst:311
msgid ""
"Consider an (admittedly complex) mapping such as the ``Magazine`` object,"
" referred to both by the ``Writer`` object and the ``Article`` object "
"using a composite primary key scheme that includes ``magazine_id`` for "
"both; then to make ``Article`` refer to ``Writer`` as well, "
"``Article.magazine_id`` is involved in two separate relationships; "
"``Article.magazine`` and ``Article.writer``::"
msgstr "`` Writer``オブジェクトと `` Article``オブジェクトの両方によって参照される `` Magazine``オブジェクトのような（確かに複雑な）マッピングを考えてみましょう。両方; 「Article」を「Writer」とすると、「Article.magazine_id」は2つの別個の関係に関係する。 `` Article.magazine``と `` Article.writer`` ::"

#: ../../orm/join_conditions.rst:350
msgid "When the above mapping is configured, we will see this warning emitted::"
msgstr "上記のマッピングが設定されると、この警告が表示されます::"

#: ../../orm/join_conditions.rst:359
msgid ""
"What this refers to originates from the fact that ``Article.magazine_id``"
" is the subject of two different foreign key constraints; it refers to "
"``Magazine.id`` directly as a source column, but also refers to "
"``Writer.magazine_id`` as a source column in the context of the composite"
" key to ``Writer``.   If we associate an ``Article`` with a particular "
"``Magazine``, but then associate the ``Article`` with a ``Writer`` that's"
"  associated  with a *different* ``Magazine``, the ORM will overwrite "
"``Article.magazine_id`` non-deterministically, silently changing which "
"magazine we refer towards; it may also attempt to place NULL into this "
"columnn if we de-associate a ``Writer`` from an ``Article``.  The warning"
" lets us know this is the case."
msgstr "これは、 `` Article.magazine_id``が2つの異なる外部キー制約の対象であるという事実から始まります。 `` Magazine.id``をソース列として直接参照するだけでなく、 `` Writer``へのコンポジットキーのコンテキストで `` Writer.magazine_id``をソース列として参照します。特定の「雑誌」と「雑誌」を関連づけ、「雑誌」と関連した「作家」と「雑誌」を関連付けると、ORMは`Article.magazine_id``を非決定的に上書きし、私たちが参照する雑誌を静かに変更します。 `` Article``から `` Writer``の関連付けを解除すると、この列にNULLを配置しようと試みることもあります。警告は、これが事実であることを私たちに知らせます。"

#: ../../orm/join_conditions.rst:371
msgid ""
"To solve this, we need to break out the behavior of ``Article`` to "
"include all three of the following features:"
msgstr "これを解決するには、次の3つの機能すべてを含めるために、「Article」の動作を打破する必要があります。"

#: ../../orm/join_conditions.rst:374
msgid ""
"``Article`` first and foremost writes to ``Article.magazine_id`` based on"
" data persisted in the ``Article.magazine`` relationship only, that is a "
"value copied from ``Magazine.id``."
msgstr "`Article.magazine`の関係にのみ保存されているデータに基づいて、` `Article.magazine_id``に` `Article``が最初に書きます。これは` `Magazine.id``からコピーされた値です。"

#: ../../orm/join_conditions.rst:378
msgid ""
"``Article`` can write to ``Article.writer_id`` on behalf of data "
"persisted in the  ``Article.writer`` relationship, but only the "
"``Writer.id`` column; the ``Writer.magazine_id`` column should not be "
"written into ``Article.magazine_id`` as it ultimately is sourced from "
"``Magazine.id``."
msgstr "`` Article``は `` Article.writer_id``に `` Article.writer``の関係で保持されたデータの代わりに `` Writer.id``列に書き込むことができます。 `` Writer.magazine_id``列は `` Article.magazine_id``に書き込まれるべきではありません。最終的に `` Magazine.id``から供給されるからです。"

#: ../../orm/join_conditions.rst:384
msgid ""
"``Article`` takes ``Article.magazine_id`` into account when loading "
"``Article.writer``, even though it *doesn't* write to it on behalf of "
"this relationship."
msgstr "`` Article``は `` Article.magazine_id``を読み込む際に考慮します。ただし、この関係に代わって*書くのではありません。"

#: ../../orm/join_conditions.rst:388
msgid ""
"To get just #1 and #2, we could specify only ``Article.writer_id`` as the"
" \"foreign keys\" for ``Article.writer``::"
msgstr "＃1と＃2だけを取得するには、 `` Article.writer``の\ &quot;foreign keys \&quot;として `` Article.writer_id``のみを指定できます::"

#: ../../orm/join_conditions.rst:396
msgid ""
"However, this has the effect of ``Article.writer`` not taking "
"``Article.magazine_id`` into account when querying against ``Writer``:"
msgstr "しかし、これは `` Article.writer``が `` Writer``に対して照会する際に `` Article.magazine_id``を考慮しないという効果があります："

#: ../../orm/join_conditions.rst:407
msgid ""
"Therefore, to get at all of #1, #2, and #3, we express the join condition"
" as well as which columns to be written by combining "
":paramref:`~.relationship.primaryjoin` fully, along with either the "
":paramref:`~.relationship.foreign_keys` argument, or more succinctly by "
"annotating with :func:`~.orm.foreign`::"
msgstr "したがって、＃1、＃2、＃3のすべてを得るためには、paramref： `〜.relationship.primaryjoin`を：paramref ： `〜.relationship.foreign_keys`引数、またはより簡潔に：func：`〜.orm.foreign`でアノテーションを付けることによって："

#: ../../orm/join_conditions.rst:421
msgid ""
"the ORM will attempt to warn when a column is used as the synchronization"
" target from more than one relationship simultaneously."
msgstr "ORMは、複数の関係から同時に列が同期ターゲットとして使用されたときに警告を出します。"

#: ../../orm/join_conditions.rst:427
msgid "Non-relational Comparisons / Materialized Path"
msgstr "非リレーショナル比較/マテリアライズド・パス"

#: ../../orm/join_conditions.rst:429
msgid "this section details an experimental feature."
msgstr "このセクションでは、実験的な特徴について詳しく説明します。"

#: ../../orm/join_conditions.rst:431
msgid ""
"Using custom expressions means we can produce unorthodox join conditions "
"that don't obey the usual primary/foreign key model.  One such example is"
" the materialized path pattern, where we compare strings for overlapping "
"path tokens in order to produce a tree structure."
msgstr "カスタム式を使用すると、通常のプライマリ/外部キーモデルに従わない非定型の結合条件を生成できます。このような例の1つがマテリアライズド・パス・パターンです。ここでは、ツリー構造を生成するためにパス・トークンを重複させるために文字列を比較します。"

#: ../../orm/join_conditions.rst:436
msgid ""
"Through careful use of :func:`.foreign` and :func:`.remote`, we can build"
" a relationship that effectively produces a rudimentary materialized path"
" system.   Essentially, when :func:`.foreign` and :func:`.remote` are on "
"the *same* side of the comparison expression, the relationship is "
"considered to be \"one to many\"; when they are on *different* sides, the"
" relationship is considered to be \"many to one\".   For the comparison "
"we'll use here, we'll be dealing with collections so we keep things "
"configured as \"one to many\"::"
msgstr "：func： `.foreign`と：func：` .remote`を注意深く使用することで、初歩的なマテリアライズドパスシステムを効果的に生成する関係を構築できます。基本的に、：func： `.foreign`と：func：` .remote`が比較式の*同じ側にある場合、その関係は\ &quot;1対多\&quot;とみなされます。彼らが*異なる*側にいるとき、その関係は\ &quot;many to one \&quot;とみなされます。ここで使用する比較のために、コレクションを扱うので、 &quot;one to many \&quot;と設定するようにしてください::"

#: ../../orm/join_conditions.rst:456
msgid ""
"Above, if given an ``Element`` object with a path attribute of "
"``\"/foo/bar2\"``, we seek for a load of ``Element.descendants`` to look "
"like::"
msgstr "上の例では、パス属性が `` \ &quot;/ foo / bar2 \&quot; ``である `` Element``オブジェクトが与えられた場合、次のように `` Element.descendants``のロードを求めます::"

#: ../../orm/join_conditions.rst:463
msgid ""
"Support has been added to allow a single-column comparison to itself "
"within a primaryjoin condition, as well as for primaryjoin conditions "
"that use :meth:`.ColumnOperators.like` as the comparison operator."
msgstr "primaryjoin条件内での単一列比較、および比較演算子として：meth： `.ColumnOperators.like`を使用するprimaryjoin条件のサポートが追加されました。"

#: ../../orm/join_conditions.rst:471
msgid "Self-Referential Many-to-Many Relationship"
msgstr "自己参照多対多リレーションシップ"

#: ../../orm/join_conditions.rst:473
msgid ""
"Many to many relationships can be customized by one or both of "
":paramref:`~.relationship.primaryjoin` and "
":paramref:`~.relationship.secondaryjoin` - the latter is significant for "
"a relationship that specifies a many-to-many reference using the "
":paramref:`~.relationship.secondary` argument. A common situation which "
"involves the usage of :paramref:`~.relationship.primaryjoin` and "
":paramref:`~.relationship.secondaryjoin` is when establishing a many-to-"
"many relationship from a class to itself, as shown below::"
msgstr "多対多リレーションシップは、paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.secondaryjoin`のいずれかまたは両方でカスタマイズできます。後者は、多対多の参照を指定する関係で重要です：paramref： `〜.relationship.secondary`引数を使用します。 paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.secondaryjoin`の使用を含む一般的な状況は、以下に示すように、クラスから多対多の関係を確立するときです："

#: ../../orm/join_conditions.rst:501
msgid ""
"Where above, SQLAlchemy can't know automatically which columns should "
"connect to which for the ``right_nodes`` and ``left_nodes`` "
"relationships.   The :paramref:`~.relationship.primaryjoin` and "
":paramref:`~.relationship.secondaryjoin` arguments establish how we'd "
"like to join to the association table. In the Declarative form above, as "
"we are declaring these conditions within the Python block that "
"corresponds to the ``Node`` class, the ``id`` variable is available "
"directly as the :class:`.Column` object we wish to join with."
msgstr "上記の場合、SQLAlchemyは、 `` right_nodes``と `` left_nodes``の関係のどちらに接続すべきかを自動的に知ることができません。 ：paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.secondaryjoin`引数は、アソシエーションテーブルへの参加方法を確立します。上記のDeclarativeフォームでは、 `` Node``クラスに対応するPythonブロック内でこれらの条件を宣言しているので、 `` id``変数は、私たちが望む：class： `.Column`オブジェクトとして直接利用できますに参加。"

#: ../../orm/join_conditions.rst:508
msgid ""
"Alternatively, we can define the :paramref:`~.relationship.primaryjoin` "
"and :paramref:`~.relationship.secondaryjoin` arguments using strings, "
"which is suitable in the case that our configuration does not have either"
" the ``Node.id`` column object available yet or the ``node_to_node`` "
"table perhaps isn't yet available. When referring to a plain "
":class:`.Table` object in a declarative string, we use the string name of"
" the table as it is present in the :class:`.MetaData`::"
msgstr "あるいは、：paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.secondaryjoin`引数を文字列で定義することができます。これは、設定にNode.id ``列オブジェクトがまだ利用可能であるか、または `` node_to_node``テーブルがおそらく利用可能ではありません。宣言的な文字列の中のplain：class： `.Table`オブジェクトを参照するとき、：class：` .MetaData` ::に存在するように、テーブルの文字列名を使用します"

#: ../../orm/join_conditions.rst:526
msgid ""
"A classical mapping situation here is similar, where ``node_to_node`` can"
" be joined to ``node.c.id``::"
msgstr "古典的なマッピング状況は似ていますが、 `` node_to_node``は `` node.c.id``に結合できます::"

#: ../../orm/join_conditions.rst:555
msgid ""
"Note that in both examples, the :paramref:`~.relationship.backref` "
"keyword specifies a ``left_nodes`` backref - when :func:`.relationship` "
"creates the second relationship in the reverse direction, it's smart "
"enough to reverse the :paramref:`~.relationship.primaryjoin` and "
":paramref:`~.relationship.secondaryjoin` arguments."
msgstr "両方の例で、：paramref： `〜.relationship.backref`キーワードは、` `left_nodes``バックリファレンスを指定します。 -  func：` .relationship`は、逆方向の第2の関係を作成するとき、 ：paramref： `〜.relationship.primaryjoin`と：paramref：`〜.relationship.secondaryjoin`引数です。"

#: ../../orm/join_conditions.rst:565
msgid "Composite \"Secondary\" Joins"
msgstr "コンポジット\ &quot;セカンダリ\&quot;の結合"

#: ../../orm/join_conditions.rst:569
msgid "This section features some new and experimental features of SQLAlchemy."
msgstr "このセクションでは、SQLAlchemyの新機能と実験的機能を紹介します。"

#: ../../orm/join_conditions.rst:571
msgid ""
"Sometimes, when one seeks to build a :func:`.relationship` between two "
"tables there is a need for more than just two or three tables to be "
"involved in order to join them.  This is an area of :func:`.relationship`"
" where one seeks to push the boundaries of what's possible, and often the"
" ultimate solution to many of these exotic use cases needs to be hammered"
" out on the SQLAlchemy mailing list."
msgstr "時には、2つのテーブルの間に：func： `.relationship &#39;を構築しようとするとき、それらに参加するために2つか3つ以上のテーブルが必要になることがあります。これは：func： `.relationship`の領域であり、可能なものの境界を突き止めようとするものであり、多くの場合、これらのエキゾチックなユースケースの究極の解決策は、SQLAlchemyのメーリングリストで叩かれる必要があります。"

#: ../../orm/join_conditions.rst:578
msgid ""
"In more recent versions of SQLAlchemy, the "
":paramref:`~.relationship.secondary` parameter can be used in some of "
"these cases in order to provide a composite target consisting of multiple"
" tables.   Below is an example of such a join condition (requires version"
" 0.9.2 at least to function as is)::"
msgstr "より最近のバージョンのSQLAlchemyでは：paramref： `〜.relationship.secondary`パラメータは、複数のテーブルからなる複合ターゲットを提供するために、これらのケースのいくつかで使用できます。以下はそのような結合条件の例です（バージョン0.9.2が少なくとも機能するために必要です）。"

#: ../../orm/join_conditions.rst:615
msgid ""
"In the above example, we provide all three of "
":paramref:`~.relationship.secondary`, "
":paramref:`~.relationship.primaryjoin`, and "
":paramref:`~.relationship.secondaryjoin`, in the declarative style "
"referring to the named tables ``a``, ``b``, ``c``, ``d`` directly.  A "
"query from ``A`` to ``D`` looks like:"
msgstr "上記の例では、paramref： `〜.relationship.secondary`、：paramref：`〜.relationship.primaryjoin`、および：paramref： `〜.relationship.secondaryjoin`の3つを、それぞれを参照する宣言的スタイルで提供します。テーブル名は `` a``、 `` b``、 `` c``、 `` d``です。 `` A``から `` D``への問い合わせは次のようになります："

#: ../../orm/join_conditions.rst:630
msgid ""
"In the above example, we take advantage of being able to stuff multiple "
"tables into a \"secondary\" container, so that we can join across many "
"tables while still keeping things \"simple\" for :func:`.relationship`, "
"in that there's just \"one\" table on both the \"left\" and the \"right\""
" side; the complexity is kept within the middle."
msgstr "上記の例では、複数のテーブルを\ &quot;セカンダリ\&quot;コンテナにまとめることができるので、func： `.relationship`のために\&quot;シンプル\ &quot;を維持しながら多くのテーブルに参加することができます。 \ &quot;left \&quot;と\ &quot;right \ sideの両方に\&quot; one \ &quot;というテーブルがあり、複雑さは真ん中に保持されています。"

#: ../../orm/join_conditions.rst:636
msgid ""
"Support is improved for allowing a :func:`.join()` construct to be used "
"directly as the target of the :paramref:`~.relationship.secondary` "
"argument, including support for joins, eager joins and lazy loading, as "
"well as support within declarative to specify complex conditions such as "
"joins involving class names as targets."
msgstr "join：eager joinとlazy loadingのサポートを含む：paramref： `〜.relationship.secondary`引数のターゲットとしてa：func：` .join（） `構造体を直接使用できるようにサポートが改善されました。宣言内でのサポートとして、クラス名をターゲットとする結合などの複雑な条件を指定します。"

#: ../../orm/join_conditions.rst:645
msgid "Relationship to Non Primary Mapper"
msgstr "非プライマリマッパーとの関係"

#: ../../orm/join_conditions.rst:647
msgid ""
"In the previous section, we illustrated a technique where we used "
":paramref:`~.relationship.secondary` in order to place additional tables "
"within a join condition.   There is one complex join case where even this"
" technique is not sufficient; when we seek to join from ``A`` to ``B``, "
"making use of any number of ``C``, ``D``, etc. in between, however there "
"are also join conditions between ``A`` and ``B`` *directly*.  In this "
"case, the join from ``A`` to ``B`` may be difficult to express with just "
"a complex :paramref:`~.relationship.primaryjoin` condition, as the "
"intermediary tables may need special handling, and it is also not "
"expressable with a :paramref:`~.relationship.secondary` object, since the"
" ``A->secondary->B`` pattern does not support any references between "
"``A`` and ``B`` directly.  When this **extremely advanced** case arises, "
"we can resort to creating a second mapping as a target for the "
"relationship.  This is where we use :func:`.mapper` in order to make a "
"mapping to a class that includes all the additional tables we need for "
"this join. In order to produce this mapper as an \"alternative\" mapping "
"for our class, we use the :paramref:`~.mapper.non_primary` flag."
msgstr "前のセクションでは、join条件内に追加のテーブルを配置するために、paramref： `.relationship.secondary`を使用する方法を示しました。この手法でも十分ではない複雑な結合ケースが1つあります。任意の数の「C」、「D」などを使用して「A」から「B」に参加しようとすると、 A``と `` B`` *直接*。この場合、 `` A``から `` B``への結合は、中間テーブルが特別な処理を必要とするかもしれないので、複雑な：paramref： `.relationship.primaryjoin`条件では表現するのが難しいかもしれません。 `` A-&gt; secondary-&gt; B``パターンは `` A``と `` B``の間の直接参照をサポートしていないので、：paramref： `〜.relationship.secondary`オブジェクトでは表現できません。この**高度な**ケースが発生すると、関係のターゲットとして2番目のマッピングを作成することに頼ることができます。ここでは、この結合に必要なすべての追加テーブルを含むクラスへのマッピングを行うためにfunc： `.mapper`を使用します。このマッパーをクラスのための\ &quot;代替\&quot;マッピングとして生成するために、：paramref： `〜.mapper.non_primary`フラグを使用します。"

#: ../../orm/join_conditions.rst:666
msgid ""
"Below illustrates a :func:`.relationship` with a simple join from ``A`` "
"to ``B``, however the primaryjoin condition is augmented with two "
"additional entities ``C`` and ``D``, which also must have rows that line "
"up with the rows in both ``A`` and ``B`` simultaneously::"
msgstr "以下は `` A``から `` B``への簡単な結合でfunc： `.relationship`を示していますが、primaryjoin条件には` `C``と` `D``という2つの追加エンティティが追加されています。同時に `` A``と `` B``の両方の行と並んでいる行を持たなければなりません::"

#: ../../orm/join_conditions.rst:709
msgid ""
"In the above case, our non-primary mapper for ``B`` will emit for "
"additional columns when we query; these can be ignored:"
msgstr "上記の場合、 `` B``のプライマリでないマッパーは、クエリを実行するときに追加の列に対して出力します。これらは無視することができます："

#: ../../orm/join_conditions.rst:720
msgid "Row-Limited Relationships with Window Functions"
msgstr "ウィンドウ関数との行限定関係"

#: ../../orm/join_conditions.rst:722
msgid ""
"Another interesting use case for non-primary mappers are situations where"
" the relationship needs to join to a specialized SELECT of any form.   "
"One scenario is when the use of a window function is desired, such as to "
"limit how many rows should be returned for a relationship.  The example "
"below illustrates a non-primary mapper relationship that will load the "
"first ten items for each collection::"
msgstr "非プライマリマッパーの別の興味深い使用例は、関係が任意のフォームの特殊なSELECTに結合する必要がある状況です。 1つのシナリオは、関係のために戻される行数を制限するなど、ウィンドウ関数の使用が必要な場合です。下の例は、各コレクションの最初の10個のアイテムを読み込む非プライマリマッパー関係を示しています::"

#: ../../orm/join_conditions.rst:754
msgid ""
"We can use the above ``partitioned_bs`` relationship with most of the "
"loader strategies, such as :func:`.selectinload`::"
msgstr "上記の `` partitioned_bs``の関係は、func： `.selectinload` ::"

#: ../../orm/join_conditions.rst:760
msgid "Where above, the \"selectinload\" query looks like:"
msgstr "上記の場合、\ &quot;selectinload \&quot;クエリは以下のようになります："

#: ../../orm/join_conditions.rst:776
msgid ""
"Above, for each matching primary key in \"a\", we will get the first ten "
"\"bs\" as ordered by \"b.id\".   By partitioning on \"a_id\" we ensure "
"that each \"row number\" is local to the parent \"a_id\"."
msgstr "上の\ &quot;a \&quot;の一致する主キーごとに、最初の10個の &quot;bs&quot;が\ &quot;b.id \&quot;の順序で取得されます。 \ &quot;a_id \&quot;を分割することで、\ &quot;行番号\&quot;が親\ &quot;a_id \&quot;に対してローカルであることが保証されます。"

#: ../../orm/join_conditions.rst:780
msgid ""
"Such a mapping would ordinarily also include a \"plain\" relationship "
"from \"A\" to \"B\", for persistence operations as well as when the full "
"set of \"B\" objects per \"A\" is desired."
msgstr "このようなマッピングには、通常、永続操作のための\ &quot;A \&quot;から\ &quot;B \&quot;への\ &quot;plain \&quot;関係も含まれ、\ &quot;A \必要である。"

#: ../../orm/join_conditions.rst:786
msgid "Building Query-Enabled Properties"
msgstr "クエリが有効なプロパティの構築"

#: ../../orm/join_conditions.rst:788
msgid ""
"Very ambitious custom join conditions may fail to be directly "
"persistable, and in some cases may not even load correctly. To remove the"
" persistence part of the equation, use the flag "
":paramref:`~.relationship.viewonly` on the "
":func:`~sqlalchemy.orm.relationship`, which establishes it as a read-only"
" attribute (data written to the collection will be ignored on flush()). "
"However, in extreme cases, consider using a regular Python property in "
"conjunction with :class:`.Query` as follows:"
msgstr "非常に野心的なカスタム結合条件は、直接永続化できず、場合によっては正しくロードされないこともあります。方程式の永続部分を削除するには、：func： `〜sqlalchemy.orm.relationship`のフラグ：paramref：`〜.relationship.viewonly`を使用します。これは、読み取り専用の属性として設定されますコレクションはflush（）で無視されます）。しかし、極端な場合には、次のように：class： `.Query`と一緒に通常のPythonプロパティを使用することを検討してください："


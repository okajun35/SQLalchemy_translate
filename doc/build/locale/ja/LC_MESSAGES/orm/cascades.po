# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../orm/cascades.rst:4
msgid "Cascades"
msgstr "カスケード"

#: ../../orm/cascades.rst:6
msgid ""
"Mappers support the concept of configurable :term:`cascade` behavior on "
":func:`~sqlalchemy.orm.relationship` constructs.  This refers to how "
"operations performed on a \"parent\" object relative to a particular "
":class:`.Session` should be propagated to items referred to by that "
"relationship (e.g. \"child\" objects), and is affected by the "
":paramref:`.relationship.cascade` option."
msgstr "マッパーは：func： `〜sqlalchemy.orm.relationship`構造体に対して、設定可能：term：` cascade`の動作をサポートしています。これは特定の：class： `.Session`に関連する\&quot;親\ &quot;オブジェクトに対する操作が、その関係（例えば\&quot;子\ &quot;オブジェクト）によって参照される項目にどのように伝播され、 ：paramref： `.relationship.cascade`オプションです。"

#: ../../orm/cascades.rst:13
msgid ""
"The default behavior of cascade is limited to cascades of the so-called "
":ref:`cascade_save_update` and :ref:`cascade_merge` settings. The typical"
" \"alternative\" setting for cascade is to add the :ref:`cascade_delete` "
"and :ref:`cascade_delete_orphan` options; these settings are appropriate "
"for related objects which only exist as long as they are attached to "
"their parent, and are otherwise deleted."
msgstr "カスケードのデフォルト動作は、いわゆる：ref： `cascade_save_update`と：ref：` cascade_merge`設定のカスケードに限定されています。カスケードの典型的な &quot;代替&quot;設定は、：ref： `cascade_delete`と：ref：` cascade_delete_orphan`オプションを追加することです。これらの設定は、親にアタッチされている限り存在し、そうでない場合は削除される関連オブジェクトに適しています。"

#: ../../orm/cascades.rst:20
msgid ""
"Cascade behavior is configured using the "
":paramref:`~.relationship.cascade` option on "
":func:`~sqlalchemy.orm.relationship`::"
msgstr "カスケードの動作は：func： `〜sqlalchemy.orm.relationship` :: paramref：`〜.relationship.cascade`オプションを使って設定します"

#: ../../orm/cascades.rst:30
msgid ""
"To set cascades on a backref, the same flag can be used with the "
":func:`~.sqlalchemy.orm.backref` function, which ultimately feeds its "
"arguments back into :func:`~sqlalchemy.orm.relationship`::"
msgstr "バックリファレンスでカスケードを設定するには、同じフラグを：func： `〜.sqlalchemy.orm.backref`関数で使用することができます。これは最終的に引数をfunc：`〜sqlalchemy.orm.relationship` ::に戻します。"

#: ../../orm/cascades.rst:43
msgid ""
"SQLAlchemy's notion of cascading behavior on relationships, as well as "
"the options to configure them, are primarily derived from the similar "
"feature in the Hibernate ORM; Hibernate refers to \"cascade\" in a few "
"places such as in `Example: Parent/Child "
"<https://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/example-"
"parentchild.html>`_. If cascades are confusing, we'll refer to their "
"conclusion, stating \"The sections we have just covered can be a bit "
"confusing. However, in practice, it all works out nicely.\""
msgstr "SQLAlchemyのリレーションシップに関するカスケード動作の概念とそれらを構成するオプションは、主にHibernate ORMの同様の機能から導出されます。 Hibernateは、「例：親/子」のようないくつかの場所で\ &quot;カスケード\&quot;を参照します。 <https://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/example-parentchild.html> `_。カスケードが混乱している場合は、「ここで取り上げたセクションはちょっと混乱するかもしれませんが、実際にはうまくいきます。"

#: ../../orm/cascades.rst:52
msgid ""
"The default value of :paramref:`~.relationship.cascade` is ``save-update,"
" merge``. The typical alternative setting for this parameter is either "
"``all`` or more commonly ``all, delete-orphan``.  The ``all`` symbol is a"
" synonym for ``save-update, merge, refresh-expire, expunge, delete``, and"
" using it in conjunction with ``delete-orphan`` indicates that the child "
"object should follow along with its parent in all cases, and be deleted "
"once it is no longer associated with that parent."
msgstr "デフォルト値：paramref： `〜.relationship.cascade`は` `save-update、merge``です。このパラメータの典型的な設定は、 ``すべて ``またはより一般的に ``すべて、削除孤立した ``のいずれかです。 `` all``シンボルは、 `` save-update、merge、refresh-expire、expunge、delete`の同義語で、 `` delete-orphan``と組み合わせて使用​​すると、子オブジェクトがその親はすべての場合において、その親とはもはや関連付けられなくなると削除される。"

#: ../../orm/cascades.rst:60
msgid ""
"The list of available values which can be specified for the "
":paramref:`~.relationship.cascade` parameter are described in the "
"following subsections."
msgstr "：paramref： `〜.relationship.cascade`パラメータで指定できる使用可能な値のリストは、次のサブセクションで説明しています。"

#: ../../orm/cascades.rst:66
msgid "save-update"
msgstr "セーブ・アップデート"

#: ../../orm/cascades.rst:68
msgid ""
"``save-update`` cascade indicates that when an object is placed into a "
":class:`.Session` via :meth:`.Session.add`, all the objects associated "
"with it via this :func:`.relationship` should also be added to that same "
":class:`.Session`.  Suppose we have an object ``user1`` with two related "
"objects ``address1``, ``address2``::"
msgstr "`` save-update``カスケードは、：meth： `.Session.add`を介してオブジェクトが：class：` .Session`に置かれたときに、this：func： `.relationship`クラス： `.Session`：同じものに追加する必要があります。 2つの関連するオブジェクト `` address1``、 `` address2`` ::を持つオブジェクト `` user1``を持っているとします。"

#: ../../orm/cascades.rst:78
msgid ""
"If we add ``user1`` to a :class:`.Session`, it will also add "
"``address1``, ``address2`` implicitly::"
msgstr "：class： `.Session`に` `user1``を追加すると、` `address1``、` `address2``が暗黙的に追加されます::"

#: ../../orm/cascades.rst:86
msgid ""
"``save-update`` cascade also affects attribute operations for objects "
"that are already present in a :class:`.Session`.  If we add a third "
"object, ``address3`` to the ``user1.addresses`` collection, it becomes "
"part of the state of that :class:`.Session`::"
msgstr "`` save-update``カスケードは：class： `.Session`に既に存在するオブジェクトの属性操作にも影響します。 3番目のオブジェクト `` address3``を `` user1.addresses``コレクションに追加すると、その状態の一部になります：class： `.Session` ::"

#: ../../orm/cascades.rst:96
msgid ""
"``save-update`` has the possibly surprising behavior which is that "
"persistent objects which were *removed* from a collection or in some "
"cases a scalar attribute may also be pulled into the :class:`.Session` of"
" a parent object; this is so that the flush process may handle that "
"related object appropriately. This case can usually only arise if an "
"object is removed from one :class:`.Session` and added to another::"
msgstr "`` save-update``はコレクションから削除された永続オブジェクトであるか、場合によってはスカラー属性も親オブジェクトの：class： `.Session`に引っ張られるという驚くべき振る舞いをします。これは、フラッシュ処理が関連するオブジェクトを適切に処理できるようにするためです。このケースは通常、オブジェクトがクラス： `.Session`から削除され、別のオブジェクトに追加された場合にのみ発生します::"

#: ../../orm/cascades.rst:113
msgid ""
"The ``save-update`` cascade is on by default, and is typically taken for "
"granted; it simplifies code by allowing a single call to "
":meth:`.Session.add` to register an entire structure of objects within "
"that :class:`.Session` at once.   While it can be disabled, there is "
"usually not a need to do so."
msgstr "`` save-update``カスケードはデフォルトでオンになっており、通常は当然のことです。 ：meth： `.Session.add`を一回呼び出すだけで、class：` .Session`内のオブジェクトの構造体全体を一度に登録することができるので、コードが簡単になります。それは無効にすることができますが、通常そうする必要はありません。"

#: ../../orm/cascades.rst:119
msgid ""
"One case where ``save-update`` cascade does sometimes get in the way is "
"in that it takes place in both directions for bi-directional "
"relationships, e.g. backrefs, meaning that the association of a child "
"object with a particular parent can have the effect of the parent object "
"being implicitly associated with that child object's :class:`.Session`; "
"this pattern, as well as how to modify its behavior using the "
":paramref:`~.relationship.cascade_backrefs` flag, is discussed in the "
"section :ref:`backref_cascade`."
msgstr "`` save-update``カスケードが途中で時々起こる1つのケースは、双方向関係（例えば、バックレファレンス）の両方向で起こるということです。つまり、特定の親との子オブジェクトの関連が、親オブジェクトのエフェクトはその子オブジェクトの暗黙的に関連付けられています：class： `.Session`;このパターンと、：paramref： `〜.relationship.cascade_backrefs`フラグを使って動作を変更する方法については、ref：` backref_cascade`のセクションで説明します。"

#: ../../orm/cascades.rst:130
msgid "delete"
msgstr "削除"

#: ../../orm/cascades.rst:132
msgid ""
"The ``delete`` cascade indicates that when a \"parent\" object is marked "
"for deletion, its related \"child\" objects should also be marked for "
"deletion.   If for example we we have a relationship ``User.addresses`` "
"with ``delete`` cascade configured::"
msgstr "`` delete``カスケードは、\ &quot;親\&quot;オブジェクトが削除対象としてマークされている場合、その関連する &quot;子&quot;オブジェクトも削除対象としてマークする必要があることを示します。たとえば、 `` User.addresses``と `` delete``カスケードを設定した関係があるとします::"

#: ../../orm/cascades.rst:142
msgid ""
"If using the above mapping, we have a ``User`` object and two related "
"``Address`` objects::"
msgstr "上記のマッピングを使用する場合、 `` User``オブジェクトと2つの関連する `` Address``オブジェクトがあります::"

#: ../../orm/cascades.rst:148
msgid ""
"If we mark ``user1`` for deletion, after the flush operation proceeds, "
"``address1`` and ``address2`` will also be deleted:"
msgstr "`` user1``に削除をマークすると、フラッシュ操作が行われた後、 `` address1``と `` address2``も削除されます："

#: ../../orm/cascades.rst:161
msgid ""
"Alternatively, if our ``User.addresses`` relationship does *not* have "
"``delete`` cascade, SQLAlchemy's default behavior is to instead de-"
"associate ``address1`` and ``address2`` from ``user1`` by setting their "
"foreign key reference to ``NULL``.  Using a mapping as follows::"
msgstr "あるいは、もし `` User.addresses``の関係が `` delete``カスケードを持っていなければ、SQLAlchemyのデフォルトの振る舞いは、 `` address1``と `` address2``を `` user1``から切り離すことですそれらの外部キー参照を `` NULL``に設定することによって、次のようなマッピングを使用する::"

#: ../../orm/cascades.rst:171
msgid ""
"Upon deletion of a parent ``User`` object, the rows in ``address`` are "
"not deleted, but are instead de-associated:"
msgstr "親の `` User``オブジェクトを削除すると、 `` address``の行は削除されませんが、代わりに関連付け解除されます："

#: ../../orm/cascades.rst:186
msgid ""
"``delete`` cascade is more often than not used in conjunction with "
":ref:`cascade_delete_orphan` cascade, which will emit a DELETE for the "
"related row if the \"child\" object is deassociated from the parent.  The"
" combination of ``delete`` and ``delete-orphan`` cascade covers both "
"situations where SQLAlchemy has to decide between setting a foreign key "
"column to NULL versus deleting the row entirely."
msgstr "`` delete``カスケードは：ref： `cascade_delete_orphan`カスケードと組み合わせて使用​​されることはよくありません。カスケードは、\&quot;子\ &quot;オブジェクトが親から分離されている場合、関連する行のDELETEを出します。 `` delete``と `` delete-orphan``カスケードの組み合わせは、SQLAlchemyが外部キー列をNULLに設定するか、行全体を削除するかを決める必要がある状況をカバーします。"

#: ../../orm/cascades.rst:195
msgid ""
"The behavior of SQLAlchemy's \"delete\" cascade has a lot of overlap with"
" the ``ON DELETE CASCADE`` feature of a database foreign key, as well as "
"with that of the ``ON DELETE SET NULL`` foreign key setting when "
"\"delete\" cascade is not specified.   Database level \"ON DELETE\" "
"cascades are specific to the \"FOREIGN KEY\" construct of the relational "
"database; SQLAlchemy allows configuration of these schema-level "
"constructs at the :term:`DDL` level using options on "
":class:`.ForeignKeyConstraint` which are described at "
":ref:`on_update_on_delete`."
msgstr "SQLAlchemyの\ &quot;delete \&quot;カスケードの動作は、データベースの外部キーの `` ON DELETE CASCADE``機能と、 `` ON DELETE SET NULL``の外部キーの設定とのオーバーラップが大きくなります\ &quot;delete \&quot;カスケードは指定されていません。データベースレベル\ &quot;ON DELETE \&quot;カスケードは、リレーショナルデータベースの\ &quot;FOREIGN KEY \&quot;構造に固有です。 SQLAlchemyでは：term： `DDL`レベルでこれらのスキーマレベルのコンストラクトを設定することができます：class：` .ForeignKeyConstraint`：ref： `on_update_on_delete`に記述されているオプションを使用します。"

#: ../../orm/cascades.rst:204
msgid ""
"It is important to note the differences between the ORM and the "
"relational database's notion of \"cascade\" as well as how they "
"integrate:"
msgstr "ORMとリレーショナルデータベースの\ &quot;カスケード\&quot;という概念とそれらの統合方法の違いに注意することは重要です。"

#: ../../orm/cascades.rst:207
msgid ""
"A database level ``ON DELETE`` cascade is configured effectively on the "
"**many-to-one** side of the relationship; that is, we configure it "
"relative to the ``FOREIGN KEY`` constraint that is the \"many\" side of a"
" relationship.  At the ORM level, **this direction is reversed**. "
"SQLAlchemy handles the deletion of \"child\" objects relative to a "
"\"parent\" from the \"parent\" side, which means that ``delete`` and "
"``delete-orphan`` cascade are configured on the **one-to-many** side."
msgstr "データベースレベルの `` ON DELETE``カスケードは、関係の** many-to-one **の側で効果的に設定されます。つまり、リレーションシップの\ &quot;many \&quot;側の &quot;FOREIGN KEY&quot;制約に関連してそれを設定します。 ORMレベルで**この方向は逆になります**。 SQLAlchemyは\ &quot;親\&quot;側から\ &quot;親\&quot;側への\ &quot;子\&quot;オブジェクトの削除を処理します。つまり、 `` delete``と `` delete-orphan``カスケードは* * 1対多**側。"

#: ../../orm/cascades.rst:216
msgid ""
"Database level foreign keys with no ``ON DELETE`` setting are often used "
"to **prevent** a parent row from being removed, as it would necessarily "
"leave an unhandled related row present.  If this behavior is desired in a"
" one-to-many relationship, SQLAlchemy's default behavior of setting a "
"foreign key to ``NULL`` can be caught in one of two ways:"
msgstr "`` ON DELETE``が設定されていないデータベースレベルの外部キーは、処理されていない関連する行が残っているため、親行が削除されないようにするためによく使用されます。この動作が一対多の関係で必要な場合、外部キーを `` NULL``に設定するSQLAlchemyのデフォルト動作は、次の2つの方法のいずれかで捕捉できます："

#: ../../orm/cascades.rst:223
msgid ""
"The easiest and most common is just to set the foreign-key-holding column"
" to ``NOT NULL`` at the database schema level.  An attempt by SQLAlchemy "
"to set the column to NULL will fail with a simple NOT NULL constraint "
"exception."
msgstr "最も簡単で最も一般的なのは、データベーススキーマレベルで外部キー保持列を `` NOT NULL``に設定するだけです。列をNULLに設定しようとすると、SQLAlchemyは単純なNOT NULL制約の例外で失敗します。"

#: ../../orm/cascades.rst:228
msgid ""
"The other, more special case way is to set the "
":paramref:`~.relationship.passive_deletes` flag to the string "
"``\"all\"``.  This has the effect of entirely disabling SQLAlchemy's "
"behavior of setting the foreign key column to NULL, and a DELETE will be "
"emitted for the parent row without any affect on the child row, even if "
"the child row is present in memory. This may be desirable in the case "
"when database-level foreign key triggers, either special ``ON DELETE`` "
"settings or otherwise, need to be activated in all cases when a parent "
"row is deleted."
msgstr "もう一つの特別な場合は、：paramref： `〜.relationship.passive_deletes`フラグを文字列` `\&quot; all \ &quot;` `に設定することです。これは、外部キー列をNULLに設定するSQLAlchemyの動作を完全に無効にし、子行がメモリに存在していても子行に影響を与えずに親行に対してDELETEを発行するという効果があります。これは、特別な `` ON DELETE` &quot;設定などのデータベースレベルの外部キーのトリガが、親の行が削除されるすべての場合にアクティブにする必要がある場合に望ましい場合があります。"

#: ../../orm/cascades.rst:237
msgid ""
"Database level ``ON DELETE`` cascade is **vastly more efficient** than "
"that of SQLAlchemy.  The database can chain a series of cascade "
"operations across many relationships at once; e.g. if row A is deleted, "
"all the related rows in table B can be deleted, and all the C rows "
"related to each of those B rows, and on and on, all within the scope of a"
" single DELETE statement.  SQLAlchemy on the other hand, in order to "
"support the cascading delete operation fully, has to individually load "
"each related collection in order to target all rows that then may have "
"further related collections.  That is, SQLAlchemy isn't sophisticated "
"enough to emit a DELETE for all those related rows at once within this "
"context."
msgstr "データベースレベルの `` ON DELETE``カスケードは** SQLAlchemyよりもはるかに効率的です**。データベースは一連のカスケード操作を多数の関係にわたって一度に連鎖させることができます。行Aが削除されると、表Bのすべての関連行が削除され、すべてのC行が単一のDELETE文の有効範囲内にあるこれらのB行にそれぞれ関連しています。一方、SQLAlchemyでは、カスケード削除操作を完全にサポートするために、関連する各コレクションを個別にロードして、すべての行をターゲットにしてから関連するコレクションを追加する必要があります。つまり、SQLAlchemyは、このコンテキスト内で関連するすべての行に対して一度にDELETEを発行するほど洗練されていません。"

#: ../../orm/cascades.rst:248
msgid ""
"SQLAlchemy doesn't **need** to be this sophisticated, as we instead "
"provide smooth integration with the database's own ``ON DELETE`` "
"functionality, by using the :paramref:`~.relationship.passive_deletes` "
"option in conjunction with properly configured foreign key constraints."
"   Under this behavior, SQLAlchemy only emits DELETE for those rows that "
"are already locally present in the :class:`.Session`; for any collections"
" that are unloaded, it leaves them to the database to handle, rather than"
" emitting a SELECT for them.  The section :ref:`passive_deletes` provides"
" an example of this use."
msgstr "SQLAlchemyは、このような洗練されたものである必要はありません。代わりに：paramref： `〜.relationship.passive_deletes`オプションを適切に使用することによって、データベース自身の` `ON DELETE``機能とのスムーズな統合を提供します構成された外部キー制約。この動作では、SQLAlchemyは：class： `.Session`;に既にローカルに存在する行に対してのみDELETEを発行します。アンロードされたコレクションの場合は、SELECTを発行するのではなく、処理するデータベースにデータベースを残します。セクション：ref： `passive_deletes`は、この使用例です。"

#: ../../orm/cascades.rst:257
msgid ""
"While database-level ``ON DELETE`` functionality works only on the "
"\"many\" side of a relationship, SQLAlchemy's \"delete\" cascade has "
"**limited** ability to operate in the *reverse* direction as well, "
"meaning it can be configured on the \"many\" side to delete an object on "
"the \"one\" side when the reference on the \"many\" side is deleted.  "
"However this can easily result in constraint violations if there are "
"other objects referring to this \"one\" side from the \"many\", so it "
"typically is only useful when a relationship is in fact a \"one to one\"."
"  The :paramref:`~.relationship.single_parent` flag should be used to "
"establish an in-Python assertion for this case."
msgstr "データベースレベルの `` ON DELETE``機能はリレーションシップの\ &quot;many \&quot;側でのみ機能しますが、SQLAlchemyの\ &quot;delete \&quot;カスケードは** reverse * \ &quot;many \&quot;側の参照が削除されたときに\ &quot;one \&quot;側のオブジェクトを削除するには\ &quot;many \&quot;側に設定することができます。しかし、これは、 &quot;many \&quot;からこの &quot;one&quot;側を参照する他のオブジェクトがあると、制約の違反につながりやすいので、通常、関係が実際には &quot;one to one&quot; 。 ：paramref： `〜.relationship.single_parent`フラグは、この場合のPythonアサーションを確立するために使われます。"

#: ../../orm/cascades.rst:269
msgid ""
"When using a :func:`.relationship` that also includes a many-to-many "
"table using the :paramref:`~.relationship.secondary` option, SQLAlchemy's"
" delete cascade handles the rows in this many-to-many table "
"automatically. Just like, as described in "
":ref:`relationships_many_to_many_deletion`, the addition or removal of an"
" object from a many-to-many collection results in the INSERT or DELETE of"
" a row in the many-to-many table, the ``delete`` cascade, when activated "
"as the result of a parent object delete operation, will DELETE not just "
"the row in the \"child\" table but also in the many-to-many table."
msgstr "：paruncref： `〜.relationship.secondary`オプションを使用して多対多テーブルも含む：：func：` .relationship`を使用すると、SQLAlchemyのdeleteカスケードはこの多対多テーブルの行を自動的に処理します。 ：ref： `relationships_many_to_many_deletion`で説明したように、多対多コレクションからオブジェクトを追加または削除すると、多対多テーブルの行のINSERTまたはDELETEが発生し、` `delete ``カスケードは、親オブジェクトの削除操作の結果として起動されると、\ &quot;子\&quot;テーブルの行だけでなく多対多テーブルも削除します。"

#: ../../orm/cascades.rst:282
msgid "delete-orphan"
msgstr "孤児を削除する"

#: ../../orm/cascades.rst:284
msgid ""
"``delete-orphan`` cascade adds behavior to the ``delete`` cascade, such "
"that a child object will be marked for deletion when it is de-associated "
"from the parent, not just when the parent is marked for deletion.   This "
"is a common feature when dealing with a related object that is \"owned\" "
"by its parent, with a NOT NULL foreign key, so that removal of the item "
"from the parent collection results in its deletion."
msgstr "`` delete-orphan``カスケードは `` delete``カスケードに振る舞いを追加します。これにより、親オブジェクトが削除マークされたときだけでなく、親オブジェクトとの関連付けが解除されたときに子オブジェクトが削除マークされます。これは、その親によって &quot;所有されている&quot;関連するオブジェクトをNOT NULL外部キーで扱う場合の共通の機能であるため、親コレクションからアイテムを削除すると削除されます。"

#: ../../orm/cascades.rst:292
msgid ""
"``delete-orphan`` cascade implies that each child object can only have "
"one parent at a time, so is configured in the vast majority of cases on a"
" one-to-many relationship.   Setting it on a many-to-one or many-to-many "
"relationship is more awkward; for this use case, SQLAlchemy requires that"
" the :func:`~sqlalchemy.orm.relationship` be configured with the "
":paramref:`~.relationship.single_parent` argument, establishes Python-"
"side validation that ensures the object is associated with only one "
"parent at a time."
msgstr "`` delete-orphan``カスケードは、各子オブジェクトが一度に1つの親しか持つことができないことを意味します。そのため、大多数の場合、1対多の関係で設定されます。多対1または多対多の関係に設定するのはもっと厄介です。この使用例では、SQLAlchemyは：func： `〜sqlalchemy.orm.relationship`を：paramref：`〜.relationship.single_parent`引数で設定し、オブジェクトが1つだけに関連付けられていることを確認するPython側の検証を行います親は一度に。"

#: ../../orm/cascades.rst:304
msgid "merge"
msgstr "行きます"

#: ../../orm/cascades.rst:306
msgid ""
"``merge`` cascade indicates that the :meth:`.Session.merge` operation "
"should be propagated from a parent that's the subject of the "
":meth:`.Session.merge` call down to referred objects. This cascade is "
"also on by default."
msgstr "`` merge``カスケードは、：meth： `.Session.merge`オペレーションが：meth：` .Session.merge`呼び出しの対象となる親から参照されるオブジェクトに伝播されるべきであることを示します。このカスケードもデフォルトでオンになっています。"

#: ../../orm/cascades.rst:314
msgid "refresh-expire"
msgstr "リフレッシュ期限切れ"

#: ../../orm/cascades.rst:316
msgid ""
"``refresh-expire`` is an uncommon option, indicating that the "
":meth:`.Session.expire` operation should be propagated from a parent down"
" to referred objects.   When using :meth:`.Session.refresh`, the referred"
" objects are expired only, but not actually refreshed."
msgstr "`` refresh-expire``は一般的ではないオプションで、：meth： `.Session.expire`操作が親から参照されたオブジェクトに伝播されるべきであることを示します。 ：meth： `.Session.refresh`を使用すると、参照されるオブジェクトは期限切れになりますが、実際にはリフレッシュされません。"

#: ../../orm/cascades.rst:324
msgid "expunge"
msgstr "消滅"

#: ../../orm/cascades.rst:326
msgid ""
"``expunge`` cascade indicates that when the parent object is removed from"
" the :class:`.Session` using :meth:`.Session.expunge`, the operation "
"should be propagated down to referred objects."
msgstr "`` expunge``カスケードは、：meth： `.Session.expunge`を使って親オブジェクトが：class：` .Session`から削除されたとき、操作は参照されるオブジェクトに伝播されるべきであることを示します。"

#: ../../orm/cascades.rst:333
msgid "Controlling Cascade on Backrefs"
msgstr "後方参照のカスケードの制御"

#: ../../orm/cascades.rst:335
msgid ""
"The :ref:`cascade_save_update` cascade by default takes place on "
"attribute change events emitted from backrefs.  This is probably a "
"confusing statement more easily described through demonstration; it means"
" that, given a mapping such as this::"
msgstr "：ref： `cascade_save_update`カスケードは、デフォルトではバックグラウンドから放出される属性変更イベントに対して行われます。これはおそらく、デモンストレーションを通じてより簡単に説明される混乱したステートメントです。これは、次のようなマッピングが与えられたことを意味します::"

#: ../../orm/cascades.rst:343
msgid ""
"If an ``Order`` is already in the session, and is assigned to the "
"``order`` attribute of an ``Item``, the backref appends the ``Item`` to "
"the ``items`` collection of that ``Order``, resulting in the ``save-"
"update`` cascade taking place::"
msgstr "セッション中に `` Order``が既に存在し、 `` Item``の `` order``属性に割り当てられている場合、バックレファレンスは `` Items``のコレクションに `` Item``を追加します`` Order``を実行し、 `` save-update``カスケードが発生します::"

#: ../../orm/cascades.rst:360
msgid ""
"This behavior can be disabled using the "
":paramref:`~.relationship.cascade_backrefs` flag::"
msgstr "この動作は、：paramref： `〜.relationship.cascade_backrefs`フラグを使って無効にすることができます::"

#: ../../orm/cascades.rst:367
msgid ""
"So above, the assignment of ``i1.order = o1`` will append ``i1`` to the "
"``items`` collection of ``o1``, but will not add ``i1`` to the session."
"   You can, of course, :meth:`~.Session.add` ``i1`` to the session at a "
"later point.   This option may be helpful for situations where an object "
"needs to be kept out of a session until it's construction is completed, "
"but still needs to be given associations to objects which are already "
"persistent in the target session."
msgstr "上のように、 `` i1.order = o1``の割り当ては、 `` o1``の `` items``コレクションに `` i1``を追加しますが、セッションに `` i1``を追加しません。もちろん、：meth： `〜.Session.add`` `i1``を後でセッションに追加できます。このオプションは、オブジェクトの構築が完了するまでオブジェクトをセッションから外しておく必要があるが、ターゲットセッションですでに永続化しているオブジェクトへの関連付けを行う必要がある場合に役立ちます。"


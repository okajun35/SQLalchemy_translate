# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../orm/inheritance_loading.rst:6
msgid "Loading Inheritance Hierarchies"
msgstr "継承階層のロード"

#: ../../orm/inheritance_loading.rst:8
msgid ""
"When classes are mapped in inheritance hierarchies using the \"joined\", "
"\"single\", or \"concrete\" table inheritance styles as described at "
":ref:`inheritance_toplevel`, the usual behavior is that a query for a "
"particular base class will also yield objects corresponding to subclasses"
" as well.   When a single query is capable of returning a result with a "
"different class or subclasses per result row, we use the term "
"\"polymorphic loading\"."
msgstr "：ref： `inheritance_toplevel`で説明されているように継承階層で\&quot; joined \ &quot;、\&quot; single \ &quot;、\&quot; concrete \ &quot;テーブルの継承スタイルを使用してマッピングされている場合、通常の動作は、サブクラスに対応するオブジェクトも生成されます。単一の問合せが結果クラスごとに異なるクラスまたはサブクラスを持つ結果を返すことができる場合は、「ポリモーフィック・ロード」という用語を使用します。"

#: ../../orm/inheritance_loading.rst:16
msgid ""
"Within the realm of polymorphic loading, specifically with joined and "
"single table inheritance, there is an additional problem of which "
"subclass attributes are to be queried up front, and which are to be "
"loaded later. When an attribute of a particular subclass is queried up "
"front, we can use it in our query as something to filter on, and it also "
"will be loaded when we get our objects back.   If it's not queried up "
"front, it gets loaded later when we first need to access it.   Basic "
"control of this behavior is provided using the "
":func:`.orm.with_polymorphic` function, as well as two variants, the "
"mapper configuration :paramref:`.mapper.with_polymorphic` in conjunction "
"with the :paramref:`.mapper.polymorphic_load` option, and the "
":class:`.Query` -level :meth:`.Query.with_polymorphic` method.    The "
"\"with_polymorphic\" family each provide a means of specifying which "
"specific subclasses of a particular base class should be included within "
"a query, which implies what columns and tables will be available in the "
"SELECT."
msgstr "多相ローディングの領域内、特に結合された単一のテーブル継承では、サブクラス属性を前に照会し、後でロードするという追加の問題があります。特定のサブクラスの属性が前面に照会されると、それを照会でフィルターにかけることができ、オブジェクトを戻すときにもロードされます。正面まで問い合わせなければ、最初にアクセスする必要があるときに後で読み込まれます。この動作の基本的な制御は、：func： `.orm.with_polymorphic`関数と、マッパー設定の2つのバリエーション、paramref：` .mapper.with_polymorphic`と：paramref： `.mapper.polymorphic_load `オプション、：class：` .Query` -level：meth： `.Query.with_polymorphic`メソッドです。 \ &quot;with_polymorphic \&quot;ファミリは、クエリ内に特定の基本クラスのどの特定のサブクラスを含めるかを指定する手段を提供します。これは、SELECTで使用できる列とテーブルを示します。"

#: ../../orm/inheritance_loading.rst:34
msgid "Using with_polymorphic"
msgstr "with_polymorphicの使用"

#: ../../orm/inheritance_loading.rst:36
msgid ""
"For the following sections, assume the ``Employee`` / ``Engineer`` / "
"``Manager`` examples introduced in :ref:`inheritance_toplevel`."
msgstr "以下のセクションでは、ref： `inheritance_toplevel`に導入された` `Employee`` /` `Engineer`` /` `Manager``の例を想定しています。"

#: ../../orm/inheritance_loading.rst:39
msgid ""
"Normally, when a :class:`.Query` specifies the base class of an "
"inheritance hierarchy, only the columns that are local to that base class"
" are queried::"
msgstr "通常、a：class： `.Query`が継承階層の基本クラスを指定すると、その基本クラスに対してローカルな列だけが照会されます::"

#: ../../orm/inheritance_loading.rst:45
msgid ""
"Above, for both single and joined table inheritance, only the columns "
"local to ``Employee`` will be present in the SELECT.   We may get back "
"instances of ``Engineer`` or ``Manager``, however they will not have the "
"additional attributes loaded until we first access them, at which point a"
" lazy load is emitted."
msgstr "上では、単一テーブル継承と結合テーブル継承の両方で、 `` Employee``にローカルな列だけがSELECTに存在します。 `` Engineer``や `` Manager``のインスタンスを返すかもしれませんが、最初にアクセスするまで追加の属性をロードすることはありません。その時点で遅延ロードが発生します。"

#: ../../orm/inheritance_loading.rst:51
msgid ""
"Similarly, if we wanted to refer to columns mapped to ``Engineer`` or "
"``Manager`` in our query that's against ``Employee``, these columns "
"aren't available directly in either the single or joined table "
"inheritance case, since the ``Employee`` entity does not refer to these "
"columns (note that for single-table inheritance, this is common if "
"Declarative is used, but not for a classical mapping)."
msgstr "同様に、 `` Engineer``や `` Manager``にマップされたクエリを `` Employee``に照らして照会したい場合、これらのカラムは単一の継承ケースまたは結合されたテーブルの継承ケースでは直接利用できません。 `` Employee``エンティティはこれらの列を参照しないので（単一テーブルの継承の場合、Declarativeが使用される場合は一般的ですが、古典的なマッピングの場合は一般的ではないことに注意してください）。"

#: ../../orm/inheritance_loading.rst:58
msgid ""
"To solve both of these issues, the :func:`.orm.with_polymorphic` function"
" provides a special :class:`.AliasedClass` that represents a range of "
"columns across subclasses. This object can be used in a :class:`.Query` "
"like any other alias.  When queried, it represents all the columns "
"present in the classes given::"
msgstr "これらの問題を解決するため、：func： `.orm.with_polymorphic`関数は、サブクラス間の列の範囲を表す特別な：class：` .AliasedClass`を提供します。このオブジェクトは他のエイリアスと同様に、：class： `.Query`で使用できます。照会すると、与えられたクラスに存在するすべての列を表します::"

#: ../../orm/inheritance_loading.rst:70
msgid ""
"If the above mapping were using joined table inheritance, the SELECT "
"statement for the above would be:"
msgstr "上記のマッピングが結合テーブルの継承を使用していた場合、上記のSELECTステートメントは次のようになります。"

#: ../../orm/inheritance_loading.rst:91
msgid ""
"Where above, the additional tables / columns for \"engineer\" and "
"\"manager\" are included.  Similar behavior occurs in the case of single "
"table inheritance."
msgstr "上記の場合、\ &quot;engineer \&quot;と\ &quot;manager \&quot;の追加テーブル/列が含まれています。単一のテーブル継承の場合も同様の動作が発生します。"

#: ../../orm/inheritance_loading.rst:94
msgid ""
":func:`.orm.with_polymorphic` accepts a single class or mapper, a list of"
" classes/mappers, or the string ``'*'`` to indicate all subclasses:"
msgstr "：func： `.orm.with_polymorphic`は、単一のクラスまたはマッパー、クラス/マッパーのリスト、またはすべてのサブクラスを示す文字列` `&#39;*&#39;` `を受け取ります："

#: ../../orm/inheritance_loading.rst:110
msgid "Using aliasing with with_polymorphic"
msgstr "with_polymorphicでのエイリアシングの使用"

#: ../../orm/inheritance_loading.rst:112
msgid ""
"The :func:`.orm.with_polymorphic` function also provides \"aliasing\" of "
"the polymorphic selectable itself, meaning, two different "
":func:`.orm.with_polymorphic` entities, referring to the same class "
"hierarchy, can be used together.  This is available using the "
":paramref:`.orm.with_polymorphic.aliased` flag. For a polymorphic "
"selectable that is across multiple tables, the default behavior is to "
"wrap the selectable into a subquery.  Below we emit a query that will "
"select for \"employee or manager\" paired with \"employee or engineer\" "
"on employees with the same name:"
msgstr "：func： `.orm.with_polymorphic`関数は、多相選択可能オブジェクト自体の\&quot;エイリアシング\ &quot;も提供します。つまり、同じクラス階層を参照する2つの異なる：func：` .orm.with_polymorphic`エンティティを一緒に使用できます。これは、：paramref： `.orm.with_polymorphic.aliased`フラグを使って利用できます。複数の表にまたがるポリモーフィック選択可能な場合、デフォルトの振る舞いは選択可能項目をサブクエリにラップすることです。以下では、同じ名前を持つ従業員の\ &quot;従業員またはエンジニア\&quot;とペアになった\ &quot;従業員またはマネージャ\&quot;を選択するクエリを発行します。"

#: ../../orm/inheritance_loading.rst:172
msgid ""
"The creation of subqueries above is very verbose.  While it creates the "
"best encapsulation of the two distinct queries, it may be inefficient. "
":func:`.orm.with_polymorphic` includes an additional flag to help with "
"this situation, :paramref:`.orm.with_polymorphic.flat`, which will "
"\"flatten\" the subquery / join combination into straight joins, applying"
" aliasing to the individual tables instead.   Setting "
":paramref:`.orm.with_polymorphic.flat` implies "
":paramref:`.orm.with_polymorphic.aliased`, so only one flag is necessary:"
msgstr "上記のサブクエリの作成は非常に冗長です。 2つの異なるクエリの最適なカプセル化を作成しますが、非効率的な場合があります。 ：func： `.orm.with_polymorphic`は、この状況を助けるための追加のフラグを含みます：paramref：` .orm.with_polymorphic.flat`：サブクエリ/ジョインの組み合わせをストレートジョインにフラット化し、代わりに個々のテーブル。設定：paramref： `.orm.with_polymorphic.flat`は：paramref：` .orm.with_polymorphic.aliased`を意味するので、フラグは1つだけ必要です。"

#: ../../orm/inheritance_loading.rst:220
msgid ""
"Note above, when using :paramref:`.orm.with_polymorphic.flat`, it is "
"often the case when used in conjunction with joined table inheritance "
"that we get a right-nested JOIN in our statement.   Some older databases,"
" in particular older versions of SQLite, may have a problem with this "
"syntax, although virtually all modern database versions now support this "
"syntax."
msgstr "上記の注意：paramref： `.orm.with_polymorphic.flat`を使用すると、結合されたテーブルの継承と組み合わせて使用​​することがよくあります。これは、ステートメント内で正しいネストされたJOINを取得します。事実上すべての現代のデータベースバージョンでこの構文がサポートされていますが、一部の古いデータベース、特に古いバージョンのSQLiteではこの構文に問題がある可能性があります。"

#: ../../orm/inheritance_loading.rst:228
msgid ""
"The :paramref:`.orm.with_polymorphic.flat` flag only applies to the use "
"of :paramref:`.with_polymorphic` with **joined table inheritance** and "
"when the :paramref:`.with_polymorphic.selectable` argument is **not** "
"used."
msgstr "：paramref： `.orm.with_polymorphic.flat`フラグは、** paramref：` .with_polymorphic`と** joined table inheritance **の使用にのみ適用されます。：paramref： `.with_polymorphic.selectable`引数が**の場合使用されていない。"

#: ../../orm/inheritance_loading.rst:233
msgid "Referring to Specific Subclass Attributes"
msgstr "特定のサブクラス属性の参照"

#: ../../orm/inheritance_loading.rst:235
msgid ""
"The entity returned by :func:`.orm.with_polymorphic` is an "
":class:`.AliasedClass` object, which can be used in a :class:`.Query` "
"like any other alias, including named attributes for those attributes on "
"the ``Employee`` class.   In our previous example, ``eng_plus_manager`` "
"becomes the entity that we use to refer to the three-way outer join "
"above.  It also includes namespaces for each class named in the list of "
"classes, so that attributes specific to those subclasses can be called "
"upon as well.   The following example illustrates calling upon attributes"
" specific to ``Engineer`` as well as ``Manager`` in terms of "
"``eng_plus_manager``::"
msgstr "：func： `.orm.with_polymorphic`によって返されるエンティティは、：class：` .AliasedClass`オブジェクトです。これは、他のエイリアスと同様に：class： `.Query`で使用できます。 「従業員」クラス。前の例では、 `` eng_plus_manager``は上記の3-way外部結合を参照するために使用するエンティティになります。また、クラスのリストに名前が付けられた各クラスの名前空間も含まれているため、それらのサブクラスに固有の属性も呼び出すことができます。次の例は、 `` Engineer``と `` Manager``に固有の属性を `` eng_plus_manager``で呼び出す方法を示しています::"

#: ../../orm/inheritance_loading.rst:255
msgid "Setting with_polymorphic at mapper configuration time"
msgstr "マッパー設定時にwith_polymorphicを設定する"

#: ../../orm/inheritance_loading.rst:257
msgid ""
"The :func:`.orm.with_polymorphic` function serves the purpose of allowing"
" \"eager\" loading of attributes from subclass tables, as well as the "
"ability to refer to the attributes from subclass tables at query time.   "
"Historically, the \"eager loading\" of columns has been the more "
"important part of the equation.   So just as eager loading for "
"relationships can be specified as a configurational option, the "
":paramref:`.mapper.with_polymorphic` configuration parameter allows an "
"entity to use a polymorphic load by default.  We can add the parameter to"
" our ``Employee`` mapping first introduced at :ref:`joined_inheritance`::"
msgstr "：func： `.orm.with_polymorphic`関数は、サブクラステーブルからの属性の読み込みを可能にする目的と、クエリ時にサブクラステーブルの属性を参照する機能を提供します。歴史的には、列の熱心な読み込みは、方程式のより重要な部分でした。したがって、関係のための熱心な読み込みをコンフィグレーションオプションとして指定することができるように、：paramref： `.mapper.with_polymorphic`設定パラメータは、エンティティがデフォルトで多態的な読み込みを使用できるようにします。最初にref： `joined_inheritance` ::で導入した` `Employee``マッピングにパラメータを追加することができます"

#: ../../orm/inheritance_loading.rst:279
msgid ""
"Above is a common setting for :paramref:`.mapper.with_polymorphic`, which"
" is to indicate an asterisk to load all subclass columns.   In the case "
"of joined table inheritance, this option should be used sparingly, as it "
"implies that the mapping will always emit a (often large) series of LEFT "
"OUTER JOIN to many tables, which is not efficient from a SQL perspective."
"   For single table inheritance, specifying the asterisk is often a good "
"idea as the load is still against a single table only, but an additional "
"lazy load of subclass-mapped columns will be prevented."
msgstr "上記は共通の設定です：paramref： `.mapper.with_polymorphic`はすべてのサブクラス列をロードするアスタリスクを示します。結合された表の継承の場合、このオプションは、マッピングが常に（多くの場合、大きな）一連のLEFT OUTER JOINを多くの表に放出することを暗に意味するため、控えめに使用する必要があります。単一テーブルの継承では、アスタリスクを指定することはしばしば良い考えです。なぜなら、ロードは依然として単一のテーブルに対してのみですが、サブクラスにマップされた列の追加の遅延負荷が防止されるからです。"

#: ../../orm/inheritance_loading.rst:288
msgid ""
"Using :func:`.orm.with_polymorphic` or :meth:`.Query.with_polymorphic` "
"will override the mapper-level :paramref:`.mapper.with_polymorphic` "
"setting."
msgstr "：func： `.orm.with_polymorphic`または：meth：` .Query.with_polymorphic`を使うと、マッパーレベル：paramref： `.mapper.with_polymorphic`の設定が上書きされます。"

#: ../../orm/inheritance_loading.rst:291
msgid ""
"The :paramref:`.mapper.with_polymorphic` option also accepts a list of "
"classes just like :func:`.orm.with_polymorphic` to polymorphically load "
"among a subset of classes.  However, when using Declarative, providing "
"classes to this list is not directly possible as the subclasses we'd like"
" to add are not available yet.   Instead, we can specify on each subclass"
" that they should individually participate in polymorphic loading by "
"default using the :paramref:`.mapper.polymorphic_load` parameter::"
msgstr "：paramref： `.mapper.with_polymorphic`オプションは、func：` .orm.with_polymorphic`のようなクラスのリストを受け入れて、クラスのサブセット間で多態的にロードします。ただし、Declarativeを使用する場合は、追加するサブクラスがまだ使用できないため、このリストにクラスを提供することは直接できません。代わりに、各サブクラスで、デフォルトで：paramref： `.mapper.polymorphic_load`パラメータを使用して、多型ロードに個別に関与する必要があることを指定できます::"

#: ../../orm/inheritance_loading.rst:317
msgid ""
"Setting the :paramref:`.mapper.polymorphic_load` parameter to the value "
"``\"inline\"`` means that the ``Engineer`` and ``Manager`` classes above "
"are part of the \"polymorphic load\" of the base ``Employee`` class by "
"default, exactly as though they had been appended to the "
":paramref:`.mapper.with_polymorphic` list of classes."
msgstr "：paramref： `.mapper.polymorphic_load`パラメータを値` `\&quot; inline \ &quot;` `に設定すると、上記の` `Engineer``と` `Manager``クラスは\&quot;多形性ロード &quot;の一部です。 ：class：paramref： `.mapper.with_polymorphic`クラスに追加されたかのように、デフォルトで` `Employee``クラスの`"

#: ../../orm/inheritance_loading.rst:324
msgid "Setting with_polymorphic against a query"
msgstr "with_polymorphicをクエリに対して設定する"

#: ../../orm/inheritance_loading.rst:326
msgid ""
"The :func:`.orm.with_polymorphic` function evolved from a query-level "
"method :meth:`.Query.with_polymorphic`.  This method has the same purpose"
" as :func:`.orm.with_polymorphic`, except is not as flexible in its usage"
" patterns in that it only applies to the first entity of the "
":class:`.Query`.   It then takes effect for all occurences of that "
"entity, so that the entity (and its subclasses) can be referred to "
"directly, rather than using an alias object.  For simple cases it might "
"be considered to be more succinct::"
msgstr "：func： `.orm.with_polymorphic`関数は、クエリレベルのメソッド：meth：` .Query.with_polymorphic`から進化しました。このメソッドは：func： `.orm.with_polymorphic`と同じ目的を持っていますが、：class：` .Query`の最初のエンティティにのみ適用されるという点で、その使用パターンに柔軟性があります。次に、そのエンティティのすべての発生に対して有効になるので、エイリアスオブジェクトを使用するのではなく、エンティティ（およびそのサブクラス）を直接参照できます。単純なケースの場合、より簡潔であると考えられるかもしれません::"

#: ../../orm/inheritance_loading.rst:344
msgid ""
"The :meth:`.Query.with_polymorphic` method has a more complicated job "
"than the :func:`.orm.with_polymorphic` function, as it needs to correctly"
" transform entities like ``Engineer`` and ``Manager`` appropriately, but "
"not interfere with other entities.  If its flexibility is lacking, switch"
" to using :func:`.orm.with_polymorphic`."
msgstr "：meth： `.Query.with_polymorphic`メソッドは、` `Engineer``や` `Manager``のようなエンティティを適切に変換する必要があるため、：func：` .orm.with_polymorphic`関数よりも複雑です。他のエンティティに干渉することはありません。柔軟性が欠けている場合は、：func： `.orm.with_polymorphic`を使用します。"

#: ../../orm/inheritance_loading.rst:353
msgid "Polymorphic Selectin Loading"
msgstr "多型セレクチンのローディング"

#: ../../orm/inheritance_loading.rst:355
msgid ""
"An alternative to using the :func:`.orm.with_polymorphic` family of "
"functions to \"eagerly\" load the additional subclasses on an inheritance"
" mapping, primarily when using joined table inheritance, is to use "
"polymorphic \"selectin\" loading.   This is an eager loading feature "
"which works similarly to the :ref:`selectin_eager_loading` feature of "
"relationship loading.   Given our example mapping, we can instruct a load"
" of ``Employee`` to emit an extra SELECT per subclass by using the "
":func:`.orm.selectin_polymorphic` loader option::"
msgstr "主に結合されたテーブルの継承を使用する場合、継承マッピングで追加のサブクラスを読み込むために：func： `.orm.with_polymorphic`ファミリの関数を使用する代わりに、多形\&quot; selectin \ &quot;ロードを使用することができます。これは、関係ロードの：ref： `selectin_eager_loading`機能と同様に動作する熱心なローディング機能です。サンプルマッピングが与えられた場合、：func： `.orm.selectin_polymorphic`ローダーオプションを使用して、` `Employee``のロードにサブクラスごとに追加のSELECTを出すように指示できます::"

#: ../../orm/inheritance_loading.rst:370
msgid ""
"When the above query is run, two additional SELECT statements will be "
"emitted:"
msgstr "上記のクエリが実行されると、2つの追加のSELECTステートメントが発行されます。"

#: ../../orm/inheritance_loading.rst:401
msgid ""
"We can similarly establish the above style of loading to take place by "
"default by specifying the :paramref:`.mapper.polymorphic_load` parameter,"
" using the value ``\"selectin\"`` on a per-subclass basis::"
msgstr "同様に：paramref： `.mapper.polymorphic_load`パラメータを指定して、デフォルトで行われる上記のロードスタイルを、サブクラスごとに` `\&quot; selectin \ &quot;` `を使って設定することができます::"

#: ../../orm/inheritance_loading.rst:437
msgid ""
"Unlike when using :func:`.orm.with_polymorphic`, when using the "
":func:`.orm.selectin_polymorphic` style of loading, we do **not** have "
"the ability to refer to the ``Engineer`` or ``Manager`` entities within "
"our main query as filter, order by, or other criteria, as these entities "
"are not present in the initial query that is used to locate results.   "
"However, we can apply loader options that apply towards ``Engineer`` or "
"``Manager``, which will take effect when the secondary SELECT is emitted."
"  Below we assume ``Manager`` has an additional relationship "
"``Manager.paperwork``, that we'd like to eagerly load as well.  We can "
"use any type of eager loading, such as joined eager loading via the "
":func:`.joinedload` function::"
msgstr "：func： `.orm.with_polymorphic`を使用する場合とは異なり、：func：` .orm.selectin_polymorphic`スタイルの読み込みを使用する場合、私たちは `` Engineer``または `` Engineer``を参照する能力を持っていません。これらのエンティティは結果を特定するために使用される最初のクエリには存在しないため、フィルタ、オーダー、またはその他の基準としてメインクエリ内の「マネージャ」エンティティを削除します。しかし、セカンダリSELECTが発行されたときに有効になる `` Engineer``または `` Manager``に適用されるローダオプションを適用できます。以下では、 ``マネージャー ``と ``マネージャー・ペーパーワーク ``という追加の関係があり、私たちも熱心にロードしたいと思っています。 ：func： `.joinedload`関数を介してeagerにロードするなど、あらゆるタイプのeagerロードを使用できます::"

#: ../../orm/inheritance_loading.rst:456
msgid ""
"Using the query above, we get three SELECT statements emitted, however "
"the one against ``Manager`` will be:"
msgstr "上記のクエリを使用すると、3つのSELECT文が発行されますが、 `` Manager``に対するものは次のようになります。"

#: ../../orm/inheritance_loading.rst:475
msgid ""
"Note that selectin polymorphic loading has similar caveats as that of "
"selectin relationship loading; for entities that make use of a composite "
"primary key, the database in use must support tuples with \"IN\", "
"currently known to work with MySQL and Postgresql."
msgstr "セレクチン多型負荷は、セレクチン関係負荷と同様の警告を有することに留意されたい。複合主キーを使用するエンティティでは、使用されているデータベースは、現在MySQLとPostgreSQLで動作することが知られている\ &quot;IN \&quot;のタプルをサポートしている必要があります。"

#: ../../orm/inheritance_loading.rst:482
msgid ""
"The selectin polymorphic loading feature should be considered as "
"**experimental** within early releases of the 1.2 series."
msgstr "selectin多型ロード機能は、1.2シリーズの初期リリースでは**実験的**とみなされるべきです。"

#: ../../orm/inheritance_loading.rst:488
msgid "Combining selectin and with_polymorphic"
msgstr "selectinとwith_polymorphicの組み合わせ"

#: ../../orm/inheritance_loading.rst:490
msgid "works as of 1.2.0b3"
msgstr "1.2.0b3から動作します"

#: ../../orm/inheritance_loading.rst:492
msgid ""
"With careful planning, selectin loading can be applied against a "
"hierarchy that itself uses \"with_polymorphic\".  A particular use case "
"is that of using selectin loading to load a joined-inheritance subtable, "
"which then uses \"with_polymorphic\" to refer to further sub-classes, "
"which may be joined- or single-table inheritanace.  If we added a class "
"``VicePresident`` that extends ``Manager`` using single-table "
"inheritance, we could ensure that a load of ``Manager`` also fully loads "
"``VicePresident`` subtypes at the same time::"
msgstr "注意深い計画では、\ &quot;with_polymorphic \&quot;を使用する階層に対してselectinローディングを適用できます。特定のユースケースはselectinの読み込みを使用して継承継承サブテーブルをロードすることです。この継承サブテーブルは継承サブテーブルまたは単一テーブル継承のサブクラスを参照するために\ &quot;with_polymorphic \&quot;を使用します。単一テーブル継承を使用して `` Manager`を拡張したクラス `` VicePresident``を追加した場合、 `` Manager``のロードでも `` VicePidentident``サブタイプを同時に読み込むことができます::"

#: ../../orm/inheritance_loading.rst:521
msgid ""
"Above, we add a ``vp_info`` column to the ``manager`` table, local to the"
" ``VicePresident`` subclass.   This subclass is linked to the polymorphic"
" identity ``\"vp\"`` which refers to rows which have this data.     By "
"setting the load style to \"inline\", it means that a load of ``Manager``"
" objects will also ensure that the ``vp_info`` column is queried for in "
"the same SELECT statement. A query against ``Employee`` that encounters a"
" ``Manager`` row would emit similarly to the following:"
msgstr "上記では、 `` VicePresident``サブクラスの `` manager``テーブルに `` vp_info``カラムを追加しています。このサブクラスは、このデータを持つ行を参照する多相識別情報 `` \ &quot;vp \&quot; ``にリンクされています。ロードスタイルを\ &quot;inline \&quot;に設定すると、 `` Manager``オブジェクトのロードによって、同じSELECT文で `` vp_info``カラムが照会されるようになります。 `` Employee``に対する `` Manager``行に遭遇するクエリは、以下のように出力されます："

#: ../../orm/inheritance_loading.rst:544
msgid ""
"Combining \"selectin\" polymorhic loading with query-time "
":func:`.orm.with_polymorphic` usage is also possible (though this is very"
" outer-space stuff!); assuming the above mappings had no "
"``polymorphic_load`` set up, we could get the same result as follows::"
msgstr "\ &quot;selectin \&quot;ポリモリックな読み込みとquery-time：func： `.orm.with_polymorphic`の使い方も可能です（これは非常に外側のものですが）。上記のマッピングに `` polymorphic_load``が設定されていないと仮定すると、次のような結果が得られます::"

#: ../../orm/inheritance_loading.rst:559
msgid "Referring to specific subtypes on relationships"
msgstr "関係の特定のサブタイプを参照する"

#: ../../orm/inheritance_loading.rst:561
msgid ""
"Mapped attributes which correspond to a :func:`.relationship` are used in"
" querying in order to refer to the linkage between two mappings.  Common "
"uses for this are to refer to a :func:`.relationship` in "
":meth:`.Query.join` as well as in loader options like "
":func:`.joinedload`.   When using :func:`.relationship` where the target "
"class is an inheritance hierarchy, the API allows that the join, eager "
"load, or other linkage should target a specific subclass, alias, or "
":func:`.orm.with_polymorphic` alias, of that class hierarchy, rather than"
" the class directly targeted by the :func:`.relationship`."
msgstr "a：func： `.relationship &#39;に対応するマップされた属性は、2つのマッピング間のリンケージを参照するためにクエリで使用されます。これの一般的な使い方は、：meth： `.Query.join`と：func：` .joinedload`のようなローダーオプションの中の：func： `.relationship`を参照することです。ターゲットクラスが継承階層である場合、：func： `.relationship`を使用する場合、APIは、結合、eager load、または他のリンケージが特定のサブクラス、エイリアス、または：func：` .orm.with_polymorphic`エイリアスをターゲットにすることを許可します：func： `.relationship`によって直接ターゲットとされるクラスではなく、そのクラス階層のクラスです。"

#: ../../orm/inheritance_loading.rst:570
msgid ""
"The :func:`~sqlalchemy.orm.interfaces.PropComparator.of_type` method "
"allows the construction of joins along "
":func:`~sqlalchemy.orm.relationship` paths while narrowing the criterion "
"to specific derived aliases or subclasses. Suppose the ``employees`` "
"table represents a collection of employees which are associated with a "
"``Company`` object. We'll add a ``company_id`` column to the "
"``employees`` table and a new table ``companies``:"
msgstr "：func： `〜sqlalchemy.orm.interfaces.PropComparator.of_type`メソッドは：func：`〜sqlalchemy.orm.relationship`のパスに沿ってジョインを構築し、特定の派生エイリアスやサブクラスに基準を絞り込みます。 `` employees``テーブルが `` Company``オブジェクトに関連付けられた従業員の集合を表すとします。 `` employees``テーブルに `` company_id``カラムと `` companies``という新しいテーブルを追加します："

#: ../../orm/inheritance_loading.rst:608
msgid ""
"When querying from ``Company`` onto the ``Employee`` relationship, the "
":meth:`.Query.join` method as well as operators like "
":meth:`.PropComparator.any` and :meth:`.PropComparator.has` will create a"
" join from ``company`` to ``employee``, without including ``engineer`` or"
" ``manager`` in the mix. If we wish to have criterion which is "
"specifically against the ``Engineer`` class, we can tell those methods to"
" join or subquery against the set of columns representing the subclass "
"using the :meth:`~.orm.interfaces.PropComparator.of_type` operator::"
msgstr "`` Company``から `` Employee``関係に問い合わせるときは、：meth： `.Query.join`メソッドと：meth：` .PropComparator.any`と：meth： `.PropComparatorのような演算子があります。 ``エンジニア ``や ``マネージャー `&#39;を含めずに` `会社&#39;` `従業員` `に参加することになる。具体的に `` Engineer``クラスに対して基準を設定したい場合、それらのメソッドに：meth： `〜.orm.interfaces.PropComparator.of_typeを使ってサブクラスを表す列の集合にサブクラス化するかサブクエリするように指示できます`演算子::"

#: ../../orm/inheritance_loading.rst:621
msgid ""
"Similarly, to join from ``Company`` to the polymorphic entity that "
"includes both ``Engineer`` and ``Manager`` columns::"
msgstr "同様に、 `` Company``から `` Engineer``と `` Manager``カラムの両方を含む多相エンティティに参加する::"

#: ../../orm/inheritance_loading.rst:636
msgid ""
"The :meth:`.PropComparator.any` and :meth:`.PropComparator.has` operators"
" also can be used with "
":func:`~sqlalchemy.orm.interfaces.PropComparator.of_type`, such as when "
"the embedded criterion is in terms of a subclass::"
msgstr "：meth： `.PropComparator.any`と：meth：` .PropComparator.has`演算子は：func： `〜sqlalchemy.orm.interfaces.PropComparator.of_type`で使用することもできます。組み込み基準がサブクラスの用語::"

#: ../../orm/inheritance_loading.rst:649
msgid "Eager Loading of Specific or Polymorphic Subtypes"
msgstr "特定または多型サブタイプのEager読み込み"

#: ../../orm/inheritance_loading.rst:651
msgid ""
"The :func:`.joinedload`, :func:`.subqueryload`, :func:`.contains_eager` "
"and other eagerloader options support paths which make use of "
":func:`~.PropComparator.of_type`. Below, we load ``Company`` rows while "
"eagerly loading related ``Engineer`` objects, querying the ``employee`` "
"and ``engineer`` tables simultaneously::"
msgstr "：func： `.joinedload`、：func：` .subqueryload`、：func： `.contains_eager`などのeagerloaderオプションは：func：`〜.PropComparator.of_type`を利用するパスをサポートします。以下では、関連する `` Engineer``オブジェクトを熱心に読み込み、 `` employee``と `` engineer``テーブルを同時に照会しながら、 `` Company``行を読み込みます。"

#: ../../orm/inheritance_loading.rst:664
msgid ""
"As is the case with :meth:`.Query.join`, :meth:`~.PropComparator.of_type`"
" can be used to combine eager loading and :func:`.orm.with_polymorphic`, "
"so that all sub-attributes of all referenced subtypes can be loaded::"
msgstr "：meth： `.Query.join`の場合と同じように、：meth：`〜.PropComparator.of_type`を使用してeager loadingと：func： `.orm.with_polymorphic`を組み合わせることができます。すべての参照されたサブタイプを読み込むことができます::"

#: ../../orm/inheritance_loading.rst:682
msgid ""
"When using :func:`.with_polymorphic` in conjunction with "
":func:`.joinedload`, the :func:`.with_polymorphic` object must be against"
" an \"aliased\" object, that is an instance of :class:`.Alias`, so that "
"the polymorphic selectable is aliased (an informative error message is "
"raised otherwise)."
msgstr "：func： `.joinedload`と一緒に：func：` .with_polymorphic`を使用する場合、：func： `.with_polymorphic`オブジェクトは：class：`のインスタンスである\ &quot;エイリアス化された\&quot;オブジェクトに対抗する必要があります。エイリアス（alias）」を使用して、多型選択可能なエイリアスがエイリアス化されるようにする（そうでなければ情報メッセージが発生する）。"

#: ../../orm/inheritance_loading.rst:688
msgid ""
"The typical way to do this is to include the "
":paramref:`.with_polymorphic.aliased` or :paramref:`.flat` flag, which "
"will apply this aliasing automatically.  However, if the "
":paramref:`.with_polymorphic.selectable` argument is being used to pass "
"an object that is already an :class:`.Alias` object then this flag should"
" **not** be set.  The \"flat\" option implies the \"aliased\" option and "
"is an alternate form of aliasing against join objects that produces fewer"
" subqueries."
msgstr "これを行う典型的な方法は：paramref： `.with_polymorphic.aliased`または：paramref：` .flat`フラグを含めることです。このフラグはこのエイリアシングを自動的に適用します。ただし、：paramref： `.with_polymorphic.selectable`引数が既に：class：` .Alias`オブジェクトのオブジェクトを渡すために使用されている場合、このフラグは設定されません**。 \ &quot;flat \&quot;オプションは\ &quot;エイリアス\&quot;オプションを意味し、より少ないサブクエリを生成する結合オブジェクトに対するエイリアシングの代替形式です。"

#: ../../orm/inheritance_loading.rst:697
msgid ""
"Once :meth:`~.PropComparator.of_type` is the target of the eager load, "
"that's the entity we would use for subsequent chaining, not the original "
"class or derived class.  If we wanted to further eager load a collection "
"on the eager-loaded ``Engineer`` class, we access this class from the "
"namespace of the :func:`.orm.with_polymorphic` object::"
msgstr "いったん：meth： `〜.PropComparator.of_type`が熱心なロードのターゲットであれば、元のクラスや派生クラスではなく、後続の連鎖に使用するエンティティです。 eager-loadedの `` Engineer``クラスのコレクションをさらに熱心にロードしたい場合、：func： `.orm.with_polymorphic`オブジェクトの名前空間からこのクラスにアクセスします::"

#: ../../orm/inheritance_loading.rst:713
msgid "Loading objects with joined table inheritance"
msgstr "テーブル継承を結合したオブジェクトのロード"

#: ../../orm/inheritance_loading.rst:715
msgid ""
"When using joined table inheritance, if we query for a specific subclass "
"that represents a JOIN of two tables such as our ``Engineer`` example "
"from the inheritance section, the SQL emitted is a join::"
msgstr "結合テーブルの継承を使用する場合、継承セクションの &quot;Engineer&quot;のような2つのテーブルのJOINを表す特定のサブクラスをクエリすると、SQLはjoin ::"

#: ../../orm/inheritance_loading.rst:721
msgid "The above query will emit SQL like:"
msgstr "上記のクエリは次のようにSQLを出力します。"

#: ../../orm/inheritance_loading.rst:732
msgid ""
"We will then get a collection of ``Engineer`` objects back, which will "
"contain all columns from ``employee`` and ``engineer`` loaded."
msgstr "`` Engineer``オブジェクトのコレクションを取得します。これには、 `` employee``と `` engineer``のすべての列がロードされます。"

#: ../../orm/inheritance_loading.rst:735
msgid ""
"However, when emitting a :class:`.Query` against a base class, the "
"behavior is to load only from the base table::"
msgstr "しかし、基本クラスに対して：class： `.Query`を発行するとき、その動作は基本テーブル::"

#: ../../orm/inheritance_loading.rst:740
msgid ""
"Above, the default behavior would be to SELECT only from the ``employee``"
" table and not from any \"sub\" tables (``engineer`` and ``manager``, in "
"our previous examples):"
msgstr "上の例では、デフォルトの動作は `` employee``テーブルのみからのSELECTであり、前の例では `` sub &#39;&quot;テーブル（` `engineer``と` `manager``）からではありません。"

#: ../../orm/inheritance_loading.rst:752
msgid ""
"After a collection of ``Employee`` objects has been returned from the "
"query, and as attributes are requested from those ``Employee`` objects "
"which are represented in either the ``engineer`` or ``manager`` child "
"tables, a second load is issued for the columns in that related row, if "
"the data was not already loaded. So above, after accessing the objects "
"you'd see further SQL issued along the lines of:"
msgstr "クエリから `` Employee``オブジェクトのコレクションが返され、 `` engineer``または `` manager``の子テーブルで表される `` Employee``オブジェクトから属性が要求されると、データがまだロードされていなければ、関連する行の列に対する2番目のロードが発行されます。上のように、オブジェクトにアクセスした後、さらに次の行に沿って発行されたSQLが表示されます。"

#: ../../orm/inheritance_loading.rst:773
msgid ""
"The :func:`.orm.with_polymorphic` function and related configuration "
"options allow us to instead emit a JOIN up front which will conditionally"
" load against ``employee``, ``engineer``, or ``manager``, very much like "
"joined eager loading works for relationships, removing the necessity for "
"a second per-entity load::"
msgstr "：func： `.orm.with_polymorphic`関数とそれに関連する設定オプションは、条件付きで` `employee``、` `engineer``、` `manager``に対して条件付きでロードするJOIN upフロントを放出することができますリレーションシップのための結合されたeagerローディングのように、エンティティごとの2番目のロードの必要性を取り除きます::"

#: ../../orm/inheritance_loading.rst:785
msgid ""
"The above produces a query which joins the ``employee`` table to both the"
" ``engineer`` and ``manager`` tables like the following:"
msgstr "上の例は、 `` employee``テーブルを `` engineer``と `` manager``テーブルの両方にジョインするクエリを生成します。"

#: ../../orm/inheritance_loading.rst:806
msgid ""
"The section :ref:`with_polymorphic` discusses the "
":func:`.orm.with_polymorphic` function and its configurational variants."
msgstr "セクション：ref： `with_polymorphic`では：func：` .orm.with_polymorphic`関数とその構成バリアントについて説明しています。"

#: ../../orm/inheritance_loading.rst:811
msgid ":ref:`with_polymorphic`"
msgstr "：ref： `with_polymorphic`"

#: ../../orm/inheritance_loading.rst:816
msgid "Loading objects with single table inheritance"
msgstr "1つのテーブル継承を持つオブジェクトのロード"

#: ../../orm/inheritance_loading.rst:818
msgid ""
"In modern Declarative, single inheritance mappings produce "
":class:`.Column` objects that are mapped only to a subclass, and not "
"available from the superclass, even though they are present on the same "
"table. In our example from :ref:`single_inheritance`, the ``Manager`` "
"mapping for example had a :class:`.Column` specified::"
msgstr "現代の宣言型では、単一の継承マッピングが生成されます：class： `.Column`オブジェクトは、サブクラスのみにマップされ、スーパークラスからは利用できません。例：ref： `single_inheritance`の例では、` `Manager``マッピングには：class：` .Column`が指定されています::"

#: ../../orm/inheritance_loading.rst:831
msgid ""
"Above, there would be no ``Employee.manager_data`` attribute, even though"
" the ``employee`` table has a ``manager_data`` column. A query against "
"``Manager`` will include this column in the query, as well as an IN "
"clause to limit rows only to ``Manager`` objects:"
msgstr "上記の場合、 `` employee``テーブルに `` manager_data``カラムがあっても、 `` Employee.manager_data``属性はありません。 `` Manager``に対するクエリは、 `` Manager``オブジェクトだけに行を制限するIN句と同様に、このカラムをクエリに含めます："

#: ../../orm/inheritance_loading.rst:850
msgid ""
"However, in a similar way to that of joined table inheritance, a query "
"against ``Employee`` will only query for columns mapped to ``Employee``:"
msgstr "しかし、結合されたテーブルの継承と同様に、 `` Employee``に対するクエリは、 `` Employee``にマップされたカラムに対してのみクエリを実行します："

#: ../../orm/inheritance_loading.rst:862
msgid ""
"If we get back an instance of ``Manager`` from our result, accessing "
"additional columns only mapped to ``Manager`` emits a lazy load for those"
" columns, in a similar way to joined inheritance::"
msgstr "私たちの結果から `` Manager``のインスタンスを取り戻せば、 `` Manager``にのみマップされた追加のカラムにアクセスすることは、継承継承と同様に、それらのカラムに遅延ロードを発生させます::"

#: ../../orm/inheritance_loading.rst:870
msgid ""
"The :func:`.orm.with_polymorphic` function serves a similar role as  "
"joined inheritance in the case of single inheritance; it allows both for "
"eager loading of subclass attributes as well as specification of "
"subclasses in a query, just without the overhead of using OUTER JOIN::"
msgstr "：func： `.orm.with_polymorphic`関数は、単一継承の場合継承継承と同様の役割を果たします。 OUTER JOIN ::を使用するオーバーヘッドがなくても、サブクラス属性の読み込みとクエリ内のサブクラスの指定が可能です"

#: ../../orm/inheritance_loading.rst:884
msgid ""
"Above, our query remains against a single table however we can refer to "
"the columns present in ``Manager`` or ``Engineer`` using the "
"\"polymorphic\" namespace. Since we specified ``\"*\"`` for the entities,"
" both ``Engineer`` and ``Manager`` will be loaded at once.  SQL emitted "
"would be:"
msgstr "上記のクエリは1つのテーブルに対して残っていますが、 `` Manager``または `` Engineer``にあるカラムを\ &quot;polymorphic \&quot;名前空間で参照できます。エンティティに対して `` \ &quot;* \&quot; ``を指定しているので、 `` Engineer``と `` Manager``が一度に読み込まれます。 SQLは次のように出力されます。"

#: ../../orm/inheritance_loading.rst:904
msgid "Inheritance Loading API"
msgstr "継承ロードAPI"

#: of sqlalchemy.orm.with_polymorphic:1
msgid ""
"Produce an :class:`.AliasedClass` construct which specifies columns for "
"descendant mappers of the given base."
msgstr "指定された基底の子孫マッパーの列を指定するclass： `.AliasedClass`構文を生成します。"

#: of sqlalchemy.orm.with_polymorphic:4
msgid ""
"Using this method will ensure that each descendant mapper's tables are "
"included in the FROM clause, and will allow filter() criterion to be used"
" against those tables.  The resulting instances will also have those "
"columns already loaded so that no \"post fetch\" of those columns will be"
" required."
msgstr "このメソッドを使用すると、各子孫マッパーのテーブルがFROM句に含まれていることを確認し、それらのテーブルに対してfilter（）条件を使用できるようになります。結果のインスタンスには既にこれらの列がロードされているため、これらの列の\ &quot;ポストフェッチ\&quot;は必要ありません。"

#: of sqlalchemy.orm.with_polymorphic:12
msgid ""
":ref:`with_polymorphic` - full discussion of "
":func:`.orm.with_polymorphic`."
msgstr "：ref： `with_polymorphic`  -  func：` .orm.with_polymorphic`の完全な議論です。"

#: of sqlalchemy.orm.with_polymorphic
msgid "パラメータ"
msgstr "パラメータ"

#: of sqlalchemy.orm.with_polymorphic:15
msgid "Base class to be aliased."
msgstr "エイリアスするベースクラス。"

#: of sqlalchemy.orm.with_polymorphic:17
msgid ""
"a single class or mapper, or list of class/mappers, which inherit from "
"the base class. Alternatively, it may also be the string ``'*'``, in "
"which case all descending mapped classes will be added to the FROM "
"clause."
msgstr "単一のクラスまたはマッパー、または基本クラスから継承したクラス/マッパーのリスト代わりに、文字列 `` &#39;*&#39; &#39;`でもかまいません。この場合、降順にマップされたすべてのクラスがFROM句に追加されます。"

#: of sqlalchemy.orm.with_polymorphic:22
msgid ""
"when True, the selectable will be wrapped in an alias, that is ``(SELECT "
"* FROM <fromclauses>) AS anon_1``. This can be important when using the "
"with_polymorphic() to create the target of a JOIN on a backend that does "
"not support parenthesized joins, such as SQLite and older versions of "
"MySQL.   However if the :paramref:`.with_polymorphic.selectable` "
"parameter is in use with an existing :class:`.Alias` construct, then you "
"should not set this flag."
msgstr "Trueの場合、選択可能なものは別名でラップされます。つまり、 ``（* SELECT * FROM <fromclauses> ）as anon_1``。これは、with_polymorphic（）を使用して、SQLiteや古いバージョンのMySQLなど、カッコで囲まれた結合をサポートしていないバックエンドでJOINのターゲットを作成するときに重要になります。ただし、：paramref： `.with_polymorphic.selectable`パラメータが既存の：class：` .Alias`構造で使用されている場合、このフラグは設定しないでください。"

#: of sqlalchemy.orm.with_polymorphic:32
msgid ""
"Boolean, will be passed through to the :meth:`.FromClause.alias` call so "
"that aliases of :class:`.Join` objects don't include an enclosing SELECT."
"  This can lead to more efficient queries in many circumstances.  A JOIN "
"against a nested JOIN will be rewritten as a JOIN against an aliased "
"SELECT subquery on backends that don't support this syntax.  Setting "
"``flat`` to ``True`` implies the ``aliased`` flag is also ``True``.  .. "
"versionadded:: 0.9.0  .. seealso:: :meth:`.Join.alias`"
msgstr "Boolean：は：meth： `.FromClause.alias`呼び出しに渡され、class：` .Join`オブジェクトのエイリアスには囲みSELECTが含まれません。これにより、多くの状況でより効率的なクエリにつながる可能性があります。ネストされたJOINに対するJOINは、この構文をサポートしていないバックエンド上のエイリアス化されたSELECTサブクエリに対するJOINとして書き換えられます。 `` flat``を `` True``に設定すると、 `` aliased``フラグも `` True``を意味します。 .. versionadded :: 0.9.0 .. seealso :: meth： `.Join.alias`"

#: of sqlalchemy.orm.with_polymorphic:32
msgid ""
"Boolean, will be passed through to the :meth:`.FromClause.alias` call so "
"that aliases of :class:`.Join` objects don't include an enclosing SELECT."
"  This can lead to more efficient queries in many circumstances.  A JOIN "
"against a nested JOIN will be rewritten as a JOIN against an aliased "
"SELECT subquery on backends that don't support this syntax."
msgstr "Boolean：は：meth： `.FromClause.alias`呼び出しに渡され、class：` .Join`オブジェクトのエイリアスには囲みSELECTが含まれません。これにより、多くの状況でより効率的なクエリにつながる可能性があります。ネストされたJOINに対するJOINは、この構文をサポートしていないバックエンド上のエイリアス化されたSELECTサブクエリに対するJOINとして書き換えられます。"

#: of sqlalchemy.orm.with_polymorphic:39
msgid ""
"Setting ``flat`` to ``True`` implies the ``aliased`` flag is also "
"``True``."
msgstr "`` flat``を `` True``に設定すると、 `` aliased``フラグも `` True``を意味します。"

#: of sqlalchemy.orm.with_polymorphic:44
msgid ":meth:`.Join.alias`"
msgstr "：meth： `.Join.alias`"

#: of sqlalchemy.orm.with_polymorphic:46
msgid ""
"a table or select() statement that will be used in place of the generated"
" FROM clause. This argument is required if any of the desired classes use"
" concrete table inheritance, since SQLAlchemy currently cannot generate "
"UNIONs among tables automatically. If used, the ``selectable`` argument "
"must represent the full set of tables and columns mapped by every mapped "
"class. Otherwise, the unaccounted mapped columns will result in their "
"table being appended directly to the FROM clause which will usually lead "
"to incorrect results."
msgstr "生成されたFROM句の代わりに使用されるtableまたはselect（）文。この引数は、SQLAlchemyが現在テーブル間でUNIONを自動的に生成できないため、目的のクラスのいずれかが具体的なテーブル継承を使用する場合に必要です。使用されている場合、 `` selectable``引数は、マップされたすべてのクラスによってマップされたテーブルとカラムのフルセットを表す必要があります。そうしないと、未対応のマップされた列は、結果として誤った結果につながるFROM句に直接表が追加されます。"

#: of sqlalchemy.orm.with_polymorphic:56
msgid ""
"a column to be used as the \"discriminator\" column for the given "
"selectable. If not given, the polymorphic_on attribute of the base "
"classes' mapper will be used, if any. This is useful for mappings that "
"don't have polymorphic loading behavior by default."
msgstr "指定された選択肢の\ &quot;discriminator \&quot;列として使用される列。指定されていない場合、ベースクラスのマッパーのpolymorphic_on属性があればそれが使用されます。これは、デフォルトで多態的な読み込み動作を持たないマッピングに便利です。"

#: of sqlalchemy.orm.with_polymorphic:62
msgid ""
"if True, an INNER JOIN will be used.  This should only be specified if "
"querying for one specific subtype only"
msgstr "Trueの場合は、INNER JOINが使用されます。 1つの特定のサブタイプのみを照会する場合にのみ指定してください"

#: of sqlalchemy.orm.selectin_polymorphic:1
msgid ""
"Indicate an eager load should take place for all attributes specific to a"
" subclass."
msgstr "サブクラスに固有のすべての属性に対して熱心な負荷が発生することを示します。"

#: of sqlalchemy.orm.selectin_polymorphic:4
msgid ""
"This uses an additional SELECT with IN against all matched primary key "
"values, and is the per-query analogue to the ``\"selectin\"`` setting on "
"the :paramref:`.mapper.polymorphic_load` parameter."
msgstr "これは、一致するすべてのプライマリキー値に対してINで追加のSELECTを使用し、：paramref： `.mapper.polymorphic_load`パラメータの` `\&quot; selectin \ &quot;` `設定に対するクエリごとの類似点です。"

#: of sqlalchemy.orm.selectin_polymorphic:12
msgid ":ref:`inheritance_polymorphic_load`"
msgstr "：ref： `inheritance_polymorphic_load`"


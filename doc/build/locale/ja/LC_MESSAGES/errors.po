# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../errors.rst:7
msgid "Error Messages"
msgstr "エラーメッセージ"

#: ../../errors.rst:9
msgid ""
"This section lists descriptions and background for common error messages "
"and warnings raised or emitted by SQLAlchemy."
msgstr "このセクションでは、一般的なエラーメッセージと、SQLAlchemyによって発生または発生した警告の説明と背景を示します。"

#: ../../errors.rst:12
msgid ""
"SQLAlchemy normally raises errors within the context of a SQLAlchemy-"
"specific exception class.  For details on these classes, see "
":ref:`core_exceptions_toplevel` and :ref:`orm_exceptions_toplevel`."
msgstr "SQLAlchemyは通常、SQLAlchemy固有の例外クラスのコンテキスト内でエラーを発生させます。これらのクラスの詳細については、：ref： `core_exceptions_toplevel`と：ref：` orm_exceptions_toplevel`を参照してください。"

#: ../../errors.rst:16
msgid ""
"SQLAlchemy errors can roughly be separated into two categories, the "
"**programming-time error** and the **runtime error**.     Programming-"
"time errors are raised as a result of functions or methods being called "
"with incorrect arguments, or from other configuration-oriented methods "
"such  as mapper configurations that can't be resolved.   The programming-"
"time error is typically immediate and deterministic.    The runtime error"
" on the other hand represents a failure that occurs as a program runs in "
"response to some condition that occurs arbitrarily, such as database "
"connections being exhausted or some data-related issue occurring.   "
"Runtime errors are more likely to be seen in the logs of a running "
"application as the program encounters these states in response to load "
"and data being encountered."
msgstr "SQLAlchemyのエラーは大まかに、プログラミング時エラー**とランタイムエラー**の2つのカテゴリに分類されます。プログラミング時エラーは、関数やメソッドが不正な引数で呼び出されたり、解決できないマッパー構成などの他の構成指向のメソッドから呼び出された結果発生します。プログラミング時のエラーは通常、即時かつ確定的です。一方、実行時エラーは、データベース接続が枯渇したり、データ関連の問題が発生したりするなど、任意の状況に応じてプログラムが実行されるときに発生する障害を表します。ランタイムエラーは、実行中のアプリケーションのログに表示される可能性が高くなります。プログラムは、負荷やデータに遭遇したときにこれらの状態に遭遇します。"

#: ../../errors.rst:28
msgid ""
"Since runtime errors are not as easy to reproduce and often occur in "
"response to some arbitrary condition as the program runs, they are more "
"difficult to debug and also affect programs that have already been put "
"into production."
msgstr "実行時エラーは再現が容易ではなく、プログラムが実行されるときに何らかの条件に応じて頻繁に発生するため、デバッグが難しく、既にプロダクションに入っているプログラムにも影響します。"

#: ../../errors.rst:32
msgid ""
"Within this section, the goal is to try to provide background on some of "
"the most common runtime errors as well as programming time errors."
msgstr "このセクションでは、最も一般的な実行時エラーの一部とプログラミング時間エラーの背景について説明します。"

#: ../../errors.rst:37
msgid "Connections and Transactions"
msgstr "接続とトランザクション"

#: ../../errors.rst:42
msgid ""
"QueuePool limit of size <x> overflow <y> reached, connection timed out, "
"timeout <z>"
msgstr "QueuePoolサイズの制限<x>オーバーフロー<y>到達、接続タイムアウト、タイムアウト<z>"

#: ../../errors.rst:44
msgid ""
"This is possibly the most common runtime error experienced, as it "
"directly involves the work load of the application surpassing a "
"configured limit, one which typically applies to nearly all SQLAlchemy "
"applications."
msgstr "これはおそらく最も一般的な実行時エラーです。これは、構成された制限を超えるアプリケーションの作業負荷に直接関係しているため、通常はほぼすべてのSQLAlchemyアプリケーションに適用されます。"

#: ../../errors.rst:48
msgid ""
"The following points summarize what this error means, beginning with the "
"most fundamental points that most SQLAlchemy users should already be "
"familiar with."
msgstr "以下の点は、ほとんどのSQLAlchemyユーザーがすでによく知っているはずの最も基本的な点から始めて、このエラーの意味を要約しています。"

#: ../../errors.rst:52
msgid ""
"**The SQLAlchemy Engine object uses a pool of connections by default** - "
"What this means is that when one makes use of a SQL database connection "
"resource of an :class:`.Engine` object, and then :term:`releases` that "
"resource, the database connection itself remains connected to the "
"database and is returned to an internal queue where it can be used again."
"  Even though the code may appear to be ending its conversation with the "
"database, in many cases the application will still maintain a fixed "
"number of database connections that persist until the application ends or"
" the pool is explicitly disposed."
msgstr "** SQLAlchemy Engineオブジェクトは、デフォルトで接続のプールを使用します**  - これは、：class： `.Engine`オブジェクトのSQLデータベース接続リソースを使用し、次に：term：` releases`を使用すると、データベース接続自体はデータベースに接続されたままで、内部キューに戻され、そこで再び使用できます。コードがデータベースとの会話を終了しているように見えるかもしれませんが、多くの場合、アプリケーションはアプリケーションが終了するまで、またはプールが明示的に破棄されるまで、一定数のデータベース接続を維持します。"

#: ../../errors.rst:61
msgid ""
"Because of the pool, when an application makes use of a SQL database "
"connection, most typically from either making use of "
":meth:`.Engine.connect` or when making queries using an ORM "
":class:`.Session`, this activity does not necessarily establish a new "
"connection to the database at the moment the connection object is "
"acquired; it instead consults the connection pool for a connection, which"
" will often retrieve an existing connection from the pool to be re-used."
"  If no connections are available, the pool will create a new database "
"connection, but only if the pool has not surpassed a configured capacity."
msgstr "プールのために、アプリケーションがSQLデータベース接続を使用する場合、最も一般的には：meth： `.Engine.connect`を使用するか、ORM：class：` .Session`を使用してクエリを作成する場合、このアクティビティは接続オブジェクトが取得された時点で必ずしもデータベースへの新しい接続を確立する必要はなく、代わりに接続プールを調べて接続に使用します。接続では、既存の接続をプールから検索して再利用することがよくあります。使用可能な接続がない場合、プールは新しいデータベース接続を作成しますが、プールが設定された容量を超えていない場合に限ります。"

#: ../../errors.rst:71
msgid ""
"The default pool used in most cases is called :class:`.QueuePool`.  When "
"you ask this pool to give you a connection and none are available, it "
"will create a new connection **if the total number of connections in play"
" are less than a configured value**.  This value is equal to the **pool "
"size plus the max overflow**.     That means if you have configured your "
"engine as::"
msgstr "ほとんどの場合に使用されるデフォルトプールは、class： `.QueuePool`と呼ばれます。このプールに接続を許可するように依頼しても利用できない場合、再生中の接続の総数が設定された値未満であれば、新しい接続**が作成されます。この値は**プールサイズ+最大オーバーフロー**に等しいです。つまり、あなたのエンジンを次のように設定していれば、"

#: ../../errors.rst:80
msgid ""
"The above :class:`.Engine` will allow **at most 30 connections** to be in"
" play at any time, not including connections that were detached from the "
"engine or invalidated.  If a request for a new connection arrives and 30 "
"connections are already in use by other parts of the application, the "
"connection pool will block for a fixed period of time, before timing out "
"and raising this error message."
msgstr "上記の：class： `.Engine`は、エンジンから切り離されたり、無効にされた接続を含めずに、**最大で30の接続**がいつでも有効になります。新しい接続の要求が到着し、30の接続がアプリケーションの他の部分ですでに使用されている場合、接続プールは一定の時間ブロックされ、タイムアウトしてこのエラーメッセージが表示されます。"

#: ../../errors.rst:87
msgid ""
"In order to allow for a higher number of connections be in use at once, "
"the pool can be adjusted using the :paramref:`.create_engine.pool_size` "
"and :paramref:`.create_engine.max_overflow` parameters as passed to the "
":func:`.create_engine` function.      The timeout to wait for a "
"connection to be available is configured using the "
":paramref:`.create_engine.pool_timeout` parameter."
msgstr "一度に多くの接続を使用できるようにするには、：paramref： `.create_engine.pool_size`と：paramref：` .create_engine.max_overflow`パラメータを：func： `.create_engine`関数です。接続が使用可能になるまで待機するタイムアウトは、：paramref： `.create_engine.pool_timeout`パラメータを使用して設定します。"

#: ../../errors.rst:94
msgid ""
"The pool can be configured to have unlimited overflow by setting "
":paramref:`.create_engine.max_overflow` to the value \"-1\".  With this "
"setting, the pool will still maintain a fixed pool of connections, "
"however it will never block upon a new connection being requested; it "
"will instead unconditionally make a new connection if none are available."
msgstr "プールは、paramref： `.create_engine.max_overflow`を値「1」に設定することにより、無制限のオーバーフローを持つように設定することができます。この設定では、プールには固定接続プールが維持されますが、新しい接続が要求されるとブロックされません。使用できない場合は、無条件に新しい接続を作成します。"

#: ../../errors.rst:100
msgid ""
"However, when running in this way, if the application has an issue where "
"it is using up all available connectivity resources, it will eventually "
"hit the configured limit of available connections on the database itself,"
" which will again return an error.  More seriously, when the application "
"exhausts the database of connections, it usually will have caused a great"
" amount of  resources to be used up before failing, and can also "
"interfere with other applications and database status mechanisms that "
"rely upon being able to connect to the database."
msgstr "ただし、この方法で実行すると、使用可能なすべての接続リソースを使用しているアプリケーションに問題が発生すると、データベース自体で使用可能な接続の構成済みの制限に達し、エラーが返されます。さらに真剣に言えば、アプリケーションが接続のデータベースを使い果たしてしまうと、大量のリソースが失敗する前に使い切られ、データベースに接続できることに依存する他のアプリケーションやデータベースの状態の仕組みにも干渉することになります。"

#: ../../errors.rst:109
msgid ""
"Given the above, the connection pool can be looked at as a **safety valve"
" for connection use**, providing a critical layer of protection against a"
" rogue application causing the entire database to become unavailable to "
"all other applications.   When receiving this error message, it is vastly"
" preferable to repair the issue using up too many connections and/or "
"configure the limits appropriately, rather than allowing for unlimited "
"overflow which does not actually solve the underlying issue."
msgstr "上記を考慮すると、接続プールは**接続用の安全弁**として見ることができ、不正なアプリケーションに対してクリティカルな保護層を提供し、データベース全体が他のすべてのアプリケーションで使用できなくなる原因となります。このエラーメッセージが表示された場合、実際に根本的な問題を解決しない無制限のオーバーフローを許可するのではなく、過剰な接続を使用して問題を修復したり、適切な制限を構成したりすることが非常に好ましいです。"

#: ../../errors.rst:117
msgid ""
"What causes an application to use up all the connections that it has "
"available?"
msgstr "何が原因でアプリケーションが利用可能なすべての接続を使い果たしますか？"

#: ../../errors.rst:119
msgid ""
"**The application is fielding too many concurrent requests to do work "
"based on the configured value for the pool** - This is the most "
"straightforward cause.  If you have an application that runs in a thread "
"pool that allows for 30 concurrent threads, with one connection in use "
"per thread, if your pool is not configured to allow at least 30 "
"connections checked out at once, you will get this error once your "
"application receives enough concurrent requests. Solution is to raise the"
" limits on the pool or lower the number of concurrent threads."
msgstr "**アプリケーションはプールの設定値に基づいて作業を行うために同時に実行する要求が多すぎます**  - これが最も単純な原因です。スレッドごとに1つの接続が使用されている30の同時スレッドを許可するスレッドプールで実行されるアプリケーションを使用している場合、一度に30以上の接続をチェックアウトできるようにプールが構成されていない場合、アプリケーションは十分な同時要求を受け取ります。解決策は、プールの制限を上げるか、同時スレッドの数を減らすことです。"

#: ../../errors.rst:128
msgid ""
"**The application is not returning connections to the pool** - This is "
"the next most common reason, which is that the application is making use "
"of the connection pool, but the program is failing to :term:`release` "
"these connections and is instead leaving them open.   The connection pool"
" as well as the ORM :class:`.Session` do have logic such that when the "
"session and/or connection object is garbage collected, it results in the "
"underlying connection resources being released, however this behavior "
"cannot be relied upon to release resources in a timely manner."
msgstr "**アプリケーションがプールに接続を戻していない**  - これは、アプリケーションが接続プールを利用しているという次の最も一般的な理由ですが、プログラムはこれらの接続を「解放」することに失敗しています。代わりにそれらを開いたままにしています。 ORM：class： `.Session`だけでなく接続プールも、セッションや接続オブジェクトがガベージコレクトされたときに、基底の接続リソースが解放されるようなロジックを持っていますが、この動作に依存することはできませんタイムリーにリソースを解放する。"

#: ../../errors.rst:137
msgid ""
"A common reason this can occur is that the application uses ORM sessions "
"and does not call :meth:`.Session.close` upon them one the work involving"
" that session is complete. Solution is to make sure ORM sessions if using"
" the ORM, or engine-bound :class:`.Connection` objects if using Core, are"
" explicitly closed at the end of the work being done, either via the "
"appropriate ``.close()`` method, or by using one of the available context"
" managers (e.g. \"with:\" statement) to properly release the resource."
msgstr "これが起こり得る一般的な理由は、アプリケーションがORMセッションを使用し、そのセッションに関する作業が完了したときに：meth： `。Session.close`を呼び出さないということです。解決方法は、ORMまたはengine-bound：class： `.Connection`オブジェクトを使用している場合は、ORMセッションを確実に行うことです。作業の最後に適切な` `.close（）またはリソースを適切に解放するために利用可能なコンテキストマネージャ（例えば、\ &quot;with：\&quot;文）の1つを使用することによって、"

#: ../../errors.rst:145
msgid ""
"**The application is attempting to run long-running transactions** - A "
"database transaction is a very expensive resource, and should **never be "
"left idle waiting for some event to occur**.  If an application is "
"waiting for a user to push a button, or a result to come off of a long "
"running job queue, or is holding a persistent connection open to a "
"browser, **don't keep a database transaction open for the whole time**.  "
"As the application needs to work with the database and interact with an "
"event, open a short-lived transaction at that point and then close it."
msgstr "**アプリケーションは長時間実行されるトランザクションを実行しようとしています**  - データベーストランザクションは非常に高価なリソースであり、何らかのイベントが発生するのを待つことがありません**。アプリケーションがボタンを押すのを待っている、または結果が長時間実行されているジョブキューから外れる、または永続的な接続をブラウザに開いている場合、**データベーストランザクション全体を開いたままにしないでください時間**。アプリケーションがデータベースを操作してイベントと対話する必要があるため、その時点で短命のトランザクションを開いて閉じます。"

#: ../../errors.rst:154
msgid ""
"**The application is deadlocking** - Also a common cause of this error "
"and more difficult to grasp, if an application is not able to complete "
"its use of a connection either due to an application-side or database-"
"side deadlock, the application can use up all the available connections "
"which then leads to additional requests receiving this error.   Reasons "
"for deadlocks include:"
msgstr "**アプリケーションがデッドロックしている**  - また、このエラーの一般的な原因と把握が困難な場合、アプリケーション側またはデータベース側のデッドロックのためにアプリケーションが接続の使用を完了できない場合、アプリケーション使用可能なすべての接続を使い切り、このエラーを受け取った追加の要求につながります。デッドロックの理由は次のとおりです。"

#: ../../errors.rst:160
msgid ""
"Using an implicit async system such as gevent or eventlet without "
"properly monkeypatching all socket libraries and drivers, or which has "
"bugs in not fully covering for all monkeypatched driver methods, or less "
"commonly when the async system is being used against CPU-bound workloads "
"and greenlets making use of database resources are simply waiting too "
"long to attend to them.  Neither implicit nor explicit async programming "
"frameworks are typically necessary or appropriate for the vast majority "
"of relational database operations; if an application must use an async "
"system for some area of functionality, it's best that database-oriented "
"business methods run within traditional threads that pass messages to the"
" async part of the application."
msgstr "すべてのソケットライブラリとドライバを適切にmonkeypatchすることなくgeventやeventletなどの暗黙的な非同期システムを使用するか、すべてのmonkeypatchedドライバメソッドを完全にカバーしていないバグがあるか、またはCPUバインドワークロードとgreenletsに対して非同期システムを使用するデータベースリソースを利用することは、あまりにも時間がかかりすぎて、それらに参加することができません。暗黙的または明示的な非同期プログラミングフレームワークは、通常、大部分のリレーショナルデータベース操作に必要または適切ではありません。アプリケーションがある機能領域で非同期システムを使用する必要がある場合は、アプリケーションの非同期部分にメッセージを渡す従来のスレッド内でデータベース指向のビジネスメソッドを実行することをお勧めします。"

#: ../../errors.rst:173
msgid "A database side deadlock, e.g. rows are mutually deadlocked"
msgstr "データベース側のデッドロック、たとえば行がデッドロックしている"

#: ../../errors.rst:175
msgid ""
"Threading errors, such as mutexes in a mutual deadlock, or calling upon "
"an already locked mutex in the same thread"
msgstr "相互デッドロックのミューテックスなどのスレッドエラー、または同じスレッドの既にロックされているミューテックスを呼び出す"

#: ../../errors.rst:178
msgid ""
"Keep in mind an alternative to using pooling is to turn off pooling "
"entirely. See the section :ref:`pool_switching` for background on this.  "
"However, note that when this error message is occurring, it is **always**"
" due to a bigger problem in the application itself; the pool just helps "
"to reveal the problem sooner."
msgstr "プーリングを使用する代わりに、プーリングを完全にオフにすることを忘れないでください。これに関する背景については、ref： `pool_switching`を参照してください。ただし、このエラーメッセージが表示されているときは、アプリケーション自体の大きな問題のため**常に**です。プールはただちに問題を早く明らかにするのに役立ちます。"

#: ../../errors.rst:186
msgid ":ref:`pooling_toplevel`"
msgstr "：ref： `pooling_toplevel`"

#: ../../errors.rst:188
msgid ":ref:`connections_toplevel`"
msgstr "：ref： `connections_toplevel`"

#: ../../errors.rst:194
msgid "DBAPI Errors"
msgstr "DBAPIエラー"

#: ../../errors.rst:196
msgid ""
"The Python database API, or DBAPI, is a specification for database "
"drivers which can be located at `Pep-249 "
"<https://www.python.org/dev/peps/pep-0249/>`_. This API specifies a set "
"of exception classes that accommodate the full range of failure modes of "
"the database."
msgstr "PythonデータベースAPI（DBAPI）は、データベースドライバの仕様であり、 `Pep-249 <https://www.python.org/dev/peps/pep-0249/> `_。このAPIは、データベースのすべての障害モードに対応する一連の例外クラスを指定します。"

#: ../../errors.rst:201
msgid ""
"SQLAlchemy does not generate these exceptions directly.  Instead, they "
"are intercepted from the database driver and wrapped by the SQLAlchemy-"
"provided exception :class:`.DBAPIError`, however the messaging within the"
" exception is **generated by the driver, not SQLAlchemy**."
msgstr "SQLAlchemyはこれらの例外を直接生成しません。代わりにデータベースドライバから傍受され、SQLAlchemy提供の例外：class： `.DBAPIError`でラップされますが、例外内のメッセージはSQLAlchemy **ではなくドライバによって生成されます。"

#: ../../errors.rst:209
msgid "InterfaceError"
msgstr "InterfaceError"

#: ../../errors.rst:211
msgid ""
"Exception raised for errors that are related to the database interface "
"rather than the database itself."
msgstr "データベース自体ではなく、データベースインターフェイスに関連するエラーに対して例外が発生しました。"

#: ../../errors.rst:214 ../../errors.rst:230 ../../errors.rst:241
#: ../../errors.rst:254 ../../errors.rst:270 ../../errors.rst:281
#: ../../errors.rst:298 ../../errors.rst:315
msgid ""
"This error is a :ref:`DBAPI Error <error_dbapi>` and originates from the "
"database driver (DBAPI), not SQLAlchemy itself."
msgstr "このエラーは次のとおりです：ref： `DBAPI Error <error_dbapi> `であり、SQLAlchemy自体ではなく、データベースドライバ（DBAPI）から発生します。"

#: ../../errors.rst:217
msgid ""
"The ``InterfaceError`` is sometimes raised by drivers in the context of "
"the database connection being dropped, or not being able to connect to "
"the database.   For tips on how to deal with this, see the section "
":ref:`pool_disconnects`."
msgstr "`` InterfaceError``は、データベース接続が破棄されている、またはデータベースに接続できないという状況でドライバによって発生することがあります。これに対処する方法については、ref： `pool_disconnects`を参照してください。"

#: ../../errors.rst:225
msgid "DatabaseError"
msgstr "データベースエラー"

#: ../../errors.rst:227
msgid ""
"Exception raised for errors that are related to the database itself, and "
"not the interface or data being passed."
msgstr "渡されるインタフェースやデータではなく、データベース自体に関連するエラーについては例外が発生します。"

#: ../../errors.rst:236
msgid "DataError"
msgstr "データエラー"

#: ../../errors.rst:238
msgid ""
"Exception raised for errors that are due to problems with the processed "
"data like division by zero, numeric value out of range, etc."
msgstr "ゼロ除算、範囲外の数値などの処理されたデータの問題によるエラーの場合は例外が発生します。"

#: ../../errors.rst:247
msgid "OperationalError"
msgstr "OperationalError"

#: ../../errors.rst:249
msgid ""
"Exception raised for errors that are related to the database's operation "
"and not necessarily under the control of the programmer, e.g. an "
"unexpected disconnect occurs, the data source name is not found, a "
"transaction could not be processed, a memory allocation error occurred "
"during processing, etc."
msgstr "予期せぬ切断が発生した、データソース名が見つからない、トランザクションを処理できなかった、処理中にメモリ割り当てエラーが発生したなど、データベースの操作に関連し、プログラマの制御下にあるとは限りません。等"

#: ../../errors.rst:257
msgid ""
"The ``OperationalError`` is the most common (but not the only) error "
"class used by drivers in the context of the database connection being "
"dropped, or not being able to connect to the database.   For tips on how "
"to deal with this, see the section :ref:`pool_disconnects`."
msgstr "`` OperationalError``は、データベース接続がドロップされている、またはデータベースに接続できないという状況でドライバが使用する最も一般的な（しかし唯一ではない）エラークラスです。これに対処する方法については、ref： `pool_disconnects`を参照してください。"

#: ../../errors.rst:265
msgid "IntegrityError"
msgstr "IntegrityError"

#: ../../errors.rst:267
msgid ""
"Exception raised when the relational integrity of the database is "
"affected, e.g. a foreign key check fails."
msgstr "データベースのリレーショナル・インテグリティが影響を受けた場合、たとえば外部キー・チェックに失敗した場合に発生する例外。"

#: ../../errors.rst:276
msgid "InternalError"
msgstr "内部エラー"

#: ../../errors.rst:278
msgid ""
"Exception raised when the database encounters an internal error, e.g. the"
" cursor is not valid anymore, the transaction is out of sync, etc."
msgstr "データベースが内部エラーに遭遇したときに発生する例外。カーソルがもはや有効でない、トランザクションが同期していないなど"

#: ../../errors.rst:284
msgid ""
"The ``InternalError`` is sometimes raised by drivers in the context of "
"the database connection being dropped, or not being able to connect to "
"the database.   For tips on how to deal with this, see the section "
":ref:`pool_disconnects`."
msgstr "`` InternalError``は、データベース接続が破棄されている、またはデータベースに接続できないという状況でドライバによって発生することがあります。これに対処する方法については、ref： `pool_disconnects`を参照してください。"

#: ../../errors.rst:292
msgid "ProgrammingError"
msgstr "ProgrammingError"

#: ../../errors.rst:294
msgid ""
"Exception raised for programming errors, e.g. table not found or already "
"exists, syntax error in the SQL statement, wrong number of parameters "
"specified, etc."
msgstr "テーブルが見つからないか、すでに存在している、SQL文の構文エラー、指定されたパラメータの数が間違っているなどのプログラミングエラーの例外"

#: ../../errors.rst:301
msgid ""
"The ``ProgrammingError`` is sometimes raised by drivers in the context of"
" the database connection being dropped, or not being able to connect to "
"the database.   For tips on how to deal with this, see the section "
":ref:`pool_disconnects`."
msgstr "`` ProgrammingError``は、データベース接続がドロップされている、またはデータベースに接続できないという状況でドライバによって発生することがあります。これに対処する方法については、ref： `pool_disconnects`を参照してください。"

#: ../../errors.rst:309
msgid "NotSupportedError"
msgstr "NotSupportedError"

#: ../../errors.rst:311
msgid ""
"Exception raised in case a method or database API was used which is not "
"supported by the database, e.g. requesting a .rollback() on a connection "
"that does not support transaction or has transactions turned off."
msgstr "トランザクションをサポートしていない、またはトランザクションがオフになっている接続で.rollback（）を要求するなど、データベースでサポートされていないメソッドまたはデータベースAPIが使用された場合に発生する例外。"

#: ../../errors.rst:319
msgid "SQL Expression Language"
msgstr "SQL式言語"

#: ../../errors.rst:324
msgid "This Compiled object is not bound to any Engine or Connection"
msgstr "このコンパイルされたオブジェクトはエンジンまたは接続にバインドされていません"

#: ../../errors.rst:326
msgid ""
"This error refers to the concept of \"bound metadata\", described at "
":ref:`dbengine_implicit`.   The issue occurs when one invokes the "
":meth:`.Executable.execute` method directly off of a Core expression "
"object that is not associated with any :class:`.Engine`::"
msgstr "このエラーは、\ &quot;バインドされたメタデータ\&quot;という概念を参照しています：ref： `dbengine_implicit`で説明されています。この問題は、：meth： `.Executable.execute`メソッドを：class：` .Engine` ::に関連付けられていないCore式オブジェクトから直接呼び出すと発生します。"

#: ../../errors.rst:337
msgid ""
"What the logic is expecting is that the :class:`.MetaData` object has "
"been **bound** to a :class:`.Engine`::"
msgstr "論理が期待していることは：class： `.MetaData`オブジェクトが**：**：.Engine` ::にバインドされていることです。"

#: ../../errors.rst:343
msgid ""
"Where above, any statement that derives from a :class:`.Table` which in "
"turn derives from that :class:`.MetaData` will implicitly make use of the"
" given :class:`.Engine` in order to invoke the statement."
msgstr "上記の場合、a：：class： `.Table`から派生した文は、class：` .MetaData`から派生し、文を呼び出すために暗黙的に指定された：class： `.Engine`を使用します。"

#: ../../errors.rst:347
msgid ""
"Note that the concept of bound metadata is a **legacy pattern** and in "
"most cases is **highly discouraged**.   The best way to invoke the "
"statement is to pass it to the :meth:`.Connection.execute` method of a "
":class:`.Connection`::"
msgstr "バウンドメタデータの概念は**従来のパターン**であり、ほとんどの場合、**は非常に推奨されていません**。ステートメントを呼び出す最良の方法は、それを：class： `.Connection` :: meth：` .Connection.execute`メソッドに渡すことです。"

#: ../../errors.rst:354
msgid ""
"When using the ORM, a similar facility is available via the "
":class:`.Session`::"
msgstr "ORMを使用する場合、同様の機能が：class： `.Session` ::"

#: ../../errors.rst:360
msgid ":ref:`dbengine_implicit`"
msgstr "：ref： `dbengine_implicit`"

#: ../../errors.rst:366
msgid "A value is required for bind parameter <x> (in parameter group <y>)"
msgstr "バインドパラメータには値が必要です<x> （パラメータ群<y> ）"

#: ../../errors.rst:368
msgid ""
"This error occurs when a statement makes use of :func:`.bindparam` either"
" implicitly or explicitly and does not provide a value when the statement"
" is executed::"
msgstr "このエラーは、文が：func： `.bindparam`を暗黙的または明示的に使用し、文が実行されるときに値を提供しない場合に発生します::"

#: ../../errors.rst:376
msgid ""
"Above, no value has been provided for the parameter \"my_param\".  The "
"correct approach is to provide a value::"
msgstr "上記の場合、パラメータ &quot;my_param&quot;に値は指定されていません。正しいアプローチは、値を提供することです::"

#: ../../errors.rst:381
msgid ""
"When the message takes the form \"a value is required for bind parameter "
"<x> in parameter group <y>\", the message is referring to the "
"\"executemany\" stye of execution.  In this case, the statement is "
"typically an INSERT, UPDATE, or DELETE and a list of parameters is being "
"passed.   In this format, the statement may be generated dynamically to "
"include parameter positions for every parameter given in the argument "
"list, where it will use the **first set of parameters** to determine what"
" these should be."
msgstr "メッセージに\ &quot;バインドパラメータに値が必要です<x>パラメータグループ内<y> \ &quot;であれば、メッセージは実行中のexecutemanyを参照していますこの場合、ステートメントは通常INSERT、UPDATE、またはDELETEであり、パラメータのリストが渡されます。引数リストに指定されたすべてのパラメータのパラメータ位置を含むように動的に生成されます。ここで、**最初のパラメータセット**が使用されます。"

#: ../../errors.rst:389
msgid ""
"For example, the statement below is calculated based on the first "
"parameter set to require the parameters, \"a\", \"b\", and \"c\" - these "
"names determine the final string format of the statement which will be "
"used for each set of parameters in the list.  As the second entry does "
"not contain \"b\", this error is generated::"
msgstr "たとえば、以下のステートメントは、\ &quot;a \&quot;、\ &quot;b \&quot;、\ &quot;c \&quot;のパラメータを必要とするように設定された最初のパラメータに基づいて計算されます。リスト内のパラメータのセットごとに使用することができます。 2番目のエントリに\ &quot;b \&quot;が含まれていないため、このエラーが生成されます::"

#: ../../errors.rst:416
msgid ""
"Since \"b\" is required, pass it as ``None`` so that the INSERT may "
"proceed::"
msgstr "\ &quot;b \&quot;が必要なので、INSERTが進むように `` None``として渡してください::"

#: ../../errors.rst:428
msgid ":ref:`coretutorial_bind_param`"
msgstr "：ref： `coretutorial_bind_param`"

#: ../../errors.rst:430
msgid ":ref:`execute_multiple`"
msgstr "：ref： `execute_multiple`"

#: ../../errors.rst:433
msgid "Object Relational Mapping"
msgstr "オブジェクトリレーショナルマッピング"

#: ../../errors.rst:438
msgid ""
"Parent instance <x> is not bound to a Session; (lazy load/deferred "
"load/refresh/etc.) operation cannot proceed"
msgstr "親インスタンス<x>セッションにバインドされていません。 （レイジーロード/遅延ロード/リフレッシュなど）操作を続行できません"

#: ../../errors.rst:440
msgid ""
"This is likely the most common error message when dealing with the ORM, "
"and it occurs as a result of the nature of a technique the ORM makes wide"
" use of known as :term:`lazy loading`.   Lazy loading is a common object-"
"relational pattern whereby an object that's persisted by the ORM "
"maintains a proxy to the database itself, such that when various "
"attributes upon the object are accessed, their value may be retrieved "
"from the database *lazily*.   The advantage to this approach is that "
"objects can be retrieved from the database without having to load all of "
"their attributes or related data at once, and instead only that data "
"which is requested can be delivered at that time.   The major "
"disadvantage is basically a mirror image of the advantage, which is that "
"if lots of objects are being loaded which are known to require a certain "
"set of data in all cases, it is wasteful to load that additional data "
"piecemeal."
msgstr "これは、ORMを扱う際の最も一般的なエラーメッセージである可能性が高く、ORMが広く利用している：term： `lazy loading`の手法の性質の結果として発生します。レイジーローディングは、ORMによって保持されるオブジェクトがデータベース自体へのプロキシを維持する共通のオブジェクトリレーショナルパターンです。そのため、オブジェクトのさまざまな属性にアクセスすると、その値をデータベース* lazily *から取得できます。このアプローチの利点は、属性や関連データを一度に読み込むことなく、オブジェクトをデータベースから取得でき、その時に要求されたデータのみを配信できることです。主な欠点は、基本的には利点の鏡像であり、すべてのケースで一定のデータセットを必要とすることが知られているオブジェクトが多数ロードされている場合、その追加のデータをロードするのは無駄です。"

#: ../../errors.rst:453
msgid ""
"Another caveat of lazy loading beyond the usual efficiency concerns is "
"that in order for lazy loading to proceed, the object has to **remain "
"associated with a Session** in order to be able to retrieve its state.  "
"This error message means that an object has become de-associated with its"
" :class:`.Session` and is being asked to lazy load data from the "
"database."
msgstr "通常の効率の懸念を超える遅延ロードのもう1つの注意点は、レイジーローディングを続行するには、オブジェクトを状態**を取得できるようにSession **に関連付けたままにしなければならないということです。このエラーメッセージは、オブジェクトが：class： `.Session`との関連付けが解除され、データベースからのデータの遅延ロードを要求されていることを意味します。"

#: ../../errors.rst:459
msgid ""
"The most common reason that objects become detached from their "
":class:`.Session` is that the session itself was closed, typically via "
"the :meth:`.Session.close` method.   The objects will then live on to be "
"accessed further, very often within web applications where they are "
"delivered to a server-side templating engine and are asked for further "
"attributes which they cannot load."
msgstr "オブジェクトがclass： `.Session`から切り離される最も一般的な理由は、セッション自体が閉じられていることです。通常は：meth：`。Session.close`メソッドを使用します。オブジェクトは、Webアプリケーションの中でさらに頻繁にアクセスされてアクセスされ、サーバー側のテンプレートエンジンに渡され、読み込めない属性をさらに要求されます。"

#: ../../errors.rst:465
msgid "Mitigation of this error is via two general techniques:"
msgstr "このエラーを緩和するには、2つの一般的な方法があります。"

#: ../../errors.rst:467
msgid ""
"**Don't close the session prematurely** - Often, applications will close "
"out a transaction before passing off related objects to some other system"
" which then fails due to this error.   Sometimes the transaction doesn't "
"need to be closed so soon; an example is the web application closes out "
"the transaction before the view is rendered.  This is often done in the "
"name of \"correctness\", but may be seen as a mis-application of "
"\"encapsulation\", as this term refers to code organization, not actual "
"actions. The template that uses an ORM object is making use of the `proxy"
" pattern <https://en.wikipedia.org/wiki/Proxy_pattern>`_ which keeps "
"database logic encapsulated from the caller.   If the :class:`.Session` "
"can be held open until the lifespan of the objects are done, this is the "
"best approach."
msgstr "**早期にセッションを閉じない**  - アプリケーションは、関連するオブジェクトを他のシステムに渡す前にトランザクションをクローズし、このエラーのために失敗することがあります。場合によっては、トランザクションをすぐにクローズする必要はありません。ビューがレンダリングされる前に、Webアプリケーションがトランザクションをクローズする例があります。これはしばしば\ &quot;正確さ\&quot;という名前で行われますが、\ &quot;カプセル化\&quot;が誤って適用されているように見えることがあります。 ORMオブジェクトを使用するテンプレートは、 `proxyパターン<https://en.wikipedia.org/wiki/Proxy_pattern> `_はデータベースロジックを呼び出し側からカプセル化した状態にします。オブジェクトの寿命が終わるまで：class： `.Session`を開いておくことができれば、これが最善の方法です。"

#: ../../errors.rst:479
msgid ""
"**Load everything that's needed up front** - It is very often impossible "
"to keep the transaction open, especially in more complex applications "
"that need to pass objects off to other systems that can't run in the same"
" context even though they're in the same process.  In this case, the "
"application should try to make appropriate use of :term:`eager loading` "
"to ensure that objects have what they need up front.   As an additional "
"measure, special directives like the :func:`.raiseload` option can ensure"
" that systems don't call upon lazy loading when its not expected."
msgstr "**フロントに必要なものをすべてロード**  - トランザクションをオープンにすることは不可能です。特に、複雑なアプリケーションでは、同じコンテキストで実行できない他のシステムにオブジェクトを渡す必要があります同じプロセスでこの場合、アプリケーションは、オブジェクトが正面から必要なものを持っていることを保証するためにterm： `eager loading &#39;を適切に使用しようとするべきです。追加の手段として、：func： `.raiseload`オプションのような特別な指示は、システムが期待していないときに遅延ロードを呼び出さないようにすることができます。"

#: ../../errors.rst:490
msgid ""
":ref:`loading_toplevel` - detailed documentation on eager loading and "
"other relationship-oriented loading techniques"
msgstr "：ref： `loading_toplevel`  - 熱心な読み込みや他の関係指向の読み込みテクニックに関する詳細なドキュメント"

#: ../../errors.rst:495
msgid "Core Exception Classes"
msgstr "コア例外クラス"

#: ../../errors.rst:497
msgid "See :ref:`core_exceptions_toplevel` for Core exception classes."
msgstr "コア例外クラスについては：ref： `core_exceptions_toplevel`を参照してください。"

#: ../../errors.rst:501
msgid "ORM Exception Classes"
msgstr "ORM例外クラス"

#: ../../errors.rst:503
msgid "See :ref:`orm_exceptions_toplevel` for ORM exception classes."
msgstr "ORM例外クラスについては：ref： `orm_exceptions_toplevel`を参照してください。"


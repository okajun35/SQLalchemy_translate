# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../core/metadata.rst:9
msgid "Describing Databases with MetaData"
msgstr "MetaDataを使用したデータベースの記述"

#: ../../core/metadata.rst:13
msgid ""
"This section discusses the fundamental :class:`.Table`, :class:`.Column` "
"and :class:`.MetaData` objects."
msgstr "このセクションでは、class： `.Table`、：class：` .Column`、：class： `.MetaData`オブジェクトの基本について説明します。"

#: ../../core/metadata.rst:16
msgid ""
"A collection of metadata entities is stored in an object aptly named "
":class:`~sqlalchemy.schema.MetaData`::"
msgstr "メタデータエンティティのコレクションは、適切な名前のオブジェクトに格納されます：class： `〜sqlalchemy.schema.MetaData` ::"

#: ../../core/metadata.rst:23
msgid ""
":class:`~sqlalchemy.schema.MetaData` is a container object that keeps "
"together many different features of a database (or multiple databases) "
"being described."
msgstr "：class： `〜sqlalchemy.schema.MetaData`は、記述されているデータベース（または複数のデータベース）の多くの異なる機能をまとめて保持するコンテナオブジェクトです。"

#: ../../core/metadata.rst:26
msgid ""
"To represent a table, use the :class:`~sqlalchemy.schema.Table` class. "
"Its two primary arguments are the table name, then the "
":class:`~sqlalchemy.schema.MetaData` object which it will be associated "
"with. The remaining positional arguments are mostly "
":class:`~sqlalchemy.schema.Column` objects describing each column::"
msgstr "テーブルを表現するには、：class： `〜sqlalchemy.schema.Table`クラスを使用します。その主な2つの引数は、テーブル名と、次に関連付けられる：class： `〜sqlalchemy.schema.MetaData`オブジェクトです。残りの位置引数は主に次のとおりです：class： `〜sqlalchemy.schema.Column`オブジェクト各列を記述する::"

#: ../../core/metadata.rst:39
msgid ""
"Above, a table called ``user`` is described, which contains four columns."
" The primary key of the table consists of the ``user_id`` column. "
"Multiple columns may be assigned the ``primary_key=True`` flag which "
"denotes a multi-column primary key, known as a *composite* primary key."
msgstr "上記では、4つの列を含む `` user``という表が記述されています。テーブルの主キーは `` user_id``カラムで構成されています。 `` primary_key = True``フラグを複数の列に割り当てることができます。このフラグは、複合*主キーと呼ばれる複数列の主キーを示します。"

#: ../../core/metadata.rst:44
msgid ""
"Note also that each column describes its datatype using objects "
"corresponding to genericized types, such as "
":class:`~sqlalchemy.types.Integer` and :class:`~sqlalchemy.types.String`."
" SQLAlchemy features dozens of types of varying levels of specificity as "
"well as the ability to create custom types. Documentation on the type "
"system can be found at :ref:`types_toplevel`."
msgstr "各カラムは、class： `〜sqlalchemy.types.Integer`と：class：`〜sqlalchemy.types.String`のような、汎用化された型に対応するオブジェクトを使ってそのデータ型を記述することにも注意してください。 SQLAlchemyには、さまざまなレベルの特異性とカスタムタイプの作成機能が数十種類あります。型システムに関するドキュメントは：ref： `types_toplevel`にあります。"

#: ../../core/metadata.rst:51
msgid "Accessing Tables and Columns"
msgstr "表と列へのアクセス"

#: ../../core/metadata.rst:53
msgid ""
"The :class:`~sqlalchemy.schema.MetaData` object contains all of the "
"schema constructs we've associated with it. It supports a few methods of "
"accessing these table objects, such as the ``sorted_tables`` accessor "
"which returns a list of each :class:`~sqlalchemy.schema.Table` object in "
"order of foreign key dependency (that is, each table is preceded by all "
"tables which it references)::"
msgstr "：class： `〜sqlalchemy.schema.MetaData`オブジェクトには、それに関連付けられているすべてのスキーマ構造が含まれています。 `：sqlalchemy.schema.Table`オブジェクトのそれぞれのリストを外部キーの依存性の順に返す` `sorted_tables``アクセサのような、これらのテーブルオブジェクトにアクセスするいくつかのメソッドをサポートしています（つまり、各テーブルそれが参照するすべてのテーブルが先行します）::"

#: ../../core/metadata.rst:67
msgid ""
"In most cases, individual :class:`~sqlalchemy.schema.Table` objects have "
"been explicitly declared, and these objects are typically accessed "
"directly as module-level variables in an application. Once a "
":class:`~sqlalchemy.schema.Table` has been defined, it has a full set of "
"accessors which allow inspection of its properties. Given the following "
":class:`~sqlalchemy.schema.Table` definition::"
msgstr "ほとんどの場合、individual：class： `〜sqlalchemy.schema.Table`オブジェクトは明示的に宣言されており、通常、これらのオブジェクトはアプリケーション内でモジュールレベルの変数として直接アクセスされます。一旦a：class： `〜sqlalchemy.schema.Table`が定義されると、それはそのプロパティの検査を可能にするアクセサのフルセットを持ちます。次のように与えられます：class： `〜sqlalchemy.schema.Table`定義::"

#: ../../core/metadata.rst:80
msgid ""
"Note the :class:`~sqlalchemy.schema.ForeignKey` object used in this table"
" - this construct defines a reference to a remote table, and is fully "
"described in :ref:`metadata_foreignkeys`. Methods of accessing "
"information about this table include::"
msgstr "この表で使用されるclass： `〜sqlalchemy.schema.ForeignKey`オブジェクトに注意してください。この構造体はリモートテーブルへの参照を定義します：ref：` metadata_foreignkeys`で詳しく説明されています。このテーブルに関する情報にアクセスする方法には、::"

#: ../../core/metadata.rst:130
msgid "Creating and Dropping Database Tables"
msgstr "データベーステーブルの作成と削除"

#: ../../core/metadata.rst:132
msgid ""
"Once you've defined some :class:`~sqlalchemy.schema.Table` objects, "
"assuming you're working with a brand new database one thing you might "
"want to do is issue CREATE statements for those tables and their related "
"constructs (as an aside, it's also quite possible that you *don't* want "
"to do this, if you already have some preferred methodology such as tools "
"included with your database or an existing scripting system - if that's "
"the case, feel free to skip this section - SQLAlchemy has no requirement "
"that it be used to create your tables)."
msgstr "class： `〜sqlalchemy.schema.Table`オブジェクトをいくつか定義したら、新しいデータベースを扱っていると仮定すると、それらのテーブルと関連する構造体に対してCREATE文を発行することができます。また、データベースや既存のスクリプティングシステムに含まれているツールなどの既存の方法論をすでに使用している場合は、これをしたくないかもしれません。もしそうなら、このセクションをスキップしてください。 SQLAlchemyはテーブルの作成に使用する必要はありません）。"

#: ../../core/metadata.rst:141
msgid ""
"The usual way to issue CREATE is to use "
":func:`~sqlalchemy.schema.MetaData.create_all` on the "
":class:`~sqlalchemy.schema.MetaData` object. This method will issue "
"queries that first check for the existence of each individual table, and "
"if not found will issue the CREATE statements:"
msgstr "CREATEを発行する通常の方法は：class： `〜sqlalchemy.schema.MetaData`オブジェクトに対して：func：`〜sqlalchemy.schema.MetaData.create_all`を使用することです。このメソッドは、最初に各テーブルの存在をチェックするクエリを発行し、見つからなければCREATEステートメントを発行します。"

#: ../../core/metadata.rst:183
msgid ""
":func:`~sqlalchemy.schema.MetaData.create_all` creates foreign key "
"constraints between tables usually inline with the table definition "
"itself, and for this reason it also generates the tables in order of "
"their dependency. There are options to change this behavior such that "
"``ALTER TABLE`` is used instead."
msgstr "：func： `〜sqlalchemy.schema.MetaData.create_all`は、通常、テーブル定義間に外部キー制約を作成します。そのため、依存関係の順番でテーブルを生成します。代わりに `` ALTER TABLE``が使用されるようにこの動作を変更するオプションがあります。"

#: ../../core/metadata.rst:188
msgid ""
"Dropping all tables is similarly achieved using the "
":func:`~sqlalchemy.schema.MetaData.drop_all` method. This method does the"
" exact opposite of :func:`~sqlalchemy.schema.MetaData.create_all` - the "
"presence of each table is checked first, and tables are dropped in "
"reverse order of dependency."
msgstr "すべてのテーブルを削除するには、同様に：func： `〜sqlalchemy.schema.MetaData.drop_all`メソッドを使用します。 func： `〜sqlalchemy.schema.MetaData.create_all`  - 各テーブルの存在が最初にチェックされ、テーブルは依存性の逆の順序で削除されます。"

#: ../../core/metadata.rst:194
msgid ""
"Creating and dropping individual tables can be done via the ``create()`` "
"and ``drop()`` methods of :class:`~sqlalchemy.schema.Table`. These "
"methods by default issue the CREATE or DROP regardless of the table being"
" present:"
msgstr "個々のテーブルを作成して削除するには、class： `〜sqlalchemy.schema.Table`の` `create（）` `と` `drop（）` `メソッドを使います。これらのメソッドは、デフォルトで存在するテーブルに関係なく、CREATEまたはDROPを発行します。"

#: ../../core/metadata.rst:217
msgid "``drop()`` method:"
msgstr "`` drop（） ``メソッド："

#: ../../core/metadata.rst:225
msgid ""
"To enable the \"check first for the table existing\" logic, add the "
"``checkfirst=True`` argument to ``create()`` or ``drop()``::"
msgstr "\ &quot;テーブルの存在を最初にチェックする\&quot;ロジックを有効にするには、 `` check（） ``引数を `` create（） ``または `` drop（） `::に追加します。"

#: ../../core/metadata.rst:234
msgid "Altering Schemas through Migrations"
msgstr "移行によるスキーマの変更"

#: ../../core/metadata.rst:236
msgid ""
"While SQLAlchemy directly supports emitting CREATE and DROP statements "
"for schema constructs, the ability to alter those constructs, usually via"
" the ALTER statement as well as other database-specific constructs, is "
"outside of the scope of SQLAlchemy itself.  While it's easy enough to "
"emit ALTER statements and similar by hand, such as by passing a string to"
" :meth:`.Connection.execute` or by using the :class:`.DDL` construct, "
"it's a common practice to automate the maintenance of database schemas in"
" relation to application code using schema migration tools."
msgstr "SQLAlchemyは、スキーマ構造に対してCREATEおよびDROPステートメントを発行することを直接サポートしていますが、通常はALTERステートメントや他のデータベース固有の構造を介してこれらの構造を変更する機能はSQLAlchemyの範囲外です。 ：meth： `.Connection.execute`や：class：` .DDL`構造体に文字列を渡すなど、手作業でALTER文などを出力するのは簡単ですが、メンテナンスを自動化するのが一般的ですスキーマ・マイグレーション・ツールを使用してアプリケーション・コードに関連したデータベース・スキーマを作成します。"

#: ../../core/metadata.rst:244
msgid "There are two major migration tools available for SQLAlchemy:"
msgstr "SQLAlchemyには、次の2つの主要な移行ツールがあります。"

#: ../../core/metadata.rst:246
msgid ""
"`Alembic <http://alembic.zzzcomputing.com>`_ - Written by the author of "
"SQLAlchemy, Alembic features a highly customizable environment and a "
"minimalistic usage pattern, supporting such features as transactional "
"DDL, automatic generation of \"candidate\" migrations, an \"offline\" "
"mode which generates SQL scripts, and support for branch resolution."
msgstr "`アレムビア<http://alembic.zzzcomputing.com> `_  -  SQLAlchemyの著者によって書かれたAlembicは、トランザクションDDL、\&quot;候補\ &quot;移行の自動生成、SQLスクリプトを生成する\&quot;オフライン\ &quot;モードなどの機能をサポートする高度にカスタマイズ可能な環境と最小限の使用パターンを備えています、支店の解決をサポートします。"

#: ../../core/metadata.rst:251
msgid ""
"`SQLAlchemy-Migrate <https://github.com/openstack/sqlalchemy-migrate>`_ -"
" The original migration tool for SQLAlchemy, SQLAlchemy-Migrate is widely"
" used and continues under active development.   SQLAlchemy-Migrate "
"includes features such as SQL script generation, ORM class generation, "
"ORM model comparison, and extensive support for SQLite migrations."
msgstr "`SQLAlchemy-Migrate <https://github.com/openstack/sqlalchemy-migrate> `_  -  SQLAlchemyのオリジナルの移行ツールであるSQLAlchemy-Migrateは広く使用されており、積極的な開発を続けています。 SQLAlchemy-Migrateには、SQLスクリプト生成、ORMクラス生成、ORMモデル比較、SQLite移行の広範なサポートなどの機能が含まれています。"

#: ../../core/metadata.rst:259
msgid "Specifying the Schema Name"
msgstr "スキーマ名の指定"

#: ../../core/metadata.rst:261
msgid ""
"Some databases support the concept of multiple schemas. A "
":class:`~sqlalchemy.schema.Table` can reference this by specifying the "
"``schema`` keyword argument::"
msgstr "いくつかのデータベースは、複数のスキーマの概念をサポートしています。 A：class： `〜sqlalchemy.schema.Table`は` `schema``キーワード引数を指定することでこれを参照できます::"

#: ../../core/metadata.rst:271
msgid ""
"Within the :class:`~sqlalchemy.schema.MetaData` collection, this table "
"will be identified by the combination of ``financial_info`` and "
"``remote_banks``. If another table called ``financial_info`` is "
"referenced without the ``remote_banks`` schema, it will refer to a "
"different :class:`~sqlalchemy.schema.Table`. "
":class:`~sqlalchemy.schema.ForeignKey` objects can specify references to "
"columns in this table using the form ``remote_banks.financial_info.id``."
msgstr "：class： `〜sqlalchemy.schema.MetaData`コレクションの中で、このテーブルは` `financial_info``と` `remote_banks``の組み合わせによって識別されます。 `` financial_info``と呼ばれる別のテーブルが `` remote_banks``スキーマなしで参照されると、別の：class： `〜sqlalchemy.schema.Table`を参照します。 ：class： `〜sqlalchemy.schema.ForeignKey`オブジェクトは、` `remote_banks.financial_info.id``の形式でこのテーブルのカラムへの参照を指定できます。"

#: ../../core/metadata.rst:279
msgid ""
"The ``schema`` argument should be used for any name qualifiers required, "
"including Oracle's \"owner\" attribute and similar. It also can "
"accommodate a dotted name for longer schemes::"
msgstr "`` schema``引数は、Oracleの\ &quot;owner \&quot;属性などを含む、必要な任意の名前修飾子に使用する必要があります。それはまた、より長いスキームのための点線の名前を収容することができます::"

#: ../../core/metadata.rst:286
msgid "Backend-Specific Options"
msgstr "バックエンド固有のオプション"

#: ../../core/metadata.rst:288
msgid ""
":class:`~sqlalchemy.schema.Table` supports database-specific options. For"
" example, MySQL has different table backend types, including \"MyISAM\" "
"and \"InnoDB\". This can be expressed with "
":class:`~sqlalchemy.schema.Table` using ``mysql_engine``::"
msgstr "：class： `〜sqlalchemy.schema.Table`は、データベース固有のオプションをサポートしています。たとえば、MySQLには\ &quot;MyISAM \&quot;と\ &quot;InnoDB \&quot;を含むさまざまなテーブルバックエンドタイプがあります。これは `` mysql_engine``を使ってclass： `〜sqlalchemy.schema.Table`で表すことができます::"

#: ../../core/metadata.rst:300
msgid ""
"Other backends may support table-level options as well - these would be "
"described in the individual documentation sections for each dialect."
msgstr "他のバックエンドは、テーブルレベルのオプションもサポートしています。これらは、各方言の個々のドキュメントのセクションで説明されています。"

#: ../../core/metadata.rst:304
msgid "Column, Table, MetaData API"
msgstr "列、表、メタデータAPI"

#: ../../core/metadata.rst:308
msgid ""
"Symbol indicating that a :class:`.Table` or :class:`.Sequence` should "
"have 'None' for its schema, even if the parent :class:`.MetaData` has "
"specified a schema."
msgstr "親：class： `.MetaData`がスキーマを指定していても、a：class：` .Table`または：class： `.Sequence`はそのスキーマに対して &#39;None&#39;を持つ必要があります。"

#: ../../core/metadata.rst:314
msgid ":paramref:`.MetaData.schema`"
msgstr "：paramref： `.MetaData.schema`"

#: ../../core/metadata.rst:316
msgid ":paramref:`.Table.schema`"
msgstr "：paramref： `.Table.schema`"

#: ../../core/metadata.rst:318
msgid ":paramref:`.Sequence.schema`"
msgstr "：paramref： `.Sequence.schema`"

#: of sqlalchemy.schema.Column:1
msgid "Represents a column in a database table."
msgstr "データベーステーブルの列を表します。"

#: of sqlalchemy.schema.Column.all_:1
msgid "Produce a :func:`~.expression.all_` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.all_`句を生成します。"

#: of sqlalchemy.schema.Column.all_:4 sqlalchemy.schema.Column.any_:4
msgid ""
"This operator is only appropriate against a scalar subquery object, or "
"for some backends an column expression that is against the ARRAY type, "
"e.g.::"
msgstr "この演算子は、スカラーサブクエリオブジェクトに対してのみ適切です。または、いくつかのバックエンドでは、ARRAY型の列式、たとえば::"

#: of sqlalchemy.schema.Column.all_:16
msgid ":func:`~.expression.all_` - standalone version"
msgstr "：func： `〜.expression.all_`  - スタンドアロン版"

#: of sqlalchemy.schema.Column.all_:18
msgid ":func:`~.expression.any_` - ANY operator"
msgstr "：func： `〜.expression.any_`  -  ANY演算子"

#: of sqlalchemy.schema.Column.anon_label:1
msgid "provides a constant 'anonymous label' for this ColumnElement."
msgstr "このColumnElementの定数「匿名ラベル」を提供します。"

#: of sqlalchemy.schema.Column.anon_label:3
msgid ""
"This is a label() expression which will be named at compile time. The "
"same label() is returned each time anon_label is called so that "
"expressions can reference anon_label multiple times, producing the same "
"label name at compile time."
msgstr "これはコンパイル時に命名されるlabel（）式です。 anon_labelが呼び出されるたびに同じlabel（）が返されるため、式はanon_labelを複数回参照し、コンパイル時に同じラベル名を生成できます。"

#: of sqlalchemy.schema.Column.anon_label:8
msgid ""
"the compiler uses this function automatically at compile time for "
"expressions that are known to be 'unnamed' like binary expressions and "
"function calls."
msgstr "コンパイラはコンパイル時にこの関数をバイナリ式や関数呼び出しのような &#39;名前なし&#39;の式で自動的に使用します。"

#: of sqlalchemy.schema.Column.any_:1
msgid "Produce a :func:`~.expression.any_` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.any_`句を生成します。"

#: of sqlalchemy.schema.Column.any_:16
msgid ":func:`~.expression.any_` - standalone version"
msgstr "：func： `〜.expression.any_`  - スタンドアロン版"

#: of sqlalchemy.schema.Column.any_:18
msgid ":func:`~.expression.all_` - ALL operator"
msgstr "：func： `〜.expression.all_`  - すべての演算子"

#: of sqlalchemy.schema.Column.asc:1
msgid "Produce a :func:`~.expression.asc` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.asc`句を生成します。"

#: of sqlalchemy.schema.Column.between:1
msgid ""
"Produce a :func:`~.expression.between` clause against the parent object, "
"given the lower and upper range."
msgstr "下位と上位の範囲を指定して、親オブジェクトに対してa：func： `〜.expression.between`句を生成します。"

#: of sqlalchemy.schema.Column.bool_op:1
msgid "Return a custom boolean operator."
msgstr "カスタムブール演算子を返します。"

#: of sqlalchemy.schema.Column.bool_op:3
msgid ""
"This method is shorthand for calling :meth:`.Operators.op` and passing "
"the :paramref:`.Operators.op.is_comparison` flag with True."
msgstr "このメソッドは、：meth： `.Operators.op`を呼び出し、：paramref：` .Operators.op.is_comparison`フラグをTrueで渡すことを簡略化しています。"

#: of sqlalchemy.schema.Column.bool_op:12
msgid ":meth:`.Operators.op`"
msgstr "：meth： `.Operators.op`"

#: of sqlalchemy.schema.Column.cast:1
msgid "Produce a type cast, i.e. ``CAST(<expression> AS <type>)``."
msgstr "型キャスト、つまり `` CAST（ <expression>として<type> ） ``。"

#: of sqlalchemy.schema.Column.cast:3
msgid "This is a shortcut to the :func:`~.expression.cast` function."
msgstr "これは：func： `〜.expression.cast`関数へのショートカットです。"

#: of sqlalchemy.schema.Column.collate:1
msgid ""
"Produce a :func:`~.expression.collate` clause against the parent object, "
"given the collation string."
msgstr "照合文字列を指定して、親オブジェクトに対してa：func： `〜.expression.collat​​e`句を生成します。"

#: of sqlalchemy.schema.Column.collate:6
msgid ":func:`~.expression.collate`"
msgstr "：func： `〜.expression.collat​​e`"

#: of sqlalchemy.schema.Column.compare:1
msgid "Compare this ColumnElement to another."
msgstr "このColumnElementと別のColumnElementを比較します。"

#: of sqlalchemy.schema.Column.compare:3
msgid "Special arguments understood:"
msgstr "特別な議論が理解された："

#: of sqlalchemy.schema.Column.compare sqlalchemy.schema.Column.compile
#: sqlalchemy.schema.Column.contains sqlalchemy.schema.Column.endswith
#: sqlalchemy.schema.Column.ilike sqlalchemy.schema.Column.in_
#: sqlalchemy.schema.Column.like sqlalchemy.schema.Column.op
#: sqlalchemy.schema.Column.startswith sqlalchemy.schema.MetaData.create_all
#: sqlalchemy.schema.MetaData.drop_all sqlalchemy.schema.MetaData.reflect
#: sqlalchemy.schema.Table sqlalchemy.schema.Table.argument_for
#: sqlalchemy.schema.Table.compile sqlalchemy.schema.Table.corresponding_column
#: sqlalchemy.schema.Table.join sqlalchemy.schema.Table.outerjoin
#: sqlalchemy.schema.Table.tometadata
msgid "パラメータ"
msgstr "パラメータ"

#: of sqlalchemy.schema.Column.compare:5
msgid ""
"when True, consider two columns that share a common base column as "
"equivalent (i.e. shares_lineage())"
msgstr "Trueの場合、共通の基底カラムを同等のものとして共有する2つのカラムを考慮してください（すなわち、shares_lineage（））"

#: of sqlalchemy.schema.Column.compare:8
msgid ""
"a dictionary of columns as keys mapped to sets of columns. If the given "
"\"other\" column is present in this dictionary, if any of the columns in "
"the corresponding set() pass the comparison test, the result is True. "
"This is used to expand the comparison to other columns that may be known "
"to be equivalent to this one via foreign key or other criterion."
msgstr "列のセットにマップされたキーとしての列の辞書。指定された\ &quot;その他\&quot;列がこの辞書に存在する場合、対応する集合（）のいずれかの列が比較テストに合格した場合、結果は真です。これは、外部キーまたは他の基準を介してこれと同等であることが知られている他の列との比較を拡張するために使用されます。"

#: of sqlalchemy.schema.Column.compile:1 sqlalchemy.schema.Table.compile:1
msgid "Compile this SQL expression."
msgstr "このSQL式をコンパイルします。"

#: of sqlalchemy.schema.Column.compile:3 sqlalchemy.schema.Table.compile:3
msgid ""
"The return value is a :class:`~.Compiled` object. Calling ``str()`` or "
"``unicode()`` on the returned value will yield a string representation of"
" the result. The :class:`~.Compiled` object also can return a dictionary "
"of bind parameter names and values using the ``params`` accessor."
msgstr "戻り値は：class： `〜.Compiled`オブジェクトです。返された値に対して `` str（） ``または `` unicode（） ``を呼び出すと結果の文字列表現が返されます。 ：class： `〜.Compiled`オブジェクトは、` `params``アクセサを使ってバインドパラメータの名前と値の辞書を返すこともできます。"

#: of sqlalchemy.schema.Column.compile:10 sqlalchemy.schema.Table.compile:10
msgid ""
"An ``Engine`` or ``Connection`` from which a ``Compiled`` will be "
"acquired. This argument takes precedence over this "
":class:`.ClauseElement`'s bound engine, if any."
msgstr "`` Engine``または `` Connection``から `` Compiled``を取得します。この引数はこれよりも優先されます：class： `.ClauseElement`のバウンドエンジン（もしあれば）。"

#: of sqlalchemy.schema.Column.compile:14 sqlalchemy.schema.Table.compile:14
msgid ""
"Used for INSERT and UPDATE statements, a list of column names which "
"should be present in the VALUES clause of the compiled statement. If "
"``None``, all columns from the target table object are rendered."
msgstr "INSERTおよびUPDATEステートメントに使用され、コンパイルされたステートメントのVALUES節に存在する列名のリスト。 `` None``の場合、ターゲットテーブルオブジェクトのすべての列がレンダリングされます。"

#: of sqlalchemy.schema.Column.compile:19 sqlalchemy.schema.Table.compile:19
msgid ""
"A ``Dialect`` instance from which a ``Compiled`` will be acquired. This "
"argument takes precedence over the `bind` argument as well as this "
":class:`.ClauseElement`'s bound engine, if any."
msgstr "`` Dialect``インスタンスで、 `` Compiled``を取得します。この引数は、 `bind`引数だけでなく、class：` .ClauseElement`のバウンドエンジン（存在する場合）も優先します。"

#: of sqlalchemy.schema.Column.compile:24 sqlalchemy.schema.Table.compile:24
msgid ""
"Used for INSERT statements, for a dialect which does not support inline "
"retrieval of newly generated primary key columns, will force the "
"expression used to create the new primary key value to be rendered inline"
" within the INSERT statement's VALUES clause. This typically refers to "
"Sequence execution but may also refer to any server-side default "
"generation function associated with a primary key `Column`."
msgstr "新しく生成された主キー列のインライン検索をサポートしていない方言のINSERTステートメントでは、INSERTステートメントのVALUES句内で新しい主キー値の作成式を強制的にインラインで表示します。これは、通常、シーケンスの実行を参照するが、主キー「列」に関連付けられた任意のサーバー側デフォルト生成関数を参照することもできる。"

#: of sqlalchemy.schema.Column.compile:32 sqlalchemy.schema.Table.compile:32
msgid ""
"optional dictionary of additional parameters that will be passed through "
"to the compiler within all \"visit\" methods.  This allows any custom "
"flag to be passed through to a custom compilation construct, for example."
"  It is also used for the case of passing the ``literal_binds`` flag "
"through::      from sqlalchemy.sql import table, column, select      t = "
"table('t', column('x'))      s = select([t]).where(t.c.x == 5)      print"
" s.compile(compile_kwargs={\"literal_binds\": True})  .. versionadded:: "
"0.9.0"
msgstr "すべての\ &quot;visit \&quot;メソッド内でコンパイラに渡される追加パラメータのオプション辞書。これにより、任意のカスタムフラグをカスタムコンパイル構成に渡すことができます。また、 `` literal_binds``フラグを:: sqlalchemy.sqlから渡す場合にも使用されます。import table、column、select t = table（ &#39;t&#39;、column（ &#39;x&#39;））s = select（[t ]））。ここで、（tcx == 5）は、s.compile（compile_kwargs = {\ &quot;literal_binds \&quot;：True）を出力します）.. versionadded :: 0.9.0"

#: of sqlalchemy.schema.Column.compile:32 sqlalchemy.schema.Table.compile:32
msgid ""
"optional dictionary of additional parameters that will be passed through "
"to the compiler within all \"visit\" methods.  This allows any custom "
"flag to be passed through to a custom compilation construct, for example."
"  It is also used for the case of passing the ``literal_binds`` flag "
"through::"
msgstr "すべての\ &quot;visit \&quot;メソッド内でコンパイラに渡される追加パラメータのオプション辞書。これにより、任意のカスタムフラグをカスタムコンパイル構成に渡すことができます。 `` literal_binds``フラグを::に渡す場合にも使用されます"

#: of sqlalchemy.schema.Column.compile:50 sqlalchemy.schema.Table.compile:50
msgid ":ref:`faq_sql_expression_string`"
msgstr "：ref： `faq_sql_expression_string`"

#: of sqlalchemy.schema.Column.concat:1
msgid "Implement the 'concat' operator."
msgstr "&#39;concat&#39;演算子を実装します。"

#: of sqlalchemy.schema.Column.concat:3
msgid ""
"In a column context, produces the clause ``a || b``, or uses the "
"``concat()`` operator on MySQL."
msgstr "列コンテキストでは、 `` a || MySQLで `` concat（） ``演算子を使用します。"

#: of sqlalchemy.schema.Column.contains:1
msgid "Implement the 'contains' operator."
msgstr "&#39;contains&#39;演算子を実装します。"

#: of sqlalchemy.schema.Column.contains:3
msgid ""
"Produces a LIKE expression that tests against a match for the middle of a"
" string value::"
msgstr "文字列値の真ん中との一致に対してテストするLIKE式を生成します::"

#: of sqlalchemy.schema.Column.contains:8 sqlalchemy.schema.Column.endswith:8
#: sqlalchemy.schema.Column.ilike:11 sqlalchemy.schema.Column.like:7
#: sqlalchemy.schema.Column.startswith:8 sqlalchemy.schema.Table.argument_for:3
#: sqlalchemy.schema.Table.delete:4 sqlalchemy.schema.Table.insert:4
#: sqlalchemy.schema.Table.join:4 sqlalchemy.schema.Table.outerjoin:5
#: sqlalchemy.schema.Table.tometadata:4 sqlalchemy.schema.Table.update:4
msgid "E.g.::"
msgstr "例えば：："

#: of sqlalchemy.schema.Column.contains:13
msgid ""
"Since the operator uses ``LIKE``, wildcard characters ``\"%\"`` and "
"``\"_\"`` that are present inside the <other> expression will behave like"
" wildcards as well.   For literal string values, the "
":paramref:`.ColumnOperators.contains.autoescape` flag may be set to "
"``True`` to apply escaping to occurences of these characters within the "
"string value so that they match as themselves and not as wildcard "
"characters.  Alternatively, the "
":paramref:`.ColumnOperators.contains.escape` parameter will establish a "
"given character as an escape character which can be of use when the "
"target expression is not a literal string."
msgstr "演算子は `` LIKE``を使用するので、演算子の中にはワイルドカード文字 `` \ &quot;％\&quot; ``と `` \ &quot;_ \&quot; `` <other>式はワイルドカードのようにも動作します。リテラル文字列値の場合、：paramref： `.ColumnOperators.contains.autoescape`フラグを` `True``に設定すると、文字列値内でこれらの文字がエスケープされ、ワイルドカード文字としてではなく一致するようになります。あるいは、：paramref： `.ColumnOperators.contains.escape`パラメータは、指定された文字をエスケープ文字として確立します。これは、ターゲット式がリテラル文字列でない場合に使用できます。"

#: of sqlalchemy.schema.Column.contains:24
msgid ""
"expression to be compared.   This is usually a plain string value, but "
"can also be an arbitrary SQL expression.  LIKE wildcard characters ``%`` "
"and ``_`` are not escaped by default unless the "
":paramref:`.ColumnOperators.contains.autoescape` flag is set to True."
msgstr "比較される式。これは普通は普通の文字列値ですが、任意のSQL式でもかまいません。 LIKEワイルドカード文字 ``％ ``と `` _``は、：paramref： `.ColumnOperators.contains.autoescape`フラグがTrueに設定されていない限り、デフォルトでエスケープされません。"

#: of sqlalchemy.schema.Column.contains:30
msgid ""
"boolean; when True, establishes an escape character within the LIKE "
"expression, then applies it to all occurrences of ``\"%\"``, ``\"_\"`` "
"and the escape character itself within the comparison value, which is "
"assumed to be a literal string and not a SQL expression.  An expression "
"such as::    somecolumn.contains(\"foo%bar\", autoescape=True)  Will "
"render as::    somecolumn LIKE '%' || :param || '%' ESCAPE '/'  With the "
"value of :param as ``\"foo/%bar\"``.  .. versionadded:: 1.2  .. "
"versionchanged:: 1.2.0 The   "
":paramref:`.ColumnOperators.contains.autoescape` parameter is    now a "
"simple boolean rather than a character; the escape    character itself is"
" also escaped, and defaults to a forwards    slash, which itself can be "
"customized using the    :paramref:`.ColumnOperators.contains.escape` "
"parameter."
msgstr "ブール値。 Trueの場合、LIKE式内にエスケープ文字を設定し、それを比較値の中の `` \ &quot;％\&quot; ``、 `` \ &quot;_ \&quot; ``とエスケープ文字自体のすべての出現に適用します。 SQL式ではなくリテラル文字列とみなされます。 :: somecolumn.contains（\ &quot;foo％bar \&quot;、autoescape = True）のような式は次のようにレンダリングします:: somecolumn LIKE &#39;％&#39; || ：param || &#39;％&#39; ESCAPE &#39;/&#39;：paramの値を `` \ &quot;foo /％bar \&quot; ``として指定します。 .. versionadded :: 1.2 .. versionchanged :: 1.2.0：paramref： `.ColumnOperators.contains.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.contains.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.contains:30 sqlalchemy.schema.Column.endswith:30
#: sqlalchemy.schema.Column.startswith:30
msgid ""
"boolean; when True, establishes an escape character within the LIKE "
"expression, then applies it to all occurrences of ``\"%\"``, ``\"_\"`` "
"and the escape character itself within the comparison value, which is "
"assumed to be a literal string and not a SQL expression."
msgstr "ブール値。 Trueの場合、LIKE式内にエスケープ文字を設定し、それを比較値の中の `` \ &quot;％\&quot; ``、 `` \ &quot;_ \&quot; ``とエスケープ文字自体のすべての出現に適用します。 SQL式ではなくリテラル文字列とみなされます。"

#: of sqlalchemy.schema.Column.contains:36 sqlalchemy.schema.Column.contains:61
#: sqlalchemy.schema.Column.endswith:36 sqlalchemy.schema.Column.endswith:61
#: sqlalchemy.schema.Column.startswith:36
#: sqlalchemy.schema.Column.startswith:61
msgid "An expression such as::"
msgstr "::のような表現"

#: of sqlalchemy.schema.Column.contains:40 sqlalchemy.schema.Column.contains:65
#: sqlalchemy.schema.Column.endswith:40 sqlalchemy.schema.Column.endswith:65
#: sqlalchemy.schema.Column.startswith:40
#: sqlalchemy.schema.Column.startswith:65
msgid "Will render as::"
msgstr "レンダリングする::"

#: of sqlalchemy.schema.Column.contains:44 sqlalchemy.schema.Column.endswith:44
#: sqlalchemy.schema.Column.startswith:44
msgid "With the value of :param as ``\"foo/%bar\"``."
msgstr "：paramを `` \ &quot;foo /％bar \&quot; ``として指定します。"

#: of sqlalchemy.schema.Column.contains:48
msgid ""
"The :paramref:`.ColumnOperators.contains.autoescape` parameter is  now a "
"simple boolean rather than a character; the escape  character itself is "
"also escaped, and defaults to a forwards  slash, which itself can be "
"customized using the  :paramref:`.ColumnOperators.contains.escape` "
"parameter."
msgstr "：paramref： `.ColumnOperators.contains.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.contains.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.contains:55
msgid ""
"a character which when given will render with the ``ESCAPE`` keyword to "
"establish that character as the escape character.  This character can "
"then be placed preceding occurrences of ``%`` and ``_`` to allow them to "
"act as themselves and not wildcard characters.  An expression such as::"
"    somecolumn.contains(\"foo/%bar\", escape=\"^\")  Will render as::    "
"somecolumn LIKE '%' || :param || '%' ESCAPE '^'  The parameter may also "
"be combined with :paramref:`.ColumnOperators.contains.autoescape`::    "
"somecolumn.contains(\"foo%bar^bat\", escape=\"^\", autoescape=True)  "
"Where above, the given literal parameter will be converted to "
"``\"foo^%bar^^bat\"`` before being passed to the database."
msgstr "その文字をエスケープ文字として確立するために `` ESCAPE``キーワードでレンダリングされる文字を返します。この文字を ``％ ``と `` _``の前に置くことで、ワイルドカード文字ではなく自分自身として動作させることができます。 :: somecolumn.contains（\ &quot;foo /％bar \&quot;、エスケープ= \ &quot;^ \&quot;）などの式は、:: somecolumn LIKE &#39;％&#39; ||をレンダリングします。 ：param || &#39;％&#39; ESCAPE &#39;^&#39;パラメタ： `.ColumnOperators.contains.autoescape` :: somecolumn.contains（\&quot; foo％bar ^ bat \ &quot;、エスケープ= \&quot; ^ \ &quot;、autoescape = True）上記の場合、与えられたリテラルパラメータはデータベースに渡される前に `` \ &quot;foo ^％bar ^^ bat \&quot; ``に変換されます。"

#: of sqlalchemy.schema.Column.contains:55 sqlalchemy.schema.Column.endswith:55
#: sqlalchemy.schema.Column.startswith:55
msgid ""
"a character which when given will render with the ``ESCAPE`` keyword to "
"establish that character as the escape character.  This character can "
"then be placed preceding occurrences of ``%`` and ``_`` to allow them to "
"act as themselves and not wildcard characters."
msgstr "その文字をエスケープ文字として確立するために `` ESCAPE``キーワードでレンダリングされる文字を返します。この文字を ``％ ``と `` _``の前に置くことで、ワイルドカード文字ではなく自分自身として動作させることができます。"

#: of sqlalchemy.schema.Column.contains:69
msgid ""
"The parameter may also be combined with "
":paramref:`.ColumnOperators.contains.autoescape`::"
msgstr "パラメータは以下のものと組み合わせることもできます：paramref： `.ColumnOperators.contains.autoescape` ::"

#: of sqlalchemy.schema.Column.contains:74 sqlalchemy.schema.Column.endswith:74
#: sqlalchemy.schema.Column.startswith:74
msgid ""
"Where above, the given literal parameter will be converted to "
"``\"foo^%bar^^bat\"`` before being passed to the database."
msgstr "上記の場合、与えられたリテラルパラメータはデータベースに渡される前に `` \ &quot;foo ^％bar ^^ bat \&quot; ``に変換されます。"

#: of sqlalchemy.schema.Column.contains:79 sqlalchemy.schema.Column.endswith:79
msgid ":meth:`.ColumnOperators.startswith`"
msgstr "：meth： `.ColumnOperators.startswith`"

#: of sqlalchemy.schema.Column.contains:81
#: sqlalchemy.schema.Column.startswith:79
msgid ":meth:`.ColumnOperators.endswith`"
msgstr "：meth： `.ColumnOperators.endswith`"

#: of sqlalchemy.schema.Column.contains:83 sqlalchemy.schema.Column.endswith:83
#: sqlalchemy.schema.Column.ilike:24 sqlalchemy.schema.Column.notlike:10
#: sqlalchemy.schema.Column.startswith:83
msgid ":meth:`.ColumnOperators.like`"
msgstr "：meth： `.ColumnOperators.like`"

#: of sqlalchemy.schema.Column.copy:1
msgid "Create a copy of this ``Column``, unitialized."
msgstr "ユニット化されたこの `` Column``のコピーを作成します。"

#: of sqlalchemy.schema.Column.copy:3
msgid "This is used in ``Table.tometadata``."
msgstr "これは `` Table.tometadata``で使われます。"

#: of sqlalchemy.schema.Column.desc:1
msgid "Produce a :func:`~.expression.desc` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.desc`句を生成します。"

#: of sqlalchemy.schema.Column.distinct:1
msgid "Produce a :func:`~.expression.distinct` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.distinct`節を生成します。"

#: of sqlalchemy.schema.Column.endswith:1
msgid "Implement the 'endswith' operator."
msgstr "&#39;endswith&#39;演算子を実装します。"

#: of sqlalchemy.schema.Column.endswith:3
msgid ""
"Produces a LIKE expression that tests against a match for the end of a "
"string value::"
msgstr "文字列値の終わりに一致するかどうかをテストするLIKE式を生成します。"

#: of sqlalchemy.schema.Column.endswith:13
msgid ""
"Since the operator uses ``LIKE``, wildcard characters ``\"%\"`` and "
"``\"_\"`` that are present inside the <other> expression will behave like"
" wildcards as well.   For literal string values, the "
":paramref:`.ColumnOperators.endswith.autoescape` flag may be set to "
"``True`` to apply escaping to occurences of these characters within the "
"string value so that they match as themselves and not as wildcard "
"characters.  Alternatively, the "
":paramref:`.ColumnOperators.endswith.escape` parameter will establish a "
"given character as an escape character which can be of use when the "
"target expression is not a literal string."
msgstr "演算子は `` LIKE``を使用するので、演算子の中にはワイルドカード文字 `` \ &quot;％\&quot; ``と `` \ &quot;_ \&quot; `` <other>式はワイルドカードのようにも動作します。リテラル文字列値の場合、：paramref： `.ColumnOperators.endswith.autoescape`フラグを` `True``に設定して、文字列値内のこれらの文字のエスケープを適用し、ワイルドカード文字ではなく一致するようにすることができます。代わりに、：paramref： `.ColumnOperators.endswith.escape`パラメータは、ターゲット式がリテラル文字列でない場合に使用できるエスケープ文字として、指定された文字を確立します。"

#: of sqlalchemy.schema.Column.endswith:24
msgid ""
"expression to be compared.   This is usually a plain string value, but "
"can also be an arbitrary SQL expression.  LIKE wildcard characters ``%`` "
"and ``_`` are not escaped by default unless the "
":paramref:`.ColumnOperators.endswith.autoescape` flag is set to True."
msgstr "比較される式。これは普通は普通の文字列値ですが、任意のSQL式でもかまいません。 LIKEワイルドカード文字 ``％ ``と `` _``は、：paramref： `.ColumnOperators.endswith.autoescape`フラグがTrueに設定されていない限り、デフォルトでエスケープされません。"

#: of sqlalchemy.schema.Column.endswith:30
msgid ""
"boolean; when True, establishes an escape character within the LIKE "
"expression, then applies it to all occurrences of ``\"%\"``, ``\"_\"`` "
"and the escape character itself within the comparison value, which is "
"assumed to be a literal string and not a SQL expression.  An expression "
"such as::    somecolumn.endswith(\"foo%bar\", autoescape=True)  Will "
"render as::    somecolumn LIKE '%' || :param ESCAPE '/'  With the value "
"of :param as ``\"foo/%bar\"``.  .. versionadded:: 1.2  .. "
"versionchanged:: 1.2.0 The   "
":paramref:`.ColumnOperators.endswith.autoescape` parameter is    now a "
"simple boolean rather than a character; the escape    character itself is"
" also escaped, and defaults to a forwards    slash, which itself can be "
"customized using the    :paramref:`.ColumnOperators.endswith.escape` "
"parameter."
msgstr "ブール値。 Trueの場合、LIKE式内にエスケープ文字を設定し、それを比較値の中の `` \ &quot;％\&quot; ``、 `` \ &quot;_ \&quot; ``とエスケープ文字自体のすべての出現に適用します。 SQL式ではなくリテラル文字列とみなされます。 :: somecolumn.endswith（\ &quot;foo％bar \&quot;、autoescape = True）のような式は次のようにレンダリングします:: somecolumn LIKE &#39;％&#39; || ：param ESCAPE &#39;/&#39;：paramの値を `` \ &quot;foo /％bar \&quot; ``として指定します。 .. versionadded :: 1.2 .. versionchanged :: 1.2.0：paramref： `.ColumnOperators.endswith.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.endswith.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.endswith:48
msgid ""
"The :paramref:`.ColumnOperators.endswith.autoescape` parameter is  now a "
"simple boolean rather than a character; the escape  character itself is "
"also escaped, and defaults to a forwards  slash, which itself can be "
"customized using the  :paramref:`.ColumnOperators.endswith.escape` "
"parameter."
msgstr "：paramref： `.ColumnOperators.endswith.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.endswith.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.endswith:55
msgid ""
"a character which when given will render with the ``ESCAPE`` keyword to "
"establish that character as the escape character.  This character can "
"then be placed preceding occurrences of ``%`` and ``_`` to allow them to "
"act as themselves and not wildcard characters.  An expression such as::"
"    somecolumn.endswith(\"foo/%bar\", escape=\"^\")  Will render as::    "
"somecolumn LIKE '%' || :param ESCAPE '^'  The parameter may also be "
"combined with :paramref:`.ColumnOperators.endswith.autoescape`::    "
"somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)  "
"Where above, the given literal parameter will be converted to "
"``\"foo^%bar^^bat\"`` before being passed to the database."
msgstr "その文字をエスケープ文字として確立するために `` ESCAPE``キーワードでレンダリングされる文字を返します。この文字を ``％ ``と `` _``の前に置くことで、ワイルドカード文字ではなく自分自身として動作させることができます。 :: somecolumn.endswith（\ &quot;foo /％bar \&quot;、エスケープ= \ &quot;^ \&quot;）などの式は、:: somecolumn LIKE &#39;％&#39; ||をレンダリングします。 ：paramref： `.ColumnOperators.endswith.autoescape` :: somecolumn.endswith（\&quot; foo％bar ^ bat \ &quot;、エスケープ= \&quot; ^ \ &quot;、autoescape = True）上記の場合、与えられたリテラルパラメータはデータベースに渡される前に `` \ &quot;foo ^％bar ^^ bat \&quot; ``に変換されます。"

#: of sqlalchemy.schema.Column.endswith:69
msgid ""
"The parameter may also be combined with "
":paramref:`.ColumnOperators.endswith.autoescape`::"
msgstr "パラメタは以下のものと組み合わせることもできます：paramref： `.ColumnOperators.endswith.autoescape` ::"

#: of sqlalchemy.schema.Column.endswith:81
#: sqlalchemy.schema.Column.startswith:81
msgid ":meth:`.ColumnOperators.contains`"
msgstr "：meth： `.ColumnOperators.contains`"

#: of sqlalchemy.schema.Column.expression:1
msgid "Return a column expression."
msgstr "列式を返します。"

#: of sqlalchemy.schema.Column.expression:3
msgid "Part of the inspection interface; returns self."
msgstr "検査インタフェースの一部。自己を返します。"

#: of sqlalchemy.schema.Column.ilike:1
msgid "Implement the ``ilike`` operator, e.g. case insensitive LIKE."
msgstr "`` ilike``演算子を実装します。例えば、大文字小文字を区別しないLIKEです。"

#: of sqlalchemy.schema.Column.ilike:3
msgid "In a column context, produces an expression either of the form::"
msgstr "列コンテキストでは、次の形式の式を生成します。"

#: of sqlalchemy.schema.Column.ilike:7
msgid "Or on backends that support the ILIKE operator::"
msgstr "ILIKE演算子をサポートするバックエンドでは::"

#: of sqlalchemy.schema.Column.ilike:16 sqlalchemy.schema.Column.like:12
msgid "expression to be compared"
msgstr "比較される式"

#: of sqlalchemy.schema.Column.ilike:17
msgid ""
"optional escape character, renders the ``ESCAPE`` keyword, e.g.::    "
"somecolumn.ilike(\"foo/%bar\", escape=\"/\")"
msgstr "オプションのエスケープ文字は、:: somecolumn.ilike（\ &quot;foo /％bar \&quot;、escape = \ &quot;/ \&quot;）などの `` ESCAPE``キーワードをレンダリングします。"

#: of sqlalchemy.schema.Column.ilike:17 sqlalchemy.schema.Column.like:13
msgid "optional escape character, renders the ``ESCAPE`` keyword, e.g.::"
msgstr "オプションのエスケープ文字で、 `` ESCAPE``キーワードをレンダリングします。例えば::"

#: of sqlalchemy.schema.Column.in_:1
msgid "Implement the ``in`` operator."
msgstr "`` in``演算子を実装します。"

#: of sqlalchemy.schema.Column.in_:3
msgid "In a column context, produces the clause ``column IN <other>``."
msgstr "列コンテキストでは、 `` column IN <other> ``。"

#: of sqlalchemy.schema.Column.in_:5
msgid "The given parameter ``other`` may be:"
msgstr "与えられたパラメータ `` other``は次のようになります："

#: of sqlalchemy.schema.Column.in_:7
msgid "A list of literal values, e.g.::"
msgstr "リテラル値のリスト（例：::）"

#: of sqlalchemy.schema.Column.in_:11
msgid ""
"In this calling form, the list of items is converted to a set of bound "
"parameters the same length as the list given::"
msgstr "この呼び出し形式では、アイテムのリストは、与えられたリストと同じ長さのバインドされたパラメータのセットに変換されます::"

#: of sqlalchemy.schema.Column.in_:16
msgid "An empty list, e.g.::"
msgstr "空のリスト、例えば::"

#: of sqlalchemy.schema.Column.in_:20
msgid ""
"In this calling form, the expression renders a \"false\" expression, "
"e.g.::"
msgstr "この呼び出し形式では、式は\ &quot;false \&quot;式をレンダリングします。たとえば、::"

#: of sqlalchemy.schema.Column.in_:25
msgid ""
"This \"false\" expression has historically had different behaviors in "
"older SQLAlchemy versions, see "
":paramref:`.create_engine.empty_in_strategy` for behavioral options."
msgstr "この古くからのSQLAlchemyのバージョンでは、この &quot;偽の&quot;表現は異なった振る舞いをしています。paramref： `.create_engine.empty_in_strategy`は動作オプションです。"

#: of sqlalchemy.schema.Column.in_:29
msgid "simplified the behavior of \"empty in\" expressions"
msgstr "\ &quot;空の\&quot;式の動作を単純化"

#: of sqlalchemy.schema.Column.in_:32
msgid ""
"A bound parameter, e.g. :func:`.bindparam`, may be used if it includes "
"the :paramref:`.bindparam.expanding` flag::"
msgstr "もし：paramref： `.bindparam.expanding`フラグを含んでいれば、バインドされたパラメータ、例えば：func：` .bindparam`を使うことができます："

#: of sqlalchemy.schema.Column.in_:37
msgid ""
"In this calling form, the expression renders a special non-SQL "
"placeholder expression that looks like::"
msgstr "この呼び出し形式では、次のような特別な非SQLプレースホルダ式がレンダリングされます。"

#: of sqlalchemy.schema.Column.in_:42
msgid ""
"This placeholder expression is intercepted at statement execution time to"
" be converted into the variable number of bound parameter form "
"illustrated earlier.   If the statement were executed as::"
msgstr "このプレースホルダー式は、ステートメントの実行時にインターセプトされ、前述の可変数のバインドされたパラメーター・フォームに変換されます。文が次のように実行された場合："

#: of sqlalchemy.schema.Column.in_:48
msgid "The database would be passed a bound parameter for each value::"
msgstr "データベースには各値のバインドされたパラメータが渡されます::"

#: of sqlalchemy.schema.Column.in_:52
msgid "added \"expanding\" bound parameters"
msgstr "バインドされたパラメータを &quot;展開する&quot;ことを追加しました"

#: of sqlalchemy.schema.Column.in_:54
msgid ""
"If an empty list is passed, a special \"empty list\" expression, which is"
" specific to the database in use, is rendered.  On SQLite this would be::"
msgstr "空のリストが渡されると、使用中のデータベースに固有の特殊な &quot;空のリスト&quot;表現がレンダリングされます。 SQLiteではこれは::"

#: of sqlalchemy.schema.Column.in_:60
msgid "\"expanding\" bound parameters now support empty lists"
msgstr "\ &quot;expanded \&quot;バインドされたパラメータは空のリストをサポートするようになりました。"

#: of sqlalchemy.schema.Column.in_:63
msgid "a :func:`.select` construct, which is usually a correlated scalar select::"
msgstr "a：func： `.select`構造体。これは通常、相関スカラー選択::"

#: of sqlalchemy.schema.Column.in_:73
msgid "In this calling form, :meth:`.ColumnOperators.in_` renders as given::"
msgstr "この呼び出し形式では、：meth： `.ColumnOperators.in_`は与えられたとおりにレンダリングします::"

#: of sqlalchemy.schema.Column.in_:78
msgid ""
"a list of literals, a :func:`.select` construct, or a :func:`.bindparam` "
"construct that includes the :paramref:`.bindparam.expanding` flag set to "
"True."
msgstr "リテラルのリスト、a：func： `.select`構造体、または：paramref：` .bindparam.expanding`フラグがTrueに設定されているa：func： `.bindparam`構造体です。"

#: of sqlalchemy.schema.Column.info:1 sqlalchemy.schema.SchemaItem.info:1
#: sqlalchemy.schema.Table.info:1
msgid ""
"Info dictionary associated with the object, allowing user-defined data to"
" be associated with this :class:`.SchemaItem`."
msgstr "オブジェクトに関連付けられた情報ディクショナリで、ユーザ定義データをthis：class： `.SchemaItem`に関連付けることができます。"

#: of sqlalchemy.schema.Column.info:4 sqlalchemy.schema.SchemaItem.info:4
#: sqlalchemy.schema.Table.info:4
msgid ""
"The dictionary is automatically generated when first accessed. It can "
"also be specified in the constructor of some objects, such as "
":class:`.Table` and :class:`.Column`."
msgstr "辞書は、最初にアクセスされると自動的に生成されます。これは、class： `.Table`や：class：` .Column`のようなオブジェクトのコンストラクタで指定することもできます。"

#: of sqlalchemy.schema.Column.is_:1
msgid "Implement the ``IS`` operator."
msgstr "`` IS``演算子を実装してください。"

#: of sqlalchemy.schema.Column.is_:3
msgid ""
"Normally, ``IS`` is generated automatically when comparing to a value of "
"``None``, which resolves to ``NULL``.  However, explicit usage of ``IS`` "
"may be desirable if comparing to boolean values on certain platforms."
msgstr "通常、 `` IS``は `` None``の値と比較すると自動的に生成され、 `` NULL``に解決されます。しかし、特定のプラットフォーム上のブール値と比較すると、明示的に &quot;IS&quot;を使用することが望ましい場合があります。"

#: of sqlalchemy.schema.Column.is_:10
msgid ":meth:`.ColumnOperators.isnot`"
msgstr "：meth： `.ColumnOperators.isnot`"

#: of sqlalchemy.schema.Column.is_distinct_from:1
msgid "Implement the ``IS DISTINCT FROM`` operator."
msgstr "`` IS DISTINCT FROM``演算子を実装してください。"

#: of sqlalchemy.schema.Column.is_distinct_from:3
msgid ""
"Renders \"a IS DISTINCT FROM b\" on most platforms; on some such as "
"SQLite may render \"a IS NOT b\"."
msgstr "ほとんどのプラットフォームで\ &quot;a DISABLEからFROM \&quot;をレンダリングします。そのようなSQLiteは\ &quot;a IS NOT b \&quot;をレンダリングすることがあります。"

#: of sqlalchemy.schema.Column.isnot:1
msgid "Implement the ``IS NOT`` operator."
msgstr "`` IS NOT``演算子を実装してください。"

#: of sqlalchemy.schema.Column.isnot:3
msgid ""
"Normally, ``IS NOT`` is generated automatically when comparing to a value"
" of ``None``, which resolves to ``NULL``.  However, explicit usage of "
"``IS NOT`` may be desirable if comparing to boolean values on certain "
"platforms."
msgstr "通常、 `` NOT &#39;&#39;は `` NULL``に解決する `` None``の値と比較すると自動的に生成されます。しかし、特定のプラットフォーム上のブール値と比較した場合、明示的に &quot;IS NOT&quot;を使用することが望ましいかもしれません。"

#: of sqlalchemy.schema.Column.isnot:10
msgid ":meth:`.ColumnOperators.is_`"
msgstr "：meth： `.ColumnOperators.is_`"

#: of sqlalchemy.schema.Column.isnot_distinct_from:1
msgid "Implement the ``IS NOT DISTINCT FROM`` operator."
msgstr "`` IS NOT DISTINCT FROM``演算子を実装してください。"

#: of sqlalchemy.schema.Column.isnot_distinct_from:3
msgid ""
"Renders \"a IS NOT DISTINCT FROM b\" on most platforms; on some such as "
"SQLite may render \"a IS b\"."
msgstr "ほとんどのプラットフォームで\ &quot;a is not DISTINCT FROM b \&quot;をレンダリングします。そのようなSQLiteは\ &quot;a IS b \&quot;をレンダリングします。"

#: of sqlalchemy.schema.Column.label:1
msgid "Produce a column label, i.e. ``<columnname> AS <name>``."
msgstr "列ラベル、すなわち `` <columnname>として<name> ``。"

#: of sqlalchemy.schema.Column.label:3
msgid "This is a shortcut to the :func:`~.expression.label` function."
msgstr "これは：func： `〜.expression.label`関数へのショートカットです。"

#: of sqlalchemy.schema.Column.label:5
msgid "if 'name' is None, an anonymous label name will be generated."
msgstr "&#39;name&#39;がNoneの場合、匿名ラベル名が生成されます。"

#: of sqlalchemy.schema.Column.like:1
msgid "Implement the ``like`` operator."
msgstr "`` like``演算子を実装します。"

#: of sqlalchemy.schema.Column.like:3
msgid "In a column context, produces the expression::"
msgstr "列コンテキストでは、次の式を生成します。"

#: of sqlalchemy.schema.Column.like:13
msgid ""
"optional escape character, renders the ``ESCAPE`` keyword, e.g.::    "
"somecolumn.like(\"foo/%bar\", escape=\"/\")"
msgstr "オプションのエスケープ文字は、:: somecolumn.like（\ &quot;foo /％bar \&quot;、escape = \ &quot;/ \&quot;）などの `` ESCAPE``キーワードをレンダリングします。"

#: of sqlalchemy.schema.Column.like:20 sqlalchemy.schema.Column.notilike:10
msgid ":meth:`.ColumnOperators.ilike`"
msgstr "：meth： `.ColumnOperators.ilike`"

#: of sqlalchemy.schema.Column.match:1
msgid "Implements a database-specific 'match' operator."
msgstr "データベース固有の &#39;match&#39;演算子を実装します。"

#: of sqlalchemy.schema.Column.match:3
msgid ""
":meth:`~.ColumnOperators.match` attempts to resolve to a MATCH-like "
"function or operator provided by the backend. Examples include:"
msgstr "：meth： `〜.ColumnOperators.match`は、バックエンドによって提供されるMATCHのような関数または演算子への解決を試みます。例としては、"

#: of sqlalchemy.schema.Column.match:7
msgid "PostgreSQL - renders ``x @@ to_tsquery(y)``"
msgstr "PostgreSQL  -  `` @ @ to_tsquery（y） ``をレンダリングします。"

#: of sqlalchemy.schema.Column.match:8
msgid "MySQL - renders ``MATCH (x) AGAINST (y IN BOOLEAN MODE)``"
msgstr "MySQLは `` MATCH（x）を反対にします（ブーリアンモードではy） ``"

#: of sqlalchemy.schema.Column.match:9
msgid "Oracle - renders ``CONTAINS(x, y)``"
msgstr "Oracleは `` CONTAINS（x、y） ``をレンダリングします"

#: of sqlalchemy.schema.Column.match:10
msgid "other backends may provide special implementations."
msgstr "他のバックエンドは特別な実装を提供するかもしれません。"

#: of sqlalchemy.schema.Column.match:11
msgid ""
"Backends without any special implementation will emit the operator as "
"\"MATCH\".  This is compatible with SQlite, for example."
msgstr "特別な実装をしないバックエンドは、演算子を\ &quot;MATCH \&quot;として出力します。これは、例えば、SQliteと互換性があります。"

#: of sqlalchemy.schema.Column.notilike:1
msgid "implement the ``NOT ILIKE`` operator."
msgstr "`` NOT ILIKE``演算子を実装してください。"

#: of sqlalchemy.schema.Column.notilike:3
msgid ""
"This is equivalent to using negation with :meth:`.ColumnOperators.ilike`,"
" i.e. ``~x.ilike(y)``."
msgstr "これは：meth： `.ColumnOperators.ilike`、つまり` `〜x.ilike（y）` `で否定を使うのと同じです。"

#: of sqlalchemy.schema.Column.notin_:1
msgid "implement the ``NOT IN`` operator."
msgstr "`` NOT IN``演算子を実装してください。"

#: of sqlalchemy.schema.Column.notin_:3
msgid ""
"This is equivalent to using negation with :meth:`.ColumnOperators.in_`, "
"i.e. ``~x.in_(y)``."
msgstr "これは：meth： `.ColumnOperators.in_`、つまり` `〜x.in_（y）` `で否定を使うのと同じです。"

#: of sqlalchemy.schema.Column.notin_:6
msgid ""
"In the case that ``other`` is an empty sequence, the compiler produces an"
" \"empty not in\" expression.   This defaults to the expression \"1 = 1\""
" to produce true in all cases.  The "
":paramref:`.create_engine.empty_in_strategy` may be used to alter this "
"behavior."
msgstr "`` other``が空のシーケンスである場合、コンパイラは\ &quot;空ではない\&quot;という式を生成します。これは、すべての場合に真を生成するために、デフォルトでは &quot;1 = 1&quot;という表現になります：paramref： `.create_engine.empty_in_strategy`を使ってこの動作を変更することができます。"

#: of sqlalchemy.schema.Column.notin_:12
msgid ""
"The :meth:`.ColumnOperators.in_` and :meth:`.ColumnOperators.notin_` "
"operators now produce a \"static\" expression for an empty IN sequence by"
" default."
msgstr "：meth： `.ColumnOperators.in_`と：meth：` .ColumnOperators.notin_`演算子は、デフォルトで空のINシーケンスのための\ &quot;静的\&quot;式を生成するようになりました。"

#: of sqlalchemy.schema.Column.notin_:19
msgid ":meth:`.ColumnOperators.in_`"
msgstr "：meth： `.ColumnOperators.in_`"

#: of sqlalchemy.schema.Column.notlike:1
msgid "implement the ``NOT LIKE`` operator."
msgstr "`` NOT LIKE``演算子を実装してください。"

#: of sqlalchemy.schema.Column.notlike:3
msgid ""
"This is equivalent to using negation with :meth:`.ColumnOperators.like`, "
"i.e. ``~x.like(y)``."
msgstr "これは：meth： `.ColumnOperators.like`、つまり` `〜x.like（y）` `で否定を使うのと同じです。"

#: of sqlalchemy.schema.Column.nullsfirst:1
msgid ""
"Produce a :func:`~.expression.nullsfirst` clause against the parent "
"object."
msgstr "親オブジェクトに対してa：func： `〜.expression.nullsfirst`句を生成します。"

#: of sqlalchemy.schema.Column.nullslast:1
msgid "Produce a :func:`~.expression.nullslast` clause against the parent object."
msgstr "親オブジェクトに対してa：func： `〜.expression.nullslast`句を生成します。"

#: of sqlalchemy.schema.Column.op:1
msgid "produce a generic operator function."
msgstr "ジェネリック演算子関数を生成します。"

#: of sqlalchemy.schema.Column.op:3 sqlalchemy.schema.Table:3
msgid "e.g.::"
msgstr "例えば：："

#: of sqlalchemy.schema.Column.op:7
msgid "produces::"
msgstr "生成::"

#: of sqlalchemy.schema.Column.op:11
msgid ""
"This function can also be used to make bitwise operators explicit. For "
"example::"
msgstr "この関数は、ビット演算子を明示的にするためにも使用できます。例えば：："

#: of sqlalchemy.schema.Column.op:16
msgid "is a bitwise AND of the value in ``somecolumn``."
msgstr "`` somecolumn``の値のビット単位のANDです。"

#: of sqlalchemy.schema.Column.op:18
msgid ""
"a string which will be output as the infix operator between this element "
"and the expression passed to the generated function."
msgstr "この要素と生成された関数に渡される式との間の中置演算子として出力される文字列。"

#: of sqlalchemy.schema.Column.op:22
msgid ""
"precedence to apply to the operator, when parenthesizing expressions.  A "
"lower number will cause the expression to be parenthesized when applied "
"against another operator with higher precedence.  The default value of "
"``0`` is lower than all operators except for the comma (``,``) and ``AS``"
" operators. A value of 100 will be higher or equal to all operators, and "
"-100 will be lower than or equal to all operators.  .. versionadded:: 0.8"
" - added the 'precedence' argument."
msgstr "式をカッコで括るとき、演算子に適用する優先順位。数値が小さいほど優先順位の高い別の演算子に対して適用されたときに式がかっこにされます。デフォルト値 `` 0``はカンマ（ ``、 ``）と `` AS``演算子を除くすべての演算子よりも低くなります。 100の値はすべての演算子より高くなるか等しいことになり、-100はすべての演算子以下になります。 .. versionadded :: 0.8  -  &#39;precedence&#39;引数を追加しました。"

#: of sqlalchemy.schema.Column.op:22
msgid ""
"precedence to apply to the operator, when parenthesizing expressions.  A "
"lower number will cause the expression to be parenthesized when applied "
"against another operator with higher precedence.  The default value of "
"``0`` is lower than all operators except for the comma (``,``) and ``AS``"
" operators. A value of 100 will be higher or equal to all operators, and "
"-100 will be lower than or equal to all operators."
msgstr "式をカッコで括るとき、演算子に適用する優先順位。数値が小さいほど優先順位の高い別の演算子に対して適用されたときに式がかっこにされます。デフォルト値 `` 0``はカンマ（ ``、 ``）と `` AS``演算子を除くすべての演算子よりも低くなります。 100の値はすべての演算子より高くなるか等しいことになり、-100はすべての演算子以下になります。"

#: of sqlalchemy.schema.Column.op:30
msgid "- added the 'precedence' argument."
msgstr "-  &#39;precedence&#39;引数を追加しました。"

#: of sqlalchemy.schema.Column.op:32
msgid ""
"if True, the operator will be considered as a \"comparison\" operator, "
"that is which evaluates to a boolean true/false value, like ``==``, "
"``>``, etc.  This flag should be set so that ORM relationships can "
"establish that the operator is a comparison operator when used in a "
"custom join condition.  .. versionadded:: 0.9.2 - added the    "
":paramref:`.Operators.op.is_comparison` flag."
msgstr "Trueの場合、演算子は `` == ``、 `` `` ``などのブール値の真偽値を評価する\ &quot;比較演算子&quot;とみなされます。このフラグは、 ORM関係によって、カスタム結合条件で使用される場合、演算子が比較演算子であることが確認されます。 .. versionadded :: 0.9.2  -  paramref： `.Operators.op.is_comparison`フラグを追加しました。"

#: of sqlalchemy.schema.Column.op:32
msgid ""
"if True, the operator will be considered as a \"comparison\" operator, "
"that is which evaluates to a boolean true/false value, like ``==``, "
"``>``, etc.  This flag should be set so that ORM relationships can "
"establish that the operator is a comparison operator when used in a "
"custom join condition."
msgstr "Trueの場合、演算子は `` == ``、 `` `` ``などのブール値の真偽値を評価する\ &quot;比較演算子&quot;とみなされます。このフラグは、 ORM関係によって、カスタム結合条件で使用される場合、演算子が比較演算子であることが確認されます。"

#: of sqlalchemy.schema.Column.op:38
msgid "- added the :paramref:`.Operators.op.is_comparison` flag."
msgstr "-  paramref： `.Operators.op.is_comparison`フラグを追加しました。"

#: of sqlalchemy.schema.Column.op:41
msgid ""
"a :class:`.TypeEngine` class or object that will force the return type of"
" an expression produced by this operator to be of that type.   By "
"default, operators that specify :paramref:`.Operators.op.is_comparison` "
"will resolve to :class:`.Boolean`, and those that do not will be of the "
"same type as the left-hand operand.  .. versionadded:: 1.2.0b3 - added "
"the    :paramref:`.Operators.op.return_type` argument."
msgstr "a：class： `.TypeEngine`クラスまたはこの演算子によって生成された式の戻り値の型を強制的にその型にするオブジェクトです。デフォルトでは：paramref： `.Operators.op.is_comparison`を指定する演算子は：class：` .Boolean`に解決され、左オペランドと同じ型にはなりません。 .. versionadded :: 1.2.0b3  - ：paramref： `.Operators.op.return_type`引数を追加しました。"

#: of sqlalchemy.schema.Column.op:41
msgid ""
"a :class:`.TypeEngine` class or object that will force the return type of"
" an expression produced by this operator to be of that type.   By "
"default, operators that specify :paramref:`.Operators.op.is_comparison` "
"will resolve to :class:`.Boolean`, and those that do not will be of the "
"same type as the left-hand operand."
msgstr "a：class： `.TypeEngine`クラスまたはこの演算子によって生成された式の戻り値の型を強制的にその型にするオブジェクトです。デフォルトでは：paramref： `.Operators.op.is_comparison`を指定する演算子は：class：` .Boolean`に解決され、左オペランドと同じ型にはなりません。"

#: of sqlalchemy.schema.Column.op:48
msgid "- added the :paramref:`.Operators.op.return_type` argument."
msgstr "- ：paramref： `.Operators.op.return_type`引数を追加しました。"

#: of sqlalchemy.schema.Column.op:53
msgid ":ref:`types_operators`"
msgstr "：ref： `types_operators`"

#: of sqlalchemy.schema.Column.op:55
msgid ":ref:`relationship_custom_operator`"
msgstr "：ref： `relationship_custom_operator`"

#: of sqlalchemy.schema.Column.quote:1 sqlalchemy.schema.SchemaItem.quote:1
#: sqlalchemy.schema.Table.quote:1
msgid ""
"Return the value of the ``quote`` flag passed to this schema object, for "
"those schema items which have a ``name`` field."
msgstr "`` name``フィールドを持つスキーマ項目については、このスキーマオブジェクトに渡された `` quote``フラグの値を返します。"

#: of sqlalchemy.schema.Column.quote:5 sqlalchemy.schema.SchemaItem.quote:5
#: sqlalchemy.schema.Table.quote:5
msgid "Use ``<obj>.name.quote``"
msgstr "`` <obj> .name.quote``"

#: of sqlalchemy.schema.Column.references:1
msgid "Return True if this Column references the given column via foreign key."
msgstr "この列が外部キーを介して指定された列を参照する場合はTrueを返します。"

#: of sqlalchemy.schema.Column.shares_lineage:1
msgid ""
"Return True if the given :class:`.ColumnElement` has a common ancestor to"
" this :class:`.ColumnElement`."
msgstr "与えられた：class： `.ColumnElement`がthis：class：` .ColumnElement`に共通の祖先を持つ場合、Trueを返します。"

#: of sqlalchemy.schema.Column.startswith:1
msgid "Implement the ``startswith`` operator."
msgstr "`` startswith``演算子を実装してください。"

#: of sqlalchemy.schema.Column.startswith:3
msgid ""
"Produces a LIKE expression that tests against a match for the start of a "
"string value::"
msgstr "文字列値の開始の一致をテストするLIKE式を生成します::"

#: of sqlalchemy.schema.Column.startswith:13
msgid ""
"Since the operator uses ``LIKE``, wildcard characters ``\"%\"`` and "
"``\"_\"`` that are present inside the <other> expression will behave like"
" wildcards as well.   For literal string values, the "
":paramref:`.ColumnOperators.startswith.autoescape` flag may be set to "
"``True`` to apply escaping to occurences of these characters within the "
"string value so that they match as themselves and not as wildcard "
"characters.  Alternatively, the "
":paramref:`.ColumnOperators.startswith.escape` parameter will establish a"
" given character as an escape character which can be of use when the "
"target expression is not a literal string."
msgstr "演算子は `` LIKE``を使用するので、演算子の中にはワイルドカード文字 `` \ &quot;％\&quot; ``と `` \ &quot;_ \&quot; `` <other>式はワイルドカードのようにも動作します。リテラル文字列の場合、：paramref： `.ColumnOperators.startswith.autoescape`フラグを` `True``に設定して、文字列値内のこれらの文字のエスケープを適用し、ワイルドカード文字ではなく自分自身として一致させることができます。代わりに、：paramref： `.ColumnOperators.startswith.escape`パラメータは、ターゲット式がリテラル文字列でない場合に使用できるエスケープ文字として、指定された文字を確立します。"

#: of sqlalchemy.schema.Column.startswith:24
msgid ""
"expression to be compared.   This is usually a plain string value, but "
"can also be an arbitrary SQL expression.  LIKE wildcard characters ``%`` "
"and ``_`` are not escaped by default unless the "
":paramref:`.ColumnOperators.startswith.autoescape` flag is set to True."
msgstr "比較される式。これは普通は普通の文字列値ですが、任意のSQL式でもかまいません。 LIKEワイルドカード文字 ``％ ``と `` _``は、：paramref： `.ColumnOperators.startswith.autoescape`フラグがTrueに設定されていない限り、デフォルトではエスケープされません。"

#: of sqlalchemy.schema.Column.startswith:30
msgid ""
"boolean; when True, establishes an escape character within the LIKE "
"expression, then applies it to all occurrences of ``\"%\"``, ``\"_\"`` "
"and the escape character itself within the comparison value, which is "
"assumed to be a literal string and not a SQL expression.  An expression "
"such as::    somecolumn.startswith(\"foo%bar\", autoescape=True)  Will "
"render as::    somecolumn LIKE :param || '%' ESCAPE '/'  With the value "
"of :param as ``\"foo/%bar\"``.  .. versionadded:: 1.2  .. "
"versionchanged:: 1.2.0 The   "
":paramref:`.ColumnOperators.startswith.autoescape` parameter is    now a "
"simple boolean rather than a character; the escape    character itself is"
" also escaped, and defaults to a forwards    slash, which itself can be "
"customized using the    :paramref:`.ColumnOperators.startswith.escape` "
"parameter."
msgstr "ブール値。 Trueの場合、LIKE式内にエスケープ文字を設定し、それを比較値の中の `` \ &quot;％\&quot; ``、 `` \ &quot;_ \&quot; ``とエスケープ文字自体のすべての出現に適用します。 SQL式ではなくリテラル文字列とみなされます。 :: somecolumn.startswith（\ &quot;foo％bar \&quot;、autoescape = True）のような式は、:: somecolumnのようにレンダリングします：param || &#39;％&#39; ESCAPE &#39;/&#39;：paramの値を `` \ &quot;foo /％bar \&quot; ``として指定します。 .. versionadded :: 1.2 .. versionchanged :: 1.2.0：paramref： `.ColumnOperators.startswith.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.startswith.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.startswith:48
msgid ""
"The :paramref:`.ColumnOperators.startswith.autoescape` parameter is  now "
"a simple boolean rather than a character; the escape  character itself is"
" also escaped, and defaults to a forwards  slash, which itself can be "
"customized using the  :paramref:`.ColumnOperators.startswith.escape` "
"parameter."
msgstr "：paramref： `.ColumnOperators.startswith.autoescape`パラメータは、文字ではなく単純なブール値になりました。エスケープ文字自体もエスケープされ、デフォルトは前方スラッシュになります。それ自体は：paramref： `.ColumnOperators.startswith.escape`パラメータを使用してカスタマイズできます。"

#: of sqlalchemy.schema.Column.startswith:55
msgid ""
"a character which when given will render with the ``ESCAPE`` keyword to "
"establish that character as the escape character.  This character can "
"then be placed preceding occurrences of ``%`` and ``_`` to allow them to "
"act as themselves and not wildcard characters.  An expression such as::"
"    somecolumn.startswith(\"foo/%bar\", escape=\"^\")  Will render as::"
"    somecolumn LIKE :param || '%' ESCAPE '^'  The parameter may also be "
"combined with :paramref:`.ColumnOperators.startswith.autoescape`::    "
"somecolumn.startswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)  "
"Where above, the given literal parameter will be converted to "
"``\"foo^%bar^^bat\"`` before being passed to the database."
msgstr "その文字をエスケープ文字として確立するために `` ESCAPE``キーワードでレンダリングされる文字を返します。この文字を ``％ ``と `` _``の前に置くことで、ワイルドカード文字ではなく自分自身として動作させることができます。 :: somecolumn.startswith（\ &quot;foo /％bar \&quot;、escape = \ &quot;^ \&quot;）のような式は、:: somecolumn LIKE：param ||をレンダリングします。 &#39;％&#39; ESCAPE &#39;^&#39;パラメタ： `.ColumnOperators.startswith.autoescape` :: somecolumn.startswith（\&quot; foo％bar ^ bat \ &quot;、escape = \&quot; ^ \ &quot;、autoescape = True）上記の場合、与えられたリテラルパラメータはデータベースに渡される前に `` \ &quot;foo ^％bar ^^ bat \&quot; ``に変換されます。"

#: of sqlalchemy.schema.Column.startswith:69
msgid ""
"The parameter may also be combined with "
":paramref:`.ColumnOperators.startswith.autoescape`::"
msgstr "パラメータは以下のものと組み合わせることもできます：paramref： `.ColumnOperators.startswith.autoescape` ::"

#: of sqlalchemy.schema.MetaData:1
msgid ""
"A collection of :class:`.Table` objects and their associated schema "
"constructs."
msgstr "：class： `.Table`オブジェクトとそれに関連するスキーマ構造体のコレクションです。"

#: of sqlalchemy.schema.MetaData:4
msgid ""
"Holds a collection of :class:`.Table` objects as well as an optional "
"binding to an :class:`.Engine` or :class:`.Connection`.  If bound, the "
":class:`.Table` objects in the collection and their columns may "
"participate in implicit SQL execution."
msgstr "class： `.Table`オブジェクトのコレクションと、：class：` .Engine`または：class： `.Connection`へのオプションのバインディングを保持します。バインドされている場合は、コレクション内の：class： `.Table`オブジェクトとその列が暗黙的なSQL実行に参加することがあります。"

#: of sqlalchemy.schema.MetaData:10
msgid ""
"The :class:`.Table` objects themselves are stored in the "
":attr:`.MetaData.tables` dictionary."
msgstr "：class： `.Table`オブジェクト自体は、：attr：` .MetaData.tables`辞書に格納されています。"

#: of sqlalchemy.schema.MetaData:13
msgid ""
":class:`.MetaData` is a thread-safe object for read operations. "
"Construction of new tables within a single :class:`.MetaData` object, "
"either explicitly or via reflection, may not be completely thread-safe."
msgstr "：class： `.MetaData`は読み込み操作のためのスレッドセーフなオブジェクトです。単一の：class： `.MetaData`オブジェクト内に新しいテーブルを作成することは、明示的にまたはリフレクションによって完全にスレッドセーフではないかもしれません。"

#: of sqlalchemy.schema.MetaData:19 sqlalchemy.schema.Table:19
msgid ":ref:`metadata_describing` - Introduction to database metadata"
msgstr "：ref： `metadata_describing`  - データベースメタデータの概要"

#: of sqlalchemy.schema.MetaData.append_ddl_listener:1
msgid "Append a DDL event listener to this ``MetaData``."
msgstr "この `` MetaData``にDDLイベントリスナーを追加してください。"

#: of sqlalchemy.schema.MetaData.append_ddl_listener:3
#: sqlalchemy.schema.Table.append_ddl_listener:3
msgid "See :class:`.DDLEvents`."
msgstr "参照：class： `.DDLEvents`。"

#: of sqlalchemy.schema.MetaData.bind:1
msgid ""
"An :class:`.Engine` or :class:`.Connection` to which this "
":class:`.MetaData` is bound."
msgstr "An：class： `.Engine`または：class：` .Connection`これは：class： `.MetaData`がバインドされています。"

#: of sqlalchemy.schema.MetaData.bind:4
msgid ""
"Typically, a :class:`.Engine` is assigned to this attribute so that "
"\"implicit execution\" may be used, or alternatively as a means of "
"providing engine binding information to an ORM :class:`.Session` object::"
msgstr "通常、a：class： `.Engine`がこの属性に割り当てられ、\&quot;暗黙の実行\ &quot;が使用されるか、ORMにエンジンバインディング情報を提供する手段として使用されます：class：` .Session`オブジェクト::"

#: of sqlalchemy.schema.MetaData.bind:14
msgid ":ref:`dbengine_implicit` - background on \"bound metadata\""
msgstr "：ref： `dbengine_implicit`  - バインドされたメタデータの背景\"

#: of sqlalchemy.schema.MetaData.clear:1
msgid "Clear all Table objects from this MetaData."
msgstr "このメタデータからすべてのテーブルオブジェクトを消去します。"

#: of sqlalchemy.schema.MetaData.create_all:1
msgid "Create all tables stored in this metadata."
msgstr "このメタデータに格納されているすべてのテーブルを作成します。"

#: of sqlalchemy.schema.MetaData.create_all:3
msgid ""
"Conditional by default, will not attempt to recreate tables already "
"present in the target database."
msgstr "条件付きでは、ターゲット・データベースにすでに存在する表を再作成しようとしません。"

#: of sqlalchemy.schema.MetaData.create_all:6
#: sqlalchemy.schema.MetaData.drop_all:6 sqlalchemy.schema.MetaData.reflect:9
msgid ""
"A :class:`.Connectable` used to access the database; if None, uses the "
"existing bind on this ``MetaData``, if any."
msgstr "A：クラス：データベースへのアクセスに `.Connectable`が使われました。もしNoneならば、この `` MetaData``上の既存のバインドを使用します。"

#: of sqlalchemy.schema.MetaData.create_all:11
#: sqlalchemy.schema.MetaData.drop_all:11
msgid ""
"Optional list of ``Table`` objects, which is a subset of the total tables"
" in the ``MetaData`` (others are ignored)."
msgstr "`` Table``オブジェクトのオプションのリストです。これは `` MetaData``の中の総テーブルのサブセットです（他は無視されます）。"

#: of sqlalchemy.schema.MetaData.create_all:15
msgid ""
"Defaults to True, don't issue CREATEs for tables already present in the "
"target database."
msgstr "既定値はTrueです。ターゲットデータベースに既に存在するテーブルに対してCREATEを発行しないでください。"

#: of sqlalchemy.schema.MetaData.drop_all:1
msgid "Drop all tables stored in this metadata."
msgstr "このメタデータに格納されているすべてのテーブルを削除します。"

#: of sqlalchemy.schema.MetaData.drop_all:3
msgid ""
"Conditional by default, will not attempt to drop tables not present in "
"the target database."
msgstr "デフォルトでは、条件付きでは、ターゲット・データベースに存在しない表を削除しようとしません。"

#: of sqlalchemy.schema.MetaData.drop_all:15
msgid ""
"Defaults to True, only issue DROPs for tables confirmed to be present in "
"the target database."
msgstr "既定値はTrueです。ターゲットデータベースに存在することが確認されたテーブルのDROPのみを発行します。"

#: of sqlalchemy.schema.MetaData.is_bound:1
msgid "True if this MetaData is bound to an Engine or Connection."
msgstr "このメタデータがエンジンまたは接続にバインドされている場合はtrue。"

#: of sqlalchemy.schema.MetaData.reflect:1
msgid "Load all available table definitions from the database."
msgstr "使用可能なすべてのテーブル定義をデータベースからロードします。"

#: of sqlalchemy.schema.MetaData.reflect:3
msgid ""
"Automatically creates ``Table`` entries in this ``MetaData`` for any "
"table available in the database but not yet present in the ``MetaData``."
"  May be called multiple times to pick up tables recently added to the "
"database, however no special action is taken if a table in this "
"``MetaData`` no longer exists in the database."
msgstr "`` MetaData``にデータベースには存在しますが、まだ `` MetaData``には存在しないテーブルのために、この `` MetaData``に `` Table``エントリを自動的に作成します。最近データベースに追加されたテーブルを拾うために複数回呼び出されるかもしれませんが、この `` MetaData``のテーブルがデータベースに存在しなくなった場合は特別な処置はとられません。"

#: of sqlalchemy.schema.MetaData.reflect:13
msgid ""
"Optional, query and reflect tables from an alterate schema. If None, the "
"schema associated with this :class:`.MetaData` is used, if any."
msgstr "オプションで、変更スキーマの表を照会および反映します。 Noneの場合、この：class： `.MetaData`に関連付けられたスキーマがあればそれが使用されます。"

#: of sqlalchemy.schema.MetaData.reflect:18
msgid "If True, also reflect views."
msgstr "Trueの場合は、ビューも反映されます。"

#: of sqlalchemy.schema.MetaData.reflect:21
msgid ""
"Optional.  Load only a sub-set of available named tables.  May be "
"specified as a sequence of names or a callable.  If a sequence of names "
"is provided, only those tables will be reflected.  An error is raised if "
"a table is requested but not available.  Named tables already present in "
"this ``MetaData`` are ignored.  If a callable is provided, it will be "
"used as a boolean predicate to filter the list of potential table names."
"  The callable is called with a table name and this ``MetaData`` instance"
" as positional arguments and should return a true value for any table to "
"reflect."
msgstr "オプション。使用可能な名前付きテーブルのサブセットのみをロードします。名前のシーケンスまたは呼び出し可能なものとして指定することができます。一連の名前が指定されている場合、それらのテーブルだけが反映されます。表が要求されたが使用できない場合は、エラーが発生します。この `` MetaData``に既に存在する名前付きテーブルは無視されます。呼び出し可能なものが提供されている場合は、ブール述語として使用され、潜在的なテーブル名のリストをフィルタリングします。呼び出し可能オブジェクトは、テーブル名とこの「MetaData」インスタンスを位置引数として呼び出され、どのテーブルにも反映させるために真の値を返さなければなりません。"

#: of sqlalchemy.schema.MetaData.reflect:22
msgid ""
"Optional.  Load only a sub-set of available named tables.  May be "
"specified as a sequence of names or a callable."
msgstr "オプション。使用可能な名前付きテーブルのサブセットのみをロードします。名前のシーケンスまたは呼び出し可能なものとして指定することができます。"

#: of sqlalchemy.schema.MetaData.reflect:25
msgid ""
"If a sequence of names is provided, only those tables will be reflected."
"  An error is raised if a table is requested but not available.  Named "
"tables already present in this ``MetaData`` are ignored."
msgstr "一連の名前が指定されている場合、それらのテーブルだけが反映されます。表が要求されたが使用できない場合は、エラーが発生します。この `` MetaData``に既に存在する名前付きテーブルは無視されます。"

#: of sqlalchemy.schema.MetaData.reflect:30
msgid ""
"If a callable is provided, it will be used as a boolean predicate to "
"filter the list of potential table names.  The callable is called with a "
"table name and this ``MetaData`` instance as positional arguments and "
"should return a true value for any table to reflect."
msgstr "呼び出し可能なものが提供されている場合は、ブール述語として使用され、潜在的なテーブル名のリストをフィルタリングします。呼び出し可能オブジェクトは、テーブル名とこの「MetaData」インスタンスを位置引数として呼び出され、どのテーブルにも反映させるために真の値を返さなければなりません。"

#: of sqlalchemy.schema.MetaData.reflect:35
msgid ""
"Passed along to each :class:`.Table` as "
":paramref:`.Table.extend_existing`.  .. versionadded:: 0.9.1"
msgstr "各クラスに渡されました：class： `.Table`：paramref：` .Table.extend_existing`。 .. versionadded :: 0.9.1"

#: of sqlalchemy.schema.MetaData.reflect:35
msgid ""
"Passed along to each :class:`.Table` as "
":paramref:`.Table.extend_existing`."
msgstr "各クラスに渡されました：class： `.Table`：paramref：` .Table.extend_existing`。"

#: of sqlalchemy.schema.MetaData.reflect:40
msgid ""
"Passed along to each :class:`.Table` as "
":paramref:`.Table.autoload_replace`.  .. versionadded:: 0.9.1"
msgstr "各クラスに渡されました：class： `.Table`：paramref：` .Table.autoload_replace`。 .. versionadded :: 0.9.1"

#: of sqlalchemy.schema.MetaData.reflect:40
msgid ""
"Passed along to each :class:`.Table` as "
":paramref:`.Table.autoload_replace`."
msgstr "各クラスに渡されました：class： `.Table`：paramref：` .Table.autoload_replace`。"

#: of sqlalchemy.schema.MetaData.reflect:45
msgid ""
"Additional keyword arguments not mentioned above are dialect specific, "
"and passed in the form ``<dialectname>_<argname>``.  See the "
"documentation regarding an individual dialect at :ref:`dialect_toplevel` "
"for detail on documented arguments.   .. versionadded:: 0.9.2 - Added"
"     :paramref:`.MetaData.reflect.**dialect_kwargs` to support     "
"dialect-level reflection options for all :class:`.Table`     objects "
"reflected."
msgstr "上記で言及されていない追加のキーワード引数は、方言固有のもので、 `` <dialectname> _ <argname> ``。ドキュメント化された引数の詳細は、ref： `dialect_toplevel`を参照してください。 versionadded :: 0.9.2  -  paramref： `.MetaData.reflect。** dialect_kwargs`：全ての：dialable-level反映オプションをサポートする：class：` .Table`オブジェクトが反映されました。"

#: of sqlalchemy.schema.MetaData.reflect:45
msgid ""
"Additional keyword arguments not mentioned above are dialect specific, "
"and passed in the form ``<dialectname>_<argname>``.  See the "
"documentation regarding an individual dialect at :ref:`dialect_toplevel` "
"for detail on documented arguments."
msgstr "上記で言及されていない追加のキーワード引数は、方言固有のもので、 `` <dialectname> _ <argname> ``。ドキュメント化された引数の詳細は、ref： `dialect_toplevel`を参照してください。"

#: of sqlalchemy.schema.MetaData.reflect:51
msgid ""
"- Added :paramref:`.MetaData.reflect.**dialect_kwargs` to support "
"dialect-level reflection options for all :class:`.Table` objects "
"reflected."
msgstr "- 追加された：paramref： `.MetaData.reflect。** dialect_kwargs`は全ての：dialable-level反映オプションをサポートする：class：` .Table`オブジェクトが反映されました。"

#: of sqlalchemy.schema.MetaData.remove:1
msgid "Remove the given Table object from this MetaData."
msgstr "このMetaDataから指定されたTableオブジェクトを削除します。"

#: of sqlalchemy.schema.MetaData.sorted_tables:1
msgid ""
"Returns a list of :class:`.Table` objects sorted in order of foreign key "
"dependency."
msgstr "外部キーの依存性の順にソートされた：class： `.Table`オブジェクトのリストを返します。"

#: of sqlalchemy.schema.MetaData.sorted_tables:4
msgid ""
"The sorting will place :class:`.Table` objects that have dependencies "
"first, before the dependencies themselves, representing the order in "
"which they can be created.   To get the order in which the tables would "
"be dropped, use the ``reversed()`` Python built-in."
msgstr "ソートには、依存関係の前に依存関係が最初にあるclass： `.Table`オブジェクトが作成されます。テーブルを削除する順序を取得するには、 `` reversed（） `` Python組み込み関数を使用します。"

#: of sqlalchemy.schema.MetaData.sorted_tables:11
msgid ""
"The :attr:`.sorted_tables` accessor cannot by itself accommodate "
"automatic resolution of dependency cycles between tables, which are "
"usually caused by mutually dependent foreign key constraints. To resolve "
"these cycles, either the :paramref:`.ForeignKeyConstraint.use_alter` "
"parameter may be appled to those constraints, or use the "
":func:`.schema.sort_tables_and_constraints` function which will break out"
" foreign key constraints involved in cycles separately."
msgstr "：attr： `.sorted_tables`アクセサは、テーブル間の依存関係サイクルの自動解決に対応することはできません。これは通常、相互に依存する外部キー制約によって引き起こされます。これらのサイクルを解決するには、：paramref： `.ForeignKeyConstraint.use_alter`パラメータをこれらの制約に適用するか、または：func：` .schema.sort_tables_and_constraints`関数を使用します。"

#: of sqlalchemy.schema.MetaData.sorted_tables:22
msgid ":func:`.schema.sort_tables`"
msgstr "：func： `.schema.sort_tables`"

#: of sqlalchemy.schema.MetaData.sorted_tables:24
msgid ":func:`.schema.sort_tables_and_constraints`"
msgstr "：func： `.schema.sort_tables_and_constraints`"

#: of sqlalchemy.schema.MetaData.sorted_tables:26
msgid ":attr:`.MetaData.tables`"
msgstr "：attr： `.MetaData.tables`"

#: of sqlalchemy.schema.MetaData.sorted_tables:28
msgid ":meth:`.Inspector.get_table_names`"
msgstr "：meth： `.Inspector.get_table_names`"

#: of sqlalchemy.schema.MetaData.sorted_tables:30
msgid ":meth:`.Inspector.get_sorted_table_and_fkc_names`"
msgstr "：meth： `.Inspector.get_sorted_table_and_fkc_names`"

#: of sqlalchemy.schema.MetaData.tables:1
msgid ""
"A dictionary of :class:`.Table` objects keyed to their name or \"table "
"key\"."
msgstr "class： `.Table`オブジェクトの辞書で、その名前や\&quot;テーブルキー\ &quot;に合わせています。"

#: of sqlalchemy.schema.MetaData.tables:3
msgid ""
"The exact key is that determined by the :attr:`.Table.key` attribute; for"
" a table with no :attr:`.Table.schema` attribute, this is the same as "
":attr:`.Table.name`.  For a table with a schema, it is typically of the "
"form ``schemaname.tablename``."
msgstr "正確なキーは、：attr： `.Table.key`属性で決まります。 no：attr： `.Table.schema`属性を持つテーブルの場合、attr：` .Table.name`と同じです。スキーマを持つテーブルの場合、通常は `` schemaname.tablename``の形式です。"

#: of sqlalchemy.schema.MetaData.tables:10
msgid ":attr:`.MetaData.sorted_tables`"
msgstr "：attr： `.MetaData.sorted_tables`"

#: of sqlalchemy.schema.SchemaItem:1
msgid "Base class for items that define a database schema."
msgstr "データベーススキーマを定義する項目の基本クラス。"

#: of sqlalchemy.schema.SchemaItem.get_children:1
msgid "used to allow SchemaVisitor access"
msgstr "SchemaVisitorへのアクセスを許可するために使用されます"

#: of sqlalchemy.schema.Table:1
msgid "Represent a table in a database."
msgstr "データベース内の表を表します。"

#: of sqlalchemy.schema.Table:10
msgid ""
"The :class:`.Table` object constructs a unique instance of itself based "
"on its name and optional schema name within the given :class:`.MetaData` "
"object. Calling the :class:`.Table` constructor with the same name and "
"same :class:`.MetaData` argument a second time will return the *same* "
":class:`.Table` object - in this way the :class:`.Table` constructor acts"
" as a registry function."
msgstr "：class： `.Table`オブジェクトは、指定された：class：` .MetaData`オブジェクト内の名前とオプションのスキーマ名に基づいて、独自のインスタンスを構築します。 ：class： `.Table`コンストラクタを同じ名前で同じ：class：` .MetaData`引数で呼び出すと、同じ*：class： `.Table`オブジェクトが返されます：このように：class：` .Table`コンストラクタはレジストリ関数として機能します。"

#: of sqlalchemy.schema.Table:21
msgid "Constructor arguments are as follows:"
msgstr "コンストラクタ引数は次のとおりです。"

#: of sqlalchemy.schema.Table:23
msgid ""
"The name of this table as represented in the database.  The table name, "
"along with the value of the ``schema`` parameter, forms a key which "
"uniquely identifies this :class:`.Table` within the owning "
":class:`.MetaData` collection. Additional calls to :class:`.Table` with "
"the same name, metadata, and schema name will return the same "
":class:`.Table` object.  Names which contain no upper case characters "
"will be treated as case insensitive names, and will not be quoted unless "
"they are a reserved word or contain special characters. A name with any "
"number of upper case characters is considered to be case sensitive, and "
"will be sent as quoted.  To enable unconditional quoting for the table "
"name, specify the flag ``quote=True`` to the constructor, or use the "
":class:`.quoted_name` construct to specify the name."
msgstr "データベースで表されるこのテーブルの名前。テーブル名と `` schema``パラメータの値は、owning：class： `.MetaData`コレクション内でclass：` .Table`を一意に識別するキーを形成します。同じ名前、メタデータ、およびスキーマ名を持つ：class： `.Table`への追加の呼び出しは、同じ：class：` .Table`オブジェクトを返します。大文字を含まない名前は、大文字小文字を区別しない名前として扱われ、予約語であるか特殊文字を含まない限り、引用符で囲まれません。任意の数の大文字を含む名前は大文字と小文字が区別され、引用符で送信されます。テーブル名の無条件引用を有効にするには、コンストラクタに対してフラグ `` quote = True``を指定するか、：class： `.quoted_name`構造体を使用して名前を指定します。"

#: of sqlalchemy.schema.Table:23
msgid "The name of this table as represented in the database."
msgstr "データベースで表されるこのテーブルの名前。"

#: of sqlalchemy.schema.Table:25
msgid ""
"The table name, along with the value of the ``schema`` parameter, forms a"
" key which uniquely identifies this :class:`.Table` within the owning "
":class:`.MetaData` collection. Additional calls to :class:`.Table` with "
"the same name, metadata, and schema name will return the same "
":class:`.Table` object."
msgstr "テーブル名と `` schema``パラメータの値は、owning：class： `.MetaData`コレクション内でclass：` .Table`を一意に識別するキーを形成します。同じ名前、メタデータ、およびスキーマ名を持つ：class： `.Table`への追加の呼び出しは、同じ：class：` .Table`オブジェクトを返します。"

#: of sqlalchemy.schema.Table:31
msgid ""
"Names which contain no upper case characters will be treated as case "
"insensitive names, and will not be quoted unless they are a reserved word"
" or contain special characters. A name with any number of upper case "
"characters is considered to be case sensitive, and will be sent as "
"quoted."
msgstr "大文字を含まない名前は、大文字小文字を区別しない名前として扱われ、予約語であるか特殊文字を含まない限り、引用符で囲まれません。任意の数の大文字を含む名前は大文字と小文字が区別され、引用符で送信されます。"

#: of sqlalchemy.schema.Table:37
msgid ""
"To enable unconditional quoting for the table name, specify the flag "
"``quote=True`` to the constructor, or use the :class:`.quoted_name` "
"construct to specify the name."
msgstr "テーブル名の無条件引用を有効にするには、コンストラクタに対してフラグ `` quote = True``を指定するか、：class： `.quoted_name`構造体を使用して名前を指定します。"

#: of sqlalchemy.schema.Table:41
msgid ""
"a :class:`.MetaData` object which will contain this table.  The metadata "
"is used as a point of association of this table with other tables which "
"are referenced via foreign key.  It also may be used to associate this "
"table with a particular :class:`.Connectable`."
msgstr "a：class：このテーブルを含む `.MetaData`オブジェクトです。メタデータは、外部キーを介して参照される他のテーブルとこのテーブルの関連付けのポイントとして使用されます。また、このテーブルを特定の：class： `.Connectable`に関連付けるために使用することもできます。"

#: of sqlalchemy.schema.Table:47
msgid ""
"Additional positional arguments are used primarily to add the list of "
":class:`.Column` objects contained within this table. Similar to the "
"style of a CREATE TABLE statement, other :class:`.SchemaItem` constructs "
"may be added here, including :class:`.PrimaryKeyConstraint`, and "
":class:`.ForeignKeyConstraint`."
msgstr "追加の位置引数は、主にこのテーブルに含まれる：class： `.Column`オブジェクトのリストを追加するために使用されます。 CREATE TABLE文のスタイルと同様に、class： `.PrimaryKeyConstraint`や：class：` .ForeignKeyConstraint`を含むclass： `.SchemaItem`の構造体をここに追加することができます。"

#: of sqlalchemy.schema.Table:53
msgid ""
"Defaults to False, unless :paramref:`.Table.autoload_with` is set in "
"which case it defaults to True; :class:`.Column` objects for this table "
"should be reflected from the database, possibly augmenting or replacing "
"existing :class:`.Column` objects that were explicitly specified.  .. "
"versionchanged:: 1.0.0 setting the :paramref:`.Table.autoload_with`    "
"parameter implies that :paramref:`.Table.autoload` will default    to "
"True.  .. seealso::      :ref:`metadata_reflection_toplevel`"
msgstr "paramref： `.Table.autoload_with`が設定されている場合を除き、デフォルトはTrueです。 ：このテーブルの `class：` .Column`オブジェクトは、明示的に指定されたexisting：class： `.Column`オブジェクトを増やしたり、置き換えたりするためにデータベースから反映されるべきです。 .. versionchanged :: 1.0.0：paramref： `.Table.autoload_with`パラメータを設定すると、それは：paramref：` .Table.autoload`がデフォルトでTrueになります。 .. seealso ::：ref： `metadata_reflection_toplevel`"

#: of sqlalchemy.schema.Table:53
msgid ""
"Defaults to False, unless :paramref:`.Table.autoload_with` is set in "
"which case it defaults to True; :class:`.Column` objects for this table "
"should be reflected from the database, possibly augmenting or replacing "
"existing :class:`.Column` objects that were explicitly specified."
msgstr "paramref： `.Table.autoload_with`が設定されている場合を除き、デフォルトはTrueです。 ：このテーブルの `class：` .Column`オブジェクトは、明示的に指定されたexisting：class： `.Column`オブジェクトを増やしたり、置き換えたりするためにデータベースから反映されるべきです。"

#: of sqlalchemy.schema.Table:59
msgid ""
"setting the :paramref:`.Table.autoload_with` parameter implies that "
":paramref:`.Table.autoload` will default to True."
msgstr "：paramref： `.Table.autoload_with`パラメータを設定すると、それは：paramref：` .Table.autoload`はデフォルトでTrueになります。"

#: of sqlalchemy.schema.Table:65
msgid ":ref:`metadata_reflection_toplevel`"
msgstr "：ref： `metadata_reflection_toplevel`"

#: of sqlalchemy.schema.Table:67
msgid ""
"Defaults to ``True``; when using :paramref:`.Table.autoload` in "
"conjunction with :paramref:`.Table.extend_existing`, indicates that "
":class:`.Column` objects present in the already-existing :class:`.Table` "
"object should be replaced with columns of the same name retrieved from "
"the autoload process.   When ``False``, columns already present under "
"existing names will be omitted from the reflection process.  Note that "
"this setting does not impact :class:`.Column` objects specified "
"programmatically within the call to :class:`.Table` that also is "
"autoloading; those :class:`.Column` objects will always replace existing "
"columns of the same name when :paramref:`.Table.extend_existing` is "
"``True``.  .. versionadded:: 0.7.5  .. seealso::      "
":paramref:`.Table.autoload`      :paramref:`.Table.extend_existing`"
msgstr "デフォルトは `` True``です。 paramref： `.Table.autoload`を：paramref：` .Table.extend_existing`と組み合わせて使用​​すると、：class： `.Column`オブジェクトがすでに存在する：class：` .Table`オブジェクトが存在する必要があります。自動ロードプロセスから取得した同じ名前の列に置き換えられました。 `` False``の場合、既存の名前の下に既に存在する列は反映プロセスから除外されます。この設定は影響を与えないことに注意してください：class： `.Column`オブジェクトは、プログラム内で：class：` .Table`の呼び出しの中で指定されています。それらは：class： `.Column`オブジェクトは、paramref：` .Table.extend_existing`が `` True``の場合、常に同じ名前の既存のカラムを置き換えます。 .. versionadded :: 0.7.5 .. seealso :: paramref： `.Table.autoload`：paramref：` .Table.extend_existing`"

#: of sqlalchemy.schema.Table:67
msgid ""
"Defaults to ``True``; when using :paramref:`.Table.autoload` in "
"conjunction with :paramref:`.Table.extend_existing`, indicates that "
":class:`.Column` objects present in the already-existing :class:`.Table` "
"object should be replaced with columns of the same name retrieved from "
"the autoload process.   When ``False``, columns already present under "
"existing names will be omitted from the reflection process."
msgstr "デフォルトは `` True``です。 paramref： `.Table.autoload`を：paramref：` .Table.extend_existing`と組み合わせて使用​​すると、：class： `.Column`オブジェクトがすでに存在する：class：` .Table`オブジェクトが存在する必要があります。自動ロードプロセスから取得した同じ名前の列に置き換えられました。 `` False``の場合、既存の名前の下に既に存在する列は反映プロセスから除外されます。"

#: of sqlalchemy.schema.Table:76
msgid ""
"Note that this setting does not impact :class:`.Column` objects specified"
" programmatically within the call to :class:`.Table` that also is "
"autoloading; those :class:`.Column` objects will always replace existing "
"columns of the same name when :paramref:`.Table.extend_existing` is "
"``True``."
msgstr "この設定は影響を与えないことに注意してください：class： `.Column`オブジェクトは、プログラム内で：class：` .Table`の呼び出しの中で指定されています。それらは：class： `.Column`オブジェクトは、paramref：` .Table.extend_existing`が `` True``の場合、常に同じ名前の既存のカラムを置き換えます。"

#: of sqlalchemy.schema.Table:86 sqlalchemy.schema.Table:100
#: sqlalchemy.schema.Table:147
msgid ":paramref:`.Table.autoload`"
msgstr "：paramref： `.Table.autoload`"

#: of sqlalchemy.schema.Table:88 sqlalchemy.schema.Table:191
msgid ":paramref:`.Table.extend_existing`"
msgstr "：paramref： `.Table.extend_existing`"

#: of sqlalchemy.schema.Table:90
msgid ""
"An :class:`.Engine` or :class:`.Connection` object with which this "
":class:`.Table` object will be reflected; when set to a non-None value, "
"it implies that :paramref:`.Table.autoload` is ``True``.   If left unset,"
" but :paramref:`.Table.autoload` is explicitly set to ``True``, an "
"autoload operation will attempt to proceed by locating an "
":class:`.Engine` or :class:`.Connection` bound to the underlying "
":class:`.MetaData` object.  .. seealso::      :paramref:`.Table.autoload`"
msgstr "これは：class： `.Table`オブジェクトが反映されるクラス：` .Engine`または：class： `.Connection`オブジェクトです。 non-None値に設定されている場合、それは：paramref： `.Table.autoload`が` `True``であることを意味します。設定されていない場合、：paramref： `.Table.autoload`が明示的に` `True``に設定されている場合、自動ロード操作は：class：` .Engine`または：class： `.Connection` bound underlying：class： `.MetaData`オブジェクトに追加します。 .. seealso :: paramref： `.Table.autoload`"

#: of sqlalchemy.schema.Table:90
msgid ""
"An :class:`.Engine` or :class:`.Connection` object with which this "
":class:`.Table` object will be reflected; when set to a non-None value, "
"it implies that :paramref:`.Table.autoload` is ``True``.   If left unset,"
" but :paramref:`.Table.autoload` is explicitly set to ``True``, an "
"autoload operation will attempt to proceed by locating an "
":class:`.Engine` or :class:`.Connection` bound to the underlying "
":class:`.MetaData` object."
msgstr "これは：class： `.Table`オブジェクトが反映されるクラス：` .Engine`または：class： `.Connection`オブジェクトです。 non-None値に設定されている場合、それは：paramref： `.Table.autoload`が` `True``であることを意味します。設定されていない場合、：paramref： `.Table.autoload`が明示的に` `True``に設定されている場合、自動ロード操作は：class：` .Engine`または：class： `.Connection` bound underlying：class： `.MetaData`オブジェクトに追加します。"

#: of sqlalchemy.schema.Table:102
msgid ""
"When ``True``, indicates that if this :class:`.Table` is already present "
"in the given :class:`.MetaData`, apply further arguments within the "
"constructor to the existing :class:`.Table`.  If "
":paramref:`.Table.extend_existing` or :paramref:`.Table.keep_existing` "
"are not set, and the given name of the new :class:`.Table` refers to a "
":class:`.Table` that is already present in the target :class:`.MetaData` "
"collection, and this :class:`.Table` specifies additional columns or "
"other constructs or flags that modify the table's state, an error is "
"raised.  The purpose of these two mutually-exclusive flags is to specify "
"what action should be taken when a :class:`.Table` is specified that "
"matches an existing :class:`.Table`, yet specifies additional constructs."
"  :paramref:`.Table.extend_existing` will also work in conjunction with "
":paramref:`.Table.autoload` to run a new reflection operation against the"
" database, even if a :class:`.Table` of the same name is already present "
"in the target :class:`.MetaData`; newly reflected :class:`.Column` "
"objects and other options will be added into the state of the "
":class:`.Table`, potentially overwriting existing columns and options of "
"the same name.  .. versionchanged:: 0.7.4 "
":paramref:`.Table.extend_existing` will    invoke a new reflection "
"operation when combined with    :paramref:`.Table.autoload` set to True."
"  As is always the case with :paramref:`.Table.autoload`, "
":class:`.Column` objects can be specified in the same :class:`.Table` "
"constructor, which will take precedence.  Below, the existing table "
"``mytable`` will be augmented with :class:`.Column` objects both "
"reflected from the database, as well as the given :class:`.Column` named "
"\"y\"::      Table(\"mytable\", metadata,                 Column('y', "
"Integer),                 extend_existing=True,                 "
"autoload=True,                 autoload_with=engine             )  .. "
"seealso::      :paramref:`.Table.autoload`      "
":paramref:`.Table.autoload_replace`      :paramref:`.Table.keep_existing`"
msgstr "`` True``は、class： `.Table`がすでに与えられている：class：` .MetaData`に存在する場合、コンストラクタ内のさらなる引数を既存の：class： `.Table`に適用することを示します。 ：paramref： `.Table.extend_existing`または：paramref：` .Table.keep_existing`が設定されておらず、new：class： `.Table`の与えられた名前が：class：` .Table`を参照していればクラス： `.MetaData`コレクションにすでに存在しています：class：` .Table`は、テーブルの状態を変更する追加の列やその他の構造体やフラグを指定すると、エラーが発生します。これらの2つの相互に排他的なフラグの目的は：class： `.Table`が既存の：class：` .Table`にマッチするように指定されていて、追加の構文を指定しているときに取るべきアクションを指定することです。 ：paramref： `.Table.extend_existing`は：paramref：` .Table.autoload`と連動して、同じ名前の：class： `.Table`が既に存在していても、データベースに対して新しいリフレクション操作を実行します。ターゲット内に存在する：class： `.MetaData`;新たに反映された：class： `.Column`オブジェクトと他のオプションは：class：` .Table`の状態に追加され、同じ名前の既存のカラムとオプションを上書きする可能性があります。 versionchanged :: 0.7.4：paramref： `.Table.extend_existing`は：paramref：` .Table.autoload`がTrueに設定されていると、新しいリフレクション操作を呼び出します。常に：paramref： `.Table.autoload`の場合と同じように、：class：` .Column`オブジェクトは同じ：class： `.Table`コンストラクタで指定することができます。以下では、データベースから反映されたclass： `.Column`オブジェクトと、与えられた：class：` .Column`という名前の\ &quot;y \&quot; :: Table（ &quot; \ &quot;mytable \&quot;、メタデータ、列（ &#39;y&#39;、整数）、extend_existing = True、autoload = True、autoload_with = engine）.. seealso :: paramref： `.Table.autoload`：paramref：` .Table。 autoload_replace`：paramref： `.Table.keep_existing`"

#: of sqlalchemy.schema.Table:102
msgid ""
"When ``True``, indicates that if this :class:`.Table` is already present "
"in the given :class:`.MetaData`, apply further arguments within the "
"constructor to the existing :class:`.Table`."
msgstr "`` True``は、class： `.Table`がすでに与えられている：class：` .MetaData`に存在する場合、コンストラクタ内のさらなる引数を既存の：class： `.Table`に適用することを示します。"

#: of sqlalchemy.schema.Table:107 sqlalchemy.schema.Table:178
msgid ""
"If :paramref:`.Table.extend_existing` or :paramref:`.Table.keep_existing`"
" are not set, and the given name of the new :class:`.Table` refers to a "
":class:`.Table` that is already present in the target :class:`.MetaData` "
"collection, and this :class:`.Table` specifies additional columns or "
"other constructs or flags that modify the table's state, an error is "
"raised.  The purpose of these two mutually-exclusive flags is to specify "
"what action should be taken when a :class:`.Table` is specified that "
"matches an existing :class:`.Table`, yet specifies additional constructs."
msgstr "：paramref： `.Table.extend_existing`または：paramref：` .Table.keep_existing`が設定されておらず、new：class： `.Table`の与えられた名前が：class：` .Table`を参照していればクラス： `.MetaData`コレクションにすでに存在しています：class：` .Table`は、テーブルの状態を変更する追加の列やその他の構造体やフラグを指定すると、エラーが発生します。これらの2つの相互に排他的なフラグの目的は：class： `.Table`が既存の：class：` .Table`にマッチするように指定されていて、追加の構文を指定しているときに取るべきアクションを指定することです。"

#: of sqlalchemy.schema.Table:118
msgid ""
":paramref:`.Table.extend_existing` will also work in conjunction with "
":paramref:`.Table.autoload` to run a new reflection operation against the"
" database, even if a :class:`.Table` of the same name is already present "
"in the target :class:`.MetaData`; newly reflected :class:`.Column` "
"objects and other options will be added into the state of the "
":class:`.Table`, potentially overwriting existing columns and options of "
"the same name."
msgstr "：paramref： `.Table.extend_existing`は：paramref：` .Table.autoload`と連動して、同じ名前の：class： `.Table`が既に存在していても、データベースに対して新しいリフレクション操作を実行します。ターゲット内に存在する：class： `.MetaData`;新たに反映された：class： `.Column`オブジェクトと他のオプションは：class：` .Table`の状態に追加され、同じ名前の既存のカラムとオプションを上書きする可能性があります。"

#: of sqlalchemy.schema.Table:127
msgid ""
":paramref:`.Table.extend_existing` will invoke a new reflection operation"
" when combined with :paramref:`.Table.autoload` set to True."
msgstr "：paramref： `.Table.extend_existing`は：paramref：` .Table.autoload`がTrueに設定されていると、新しいリフレクション操作を呼び出します。"

#: of sqlalchemy.schema.Table:131
msgid ""
"As is always the case with :paramref:`.Table.autoload`, :class:`.Column` "
"objects can be specified in the same :class:`.Table` constructor, which "
"will take precedence.  Below, the existing table ``mytable`` will be "
"augmented with :class:`.Column` objects both reflected from the database,"
" as well as the given :class:`.Column` named \"y\"::"
msgstr "常に：paramref： `.Table.autoload`の場合と同じように、：class：` .Column`オブジェクトは同じ：class： `.Table`コンストラクタで指定することができます。以下では、既存のテーブル `` mytable``は、データベースから反映されたclass： `.Column`オブジェクトと、指定された：class：` .Column`という名前の\ &quot;y \&quot; ::で補完されます。"

#: of sqlalchemy.schema.Table:149
msgid ":paramref:`.Table.autoload_replace`"
msgstr "：paramref： `.Table.autoload_replace`"

#: of sqlalchemy.schema.Table:151
msgid ":paramref:`.Table.keep_existing`"
msgstr "：paramref： `.Table.keep_existing`"

#: of sqlalchemy.schema.Table:154
msgid ""
"True by default - indicates that RETURNING can be used by default to "
"fetch newly inserted primary key values, for backends which support this."
"  Note that create_engine() also provides an implicit_returning flag."
msgstr "デフォルトでTrue  - これをサポートするバックエンドに対して、新しく挿入された主キー値をフェッチするためにRETURNINGをデフォルトで使用できることを示します。 create_engine（）は、暗黙の戻りフラグも提供することに注意してください。"

#: of sqlalchemy.schema.Table:159
msgid ""
"A list of strings indicating a subset of columns to be loaded via the "
"``autoload`` operation; table columns who aren't present in this list "
"will not be represented on the resulting ``Table`` object. Defaults to "
"``None`` which indicates all columns should be reflected."
msgstr "`` autoload``演算によってロードされる列のサブセットを示す文字列のリスト。このリストにない表の列は、結果として得られる `` Table``オブジェクトには表現されません。デフォルトは全ての列が反映されるべきであることを示す `` None``です。"

#: of sqlalchemy.schema.Table:165
msgid ""
"Optional data dictionary which will be populated into the "
":attr:`.SchemaItem.info` attribute of this object."
msgstr "このオブジェクトの：attr： `.SchemaItem.info`属性に取り込まれるオプションのデータ辞書です。"

#: of sqlalchemy.schema.Table:168
msgid ""
"When ``True``, indicates that if this Table is already present in the "
"given :class:`.MetaData`, ignore further arguments within the constructor"
" to the existing :class:`.Table`, and return the :class:`.Table` object "
"as originally created. This is to allow a function that wishes to define "
"a new :class:`.Table` on first call, but on subsequent calls will return "
"the same :class:`.Table`, without any of the declarations (particularly "
"constraints) being applied a second time.  If "
":paramref:`.Table.extend_existing` or :paramref:`.Table.keep_existing` "
"are not set, and the given name of the new :class:`.Table` refers to a "
":class:`.Table` that is already present in the target :class:`.MetaData` "
"collection, and this :class:`.Table` specifies additional columns or "
"other constructs or flags that modify the table's state, an error is "
"raised.  The purpose of these two mutually-exclusive flags is to specify "
"what action should be taken when a :class:`.Table` is specified that "
"matches an existing :class:`.Table`, yet specifies additional constructs."
"  .. seealso::      :paramref:`.Table.extend_existing`"
msgstr "`` True``は、このテーブルが与えられた：class： `.MetaData`にすでに存在する場合、コンストラクタ内の既存の：class：` .Table`へのさらなる引数を無視し、：class： ` .Table`オブジェクトを作成します。これは最初の呼び出しで新しい：class： `.Table`を定義したいが、それ以降の呼び出しでは、宣言（特に制約）が適用されずに同じ：class：` .Table`を返します。もう一度。 ：paramref： `.Table.extend_existing`または：paramref：` .Table.keep_existing`が設定されておらず、new：class： `.Table`の与えられた名前が：class：` .Table`を参照していればクラス： `.MetaData`コレクションにすでに存在しています：class：` .Table`は、テーブルの状態を変更する追加の列やその他の構造体やフラグを指定すると、エラーが発生します。これらの2つの相互に排他的なフラグの目的は：class： `.Table`が既存の：class：` .Table`にマッチするように指定されていて、追加の構文を指定しているときに取るべきアクションを指定することです。 .. seealso :: paramref： `.Table.extend_existing`"

#: of sqlalchemy.schema.Table:168
msgid ""
"When ``True``, indicates that if this Table is already present in the "
"given :class:`.MetaData`, ignore further arguments within the constructor"
" to the existing :class:`.Table`, and return the :class:`.Table` object "
"as originally created. This is to allow a function that wishes to define "
"a new :class:`.Table` on first call, but on subsequent calls will return "
"the same :class:`.Table`, without any of the declarations (particularly "
"constraints) being applied a second time."
msgstr "`` True``は、このテーブルが与えられた：class： `.MetaData`にすでに存在する場合、コンストラクタ内の既存の：class：` .Table`へのさらなる引数を無視し、：class： ` .Table`オブジェクトを作成します。これは最初の呼び出しで新しい：class： `.Table`を定義したいが、それ以降の呼び出しでは、宣言（特に制約）が適用されずに同じ：class：` .Table`を返します。もう一度。"

#: of sqlalchemy.schema.Table:193
msgid ""
"A list of tuples of the form ``(<eventname>, <fn>)`` which will be passed"
" to :func:`.event.listen` upon construction. This alternate hook to "
":func:`.event.listen` allows the establishment of a listener function "
"specific to this :class:`.Table` before the \"autoload\" process begins."
"  Particularly useful for the :meth:`.DDLEvents.column_reflect` event::"
"      def listen_for_reflect(table, column_info):         \"handle the "
"column reflection event\"         # ...      t = Table(         "
"'sometable',         autoload=True,         listeners=[             "
"('column_reflect', listen_for_reflect)         ])"
msgstr "`` `のタプルのリスト（ <eventname> 、 <fn> ） ``は、構築時に：func： `.event.listen`に渡されます。 ：func： `.event.listen`へのこの代替フックは、\&quot; autoload \ &quot;プロセスが始まる前にこの：class：` .Table`に特有のリスナー関数の設定を可能にします。特に、：meth： `.DDLEvents.column_reflect`イベントのために便利です:: def listen_for_reflect（table、column_info）：列リフレクションイベントを処理します\&quot;＃... t = Table（ &#39;sometable&#39;、autoload = True、リスナー= [（ &#39;column_reflect&#39;、listen_for_reflect）]）"

#: of sqlalchemy.schema.Table:193
msgid ""
"A list of tuples of the form ``(<eventname>, <fn>)`` which will be passed"
" to :func:`.event.listen` upon construction. This alternate hook to "
":func:`.event.listen` allows the establishment of a listener function "
"specific to this :class:`.Table` before the \"autoload\" process begins."
"  Particularly useful for the :meth:`.DDLEvents.column_reflect` event::"
msgstr "`` `のタプルのリスト（ <eventname> 、 <fn> ） ``は、構築時に：func： `.event.listen`に渡されます。 ：func： `.event.listen`へのこの代替フックは、\&quot; autoload \ &quot;プロセスが始まる前にこの：class：` .Table`に特有のリスナー関数の設定を可能にします。 ：meth： `.DDLEvents.column_reflect`イベントに特に便利です::"

#: of sqlalchemy.schema.Table:211
msgid ""
"When ``True``, indicates that this Table must already be present in the "
"given :class:`.MetaData` collection, else an exception is raised."
msgstr "`` True``は、このテーブルが指定されたクラス： `.MetaData`コレクションに既に存在していなければならないことを示します。そうでないと、例外が送出されます。"

#: of sqlalchemy.schema.Table:215
msgid ""
"A list of strings to insert after CREATE in the CREATE TABLE statement.  "
"They will be separated by spaces."
msgstr "CREATE TABLEステートメントでCREATEの後に挿入する文字列のリスト。スペースで区切られます。"

#: of sqlalchemy.schema.Table:219
msgid ""
"Force quoting of this table's name on or off, corresponding to ``True`` "
"or ``False``.  When left at its default of ``None``, the column "
"identifier will be quoted according to whether the name is case sensitive"
" (identifiers with at least one upper case character are treated as case "
"sensitive), or if it's a reserved word.  This flag is only needed to "
"force quoting of a reserved word which is not known by the SQLAlchemy "
"dialect."
msgstr "`` True``または `` False``に対応して、このテーブルの名前をオンまたはオフで強制的に引用します。デフォルトの `` None``のままにすると、名前が大文字と小文字を区別するかどうか（少なくとも大文字の大文字と小文字が区別される識別子が大文字と小文字に区別されます）、または予約語の場合に列識別子が引用されます。このフラグは、SQLAlchemy方言では知られていない予約語の引用を強制するためにのみ必要です。"

#: of sqlalchemy.schema.Table:227
msgid "same as 'quote' but applies to the schema identifier."
msgstr "&#39;quote&#39;と同じですが、スキーマ識別子に適用されます。"

#: of sqlalchemy.schema.Table:229
msgid ""
"The schema name for this table, which is required if the table resides in"
" a schema other than the default selected schema for the engine's "
"database connection.  Defaults to ``None``.  If the owning "
":class:`.MetaData` of this :class:`.Table` specifies its own "
":paramref:`.MetaData.schema` parameter, then that schema name will be "
"applied to this :class:`.Table` if the schema parameter here is set to "
"``None``.  To set a blank schema name on a :class:`.Table` that would "
"otherwise use the schema set on the owning :class:`.MetaData`, specify "
"the special symbol :attr:`.BLANK_SCHEMA`.  .. versionadded:: 1.0.14  "
"Added the :attr:`.BLANK_SCHEMA` symbol to    allow a :class:`.Table` to "
"have a blank schema name even when the    parent :class:`.MetaData` "
"specifies :paramref:`.MetaData.schema`.  The quoting rules for the schema"
" name are the same as those for the ``name`` parameter, in that quoting "
"is applied for reserved words or case-sensitive names; to enable "
"unconditional quoting for the schema name, specify the flag "
"``quote_schema=True`` to the constructor, or use the "
":class:`.quoted_name` construct to specify the name."
msgstr "このテーブルのスキーマ名。テーブルが、エンジンのデータベース接続のデフォルトで選択されたスキーマ以外のスキーマに存在する場合に必要です。デフォルトは `` None``です。この：class： `.Table`の所有：class：` .MetaData`が独自の：paramref： `.MetaData.schema`パラメータを指定すると、そのスキーマ名がclass：` .Table`に適用されますifスキーマパラメータは `` None``に設定されています。空白のスキーマ名を：class： `.Table`に設定するには、owning：class：` .MetaData`でスキーマセットを使用する場合は、特殊記号：attr： `.BLANK_SCHEMA`を指定します。 .. versionadded :: 1.0.14 parent：class： `.MetaData`が指定している場合でも：class：` .Table`が空のスキーマ名を持つことを可能にする：attr： `.BLANK_SCHEMA`シンボルを追加しました：paramref：` .MetaData.schema`。予約語または大文字小文字を区別する名前にクォートが適用されるという点で、スキーマ名の引用規則は `` name``パラメータの引用規則と同じです。スキーマ名の無条件引用を有効にするには、フラグ `` quote_schema = True``をコンストラクタに指定するか、：class： `.quoted_name`構造体を使用して名前を指定します。"

#: of sqlalchemy.schema.Table:229
msgid ""
"The schema name for this table, which is required if the table resides in"
" a schema other than the default selected schema for the engine's "
"database connection.  Defaults to ``None``."
msgstr "このテーブルのスキーマ名。テーブルが、エンジンのデータベース接続のデフォルトで選択されたスキーマ以外のスキーマに存在する場合に必要です。デフォルトは `` None``です。"

#: of sqlalchemy.schema.Table:233
msgid ""
"If the owning :class:`.MetaData` of this :class:`.Table` specifies its "
"own :paramref:`.MetaData.schema` parameter, then that schema name will be"
" applied to this :class:`.Table` if the schema parameter here is set to "
"``None``.  To set a blank schema name on a :class:`.Table` that would "
"otherwise use the schema set on the owning :class:`.MetaData`, specify "
"the special symbol :attr:`.BLANK_SCHEMA`."
msgstr "この：class： `.Table`の所有：class：` .MetaData`が独自の：paramref： `.MetaData.schema`パラメータを指定すると、そのスキーマ名がclass：` .Table`に適用されますifスキーマパラメータは `` None``に設定されています。空白のスキーマ名を：class： `.Table`に設定するには、owning：class：` .MetaData`でスキーマセットを使用する場合は、特殊記号：attr： `.BLANK_SCHEMA`を指定します。"

#: of sqlalchemy.schema.Table:240
msgid ""
"Added the :attr:`.BLANK_SCHEMA` symbol to allow a :class:`.Table` to have"
" a blank schema name even when the parent :class:`.MetaData` specifies "
":paramref:`.MetaData.schema`."
msgstr "クラス： `.MetaData`が：paramref：` .MetaData.schema`を指定していても：class： `.Table`に空のスキーマ名を持たせるための：attr：` .BLANK_SCHEMA`シンボルを追加しました。"

#: of sqlalchemy.schema.Table:244
msgid ""
"The quoting rules for the schema name are the same as those for the "
"``name`` parameter, in that quoting is applied for reserved words or "
"case-sensitive names; to enable unconditional quoting for the schema "
"name, specify the flag ``quote_schema=True`` to the constructor, or use "
"the :class:`.quoted_name` construct to specify the name."
msgstr "予約語または大文字小文字を区別する名前にクォートが適用されるという点で、スキーマ名の引用規則は `` name``パラメータの引用規則と同じです。スキーマ名の無条件引用を有効にするには、フラグ `` quote_schema = True``をコンストラクタに指定するか、：class： `.quoted_name`構造体を使用して名前を指定します。"

#: of sqlalchemy.schema.Table:251
msgid "Deprecated.  Use :paramref:`.Table.extend_existing`."
msgstr "推奨されていません。使用：paramref： `.Table.extend_existing`。"

#: of sqlalchemy.schema.Table:253
msgid ""
"Optional string that will render an SQL comment on table creation.  .. "
"versionadded:: 1.2 Added the :paramref:`.Table.comment` parameter    to "
":class:`.Table`."
msgstr "テーブル作成時にSQLコメントを表示するオプションの文字列。 .. versionadded :: 1.2：paramref： `.Table.comment`パラメータを：class：` .Table`に追加しました。"

#: of sqlalchemy.schema.Table:253
msgid "Optional string that will render an SQL comment on table creation."
msgstr "テーブル作成時にSQLコメントを表示するオプションの文字列。"

#: of sqlalchemy.schema.Table:256
msgid "Added the :paramref:`.Table.comment` parameter to :class:`.Table`."
msgstr "：paramref： `.Table.comment`パラメータを：class：` .Table`に追加しました。"

#: of sqlalchemy.schema.Table:259
msgid ""
"Additional keyword arguments not mentioned above are dialect specific, "
"and passed in the form ``<dialectname>_<argname>``. See the documentation"
" regarding an individual dialect at :ref:`dialect_toplevel` for detail on"
" documented arguments."
msgstr "上記で言及されていない追加のキーワード引数は、方言固有のもので、 `` <dialectname> _ <argname> ``。ドキュメント化された引数の詳細は、ref： `dialect_toplevel`を参照してください。"

#: of sqlalchemy.schema.Table.add_is_dependent_on:1
msgid "Add a 'dependency' for this Table."
msgstr "この表に「依存関係」を追加してください。"

#: of sqlalchemy.schema.Table.add_is_dependent_on:3
msgid ""
"This is another Table object which must be created first before this one "
"can, or dropped after this one."
msgstr "これは、このオブジェクトの前に最初に作成する必要がある別のTableオブジェクトです。"

#: of sqlalchemy.schema.Table.add_is_dependent_on:6
msgid ""
"Usually, dependencies between tables are determined via ForeignKey "
"objects.   However, for other situations that create dependencies outside"
" of foreign keys (rules, inheriting), this method can manually establish "
"such a link."
msgstr "通常、テーブル間の依存関係はForeignKeyオブジェクトを介して決定されます。ただし、外部キー（ルール、継承）以外の依存関係を作成するその他の状況では、このメソッドは手動でそのようなリンクを確立できます。"

#: of sqlalchemy.schema.Table.alias:1
msgid "return an alias of this :class:`.FromClause`."
msgstr "this：class： `.FromClause`のエイリアスを返します。"

#: of sqlalchemy.schema.Table.alias:3
msgid "This is shorthand for calling::"
msgstr "これは、呼び出しの略語です::"

#: of sqlalchemy.schema.Table.alias:8
msgid "See :func:`~.expression.alias` for details."
msgstr "詳細はfunc： `〜.expression.alias`を参照してください。"

#: of sqlalchemy.schema.Table.append_column:1
msgid "Append a :class:`~.schema.Column` to this :class:`~.schema.Table`."
msgstr "これに：class： `〜.schema.Column`を追加します：class：`〜.schema.Table`。"

#: of sqlalchemy.schema.Table.append_column:3
msgid ""
"The \"key\" of the newly added :class:`~.schema.Column`, i.e. the value "
"of its ``.key`` attribute, will then be available in the ``.c`` "
"collection of this :class:`~.schema.Table`, and the column definition "
"will be included in any CREATE TABLE, SELECT, UPDATE, etc. statements "
"generated from this :class:`~.schema.Table` construct."
msgstr "新しく追加された：class： `〜.schema.Column`の` `key &#39;&#39;、つまり` `.key``属性の値は、この` `.c``コレクションで利用可能になります： class： `〜.schema.Table`であり、カラム定義はこの：class：`〜.schema.Table`から生成されるCREATE TABLE、SELECT、UPDATEなどのステートメントに含まれます。"

#: of sqlalchemy.schema.Table.append_column:10
msgid ""
"Note that this does **not** change the definition of the table as it "
"exists within any underlying database, assuming that table has already "
"been created in the database.   Relational databases support the addition"
" of columns to existing tables using the SQL ALTER command, which would "
"need to be emitted for an already-existing table that doesn't contain the"
" newly added column."
msgstr "これは、テーブルが既にデータベースに作成されていると仮定して、基になるデータベース内に存在するテーブルの定義を変更するのではなく** **変更することに注意してください。リレーショナルデータベースでは、SQL ALTERコマンドを使用して既存のテーブルに列を追加することができます。このコマンドは、新しく追加された列を含まない既存のテーブルに対して発行する必要があります。"

#: of sqlalchemy.schema.Table.append_constraint:1
msgid "Append a :class:`~.schema.Constraint` to this :class:`~.schema.Table`."
msgstr "class： `〜.schema.Constraint`をclass：`〜.schema.Table`に追加します。"

#: of sqlalchemy.schema.Table.append_constraint:4
msgid ""
"This has the effect of the constraint being included in any future CREATE"
" TABLE statement, assuming specific DDL creation events have not been "
"associated with the given :class:`~.schema.Constraint` object."
msgstr "特定のDDL作成イベントが与えられた：class： `〜.schema.Constraint`オブジェクトに関連付けられていないと仮定すると、将来のCREATE TABLE文に制約が含まれるという影響があります。"

#: of sqlalchemy.schema.Table.append_constraint:9
msgid ""
"Note that this does **not** produce the constraint within the relational "
"database automatically, for a table that already exists in the database."
"   To add a constraint to an existing relational database table, the SQL "
"ALTER command must be used.  SQLAlchemy also provides the "
":class:`.AddConstraint` construct which can produce this SQL when invoked"
" as an executable clause."
msgstr "これは、データベースにすでに存在するテーブルに対して、自動的にリレーショナルデータベース内で制約を生成しないことに注意してください。既存のリレーショナルデータベーステーブルに制約を追加するには、SQLのALTERコマンドを使用する必要があります。 SQLAlchemyは：class： `.AddConstraint`構造体も提供します。この構造体は、実行可能節として呼び出されたときにこのSQLを生成できます。"

#: of sqlalchemy.schema.Table.append_ddl_listener:1
msgid "Append a DDL event listener to this ``Table``."
msgstr "この `` Table``にDDLイベントリスナーを追加してください。"

#: of sqlalchemy.schema.Table.argument_for:1
msgid "Add a new kind of dialect-specific keyword argument for this class."
msgstr "このクラスの新しい種類の方言固有のキーワード引数を追加します。"

#: of sqlalchemy.schema.Table.argument_for:9
msgid ""
"The :meth:`.DialectKWArgs.argument_for` method is a per-argument way "
"adding extra arguments to the :attr:`.DefaultDialect.construct_arguments`"
" dictionary. This dictionary provides a list of argument names accepted "
"by various schema-level constructs on behalf of a dialect."
msgstr "：meth： `.DialectKWArgs.argument_for`メソッドは：attr：` .DefaultDialect.construct_arguments`ディクショナリに余分な引数を追加する引数ごとの方法です。この辞書は、方言に代わってさまざまなスキーマレベルの構造によって受け入れられる引数名のリストを提供します。"

#: of sqlalchemy.schema.Table.argument_for:15
msgid ""
"New dialects should typically specify this dictionary all at once as a "
"data member of the dialect class.  The use case for ad-hoc addition of "
"argument names is typically for end-user code that is also using a custom"
" compilation scheme which consumes the additional arguments."
msgstr "新しい方言は通常、この辞書を一度に方言クラスのデータメンバーとして指定する必要があります。引数名のアドホックな追加のユースケースは、通常、追加の引数を消費するカスタムコンパイルスキームも使用するエンドユーザーコード用です。"

#: of sqlalchemy.schema.Table.argument_for:20
msgid ""
"name of a dialect.  The dialect must be locatable, else a "
":class:`.NoSuchModuleError` is raised.   The dialect must also include an"
" existing :attr:`.DefaultDialect.construct_arguments` collection, "
"indicating that it participates in the keyword-argument validation and "
"default system, else :class:`.ArgumentError` is raised.  If the dialect "
"does not include this collection, then any keyword argument can be "
"specified on behalf of this dialect already.  All dialects packaged "
"within SQLAlchemy include this collection, however for third party "
"dialects, support may vary."
msgstr "方言の名前。方言はlocatableでなければなりません。さもなければ：class： `.NoSuchModuleError`が送出されます。ダイアレクトには、既存の：attr： `.DefaultDialect.construct_arguments`コレクションも含まれていなければなりません。これはキーワード引数の検証とデフォルトシステムに参加していることを示します。それ以外の場合は：class：` .ArgumentError`が送出されます。方言にこのコレクションが含まれていない場合は、既にこの方言の代わりにキーワード引数を指定できます。 SQLAlchemy内にパッケージ化されたすべての方言にはこのコレクションが含まれていますが、サードパーティの方言ではサポートが異なる場合があります。"

#: of sqlalchemy.schema.Table.argument_for:31
msgid "name of the parameter."
msgstr "パラメータの名前。"

#: of sqlalchemy.schema.Table.argument_for:33
msgid "default value of the parameter."
msgstr "パラメータのデフォルト値。"

#: of sqlalchemy.schema.Table.bind:1
msgid "Return the connectable associated with this Table."
msgstr "このテーブルに関連する接続可能なものを返します。"

#: of sqlalchemy.schema.Table.c:1
msgid "An alias for the :attr:`.columns` attribute."
msgstr "：attr： `.columns`属性の別名です。"

#: of sqlalchemy.schema.Table.columns:1
msgid ""
"A named-based collection of :class:`.ColumnElement` objects maintained by"
" this :class:`.FromClause`."
msgstr "this：class： `.FromClause`によってメンテナンスされる：class：` .ColumnElement`オブジェクトの名前ベースのコレクションです。"

#: of sqlalchemy.schema.Table.columns:4
msgid ""
"The :attr:`.columns`, or :attr:`.c` collection, is the gateway to the "
"construction of SQL expressions using table-bound or other selectable-"
"bound columns::"
msgstr "：attr： `.columns`または：attr：` .c`コレクションは、テーブルバインドされたカラムや他の選択可能なカラムを使用してSQL式を構築するためのゲートウェイです::"

#: of sqlalchemy.schema.Table.compare:1
msgid "Compare this ClauseElement to the given ClauseElement."
msgstr "このClauseElementと指定されたClauseElementを比較します。"

#: of sqlalchemy.schema.Table.compare:3
msgid ""
"Subclasses should override the default behavior, which is a straight "
"identity comparison."
msgstr "サブクラスはデフォルトの動作を上書きする必要があります。"

#: of sqlalchemy.schema.Table.compare:6
msgid ""
"\\**kw are arguments consumed by subclass compare() methods and may be "
"used to modify the criteria for comparison. (see :class:`.ColumnElement`)"
msgstr "\\ ** kwは、サブクラスのcompare（）メソッドによって消費される引数であり、比較の基準を変更するために使用されます。 （：class： `.ColumnElement`を参照してください）"

#: of sqlalchemy.schema.Table.correspond_on_equivalents:1
msgid ""
"Return corresponding_column for the given column, or if None search for a"
" match in the given dictionary."
msgstr "指定された列のcorresponding_columnを返します。または、Noneが指定された辞書の中で一致するものを検索した場合。"

#: of sqlalchemy.schema.Table.corresponding_column:1
msgid ""
"Given a :class:`.ColumnElement`, return the exported "
":class:`.ColumnElement` object from this :class:`.Selectable` which "
"corresponds to that original :class:`~sqlalchemy.schema.Column` via a "
"common ancestor column."
msgstr "与えられたa：class： `.ColumnElement`を返すと、共通の祖先を介して、この元：class：`〜sqlalchemy.schema.Column`に対応するthis：class： `.Selectable`からexported：class：` .ColumnElement`オブジェクトを返します。カラム。"

#: of sqlalchemy.schema.Table.corresponding_column:7
msgid "the target :class:`.ColumnElement` to be matched"
msgstr "ターゲット：クラス：一致する `.ColumnElement`"

#: of sqlalchemy.schema.Table.corresponding_column:9
msgid ""
"only return corresponding columns for the given :class:`.ColumnElement`, "
"if the given :class:`.ColumnElement` is actually present within a sub-"
"element of this :class:`.FromClause`.  Normally the column will match if "
"it merely shares a common ancestor with one of the exported columns of "
"this :class:`.FromClause`."
msgstr "指定された：class： `.ColumnElement`が実際には：class：` .FromClause`のサブ要素内に存在する場合にのみ、与えられた：class： `.ColumnElement`の対応する列を返します。通常、列は、class： `.FromClause`のエクスポートされた列のいずれかと共通の祖先を単に共有する場合に一致します。"

#: of sqlalchemy.schema.Table.count:1
msgid "return a SELECT COUNT generated against this :class:`.FromClause`."
msgstr "this：class： `.FromClause`に対して生成されたSELECT COUNTを返します。"

#: of sqlalchemy.schema.Table.count:4
msgid ""
"``FromClause.count()`` is deprecated. Counting rows requires that the "
"correct column expression and accommodations for joins, DISTINCT, etc. "
"must be made, otherwise results may not be what's expected. Please use an"
" appropriate ``func.count()`` expression directly."
msgstr "`` FromClause.count（） ``は非推奨です。行を数えるには、正しい列式と結合、DISTINCTなどの調整が必要です。そうでない場合は、結果が期待どおりにならないことがあります。適切な `` func.count（） ``式を直接使用してください。"

#: of sqlalchemy.schema.Table.count:6
msgid ""
"The function generates COUNT against the first column in the primary key "
"of the table, or against the first column in the table overall.   "
"Explicit use of ``func.count()`` should be preferred::"
msgstr "この関数は、表の主キーの最初の列、または表全体の最初の列に対してCOUNTを生成します。 `` func.count（） ``の明示的な使用が望ましいはずです::"

#: of sqlalchemy.schema.Table.count:18
msgid ":data:`.func`"
msgstr "：データ： `.func`"

#: of sqlalchemy.schema.Table.create:1
msgid ""
"Issue a ``CREATE`` statement for this :class:`.Table`, using the given "
":class:`.Connectable` for connectivity."
msgstr "接続のために与えられた：class： `.Connectable`を使って、このために` class： `.Table`の` `CREATE``文を発行してください。"

#: of sqlalchemy.schema.Table.create:7
msgid ":meth:`.MetaData.create_all`."
msgstr "：meth： `.MetaData.create_all`。"

#: of sqlalchemy.schema.Table.delete:1
msgid "Generate a :func:`.delete` construct against this :class:`.TableClause`."
msgstr "このために：func： `.delete`構造を生成します：class：` .TableClause`。"

#: of sqlalchemy.schema.Table.delete:8
msgid "See :func:`.delete` for argument and usage information."
msgstr "引数と使用法については、func： `.delete`を参照してください。"

#: of sqlalchemy.schema.Table.dialect_kwargs:1
#: sqlalchemy.schema.Table.dialect_options:1
msgid ""
"A collection of keyword arguments specified as dialect-specific options "
"to this construct."
msgstr "この構文に対してダイアレクト固有のオプションとして指定されたキーワード引数の集合。"

#: of sqlalchemy.schema.Table.dialect_kwargs:4
msgid ""
"The arguments are present here in their original ``<dialect>_<kwarg>`` "
"format.  Only arguments that were actually passed are included; unlike "
"the :attr:`.DialectKWArgs.dialect_options` collection, which contains all"
" options known by this dialect including defaults."
msgstr "これらの議論は、 <dialect> _ <kwarg> ``フォーマット。実際に渡された引数のみが含まれます。 ：attr： `.DialectKWArgs.dialect_options`コレクションと異なり、デフォルトを含むこの方言で知られているすべてのオプションが含まれています。"

#: of sqlalchemy.schema.Table.dialect_kwargs:9
msgid ""
"The collection is also writable; keys are accepted of the form "
"``<dialect>_<kwarg>`` where the value will be assembled into the list of "
"options."
msgstr "コレクションは書き込み可能です。キーは `` <dialect> _ <kwarg> ``は値がオプションのリストに集められる場所です。"

#: of sqlalchemy.schema.Table.dialect_kwargs:15
msgid "The :attr:`.DialectKWArgs.dialect_kwargs` collection is now writable."
msgstr "：attr： `.DialectKWArgs.dialect_kwargs`コレクションが書き込み可能になりました。"

#: of sqlalchemy.schema.Table.dialect_kwargs:20
msgid ":attr:`.DialectKWArgs.dialect_options` - nested dictionary form"
msgstr "：attr： `.DialectKWArgs.dialect_options`  - ネストされた辞書形式"

#: of sqlalchemy.schema.Table.dialect_options:4
msgid ""
"This is a two-level nested registry, keyed to ``<dialect_name>`` and "
"``<argument_name>``.  For example, the ``postgresql_where`` argument "
"would be locatable as::"
msgstr "これは2レベルのネストされたレジストリで、 `` <dialect_name> ``と `` <argument_name> ``。たとえば、 `` postgresql_where``引数は::"

#: of sqlalchemy.schema.Table.dialect_options:14
msgid ":attr:`.DialectKWArgs.dialect_kwargs` - flat dictionary form"
msgstr "：attr： `.DialectKWArgs.dialect_kwargs`  - フラット辞書形式"

#: of sqlalchemy.schema.Table.drop:1
msgid ""
"Issue a ``DROP`` statement for this :class:`.Table`, using the given "
":class:`.Connectable` for connectivity."
msgstr "接続のために与えられた：class： `.Connectable`を使って、このために` class： `.Table`の` `DROP``文を発行してください。"

#: of sqlalchemy.schema.Table.drop:7
msgid ":meth:`.MetaData.drop_all`."
msgstr "：meth： `.MetaData.drop_all`。"

#: of sqlalchemy.schema.Table.exists:1
msgid "Return True if this table exists."
msgstr "このテーブルが存在する場合はTrueを返します。"

#: of sqlalchemy.schema.Table.foreign_key_constraints:1
msgid ""
":class:`.ForeignKeyConstraint` objects referred to by this "
":class:`.Table`."
msgstr "：class： `.ForeignKeyConstraint`オブジェクトはこれによって参照されます：class：` .Table`。"

#: of sqlalchemy.schema.Table.foreign_key_constraints:4
msgid ""
"This list is produced from the collection of :class:`.ForeignKey` objects"
" currently associated."
msgstr "このリストは、現在関連付けられている：class： `.ForeignKey`オブジェクトのコレクションから生成されます。"

#: of sqlalchemy.schema.Table.foreign_keys:1
msgid ""
"Return the collection of ForeignKey objects which this FromClause "
"references."
msgstr "このFromClauseが参照するForeignKeyオブジェクトのコレクションを返します。"

#: of sqlalchemy.schema.Table.insert:1
msgid "Generate an :func:`.insert` construct against this :class:`.TableClause`."
msgstr "これに対して、：func： `.insert`構造を生成します：class：` .TableClause`。"

#: of sqlalchemy.schema.Table.insert:8
msgid "See :func:`.insert` for argument and usage information."
msgstr "引数と使用法については、func： `.insert`を参照してください。"

#: of sqlalchemy.schema.Table.is_derived_from:1
msgid "Return True if this FromClause is 'derived' from the given FromClause."
msgstr "このFromClauseが指定されたFromClauseから &#39;派生した&#39;場合はTrueを返します。"

#: of sqlalchemy.schema.Table.is_derived_from:4
msgid "An example would be an Alias of a Table is derived from that Table."
msgstr "例は、テーブルのエイリアスがそのテーブルから派生したものです。"

#: of sqlalchemy.schema.Table.join:1
msgid ""
"Return a :class:`.Join` from this :class:`.FromClause` to another "
":class:`FromClause`."
msgstr "class： `.Join`をthis：class：` .FromClause`から別のクラス：class： `FromClause`に返します。"

#: of sqlalchemy.schema.Table.join:12
msgid "would emit SQL along the lines of::"
msgstr "::の行に沿ってSQLを出します"

#: of sqlalchemy.schema.Table.join:17 sqlalchemy.schema.Table.outerjoin:19
msgid ""
"the right side of the join; this is any :class:`.FromClause` object such "
"as a :class:`.Table` object, and may also be a selectable-compatible "
"object such as an ORM-mapped class."
msgstr "結合の右側。これはa：class： `.Table`オブジェクトのようなclass：` .FromClause`オブジェクトであり、ORMでマップされたクラスのような選択可能な互換オブジェクトでもあります。"

#: of sqlalchemy.schema.Table.join:22 sqlalchemy.schema.Table.outerjoin:24
msgid ""
"a SQL expression representing the ON clause of the join.  If left at "
"``None``, :meth:`.FromClause.join` will attempt to join the two tables "
"based on a foreign key relationship."
msgstr "結合のON句を表すSQL式。 `` None``のままにした場合、：meth： `.FromClause.join`は、外部キーの関係に基づいて2つのテーブルを結合しようとします。"

#: of sqlalchemy.schema.Table.join:26
msgid "if True, render a LEFT OUTER JOIN, instead of JOIN."
msgstr "Trueの場合は、JOINの代わりにLEFT OUTER JOINをレンダリングします。"

#: of sqlalchemy.schema.Table.join:28
msgid ""
"if True, render a FULL OUTER JOIN, instead of LEFT OUTER JOIN.  Implies "
":paramref:`.FromClause.join.isouter`.  .. versionadded:: 1.1"
msgstr "Trueの場合、LEFT OUTER JOINの代わりにFULL OUTER JOINをレンダリングします。暗黙のうちに：paramref： `.FromClause.join.isouter`。 .. versionadded :: 1.1"

#: of sqlalchemy.schema.Table.join:28
msgid ""
"if True, render a FULL OUTER JOIN, instead of LEFT OUTER JOIN.  Implies "
":paramref:`.FromClause.join.isouter`."
msgstr "Trueの場合、LEFT OUTER JOINの代わりにFULL OUTER JOINをレンダリングします。暗黙のうちに：paramref： `.FromClause.join.isouter`。"

#: of sqlalchemy.schema.Table.join:35
msgid ":func:`.join` - standalone function"
msgstr "：func： `.join`  - スタンドアロン関数"

#: of sqlalchemy.schema.Table.join:37
msgid ":class:`.Join` - the type of object produced"
msgstr "：class： `.Join`  - 生成されるオブジェクトの型"

#: of sqlalchemy.schema.Table.key:1
msgid "Return the 'key' for this :class:`.Table`."
msgstr "このために &#39;key&#39;を返します：class： `.Table`。"

#: of sqlalchemy.schema.Table.key:3
msgid ""
"This value is used as the dictionary key within the "
":attr:`.MetaData.tables` collection.   It is typically the same as that "
"of :attr:`.Table.name` for a table with no :attr:`.Table.schema` set; "
"otherwise it is typically of the form ``schemaname.tablename``."
msgstr "この値は：attr： `.MetaData.tables`コレクション内の辞書キーとして使用されます。これは通常、no：attr： `.Table.schema`が設定されたテーブルに対して：attr：` .Table.name`と同じです。それ以外の場合は、通常は `` schemaname.tablename``の形式です。"

#: of sqlalchemy.schema.Table.kwargs:1
msgid "A synonym for :attr:`.DialectKWArgs.dialect_kwargs`."
msgstr "attr： `.DialectKWArgs.dialect_kwargs`の同義語です。"

#: of sqlalchemy.schema.Table.lateral:1
msgid "Return a LATERAL alias of this :class:`.FromClause`."
msgstr "this：class： `.FromClause`のLATERALエイリアスを返します。"

#: of sqlalchemy.schema.Table.lateral:3
msgid ""
"The return value is the :class:`.Lateral` construct also provided by the "
"top-level :func:`~.expression.lateral` function."
msgstr "戻り値は：class： `.Lateral`でもあり、これは最上位の：func：`〜.expression.lateral`関数によっても提供されます。"

#: of sqlalchemy.schema.Table.lateral:10
msgid ":ref:`lateral_selects` -  overview of usage."
msgstr "：ref： `lateral_selects`  - 使い方の概要。"

#: of sqlalchemy.schema.Table.outerjoin:1
msgid ""
"Return a :class:`.Join` from this :class:`.FromClause` to another "
":class:`FromClause`, with the \"isouter\" flag set to True."
msgstr "class： `.Join`をclass：` .FromClause`から別のクラス：class： `FromClause`に返し、\&quot; isouter \ &quot;フラグをTrueに設定します。"

#: of sqlalchemy.schema.Table.outerjoin:12
msgid "The above is equivalent to::"
msgstr "上記は::"

#: of sqlalchemy.schema.Table.outerjoin:28
msgid ""
"if True, render a FULL OUTER JOIN, instead of LEFT OUTER JOIN.  .. "
"versionadded:: 1.1"
msgstr "Trueの場合、LEFT OUTER JOINの代わりにFULL OUTER JOINをレンダリングします。 .. versionadded :: 1.1"

#: of sqlalchemy.schema.Table.outerjoin:28
msgid "if True, render a FULL OUTER JOIN, instead of LEFT OUTER JOIN."
msgstr "Trueの場合、LEFT OUTER JOINの代わりにFULL OUTER JOINをレンダリングします。"

#: of sqlalchemy.schema.Table.outerjoin:35
msgid ":meth:`.FromClause.join`"
msgstr "：meth： `.FromClause.join`"

#: of sqlalchemy.schema.Table.outerjoin:37
msgid ":class:`.Join`"
msgstr "：クラス： `.Join`"

#: of sqlalchemy.schema.Table.primary_key:1
msgid ""
"Return the collection of Column objects which comprise the primary key of"
" this FromClause."
msgstr "このFromClauseの主キーを構成するColumnオブジェクトのコレクションを返します。"

#: of sqlalchemy.schema.Table.quote_schema:1
msgid ""
"Return the value of the ``quote_schema`` flag passed to this "
":class:`.Table`."
msgstr "これに渡された `` quote_schema``フラグの値を返します：class： `.Table`。"

#: of sqlalchemy.schema.Table.quote_schema:4
msgid "Use ``table.schema.quote``"
msgstr "`` table.schema.quote``を使う"

#: of sqlalchemy.schema.Table.replace_selectable:1
msgid ""
"replace all occurrences of FromClause 'old' with the given Alias object, "
"returning a copy of this :class:`.FromClause`."
msgstr "FromCloseのすべてのオカレンスを指定されたAliasオブジェクトに置き換え、これをコピーします：class： `.FromClause`。"

#: of sqlalchemy.schema.Table.select:1
msgid "return a SELECT of this :class:`.FromClause`."
msgstr "これのSELECTを返します：class： `.FromClause`。"

#: of sqlalchemy.schema.Table.select:5
msgid ""
":func:`~.sql.expression.select` - general purpose method which allows for"
" arbitrary column lists."
msgstr "：func： `〜.sql.expression.select`  - 任意の列リストを可能にする汎用メソッド。"

#: of sqlalchemy.schema.Table.self_group:1
msgid "Apply a 'grouping' to this :class:`.ClauseElement`."
msgstr "これに &#39;grouping&#39;を適用します：class： `.ClauseElement`。"

#: of sqlalchemy.schema.Table.self_group:3
msgid ""
"This method is overridden by subclasses to return a \"grouping\" "
"construct, i.e. parenthesis.   In particular it's used by \"binary\" "
"expressions to provide a grouping around themselves when placed into a "
"larger expression, as well as by :func:`.select` constructs when placed "
"into the FROM clause of another :func:`.select`.  (Note that subqueries "
"should be normally created using the :meth:`.Select.alias` method, as "
"many platforms require nested SELECT statements to be named)."
msgstr "このメソッドはサブクラスによってオーバーライドされ、\ &quot;グループ化\&quot;構造体、つまり括弧を返します。特に、大規模な式に置かれたときには、自分自身の周りにグループ化を提供するために、\ &quot;バイナリ\&quot;式で使用されます。func： `.select`は、別のFROM句に配置されたときに構築されます。func：` .select `。 （サブクエリは、通常は：meth： `.Select.alias`メソッドを使用して作成する必要があります。これは、多くのプラットフォームでネストされたSELECT文の名前を付ける必要があるためです）。"

#: of sqlalchemy.schema.Table.self_group:13
msgid ""
"As expressions are composed together, the application of "
":meth:`self_group` is automatic - end-user code should never need to use "
"this method directly.  Note that SQLAlchemy's clause constructs take "
"operator precedence into account - so parenthesis might not be needed, "
"for example, in an expression like ``x OR (y AND z)`` - AND takes "
"precedence over OR."
msgstr "式が一緒に構成されるとき、：meth： `self_group`のアプリケーションは自動です - エンドユーザコードはこのメソッドを直接使う必要はありません。 SQLAlchemyの節構文は演算子の優先順位を考慮していることに注意してください。たとえば、 `` x OR（y AND z） ``のような式のようにかっこは必要ないかもしれません。"

#: of sqlalchemy.schema.Table.self_group:21
msgid ""
"The base :meth:`self_group` method of :class:`.ClauseElement` just "
"returns self."
msgstr "base：meth： `self_group`メソッドの：class：` .ClauseElement`はselfを返します。"

#: of sqlalchemy.schema.Table.tablesample:1
msgid "Return a TABLESAMPLE alias of this :class:`.FromClause`."
msgstr "this：class： `.FromClause`のTABLESAMPLEエイリアスを返します。"

#: of sqlalchemy.schema.Table.tablesample:3
msgid ""
"The return value is the :class:`.TableSample` construct also provided by "
"the top-level :func:`~.expression.tablesample` function."
msgstr "戻り値はトップレベルの：func： `〜.expression.tablesample`関数によっても提供される：class：` .TableSample`構文です。"

#: of sqlalchemy.schema.Table.tablesample:10
msgid ":func:`~.expression.tablesample` - usage guidelines and parameters"
msgstr "：func： `〜.expression.tablesample`  - 利用ガイドラインとパラメータ"

#: of sqlalchemy.schema.Table.tometadata:1
msgid ""
"Return a copy of this :class:`.Table` associated with a different "
":class:`.MetaData`."
msgstr "this：class： `.Table`のコピーを別の：class：` .MetaData`に関連付けて返します。"

#: of sqlalchemy.schema.Table.tometadata:13
msgid ""
"Target :class:`.MetaData` object, into which the new :class:`.Table` "
"object will be created."
msgstr "Target：class： `.MetaData`オブジェクトで、new：class：` .Table`オブジェクトが作成されます。"

#: of sqlalchemy.schema.Table.tometadata:16
msgid ""
"optional string name indicating the target schema. Defaults to the "
"special symbol :attr:`.RETAIN_SCHEMA` which indicates that no change to "
"the schema name should be made in the new :class:`.Table`.  If set to a "
"string name, the new :class:`.Table` will have this new name as the "
"``.schema``.  If set to ``None``, the schema will be set to that of the "
"schema set on the target :class:`.MetaData`, which is typically ``None`` "
"as well, unless set explicitly::     m2 = MetaData(schema='newschema')"
"     # user_copy_one will have \"newschema\" as the schema name    "
"user_copy_one = user.tometadata(m2, schema=None)     m3 = MetaData()  # "
"schema defaults to None     # user_copy_two will have None as the schema "
"name    user_copy_two = user.tometadata(m3, schema=None)"
msgstr "ターゲットスキーマを示すオプションの文字列名。デフォルトは特別な記号：attr： `.RETAIN_SCHEMA`です。これはnew：class：` .Table`でスキーマ名を変更する必要がないことを示します。文字列名に設定すると、new：class： `.Table`はこの新しい名前を` `.schema``として持ちます。 `` None``に設定されている場合、スキーマはtarget：class： `.MetaData`に設定されたスキーマのスキーマに設定されます。明示的に設定されていない限り、通常は` `None``です:: m2 = MetaData user_copy_one = user.tometadata（m2、schema = None）m3 = MetaData（）＃スキーマのデフォルトはNoneです＃user_copy_twoはスキーマとしてNoneを持ちます（スキーマ= &#39;newschema&#39;）＃user_copy_oneはスキーマ名として\ &quot;newschema \名前user_copy_two = user.tometadata（m3、schema = None）"

#: of sqlalchemy.schema.Table.tometadata:16
msgid ""
"optional string name indicating the target schema. Defaults to the "
"special symbol :attr:`.RETAIN_SCHEMA` which indicates that no change to "
"the schema name should be made in the new :class:`.Table`.  If set to a "
"string name, the new :class:`.Table` will have this new name as the "
"``.schema``.  If set to ``None``, the schema will be set to that of the "
"schema set on the target :class:`.MetaData`, which is typically ``None`` "
"as well, unless set explicitly::"
msgstr "ターゲットスキーマを示すオプションの文字列名。デフォルトは特別な記号：attr： `.RETAIN_SCHEMA`です。これはnew：class：` .Table`でスキーマ名を変更する必要がないことを示します。文字列名に設定すると、new：class： `.Table`はこの新しい名前を` `.schema``として持ちます。 `` None``に設定した場合、スキーマはtarget：class： `.MetaData`に設定されたスキーマのスキーマに設定されます。明示的に設定されていなければ、通常は` `None``です："

#: of sqlalchemy.schema.Table.tometadata:35
msgid ""
"optional callable which can be supplied in order to provide for the "
"schema name that should be assigned to the referenced table of a "
":class:`.ForeignKeyConstraint`. The callable accepts this parent "
":class:`.Table`, the target schema that we are changing to, the "
":class:`.ForeignKeyConstraint` object, and the existing \"target schema\""
" of that constraint.  The function should return the string schema name "
"that should be applied. E.g.::         def referred_schema_fn(table, "
"to_schema,                                        constraint, "
"referred_schema):            if referred_schema == 'base_tables':"
"                return referred_schema            else:                "
"return to_schema         new_table = table.tometadata(m2, "
"schema=\"alt_schema\",                                "
"referred_schema_fn=referred_schema_fn)  .. versionadded:: 0.9.2"
msgstr "クラス： `.ForeignKeyConstraint`の参照されるテーブルに割り当てられるべきスキーマ名を提供するために提供することができるオプションの呼び出し可能コードです。 callableは、この親：class： `.Table`、変更するターゲットスキーマ、：class：` .ForeignKeyConstraint`オブジェクト、およびその制約の既存の\ &quot;ターゲットスキーマ\&quot;を受け取ります。スキーマ名を適用する必要があります。例：def referenced_schema_fn（table、to_schema、constraint、referenced_schema）：referenced_schema == &#39;base_tables&#39;：return referenced_schema else：return to_schema new_table = table.tometadata（m2、schema = \ &quot;alt_schema \ &quot;、referenced_schema_fn = referenced_schema_fn）.. versionadded :: 0.9.2"

#: of sqlalchemy.schema.Table.tometadata:35
msgid ""
"optional callable which can be supplied in order to provide for the "
"schema name that should be assigned to the referenced table of a "
":class:`.ForeignKeyConstraint`. The callable accepts this parent "
":class:`.Table`, the target schema that we are changing to, the "
":class:`.ForeignKeyConstraint` object, and the existing \"target schema\""
" of that constraint.  The function should return the string schema name "
"that should be applied. E.g.::"
msgstr "クラス： `.ForeignKeyConstraint`の参照されるテーブルに割り当てられるべきスキーマ名を提供するために提供することができるオプションの呼び出し可能コードです。 callableは、この親：class： `.Table`、変更するターゲットスキーマ、：class：` .ForeignKeyConstraint`オブジェクト、およびその制約の既存の\ &quot;ターゲットスキーマ\&quot;を受け取ります。スキーマ名を適用する必要があります。"

#: of sqlalchemy.schema.Table.tometadata:57
msgid ""
"optional string name indicating the target table name. If not specified "
"or None, the table name is retained.  This allows a :class:`.Table` to be"
" copied to the same :class:`.MetaData` target with a new name.  .. "
"versionadded:: 1.0.0"
msgstr "ターゲットテーブル名を示すオプションの文字列名。指定されていなければ、テーブル名は保持されます。これにより、：class： `.Table`を同じ：class：` .MetaData`ターゲットに新しい名前でコピーすることができます。 .. versionadded :: 1.0.0"

#: of sqlalchemy.schema.Table.tometadata:57
msgid ""
"optional string name indicating the target table name. If not specified "
"or None, the table name is retained.  This allows a :class:`.Table` to be"
" copied to the same :class:`.MetaData` target with a new name."
msgstr "ターゲットテーブル名を示すオプションの文字列名。指定されていなければ、テーブル名は保持されます。これにより、：class： `.Table`を同じ：class：` .MetaData`ターゲットに新しい名前でコピーすることができます。"

#: of sqlalchemy.schema.Table.update:1
msgid "Generate an :func:`.update` construct against this :class:`.TableClause`."
msgstr "これに対して、：func： `.update`構文を生成します：class：` .TableClause`。"

#: of sqlalchemy.schema.Table.update:8
msgid "See :func:`.update` for argument and usage information."
msgstr "参照：func： `.update`引数と使用法については、"

#: of sqlalchemy.schema.ThreadLocalMetaData:1
msgid "A MetaData variant that presents a different ``bind`` in every thread."
msgstr "すべてのスレッドに異なる `` bind``を表示するMetaDataバリアントです。"

#: of sqlalchemy.schema.ThreadLocalMetaData:3
msgid ""
"Makes the ``bind`` property of the MetaData a thread-local value, "
"allowing this collection of tables to be bound to different ``Engine`` "
"implementations or connections in each thread."
msgstr "MetaDataの `` bind``プロパティをスレッドローカル値にして、このテーブルのコレクションを各スレッドの異なる `` Engine``実装や接続に束縛することができます。"

#: of sqlalchemy.schema.ThreadLocalMetaData:7
msgid ""
"The ThreadLocalMetaData starts off bound to None in each thread.  Binds "
"must be made explicitly by assigning to the ``bind`` property or using "
"``connect()``.  You can also re-bind dynamically multiple times per "
"thread, just like a regular ``MetaData``."
msgstr "ThreadLocalMetaDataは、各スレッドでNoneにバインドされています。バインドは `` bind``プロパティに代入するか、 `` connect（） ``を使って明示的に行わなければなりません。通常の `` MetaData``と同様に、スレッドごとに動的に複数回動的に再バインドすることもできます。"

#: of sqlalchemy.schema.ThreadLocalMetaData.bind:1
msgid "The bound Engine or Connection for this thread."
msgstr "このスレッドのバインドされたエンジンまたは接続。"

#: of sqlalchemy.schema.ThreadLocalMetaData.bind:3
msgid ""
"This property may be assigned an Engine or Connection, or assigned a "
"string or URL to automatically create a basic Engine for this bind with "
"``create_engine()``."
msgstr "このプロパティはEngineまたはConnectionに割り当てられるか、文字列またはURLを割り当てられて、 `` create_engine（） ``でこのバインドのための基本エンジンを自動的に作成します。"

#: of sqlalchemy.schema.ThreadLocalMetaData.dispose:1
msgid "Dispose all bound engines, in all thread contexts."
msgstr "すべてのスレッドコンテキストですべてのバインドされたエンジンを破棄します。"

#: of sqlalchemy.schema.ThreadLocalMetaData.is_bound:1
msgid "True if there is a bind for this thread."
msgstr "このスレッドのバインドがあれば真。"


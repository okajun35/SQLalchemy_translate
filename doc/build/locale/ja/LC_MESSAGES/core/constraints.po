# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../core/constraints.rst:8
msgid "Defining Constraints and Indexes"
msgstr "制約とインデックスの定義"

#: ../../core/constraints.rst:10
msgid ""
"This section will discuss SQL :term:`constraints` and indexes.  In "
"SQLAlchemy the key classes include :class:`.ForeignKeyConstraint` and "
":class:`.Index`."
msgstr "このセクションでは、SQL：term： `constraints`とインデックスについて説明します。 SQLAlchemyでは、キークラスにclass： `.ForeignKeyConstraint`と：class：` .Index`があります。"

#: ../../core/constraints.rst:16
msgid "Defining Foreign Keys"
msgstr "外部キーの定義"

#: ../../core/constraints.rst:18
msgid ""
"A *foreign key* in SQL is a table-level construct that constrains one or "
"more columns in that table to only allow values that are present in a "
"different set of columns, typically but not always located on a different"
" table. We call the columns which are constrained the *foreign key* "
"columns and the columns which they are constrained towards the "
"*referenced* columns. The referenced columns almost always define the "
"primary key for their owning table, though there are exceptions to this. "
"The foreign key is the \"joint\" that connects together pairs of rows "
"which have a relationship with each other, and SQLAlchemy assigns very "
"deep importance to this concept in virtually every area of its operation."
msgstr "SQLの*外部キー*は、表の1つ以上の列を制約して、異なる表の列に存在する値（通常は別の表にあるとは限りません）のみを許可する表レベル構成です。 *外部キー*列に制限されている列、および*参照されている列に制約されている列を呼び出します。参照される列は、ほとんどの場合、所有テーブルの主キーを定義しますが、これには例外があります。外部キーはお互いに関係のある行のペアを結ぶ\ &quot;ジョイント&quot;であり、SQLAlchemyは事実上すべての操作領域でこの概念を非常に重要視しています。"

#: ../../core/constraints.rst:29
msgid ""
"In SQLAlchemy as well as in DDL, foreign key constraints can be defined "
"as additional attributes within the table clause, or for single-column "
"foreign keys they may optionally be specified within the definition of a "
"single column. The single column foreign key is more common, and at the "
"column level is specified by constructing a "
":class:`~sqlalchemy.schema.ForeignKey` object as an argument to a "
":class:`~sqlalchemy.schema.Column` object::"
msgstr "SQLAlchemyとDDLでは、外部キー制約をtable句内の追加属性として定義することも、単一列外部キー用に単一列の定義内でオプションで指定することもできます。単一の列の外部キーがより一般的であり、：class： `〜sqlalchemy.schema.Column`オブジェクトへの引数として：class：`〜sqlalchemy.schema.ForeignKey`オブジェクトを構築することによって列レベルで指定されます::"

#: ../../core/constraints.rst:43
msgid ""
"Above, we define a new table ``user_preference`` for which each row must "
"contain a value in the ``user_id`` column that also exists in the "
"``user`` table's ``user_id`` column."
msgstr "上記では、新しいテーブル `` user_preference``を定義しています。このテーブルでは、 `` user_id``カラムの値も `` user``テーブルの `` user_id``カラムにも存在しなければなりません。"

#: ../../core/constraints.rst:47
msgid ""
"The argument to :class:`~sqlalchemy.schema.ForeignKey` is most commonly a"
" string of the form *<tablename>.<columnname>*, or for a table in a "
"remote schema or \"owner\" of the form "
"*<schemaname>.<tablename>.<columnname>*. It may also be an actual "
":class:`~sqlalchemy.schema.Column` object, which as we'll see later is "
"accessed from an existing :class:`~sqlalchemy.schema.Table` object via "
"its ``c`` collection::"
msgstr "：class： `〜sqlalchemy.schema.ForeignKey`の引数は、最も一般的には* <tablename> 。 <columnname> *、またはフォームのリモートスキーマまたは\ &quot;owner \&quot;の表の場合* <schemaname> 。 <tablename> 。 <columnname> *。これは実際の：class： `〜sqlalchemy.schema.Column`オブジェクトであってもよく、これについては後述するが、これは既存の：class：`〜sqlalchemy.schema.Table`オブジェクトから `` c``コレクション：："

#: ../../core/constraints.rst:56
msgid ""
"The advantage to using a string is that the in-python linkage between "
"``user`` and ``user_preference`` is resolved only when first needed, so "
"that table objects can be easily spread across multiple modules and "
"defined in any order."
msgstr "文字列を使用する利点は、 `` user``と `` user_preference``間のin-pythonリンケージが最初に必要なときにのみ解決されるため、テーブルオブジェクトを複数のモジュールに簡単に分散させ、任意の順序で定義できることです。"

#: ../../core/constraints.rst:60
msgid ""
"Foreign keys may also be defined at the table level, using the "
":class:`~sqlalchemy.schema.ForeignKeyConstraint` object. This object can "
"describe a single- or multi-column foreign key. A multi-column foreign "
"key is known as a *composite* foreign key, and almost always references a"
" table that has a composite primary key. Below we define a table "
"``invoice`` which has a composite primary key::"
msgstr "外部キーは：class： `〜sqlalchemy.schema.ForeignKeyConstraint`オブジェクトを使用してテーブルレベルで定義することもできます。このオブジェクトは、単一または複数列の外部キーを記述できます。複数列の外部キーは、*複合*外部キーと呼ばれ、ほとんどの場合複合主キーを持つテーブルを参照します。以下では、複合主キーを持つ表 &quot;請求書&quot;を定義します::"

#: ../../core/constraints.rst:73
msgid ""
"And then a table ``invoice_item`` with a composite foreign key "
"referencing ``invoice``::"
msgstr "そして `` invoice``を参照する複合外部キーを持つ `` invoice_item``テーブル::"

#: ../../core/constraints.rst:84
msgid ""
"It's important to note that the "
":class:`~sqlalchemy.schema.ForeignKeyConstraint` is the only way to "
"define a composite foreign key. While we could also have placed "
"individual :class:`~sqlalchemy.schema.ForeignKey` objects on both the "
"``invoice_item.invoice_id`` and ``invoice_item.ref_num`` columns, "
"SQLAlchemy would not be aware that these two values should be paired "
"together - it would be two individual foreign key constraints instead of "
"a single composite foreign key referencing two columns."
msgstr "：class： `〜sqlalchemy.schema.ForeignKeyConstraint`は複合外部キーを定義する唯一の方法であることに注意することが重要です。 `` invoice_item.invoice_id``と `` invoice_item.ref_num``カラムの両方にindividual：class： `〜sqlalchemy.schema.ForeignKey`オブジェクトを置くこともできますが、SQLAlchemyはこれら2つの値を2つの列を参照する1つの複合外部キーではなく、2つの個別の外部キー制約になります。"

#: ../../core/constraints.rst:96
msgid "Creating/Dropping Foreign Key Constraints via ALTER"
msgstr "ALTERを使用した外部キ​​ー制約の作成/削除"

#: ../../core/constraints.rst:98
msgid ""
"The behavior we've seen in tutorials and elsewhere involving foreign keys"
" with DDL illustrates that the constraints are typically rendered "
"\"inline\" within the CREATE TABLE statement, such as:"
msgstr "チュートリアルやDDLで外部キーを使用する他の場所で見られた動作は、次のように、制約が通常「インライン」でCREATE TABLEステートメント内にレンダリングされることを示しています。"

#: ../../core/constraints.rst:112
msgid ""
"The ``CONSTRAINT .. FOREIGN KEY`` directive is used to create the "
"constraint in an \"inline\" fashion within the CREATE TABLE definition."
"   The :meth:`.MetaData.create_all` and :meth:`.MetaData.drop_all` "
"methods do this by default, using a topological sort of all the "
":class:`.Table` objects involved such that tables are created and dropped"
" in order of their foreign key dependency (this sort is also available "
"via the :attr:`.MetaData.sorted_tables` accessor)."
msgstr "`` CONSTRAINT .. FOREIGN KEY``ディレクティブは、CREATE TABLE定義内の\ &quot;inline \&quot;形式で制約を作成するために使用されます。 ：meth： `.MetaData.create_all`メソッドと：meth：` .MetaData.drop_all`メソッドは、デフォルトで、テーブルが作成されてドロップされるような、class： `.Table`オブジェクトのトポロジカルな並べ替えを使用しますそれらの外部キー依存性の順序（この並べ替えは、：attr： `.MetaData.sorted_tables`アクセサでも利用できます）。"

#: ../../core/constraints.rst:120
msgid ""
"This approach can't work when two or more foreign key constraints are "
"involved in a \"dependency cycle\", where a set of tables are mutually "
"dependent on each other, assuming the backend enforces foreign keys "
"(always the case except on SQLite, MySQL/MyISAM).   The methods will "
"therefore break out constraints in such a cycle into separate ALTER "
"statements, on all backends other than SQLite which does not support most"
" forms of ALTER.  Given a schema like::"
msgstr "このアプローチは、バックエンドが外部キーを強制すると仮定して、テーブルのセットが相互に依存している\ &quot;依存サイクル\&quot;に2つ以上の外部キー制約が含まれている場合は機能しません（SQLite、 MySQL / MyISAM）。したがって、この方法では、このようなサイクルの制約を、ALTERのほとんどの形式をサポートしていないSQLite以外のすべてのバックエンドで、別々のALTER文に分割します。 ::のようなスキーマを与えられた"

#: ../../core/constraints.rst:147
msgid ""
"When we call upon :meth:`.MetaData.create_all` on a backend such as the "
"PostgreSQL backend, the cycle between these two tables is resolved and "
"the constraints are created separately:"
msgstr "PostgreSQLバックエンドなどのバックエンドで：meth： `.MetaData.create_all`を呼び出すと、これらの2つのテーブル間のサイクルが解決され、制約が別々に作成されます。"

#: ../../core/constraints.rst:173
msgid ""
"In order to emit DROP for these tables, the same logic applies, however "
"note here that in SQL, to emit DROP CONSTRAINT requires that the "
"constraint has a name.  In the case of the ``'node'`` table above, we "
"haven't named this constraint; the system will therefore attempt to emit "
"DROP for only those constraints that are named:"
msgstr "これらのテーブルに対してDROPを発行するには、同じロジックが適用されますが、SQLではDROP CONSTRAINTを発行するには制約に名前が必要であることに注意してください。上の `` &#39;node&#39;``の表の場合、この制約の名前は付けていません。したがって、システムは以下の名前の制約に対してのみDROPを発行しようとします。"

#: ../../core/constraints.rst:189
msgid ""
"In the case where the cycle cannot be resolved, such as if we hadn't "
"applied a name to either constraint here, we will receive the following "
"error::"
msgstr "ここでいずれかの制約に名前を適用しなかったなど、サイクルを解決できない場合は、次のエラーが発生します。"

#: ../../core/constraints.rst:198
msgid ""
"This error only applies to the DROP case as we can emit \"ADD "
"CONSTRAINT\" in the CREATE case without a name; the database typically "
"assigns one automatically."
msgstr "このエラーはDROPの場合にのみ適用されます。というのも、CREATEの場合、名前なしで\ &quot;ADD CONSTRAINT \&quot;を発行できるからです。データベースは通常、自動的に1つを割り当てます。"

#: ../../core/constraints.rst:202
msgid ""
"The :paramref:`.ForeignKeyConstraint.use_alter` and "
":paramref:`.ForeignKey.use_alter` keyword arguments can be used to "
"manually resolve dependency cycles.  We can add this flag only to the "
"``'element'`` table as follows::"
msgstr "：paramref： `.ForeignKeyConstraint.use_alter`と：paramref：` .ForeignKey.use_alter`キーワード引数は、依存関係サイクルを手動で解決するために使用できます。このフラグは次のように `` &#39;element&#39; ``テーブルにのみ追加できます::"

#: ../../core/constraints.rst:217
msgid ""
"in our CREATE DDL we will see the ALTER statement only for this "
"constraint, and not the other one:"
msgstr "CREATE DDLでは、この制約のALTER文だけが表示され、他のものは表示されません。"

#: ../../core/constraints.rst:241
msgid ""
":paramref:`.ForeignKeyConstraint.use_alter` and "
":paramref:`.ForeignKey.use_alter`, when used in conjunction with a drop "
"operation, will require that the constraint is named, else an error like "
"the following is generated::"
msgstr "：paramref： `.ForeignKeyConstraint.use_alter`と：paramref：` .ForeignKey.use_alter`は、ドロップ操作と組み合わせて使用​​する場合、制約に名前が必要です。そうでない場合、次のようなエラーが生成されます。"

#: ../../core/constraints.rst:249
msgid ""
"- The DDL system invoked by :meth:`.MetaData.create_all` and "
":meth:`.MetaData.drop_all` will now automatically resolve mutually "
"depdendent foreign keys between tables declared by "
":class:`.ForeignKeyConstraint` and :class:`.ForeignKey` objects, without "
"the need to explicitly set the "
":paramref:`.ForeignKeyConstraint.use_alter` flag."
msgstr "- ：meth： `.MetaData.create_all`と：meth：` .MetaData.drop_all`によって呼び出されるDDLシステムは、class： `.ForeignKeyConstraint`と：class：`で宣言されたテーブル間で互いに依存しない外部キーを自動的に解決するようになりました。 ForeignKey`オブジェクトを明示的に設定する必要はありません：paramref： `.ForeignKeyConstraint.use_alter`フラグ。"

#: ../../core/constraints.rst:257
msgid ""
"- The :paramref:`.ForeignKeyConstraint.use_alter` flag can be used with "
"an un-named constraint; only the DROP operation will emit a specific "
"error when actually called upon."
msgstr "- ：paramref： `.ForeignKeyConstraint.use_alter`フラグは、名前のない制約で使用できます。実際に呼び出されたときにDROP操作だけが特定のエラーを出します。"

#: ../../core/constraints.rst:263 of sqlalchemy.schema.conv:41
msgid ":ref:`constraint_naming_conventions`"
msgstr "：ref： `constraint_naming_conventions`"

#: ../../core/constraints.rst:265
msgid ":func:`.sort_tables_and_constraints`"
msgstr "：func： `.sort_tables_and_constraints`"

#: ../../core/constraints.rst:270
msgid "ON UPDATE and ON DELETE"
msgstr "ON UPDATEおよびON DELETE"

#: ../../core/constraints.rst:272
msgid ""
"Most databases support *cascading* of foreign key values, that is the "
"when a parent row is updated the new value is placed in child rows, or "
"when the parent row is deleted all corresponding child rows are set to "
"null or deleted. In data definition language these are specified using "
"phrases like \"ON UPDATE CASCADE\", \"ON DELETE CASCADE\", and \"ON "
"DELETE SET NULL\", corresponding to foreign key constraints. The phrase "
"after \"ON UPDATE\" or \"ON DELETE\" may also other allow other phrases "
"that are specific to the database in use. The "
":class:`~sqlalchemy.schema.ForeignKey` and "
":class:`~sqlalchemy.schema.ForeignKeyConstraint` objects support the "
"generation of this clause via the ``onupdate`` and ``ondelete`` keyword "
"arguments. The value is any string which will be output after the "
"appropriate \"ON UPDATE\" or \"ON DELETE\" phrase::"
msgstr "ほとんどのデータベースは、外部キー値のカスケード*をサポートしています。つまり、親行が更新されたときに新しい値が子行に配置されたとき、または親行が削除されたときに対応する子行がすべてNULLに設定されるか、データ定義言語では、\ &quot;ON UPDATE CASCADE \&quot;、\ &quot;ON DELETE CASCADE \&quot;、\ &quot;ON DELETE SET NULL \&quot;のようなフレーズを使用して指定されます。 \ &quot;ON UPDATE \&quot;または\ &quot;ON DELETE \&quot;の後のフレーズは、使用中のデータベースに固有の他のフレーズを許可することもあります。 ：class： `〜sqlalchemy.schema.ForeignKey`と：class：`〜sqlalchemy.schema.ForeignKeyConstraint`オブジェクトは、 `` onupdate``と `` ondelete``キーワード引数を使ってこの句の生成をサポートします。値は適切な\ &quot;ON UPDATE \&quot;または\ &quot;ON DELETE \&quot;の後に出力される任意の文字列です::"

#: ../../core/constraints.rst:303
msgid ""
"Note that these clauses require ``InnoDB`` tables when used with MySQL. "
"They may also not be supported on other databases."
msgstr "MySQLで使用する場合、これらの節には `` InnoDB``テーブルが必要です。また、他のデータベースではサポートされていない場合もあります。"

#: ../../core/constraints.rst:308
msgid "UNIQUE Constraint"
msgstr "ユニーク制約"

#: ../../core/constraints.rst:310
msgid ""
"Unique constraints can be created anonymously on a single column using "
"the ``unique`` keyword on :class:`~sqlalchemy.schema.Column`. Explicitly "
"named unique constraints and/or those with multiple columns are created "
"via the :class:`~sqlalchemy.schema.UniqueConstraint` table-level "
"construct."
msgstr "固有の制約は、class： `〜sqlalchemy.schema.Column`の` `unique``キーワードを使用して、単一の列に匿名で作成できます。明示的に指定された一意の制約や複数の列を持つものは、：class： `〜sqlalchemy.schema.UniqueConstraint`テーブルレベルの構造体によって作成されます。"

#: ../../core/constraints.rst:333
msgid "CHECK Constraint"
msgstr "CHECK制約"

#: ../../core/constraints.rst:335
msgid ""
"Check constraints can be named or unnamed and can be created at the "
"Column or Table level, using the "
":class:`~sqlalchemy.schema.CheckConstraint` construct. The text of the "
"check constraint is passed directly through to the database, so there is "
"limited \"database independent\" behavior. Column level check constraints"
" generally should only refer to the column to which they are placed, "
"while table level constraints can refer to any columns in the table."
msgstr "チェック制約は名前を付けることも名前を付けることもできず、：class： `〜sqlalchemy.schema.CheckConstraint`構造体を使用して、カラムまたはテーブルレベルで作成することができます。チェック制約のテキストはデータベースに直接渡されるため、「データベースに依存しない」動作は制限されています。列レベル・チェック制約は、一般に、それらが配置されている列のみを参照すべきですが、表レベル制約は表内の任意の列を参照できます。"

#: ../../core/constraints.rst:342
msgid ""
"Note that some databases do not actively support check constraints such "
"as MySQL."
msgstr "一部のデータベースはMySQLなどのチェック制約を積極的にサポートしていないことに注意してください。"

#: ../../core/constraints.rst:371
msgid "PRIMARY KEY Constraint"
msgstr "PRIMARY KEY制約"

#: ../../core/constraints.rst:373
msgid ""
"The primary key constraint of any :class:`.Table` object is implicitly "
"present, based on the :class:`.Column` objects that are marked with the "
":paramref:`.Column.primary_key` flag.   The "
":class:`.PrimaryKeyConstraint` object provides explicit access to this "
"constraint, which includes the option of being configured directly::"
msgstr "any：class： `.Table`オブジェクトの主キー制約は、：paramref：` .Column.primary_key`フラグでマークされた：class： `.Column`オブジェクトに基づいて暗黙的に存在します。 ：class： `.PrimaryKeyConstraint`オブジェクトは、この制約に明示的にアクセスします。これには、直接設定するオプションが含まれます::"

#: ../../core/constraints.rst:390
msgid ":class:`.PrimaryKeyConstraint` - detailed API documentation."
msgstr "：class： `.PrimaryKeyConstraint`  - 詳細なAPIドキュメント。"

#: ../../core/constraints.rst:393
msgid "Setting up Constraints when using the Declarative ORM Extension"
msgstr "Declarative ORM Extensionを使用する場合の制約の設定"

#: ../../core/constraints.rst:395
msgid ""
"The :class:`.Table` is the SQLAlchemy Core construct that allows one to "
"define table metadata, which among other things can be used by the "
"SQLAlchemy ORM as a target to map a class.  The :ref:`Declarative "
"<declarative_toplevel>` extension allows the :class:`.Table` object to be"
" created automatically, given the contents of the table primarily as a "
"mapping of :class:`.Column` objects."
msgstr "：class： `.Table`はSQLAlchemy Coreのコンストラクトで、テーブルのメタデータを定義することができます。SQLAlchemyのORMはクラスをマッピングするターゲットとして使用できます。 ：ref： `Declarative <declarative_toplevel> `拡張：は：class：` .Table`オブジェクトを自動的に作成することができます。テーブルの内容は、主に：class： `.Column`オブジェクトのマッピングとして与えられます。"

#: ../../core/constraints.rst:401
msgid ""
"To apply table-level constraint objects such as "
":class:`.ForeignKeyConstraint` to a table defined using Declarative, use "
"the ``__table_args__`` attribute, described at "
":ref:`declarative_table_args`."
msgstr "：class： `.ForeignKeyConstraint`のようなテーブルレベルの制約オブジェクトをDeclarativeで定義されたテーブルに適用するには、：ref：` declarative_table_args`で記述されている `` __table_args__``属性を使います。"

#: ../../core/constraints.rst:408
msgid "Configuring Constraint Naming Conventions"
msgstr "制約の命名規則の設定"

#: ../../core/constraints.rst:410
msgid ""
"Relational databases typically assign explicit names to all constraints "
"and indexes.  In the common case that a table is created using ``CREATE "
"TABLE`` where constraints such as CHECK, UNIQUE, and PRIMARY KEY "
"constraints are produced inline with the table definition, the database "
"usually has a system in place in which names are automatically assigned "
"to these constraints, if a name is not otherwise specified.  When an "
"existing database table is altered in a database using a command such as "
"``ALTER TABLE``, this command typically needs to specify explicit names "
"for new constraints as well as be able to specify the name of an existing"
" constraint that is to be dropped or modified."
msgstr "リレーショナルデータベースは、通常、すべての制約とインデックスに明示的な名前を割り当てます。通常、CHECK、UNIQUE、PRIMARY KEY制約などの制約がテーブル定義とインラインで生成される「CREATE TABLE」を使用してテーブルを作成する場合、データベースには通常、名前が自動的に割り当てられるシステムが用意されています名前が特に指定されていない場合は、これらの制約に従います。 `` ALTER TABLE``のようなコマンドを使ってデータベース内の既存のデータベーステーブルを変更した場合、このコマンドは通常、新しい制約の明示的な名前を指定するだけでなく、既存の制約の名前を指定する必要があります削除または変更されました。"

#: ../../core/constraints.rst:420
msgid ""
"Constraints can be named explicitly using the "
":paramref:`.Constraint.name` parameter, and for indexes the "
":paramref:`.Index.name` parameter.  However, in the case of constraints "
"this parameter is optional.  There are also the use cases of using the "
":paramref:`.Column.unique` and :paramref:`.Column.index` parameters which"
" create :class:`.UniqueConstraint` and :class:`.Index` objects without an"
" explicit name being specified."
msgstr "制約は、：paramref： `.Constraint.name`パラメータを使用して明示的に指定することができ、インデックスに対して：paramref：` .Index.name`パラメータを明示的に指定することができます。ただし、制約の場合、このパラメータはオプションです。また：paramref： `.Column.unique`と：paramref：` .Column.index`パラメータを使用して：class： `.UniqueConstraint`と：class：` .Index`オブジェクトを明示的に使用しないユースケースもあります名前が指定されています。"

#: ../../core/constraints.rst:427
msgid ""
"The use case of alteration of existing tables and constraints can be "
"handled by schema migration tools such as `Alembic "
"<http://alembic.zzzcomputing.com/>`_. However, neither Alembic nor "
"SQLAlchemy currently create names for constraint objects where the name "
"is otherwise unspecified, leading to the case where being able to alter "
"existing constraints means that one must reverse-engineer the naming "
"system used by the relational database to auto-assign names, or that care"
" must be taken to ensure that all constraints are named."
msgstr "既存のテーブルと制約の変更のユースケースは、「Alembic <http://alembic.zzzcomputing.com/> `_。しかし、AlembicもSQLAlchemyも現在、名前がそうでなければ指定されていない制約オブジェクトの名前を作成していないため、既存の制約を変更できるということは、リレーショナルデータベースが名前の自動割り当てに使用する命名システムをリバースエンジニアリングする必要がある、またはすべての制約に名前が付くように注意する必要があります。"

#: ../../core/constraints.rst:435
msgid ""
"In contrast to having to assign explicit names to all "
":class:`.Constraint` and :class:`.Index` objects, automated naming "
"schemes can be constructed using events.  This approach has the advantage"
" that constraints will get a consistent naming scheme without the need "
"for explicit name parameters throughout the code, and also that the "
"convention takes place just as well for those constraints and indexes "
"produced by the :paramref:`.Column.unique` and :paramref:`.Column.index` "
"parameters.  As of SQLAlchemy 0.9.2 this event-based approach is "
"included, and can be configured using the argument "
":paramref:`.MetaData.naming_convention`."
msgstr "all：class： `.Constraint`オブジェクトと：class：` .Index`オブジェクトに明示的な名前を割り当てなければならないのに対して、自動ネーミングスキームはイベントを使用して構築できます。このアプローチには、制約がコードを通じて明示的な名前パラメータを必要とせずに一貫した命名体系を得るという利点があり、paramref： `.Column.unique &#39;によって生成される制約とインデックスの場合と同様に行われます。 `：and：paramref：` .Column.index`パラメータです。 SQLAlchemy 0.9.2以降、このイベントベースのアプローチが含まれており、引数：paramref： `.MetaData.naming_convention`を使用して設定できます。"

#: ../../core/constraints.rst:445
msgid ""
":paramref:`.MetaData.naming_convention` refers to a dictionary which "
"accepts the :class:`.Index` class or individual :class:`.Constraint` "
"classes as keys, and Python string templates as values.   It also accepts"
" a series of string-codes as alternative keys, ``\"fk\"``, ``\"pk\"``, "
"``\"ix\"``, ``\"ck\"``, ``\"uq\"`` for foreign key, primary key, index, "
"check, and unique constraint, respectively.  The string templates in this"
" dictionary are used whenever a constraint or index is associated with "
"this :class:`.MetaData` object that does not have an existing name given "
"(including one exception case where an existing name can be further "
"embellished)."
msgstr "：paramref： `.MetaData.naming_convention`は：class：` .Index`クラスまたはindividual：class： `.Constraint`クラスをキーとし、Python文字列テンプレートを値として受け取るディクショナリを指します。また、一連の文字列コードを代替キー、 `` \ &quot;fk \&quot; ``、 `` \ &quot;pk \&quot; ``、 `` \ &quot;ix \&quot; ``、 `` \ &quot;ck \外部キー、主キー、索引、検査、ユニーク制約の場合は、それぞれ ``、 `` \ &quot;uq \&quot; ``となります。この辞書の文字列テンプレートは、既存の名前が与えられていないclass： `.MetaData`オブジェクトに制約またはインデックスが関連付けられている場合に使用されます（例外は既存の名前をさらに埋め込むことができます）。"

#: ../../core/constraints.rst:455
msgid "An example naming convention that suits basic cases is as follows::"
msgstr "基本的なケースに合う命名規則の例は次のとおりです::"

#: ../../core/constraints.rst:467
msgid ""
"The above convention will establish names for all constraints within the "
"target :class:`.MetaData` collection. For example, we can observe the "
"name produced when we create an unnamed :class:`.UniqueConstraint`::"
msgstr "上記の規則は、target：class： `.MetaData`コレクション内のすべての制約の名前を確立します。例えば、名前のないクラスを作成するときに生成される名前を見ることができます：class： `.UniqueConstraint` ::"

#: ../../core/constraints.rst:480
msgid ""
"This same feature takes effect even if we just use the "
":paramref:`.Column.unique` flag::"
msgstr "この同じ機能は、：paramref： `.Column.unique`フラグを使用しても有効です::"

#: ../../core/constraints.rst:490
msgid ""
"A key advantage to the naming convention approach is that the names are "
"established at Python construction time, rather than at DDL emit time.  "
"The effect this has when using Alembic's ``--autogenerate`` feature is "
"that the naming convention will be explicit when a new migration script "
"is generated::"
msgstr "命名規則アプローチの主な利点は、名前がDDLの発行時刻ではなく、Pythonの構築時に確立されることです。 Alembicの `` --autogenerate``機能を使用した場合の効果は、新しい移行スクリプトが生成されたときに命名規則が明示的になることです::"

#: ../../core/constraints.rst:498
msgid ""
"The above ``\"uq_user_name\"`` string was copied from the "
":class:`.UniqueConstraint` object that ``--autogenerate`` located in our "
"metadata."
msgstr "上記の `` \ &quot;uq_user_name \&quot; `文字列は、私たちのメタデータにある` `--autogenerate``の：class：` .UniqueConstraint`オブジェクトからコピーされました。"

#: ../../core/constraints.rst:501
msgid ""
"The default value for :paramref:`.MetaData.naming_convention` handles the"
" long-standing SQLAlchemy behavior of assigning a name to a "
":class:`.Index` object that is created using the "
":paramref:`.Column.index` parameter::"
msgstr "paramref： `.MetaData.naming_convention`のデフォルト値は、：paramref：` .Column.index`パラメータを使用して作成された：class： `.Index`オブジェクトに名前を割り当てるという長期にわたるSQLAlchemyの動作を処理します： ："

#: ../../core/constraints.rst:509
#, python-format
msgid ""
"The tokens available include ``%(table_name)s``, "
"``%(referred_table_name)s``, ``%(column_0_name)s``, "
"``%(column_0_label)s``, ``%(column_0_key)s``,  "
"``%(referred_column_0_name)s``, and ``%(constraint_name)s``; the "
"documentation for :paramref:`.MetaData.naming_convention` describes each "
"individually.  New tokens can also be added, by specifying an additional "
"token and a callable within the naming_convention dictionary.  For "
"example, if we wanted to name our foreign key constraints using a GUID "
"scheme, we could do that as follows::"
msgstr "使用可能なトークンには、 ``％（table_name）s``、 ``％（refer_table_name）s``、 `％（column_0_name）s``、` `％（column_0_label）s``、` `％（column_0_key） ``％（referenced_column_0_name）s``、 ``％（constraint_name）s``のように、 ：paramref： `.MetaData.naming_convention`は、それぞれを個別に記述します。新しいトークンは、naming_convention辞書内に追加のトークンと呼び出し可能コードを指定することによって追加することもできます。たとえば、GUIDスキームを使用して外部キー制約に名前を付ける場合は、次のようにします。"

#: ../../core/constraints.rst:537
msgid ""
"Above, when we create a new :class:`.ForeignKeyConstraint`, we will get a"
" name as follows::"
msgstr "上で、新しい：class： `.ForeignKeyConstraint`を作成すると、次のような名前が得られます::"

#: ../../core/constraints.rst:560
msgid ""
":paramref:`.MetaData.naming_convention` - for additional usage details as"
" well as a listing of all available naming components."
msgstr "：paramref： `.MetaData.naming_convention`  - 利用可能なすべてのネーミングコンポーネントのリストと同様に、追加の利用の詳細。"

#: ../../core/constraints.rst:563
msgid ""
"`The Importance of Naming Constraints "
"<http://alembic.zzzcomputing.com/en/latest/naming.html>`_ - in the "
"Alembic documentation."
msgstr "`制約の命名の重要性<http://alembic.zzzcomputing.com/en/latest/naming.html> `_  - はAlembicのドキュメントにあります。"

#: ../../core/constraints.rst:565
msgid "Added the :paramref:`.MetaData.naming_convention` argument."
msgstr "：paramref： `.MetaData.naming_convention`引数を追加しました。"

#: ../../core/constraints.rst:570
msgid "Naming CHECK Constraints"
msgstr "CHECK制約の命名"

#: ../../core/constraints.rst:572
#, python-format
msgid ""
"The :class:`.CheckConstraint` object is configured against an arbitrary "
"SQL expression, which can have any number of columns present, and "
"additionally is often configured using a raw SQL string.  Therefore a "
"common convention to use with :class:`.CheckConstraint` is one where we "
"expect the object to have a name already, and we then enhance it with "
"other convention elements. A typical convention is "
"``\"ck_%(table_name)s_%(constraint_name)s\"``::"
msgstr "：class： `.CheckConstraint`オブジェクトは、任意の数のカラムを持つ任意のSQL式に対して構成され、さらに生のSQL文字列を使用して構成されることがよくあります。したがって、class： `.CheckConstraint`と一緒に使用する共通の規約は、オブジェクトがすでに名前を持つことを期待しています。次に、他の規約でそれを拡張します。典型的な規則は `` \ &quot;ck _％（table_name）s _％（constraint_name）です。\&quot; `` ::"

#: ../../core/constraints.rst:588
msgid "The above table will produce the name ``ck_foo_value_gt_5``::"
msgstr "上記のテーブルは `` ck_foo_value_gt_5``という名前を生成します::"

#: ../../core/constraints.rst:595
#, python-format
msgid ""
":class:`.CheckConstraint` also supports the ``%(columns_0_name)s`` token;"
" we can make use of this by ensuring we use a :class:`.Column` or "
":func:`.sql.expression.column` element within the constraint's "
"expression, either by declaring the constraint separate from the table::"
msgstr "：class： `.CheckConstraint`は` `％（columns_0_name）s``トークンもサポートしています。これを使うには、制約を式の中で：class： `.Column`または：func：` .sql.expression.column`要素を使って、テーブルとは別の制約を宣言するか、"

#: ../../core/constraints.rst:610
msgid "or by using a :func:`.sql.expression.column` inline::"
msgstr "または：func： `.sql.expression.column` inline ::を使用して、"

#: ../../core/constraints.rst:623
msgid "Both will produce the name ``ck_foo_value``::"
msgstr "どちらも `` ck_foo_value``という名前を生成します::"

#: ../../core/constraints.rst:630
msgid ""
"The determination of the name of \"column zero\" is performed by scanning"
" the given expression for column objects.  If the expression has more "
"than one column present, the scan does use a deterministic search, "
"however the structure of the expression will determine which column is "
"noted as \"column zero\"."
msgstr "\ &quot;column zero \&quot;の名前の決定は、与えられた式を列オブジェクトに対して走査することによって実行される。式に複数の列がある場合、スキャンでは確定的な検索が使用されますが、式の構造によってどの列が\ &quot;列のゼロ\&quot;であるかが判別されます。"

#: ../../core/constraints.rst:636
msgid ""
"The :class:`.CheckConstraint` object now supports the ``column_0_name`` "
"naming convention token."
msgstr "：class： `.CheckConstraint`オブジェクトは、` `column_0_name``命名規約トークンをサポートするようになりました。"

#: ../../core/constraints.rst:642
msgid "Configuring Naming for Boolean, Enum, and other schema types"
msgstr "ブール型、列挙型、およびその他のスキーマ型の名前の構成"

#: ../../core/constraints.rst:644
msgid ""
"The :class:`.SchemaType` class refers to type objects such as "
":class:`.Boolean` and :class:`.Enum` which generate a CHECK constraint "
"accompanying the type. The name for the constraint here is most directly "
"set up by sending the \"name\" parameter, e.g. "
":paramref:`.Boolean.name`::"
msgstr "：class： `.SchemaType`クラスは：class：` .Boolean`や：class： `.Enum`のような型オブジェクトを参照し、型に付随するCHECK制約を生成します。ここでの制約の名前は、\ &quot;name \&quot;パラメータを送ることによって最も直接的に設定されます。例：paramref： `.Boolean.name` ::"

#: ../../core/constraints.rst:653
#, python-format
msgid ""
"The naming convention feature may be combined with these types as well, "
"normally by using a convention which includes ``%(constraint_name)s`` and"
" then applying a name to the type::"
msgstr "命名規則の特徴は、通常、 ``％（constraint_name）s``を含む規約を使ってこれらの型と組み合わされ、次に型に名前を適用します::"

#: ../../core/constraints.rst:665
msgid "The above table will produce the constraint name ``ck_foo_flag_bool``::"
msgstr "上記の表は、制約名「 `` ck_foo_flag_bool`` ::"

#: ../../core/constraints.rst:672
msgid ""
"The :class:`.SchemaType` classes use special internal symbols so that the"
" naming convention is only determined at DDL compile time.  On "
"PostgreSQL, there's a native BOOLEAN type, so the CHECK constraint of "
":class:`.Boolean` is not needed; we are safe to set up a "
":class:`.Boolean` type without a name, even though a naming convention is"
" in place for check constraints. This convention will only be consulted "
"for the CHECK constraint if we run against a database without a native "
"BOOLEAN type like SQLite or MySQL."
msgstr "：class： `.SchemaType`クラスは特殊な内部シンボルを使用するので、命名規則はDDLコンパイル時にのみ決定されます。 PostgreSQLでは、ネイティブのBOOLEAN型があるので、：class： `.Boolean`のCHECK制約は必要ありません。チェック制約の命名規則があるとしても、名前を持たないclass： `.Boolean`型を設定することは安全です。この規約は、SQLiteやMySQLのようなネイティブなBOOLEAN型を持たないデータベースに対して実行する場合にのみ、CHECK制約のために参照されます。"

#: ../../core/constraints.rst:681
msgid ""
"The CHECK constraint may also make use of the ``column_0_name`` token, "
"which works nicely with :class:`.SchemaType` since these constraints have"
" only one column::"
msgstr "CHECK制約は、 `` column_0_name``トークンを使うこともできます。これらのトークンは：class： `.SchemaType`でうまく動作します。"

#: ../../core/constraints.rst:693
msgid "The above schema will produce::"
msgstr "上記のスキーマは::"

#: ../../core/constraints.rst:700
#, python-format
msgid ""
"Constraint naming conventions that don't include ``%(constraint_name)s`` "
"again work with :class:`.SchemaType` constraints."
msgstr "`％（constraint_name）s``を含まない拘束命名規則は、class：` .SchemaType`制約で再び働きます。"

#: ../../core/constraints.rst:704
msgid "Constraints API"
msgstr "制約API"

#: of sqlalchemy.schema.Constraint:1
msgid "A table-level SQL constraint."
msgstr "表レベルのSQL制約。"

#: of sqlalchemy.schema.ColumnCollectionMixin.columns:1
msgid "A :class:`.ColumnCollection` of :class:`.Column` objects."
msgstr "A：class：class： `.Column`オブジェクトの` .ColumnCollection`です。"

#: of sqlalchemy.schema.ColumnCollectionMixin.columns:3
msgid ""
"This collection represents the columns which are referred to by this "
"object."
msgstr "このコレクションは、このオブジェクトによって参照される列を表します。"

#: of sqlalchemy.schema.ColumnCollectionConstraint:1
msgid "A constraint that proxies a ColumnCollection."
msgstr "ColumnCollectionをプロキシする制約。"

#: of sqlalchemy.schema.CheckConstraint.argument_for:1
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:1
#: sqlalchemy.schema.ForeignKey.argument_for:1
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:1
#: sqlalchemy.schema.Index.argument_for:1
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:1
#: sqlalchemy.schema.UniqueConstraint.argument_for:1
msgid "Add a new kind of dialect-specific keyword argument for this class."
msgstr "このクラスの新しい種類の方言固有のキーワード引数を追加します。"

#: of sqlalchemy.schema.CheckConstraint.argument_for:3
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:3
#: sqlalchemy.schema.ForeignKey.argument_for:3
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:3
#: sqlalchemy.schema.Index:5 sqlalchemy.schema.Index.argument_for:3
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:3
#: sqlalchemy.schema.UniqueConstraint.argument_for:3
msgid "E.g.::"
msgstr "例えば：："

#: of sqlalchemy.schema.CheckConstraint.argument_for:9
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:9
#: sqlalchemy.schema.ForeignKey.argument_for:9
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:9
#: sqlalchemy.schema.Index.argument_for:9
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:9
#: sqlalchemy.schema.UniqueConstraint.argument_for:9
msgid ""
"The :meth:`.DialectKWArgs.argument_for` method is a per-argument way "
"adding extra arguments to the :attr:`.DefaultDialect.construct_arguments`"
" dictionary. This dictionary provides a list of argument names accepted "
"by various schema-level constructs on behalf of a dialect."
msgstr "：meth： `.DialectKWArgs.argument_for`メソッドは：attr：` .DefaultDialect.construct_arguments`ディクショナリに余分な引数を追加する引数ごとの方法です。この辞書は、方言に代わってさまざまなスキーマレベルの構造によって受け入れられる引数名のリストを提供します。"

#: of sqlalchemy.schema.CheckConstraint.argument_for:15
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:15
#: sqlalchemy.schema.ForeignKey.argument_for:15
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:15
#: sqlalchemy.schema.Index.argument_for:15
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:15
#: sqlalchemy.schema.UniqueConstraint.argument_for:15
msgid ""
"New dialects should typically specify this dictionary all at once as a "
"data member of the dialect class.  The use case for ad-hoc addition of "
"argument names is typically for end-user code that is also using a custom"
" compilation scheme which consumes the additional arguments."
msgstr "新しい方言は通常、この辞書を一度に方言クラスのデータメンバーとして指定する必要があります。引数名のアドホックな追加のユースケースは、通常、追加の引数を消費するカスタムコンパイルスキームも使用するエンドユーザーコード用です。"

#: of sqlalchemy.schema.CheckConstraint.argument_for
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for
#: sqlalchemy.schema.ForeignKey.argument_for sqlalchemy.schema.ForeignKey.copy
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for
#: sqlalchemy.schema.Index.argument_for
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for
#: sqlalchemy.schema.UniqueConstraint.argument_for
msgid "パラメータ"
msgstr "パラメータ"

#: of sqlalchemy.schema.CheckConstraint.argument_for:20
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:20
#: sqlalchemy.schema.ForeignKey.argument_for:20
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:20
#: sqlalchemy.schema.Index.argument_for:20
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:20
#: sqlalchemy.schema.UniqueConstraint.argument_for:20
msgid ""
"name of a dialect.  The dialect must be locatable, else a "
":class:`.NoSuchModuleError` is raised.   The dialect must also include an"
" existing :attr:`.DefaultDialect.construct_arguments` collection, "
"indicating that it participates in the keyword-argument validation and "
"default system, else :class:`.ArgumentError` is raised.  If the dialect "
"does not include this collection, then any keyword argument can be "
"specified on behalf of this dialect already.  All dialects packaged "
"within SQLAlchemy include this collection, however for third party "
"dialects, support may vary."
msgstr "方言の名前。方言はlocatableでなければなりません。さもなければ：class： `.NoSuchModuleError`が送出されます。ダイアレクトには、既存の：attr： `.DefaultDialect.construct_arguments`コレクションも含まれていなければなりません。これはキーワード引数の検証とデフォルトシステムに参加していることを示します。それ以外の場合は：class：` .ArgumentError`が送出されます。方言にこのコレクションが含まれていない場合は、既にこの方言の代わりにキーワード引数を指定できます。 SQLAlchemy内にパッケージ化されたすべての方言にはこのコレクションが含まれていますが、サードパーティの方言ではサポートが異なる場合があります。"

#: of sqlalchemy.schema.CheckConstraint.argument_for:31
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:31
#: sqlalchemy.schema.ForeignKey.argument_for:31
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:31
#: sqlalchemy.schema.Index.argument_for:31
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:31
#: sqlalchemy.schema.UniqueConstraint.argument_for:31
msgid "name of the parameter."
msgstr "パラメータの名前。"

#: of sqlalchemy.schema.CheckConstraint.argument_for:33
#: sqlalchemy.schema.ColumnCollectionConstraint.argument_for:33
#: sqlalchemy.schema.ForeignKey.argument_for:33
#: sqlalchemy.schema.ForeignKeyConstraint.argument_for:33
#: sqlalchemy.schema.Index.argument_for:33
#: sqlalchemy.schema.PrimaryKeyConstraint.argument_for:33
#: sqlalchemy.schema.UniqueConstraint.argument_for:33
msgid "default value of the parameter."
msgstr "パラメータのデフォルト値。"

#: of sqlalchemy.schema.ColumnCollectionConstraint.columns:1
#: sqlalchemy.schema.ForeignKeyConstraint.columns:1
msgid ""
"A :class:`.ColumnCollection` representing the set of columns for this "
"constraint."
msgstr "A：class：この制約の列セットを表す `.ColumnCollection`です。"

#: of sqlalchemy.schema.CheckConstraint.contains_column:1
#: sqlalchemy.schema.ColumnCollectionConstraint.contains_column:1
#: sqlalchemy.schema.ForeignKeyConstraint.contains_column:1
#: sqlalchemy.schema.PrimaryKeyConstraint.contains_column:1
#: sqlalchemy.schema.UniqueConstraint.contains_column:1
msgid "Return True if this constraint contains the given column."
msgstr "この制約に指定された列が含まれている場合はTrueを返します。"

#: of sqlalchemy.schema.CheckConstraint.contains_column:3
#: sqlalchemy.schema.ColumnCollectionConstraint.contains_column:3
#: sqlalchemy.schema.ForeignKeyConstraint.contains_column:3
#: sqlalchemy.schema.PrimaryKeyConstraint.contains_column:3
#: sqlalchemy.schema.UniqueConstraint.contains_column:3
msgid ""
"Note that this object also contains an attribute ``.columns`` which is a "
":class:`.ColumnCollection` of :class:`.Column` objects."
msgstr "このオブジェクトには、：class： `.Column`オブジェクトの：class：` .ColumnCollection`属性である `` .columns``も含まれています。"

#: of sqlalchemy.schema.CheckConstraint.dialect_kwargs:1
#: sqlalchemy.schema.CheckConstraint.dialect_options:1
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs:1
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_options:1
#: sqlalchemy.schema.ForeignKey.dialect_kwargs:1
#: sqlalchemy.schema.ForeignKey.dialect_options:1
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs:1
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_options:1
#: sqlalchemy.schema.Index.dialect_kwargs:1
#: sqlalchemy.schema.Index.dialect_options:1
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs:1
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_options:1
#: sqlalchemy.schema.UniqueConstraint.dialect_kwargs:1
#: sqlalchemy.schema.UniqueConstraint.dialect_options:1
msgid ""
"A collection of keyword arguments specified as dialect-specific options "
"to this construct."
msgstr "この構文に対してダイアレクト固有のオプションとして指定されたキーワード引数の集合。"

#: of sqlalchemy.schema.CheckConstraint.dialect_kwargs:4
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs:4
#: sqlalchemy.schema.ForeignKey.dialect_kwargs:4
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs:4
#: sqlalchemy.schema.Index.dialect_kwargs:4
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs:4
#: sqlalchemy.schema.UniqueConstraint.dialect_kwargs:4
msgid ""
"The arguments are present here in their original ``<dialect>_<kwarg>`` "
"format.  Only arguments that were actually passed are included; unlike "
"the :attr:`.DialectKWArgs.dialect_options` collection, which contains all"
" options known by this dialect including defaults."
msgstr "これらの議論は、 <dialect> _ <kwarg> ``フォーマット。実際に渡された引数のみが含まれます。 ：attr： `.DialectKWArgs.dialect_options`コレクションと異なり、デフォルトを含むこの方言で知られているすべてのオプションが含まれています。"

#: of sqlalchemy.schema.CheckConstraint.dialect_kwargs:9
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs:9
#: sqlalchemy.schema.ForeignKey.dialect_kwargs:9
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs:9
#: sqlalchemy.schema.Index.dialect_kwargs:9
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs:9
#: sqlalchemy.schema.UniqueConstraint.dialect_kwargs:9
msgid ""
"The collection is also writable; keys are accepted of the form "
"``<dialect>_<kwarg>`` where the value will be assembled into the list of "
"options."
msgstr "コレクションは書き込み可能です。キーは `` <dialect> _ <kwarg> ``は値がオプションのリストに集められる場所です。"

#: of sqlalchemy.schema.CheckConstraint.dialect_kwargs:15
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs:15
#: sqlalchemy.schema.ForeignKey.dialect_kwargs:15
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs:15
#: sqlalchemy.schema.Index.dialect_kwargs:15
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs:15
#: sqlalchemy.schema.UniqueConstraint.dialect_kwargs:15
msgid "The :attr:`.DialectKWArgs.dialect_kwargs` collection is now writable."
msgstr "：attr： `.DialectKWArgs.dialect_kwargs`コレクションが書き込み可能になりました。"

#: of sqlalchemy.schema.CheckConstraint.dialect_kwargs:20
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_kwargs:20
#: sqlalchemy.schema.ForeignKey.dialect_kwargs:20
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_kwargs:20
#: sqlalchemy.schema.Index.dialect_kwargs:20
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_kwargs:20
#: sqlalchemy.schema.UniqueConstraint.dialect_kwargs:20
msgid ":attr:`.DialectKWArgs.dialect_options` - nested dictionary form"
msgstr "：attr： `.DialectKWArgs.dialect_options`  - ネストされた辞書形式"

#: of sqlalchemy.schema.CheckConstraint.dialect_options:4
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_options:4
#: sqlalchemy.schema.ForeignKey.dialect_options:4
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_options:4
#: sqlalchemy.schema.Index.dialect_options:4
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_options:4
#: sqlalchemy.schema.UniqueConstraint.dialect_options:4
msgid ""
"This is a two-level nested registry, keyed to ``<dialect_name>`` and "
"``<argument_name>``.  For example, the ``postgresql_where`` argument "
"would be locatable as::"
msgstr "これは2レベルのネストされたレジストリで、 `` <dialect_name> ``と `` <argument_name> ``。たとえば、 `` postgresql_where``引数は::"

#: of sqlalchemy.schema.CheckConstraint.dialect_options:14
#: sqlalchemy.schema.ColumnCollectionConstraint.dialect_options:14
#: sqlalchemy.schema.ForeignKey.dialect_options:14
#: sqlalchemy.schema.ForeignKeyConstraint.dialect_options:14
#: sqlalchemy.schema.Index.dialect_options:14
#: sqlalchemy.schema.PrimaryKeyConstraint.dialect_options:14
#: sqlalchemy.schema.UniqueConstraint.dialect_options:14
msgid ":attr:`.DialectKWArgs.dialect_kwargs` - flat dictionary form"
msgstr "：attr： `.DialectKWArgs.dialect_kwargs`  - フラット辞書形式"

#: of sqlalchemy.schema.CheckConstraint.get_children:1
#: sqlalchemy.schema.ColumnCollectionConstraint.get_children:1
#: sqlalchemy.schema.ForeignKey.get_children:1
#: sqlalchemy.schema.ForeignKeyConstraint.get_children:1
#: sqlalchemy.schema.Index.get_children:1
#: sqlalchemy.schema.PrimaryKeyConstraint.get_children:1
#: sqlalchemy.schema.UniqueConstraint.get_children:1
msgid "used to allow SchemaVisitor access"
msgstr "SchemaVisitorへのアクセスを許可するために使用されます"

#: of sqlalchemy.schema.CheckConstraint.info:1
#: sqlalchemy.schema.ColumnCollectionConstraint.info:1
#: sqlalchemy.schema.ForeignKey.info:1
#: sqlalchemy.schema.ForeignKeyConstraint.info:1 sqlalchemy.schema.Index.info:1
#: sqlalchemy.schema.PrimaryKeyConstraint.info:1
#: sqlalchemy.schema.UniqueConstraint.info:1
msgid ""
"Info dictionary associated with the object, allowing user-defined data to"
" be associated with this :class:`.SchemaItem`."
msgstr "オブジェクトに関連付けられた情報ディクショナリで、ユーザ定義データをthis：class： `.SchemaItem`に関連付けることができます。"

#: of sqlalchemy.schema.CheckConstraint.info:4
#: sqlalchemy.schema.ColumnCollectionConstraint.info:4
#: sqlalchemy.schema.ForeignKey.info:4
#: sqlalchemy.schema.ForeignKeyConstraint.info:4 sqlalchemy.schema.Index.info:4
#: sqlalchemy.schema.PrimaryKeyConstraint.info:4
#: sqlalchemy.schema.UniqueConstraint.info:4
msgid ""
"The dictionary is automatically generated when first accessed. It can "
"also be specified in the constructor of some objects, such as "
":class:`.Table` and :class:`.Column`."
msgstr "辞書は、最初にアクセスされると自動的に生成されます。これは、class： `.Table`や：class：` .Column`のようなオブジェクトのコンストラクタで指定することもできます。"

#: of sqlalchemy.schema.CheckConstraint.kwargs:1
#: sqlalchemy.schema.ColumnCollectionConstraint.kwargs:1
#: sqlalchemy.schema.ForeignKey.kwargs:1
#: sqlalchemy.schema.ForeignKeyConstraint.kwargs:1
#: sqlalchemy.schema.Index.kwargs:1
#: sqlalchemy.schema.PrimaryKeyConstraint.kwargs:1
#: sqlalchemy.schema.UniqueConstraint.kwargs:1
msgid "A synonym for :attr:`.DialectKWArgs.dialect_kwargs`."
msgstr "attr： `.DialectKWArgs.dialect_kwargs`の同義語です。"

#: of sqlalchemy.schema.CheckConstraint.quote:1
#: sqlalchemy.schema.ColumnCollectionConstraint.quote:1
#: sqlalchemy.schema.ForeignKey.quote:1
#: sqlalchemy.schema.ForeignKeyConstraint.quote:1
#: sqlalchemy.schema.Index.quote:1
#: sqlalchemy.schema.PrimaryKeyConstraint.quote:1
#: sqlalchemy.schema.UniqueConstraint.quote:1
msgid ""
"Return the value of the ``quote`` flag passed to this schema object, for "
"those schema items which have a ``name`` field."
msgstr "`` name``フィールドを持つスキーマ項目については、このスキーマオブジェクトに渡された `` quote``フラグの値を返します。"

#: of sqlalchemy.schema.CheckConstraint.quote:5
#: sqlalchemy.schema.ColumnCollectionConstraint.quote:5
#: sqlalchemy.schema.ForeignKey.quote:5
#: sqlalchemy.schema.ForeignKeyConstraint.quote:5
#: sqlalchemy.schema.Index.quote:5
#: sqlalchemy.schema.PrimaryKeyConstraint.quote:5
#: sqlalchemy.schema.UniqueConstraint.quote:5
msgid "Use ``<obj>.name.quote``"
msgstr "`` <obj> .name.quote``"

#: of sqlalchemy.schema.CheckConstraint:1
msgid "A table- or column-level CHECK constraint."
msgstr "表レベルまたは列レベルのCHECK制約。"

#: of sqlalchemy.schema.CheckConstraint:3
msgid "Can be included in the definition of a Table or Column."
msgstr "テーブルまたは列の定義に含めることができます。"

#: of sqlalchemy.schema.ForeignKey:1
msgid "Defines a dependency between two columns."
msgstr "2つの列間の依存関係を定義します。"

#: of sqlalchemy.schema.ForeignKey:3
msgid ""
"``ForeignKey`` is specified as an argument to a :class:`.Column` object, "
"e.g.::"
msgstr "`` ForeignKey``は：class： `.Column`オブジェクトへの引数として指定されます。例えば::"

#: of sqlalchemy.schema.ForeignKey:10
msgid ""
"Note that ``ForeignKey`` is only a marker object that defines a "
"dependency between two columns.   The actual constraint is in all cases "
"represented by the :class:`.ForeignKeyConstraint` object.   This object "
"will be generated automatically when a ``ForeignKey`` is associated with "
"a :class:`.Column` which in turn is associated with a :class:`.Table`.   "
"Conversely, when :class:`.ForeignKeyConstraint` is applied to a "
":class:`.Table`, ``ForeignKey`` markers are automatically generated to be"
" present on each associated :class:`.Column`, which are also associated "
"with the constraint object."
msgstr "`` ForeignKey``は、2つの列間の依存関係を定義するマーカーオブジェクトに過ぎないことに注意してください。実際の制約は、すべての場合において：class： `.ForeignKeyConstraint`オブジェクトによって表されます。このオブジェクトは `` ForeignKey``が：class： `.Column`に関連付けられているときに自動的に生成されます。これはa：class：` .Table`に関連付けられます。逆に：class： `.ForeignKeyConstraint`が：class：` .Table`に適用された場合、 `` ForeignKey``マーカーは関連するそれぞれの：class： `.Column`に自動的に生成されます。制約オブジェクト"

#: of sqlalchemy.schema.ForeignKey:21
msgid ""
"Note that you cannot define a \"composite\" foreign key constraint, that "
"is a constraint between a grouping of multiple parent/child columns, "
"using ``ForeignKey`` objects.   To define this grouping, the "
":class:`.ForeignKeyConstraint` object must be used, and applied to the "
":class:`.Table`.   The associated ``ForeignKey`` objects are created "
"automatically."
msgstr "`` ForeignKey``オブジェクトを使って、複数の親/子列のグループ化の間の制約である、\ &quot;複合\&quot;外部キー制約を定義することはできません。このグループ化を定義するには、：class： `.ForeignKeyConstraint`オブジェクトを使用し、：class：` .Table`に適用する必要があります。関連付けられた `` ForeignKey``オブジェクトは自動的に作成されます。"

#: of sqlalchemy.schema.ForeignKey:28
msgid ""
"The ``ForeignKey`` objects associated with an individual :class:`.Column`"
" object are available in the `foreign_keys` collection of that column."
msgstr "個体：class： `.Column`オブジェクトに関連付けられた` `ForeignKey``オブジェクトは、その列の` foreign_keys`コレクションで利用できます。"

#: of sqlalchemy.schema.ForeignKey:32
msgid ""
"Further examples of foreign key configuration are in "
":ref:`metadata_foreignkeys`."
msgstr "外部キー設定のさらなる例は：ref： `metadata_foreignkeys`です。"

#: of sqlalchemy.schema.ForeignKey.column:1
msgid ""
"Return the target :class:`.Column` referenced by this "
":class:`.ForeignKey`."
msgstr "クラス： `.ForeignKey`によって参照されるターゲット：クラス：` .Column`を返します。"

#: of sqlalchemy.schema.ForeignKey.column:4
msgid "If no target column has been established, an exception is raised."
msgstr "ターゲット列が確立されていない場合、例外が発生します。"

#: of sqlalchemy.schema.ForeignKey.column:7
msgid ""
"Foreign key target column resolution now occurs as soon as both the "
"ForeignKey object and the remote Column to which it refers are both "
"associated with the same MetaData object."
msgstr "ForeignKeyオブジェクトとそれが参照するリモートColumnの両方が両方とも同じMetaDataオブジェクトに関連付けられるとすぐに、外部キーのターゲット列の解決が行われます。"

#: of sqlalchemy.schema.ForeignKey.copy:1
msgid "Produce a copy of this :class:`.ForeignKey` object."
msgstr "this：class： `.ForeignKey`オブジェクトのコピーを作ります。"

#: of sqlalchemy.schema.ForeignKey.copy:3
msgid "The new :class:`.ForeignKey` will not be bound to any :class:`.Column`."
msgstr "新しい：class： `.ForeignKey`は、class：` .Column`に束縛されません。"

#: of sqlalchemy.schema.ForeignKey.copy:6
msgid ""
"This method is usually used by the internal copy procedures of "
":class:`.Column`, :class:`.Table`, and :class:`.MetaData`."
msgstr "このメソッドは通常、class： `.Column`、：class：` .Table`、：class： `.MetaData`の内部コピープロシージャによって使用されます。"

#: of sqlalchemy.schema.ForeignKey.copy:10
msgid ""
"The returned :class:`.ForeignKey` will reference the original table and "
"column name, qualified by the given string schema name."
msgstr "返される：class： `.ForeignKey`は、指定された文字列スキーマ名で修飾された元のテーブルとカラム名を参照します。"

#: of sqlalchemy.schema.ForeignKey.get_referent:1
msgid ""
"Return the :class:`.Column` in the given :class:`.Table` referenced by "
"this :class:`.ForeignKey`."
msgstr "指定された：class： `.Column`を返します：class：` .Table`これは：class： `.ForeignKey`によって参照されます。"

#: of sqlalchemy.schema.ForeignKey.get_referent:4
msgid ""
"Returns None if this :class:`.ForeignKey` does not reference the given "
":class:`.Table`."
msgstr "None：class： `.ForeignKey`は与えられた：class：` .Table`を参照しません。"

#: of sqlalchemy.schema.ForeignKey.references:1
msgid ""
"Return True if the given :class:`.Table` is referenced by this "
":class:`.ForeignKey`."
msgstr "与えられた：class： `.Table`がthis：class：` .ForeignKey`によって参照されている場合にTrueを返します。"

#: of sqlalchemy.schema.ForeignKey.target_fullname:1
msgid ""
"Return a string based 'column specification' for this "
":class:`.ForeignKey`."
msgstr "このために、列ベースの &#39;列指定&#39;を返します。class： `.ForeignKey`。"

#: of sqlalchemy.schema.ForeignKey.target_fullname:4
msgid ""
"This is usually the equivalent of the string-based \"tablename.colname\" "
"argument first passed to the object's constructor."
msgstr "これは通常、オブジェクトのコンストラクタに最初に渡される文字列ベースの\ &quot;tablename.colname \&quot;引数に相当します。"

#: of sqlalchemy.schema.ForeignKeyConstraint:1
msgid "A table-level FOREIGN KEY constraint."
msgstr "表レベルのFOREIGN KEY制約。"

#: of sqlalchemy.schema.ForeignKeyConstraint:3
msgid ""
"Defines a single column or composite FOREIGN KEY ... REFERENCES "
"constraint. For a no-frills, single column foreign key, adding a "
":class:`.ForeignKey` to the definition of a :class:`.Column` is a "
"shorthand equivalent for an unnamed, single column "
":class:`.ForeignKeyConstraint`."
msgstr "単一の列または複合FOREIGN KEY ... REFERENCES制約を定義します。ノンフリルの単一カラムの外部キーでは、：class： `.ForeignKey`を：class：` .Column`の定義に追加すると、名前のない単一の列であるclass： `.ForeignKeyConstraint`の簡略化された表現になります。"

#: of sqlalchemy.schema.ForeignKeyConstraint:9
msgid "Examples of foreign key configuration are in :ref:`metadata_foreignkeys`."
msgstr "外部キー設定の例は：ref： `metadata_foreignkeys`です。"

#: of sqlalchemy.schema.ForeignKeyConstraint.column_keys:1
msgid ""
"Return a list of string keys representing the local columns in this "
":class:`.ForeignKeyConstraint`."
msgstr "this：class： `.ForeignKeyConstraint`のローカル列を表す文字列キーのリストを返します。"

#: of sqlalchemy.schema.ForeignKeyConstraint.column_keys:4
msgid ""
"This list is either the original string arguments sent to the constructor"
" of the :class:`.ForeignKeyConstraint`, or if the constraint has been "
"initialized with :class:`.Column` objects, is the string .key of each "
"element."
msgstr "このリストは：class： `.ForeignKeyConstraint`のコンストラクタに送られた元の文字列引数か、またはclass：` .Column`オブジェクトで制約が初期化されている場合、各要素の文字列.keyです。"

#: of sqlalchemy.schema.ForeignKeyConstraint.elements:1
msgid "A sequence of :class:`.ForeignKey` objects."
msgstr "class： `.ForeignKey`オブジェクトのシーケンスです。"

#: of sqlalchemy.schema.ForeignKeyConstraint.elements:3
msgid ""
"Each :class:`.ForeignKey` represents a single referring column/referred "
"column pair."
msgstr "それぞれ：class： `.ForeignKey`は参照する単一の列/参照される列のペアを表します。"

#: of sqlalchemy.schema.ForeignKeyConstraint.elements:6
msgid "This collection is intended to be read-only."
msgstr "このコレクションは読み取り専用になっています。"

#: of sqlalchemy.schema.ForeignKeyConstraint.referred_table:1
msgid ""
"The :class:`.Table` object to which this :class:`.ForeignKeyConstraint` "
"references."
msgstr "：class： `.ForeignKeyConstraint`が参照する：class：` .Table`オブジェクトです。"

#: of sqlalchemy.schema.ForeignKeyConstraint.referred_table:4
msgid ""
"This is a dynamically calculated attribute which may not be available if "
"the constraint and/or parent table is not yet associated with a metadata "
"collection that contains the referred table."
msgstr "これは、制約テーブルおよび/または親テーブルが参照されたテーブルを含むメタデータコレクションにまだ関連付けられていない場合に利用できない、動的に計算される属性です。"

#: of sqlalchemy.schema.PrimaryKeyConstraint:1
msgid "A table-level PRIMARY KEY constraint."
msgstr "表レベルのPRIMARY KEY制約。"

#: of sqlalchemy.schema.PrimaryKeyConstraint:3
msgid ""
"The :class:`.PrimaryKeyConstraint` object is present automatically on any"
" :class:`.Table` object; it is assigned a set of :class:`.Column` objects"
" corresponding to those marked with the :paramref:`.Column.primary_key` "
"flag::"
msgstr "：class： `.PrimaryKeyConstraint`オブジェクトは、class：` .Table`オブジェクトに自動的に存在します。 ：paramref： `.Column.primary_key`フラグでマークされたものに対応する：class：` .Column`オブジェクトのセットが割り当てられます::"

#: of sqlalchemy.schema.PrimaryKeyConstraint:21
msgid ""
"The primary key of a :class:`.Table` can also be specified by using a "
":class:`.PrimaryKeyConstraint` object explicitly; in this mode of usage, "
"the \"name\" of the constraint can also be specified, as well as other "
"options which may be recognized by dialects::"
msgstr "：class： `.Table`の主キーは：class：` .PrimaryKeyConstraint`オブジェクトを明示的に使用して指定することもできます。この使用モードでは、制約の\ &quot;名前\&quot;も指定することができます。また、ダイアレクトによって認識される他のオプションも指定できます::"

#: of sqlalchemy.schema.PrimaryKeyConstraint:34
msgid ""
"The two styles of column-specification should generally not be mixed. An "
"warning is emitted if the columns present in the "
":class:`.PrimaryKeyConstraint` don't match the columns that were marked "
"as ``primary_key=True``, if both are present; in this case, the columns "
"are taken strictly from the :class:`.PrimaryKeyConstraint` declaration, "
"and those columns otherwise marked as ``primary_key=True`` are ignored.  "
"This behavior is intended to be backwards compatible with previous "
"behavior."
msgstr "2つのスタイルの列指定は、通常、混在させるべきではありません。 ：class： `.PrimaryKeyConstraint`に存在する列が、` `primary_key = True``としてマークされた列と一致しない場合、警告が発行されます。この場合、列は：class： `.PrimaryKeyConstraint`宣言から厳密に取られ、` `primary_key = True``とマークされている列は無視されます。この動作は、以前の動作と後方互換性があることを意図しています。"

#: of sqlalchemy.schema.PrimaryKeyConstraint:43
msgid ""
"Using a mixture of columns within a :class:`.PrimaryKeyConstraint` in "
"addition to columns marked as ``primary_key=True`` now emits a warning if"
" the lists don't match. The ultimate behavior of ignoring those columns "
"marked with the flag only is currently maintained for backwards "
"compatibility; this warning may raise an exception in a future release."
msgstr "`` primary_key = True``とマークされた列に加えて、class： `：.PrimaryKeyConstraint`内の列の混合を使用すると、リストが一致しない場合に警告が出力されるようになりました。フラグのみでマークされた列を無視する究極の動作は、下位互換性のために現在維持されています。この警告により、将来のリリースで例外が発生する可能性があります。"

#: of sqlalchemy.schema.PrimaryKeyConstraint:50
msgid ""
"For the use case where specific options are to be specified on the "
":class:`.PrimaryKeyConstraint`, but the usual style of using "
"``primary_key=True`` flags is still desirable, an empty "
":class:`.PrimaryKeyConstraint` may be specified, which will take on the "
"primary key column collection from the :class:`.Table` based on the "
"flags::"
msgstr "：class： `.PrimaryKeyConstraint`で特定のオプションを指定するユースケースについては、` `primary_key = True``フラグを使用する通常のスタイルは依然として望ましいです。空である：class：` .PrimaryKeyConstraint`は指定されたもので、これは：class： `.Table`からの主キー列のコレクションをフラグに基づいて受け取ります::"

#: of sqlalchemy.schema.PrimaryKeyConstraint:65
msgid ""
"an empty :class:`.PrimaryKeyConstraint` may now be specified for the "
"purposes of establishing keyword arguments with the constraint, "
"independently of the specification of \"primary key\" columns within the "
":class:`.Table` itself; columns marked as ``primary_key=True`` will be "
"gathered into the empty constraint's column collection."
msgstr "class :: `.Table`自体の中の\&quot;主キー\ &quot;カラムの指定とは無関係に、制約付きのキーワード引数を確立する目的で、空：class：`：.PrimaryKeyConstraint`を指定できるようになりました。 `` primary_key = True``とマークされた列は、空の制約の列コレクションに集められます。"

#: of sqlalchemy.schema.UniqueConstraint:1
msgid "A table-level UNIQUE constraint."
msgstr "表レベルのUNIQUE制約。"

#: of sqlalchemy.schema.UniqueConstraint:3
msgid ""
"Defines a single column or composite UNIQUE constraint. For a no-frills, "
"single column constraint, adding ``unique=True`` to the ``Column`` "
"definition is a shorthand equivalent for an unnamed, single column "
"UniqueConstraint."
msgstr "単一の列または複合UNIQUE制約を定義します。 `` Column``の定義に `` unique = True``を追加することは、名前のない単一の列UniqueConstraintの略語です。"

#: of sqlalchemy.schema.conv:1
msgid ""
"Mark a string indicating that a name has already been converted by a "
"naming convention."
msgstr "名前が既に命名規則によって変換されたことを示す文字列をマークします。"

#: of sqlalchemy.schema.conv:4
msgid ""
"This is a string subclass that indicates a name that should not be "
"subject to any further naming conventions."
msgstr "これは、それ以上の命名規則の対象にすべきではない名前を示す文字列サブクラスです。"

#: of sqlalchemy.schema.conv:7
msgid ""
"E.g. when we create a :class:`.Constraint` using a naming convention as "
"follows::"
msgstr "たとえば、次のような命名規則を使用して：class： `.Constraint`を作成します。"

#: of sqlalchemy.schema.conv:16
msgid ""
"The name of the above constraint will be rendered as ``\"ck_t_x5\"``. "
"That is, the existing name ``x5`` is used in the naming convention as the"
" ``constraint_name`` token."
msgstr "上記の制約の名前は `` \ &quot;ck_t_x5 \&quot; ``としてレンダリングされます。つまり、既存の `` x5``という名前が命名規則で `` constraint_name``トークンとして使われます。"

#: of sqlalchemy.schema.conv:20
msgid ""
"In some situations, such as in migration scripts, we may be rendering the"
" above :class:`.CheckConstraint` with a name that's already been "
"converted.  In order to make sure the name isn't double-modified, the new"
" name is applied using the :func:`.schema.conv` marker.  We can use this "
"explicitly as follows::"
msgstr "移行スクリプトのような状況では、クラス： `.CheckConstraint`を既に変換された名前でレンダリングしているかもしれません。名前が二重修飾されていないことを確認するために、新しい名前が：func： `.schema.conv`マーカーを使って適用されます。これを明示的に以下のように使用することができます::"

#: of sqlalchemy.schema.conv:33
msgid ""
"Where above, the :func:`.schema.conv` marker indicates that the "
"constraint name here is final, and the name will render as "
"``\"ck_t_x5\"`` and not ``\"ck_t_ck_t_x5\"``"
msgstr "上記の場合、：func： `.schema.conv`マーカは、ここでは制約名がfinalであり、名前は` `\&quot; ck_t_ck_t_x5 \ &quot;` `ではなく\&quot; ck_t_x5 \ &quot;` `としてレンダリングされることを示します。"

#: ../../core/constraints.rst:742
msgid "Indexes"
msgstr "インデックス"

#: ../../core/constraints.rst:744
msgid ""
"Indexes can be created anonymously (using an auto-generated name "
"``ix_<column label>``) for a single column using the inline ``index`` "
"keyword on :class:`~sqlalchemy.schema.Column`, which also modifies the "
"usage of ``unique`` to apply the uniqueness to the index itself, instead "
"of adding a separate UNIQUE constraint. For indexes with specific names "
"or which encompass more than one column, use the "
":class:`~sqlalchemy.schema.Index` construct, which requires a name."
msgstr "インデックスは匿名で作成できます（自動生成された名前 `` ix_ <column label> ``） `：`〜sqlalchemy.schema.Column`のインライン `` index``キーワードを使用して、単一の列に対して一意性を適用するために `` unique``の使用法を変更します別個のUNIQUE制約を追加する。特定の名前のインデックスや複数のカラムを含むインデックスの場合は、：class： `〜sqlalchemy.schema.Index`構文を使用します。これには名前が必要です。"

#: ../../core/constraints.rst:752
msgid ""
"Below we illustrate a :class:`~sqlalchemy.schema.Table` with several "
":class:`~sqlalchemy.schema.Index` objects associated. The DDL for "
"\"CREATE INDEX\" is issued right after the create statements for the "
"table:"
msgstr "以下にいくつかの：class： `〜sqlalchemy.schema.Index`オブジェクトが関連付けられた、class：`〜sqlalchemy.schema.Table`を示します。 \ &quot;CREATE INDEX \&quot;のDDLは、テーブルのcreate文の直後に発行されます。"

#: ../../core/constraints.rst:793
msgid ""
"Note in the example above, the :class:`.Index` construct is created "
"externally to the table which it corresponds, using :class:`.Column` "
"objects directly.  :class:`.Index` also supports \"inline\" definition "
"inside the :class:`.Table`, using string names to identify columns::"
msgstr "上記の例では、：class： `.Index`構造体は：class：` .Column`オブジェクトを直接使用して、対応するテーブルの外部に作成されています。 ：class： `.Index`は：class：` .Table`内の\ &quot;インライン\&quot;定義もサポートしています。"

#: ../../core/constraints.rst:815
msgid ""
"Support of \"inline\" definition inside the :class:`.Table` for "
":class:`.Index`\\ ."
msgstr "class： `.Index`のための：class：` .Table`の内部での\ &quot;インライン\&quot;定義のサポート。"

#: ../../core/constraints.rst:819
msgid ""
"The :class:`~sqlalchemy.schema.Index` object also supports its own "
"``create()`` method:"
msgstr "：class： `〜sqlalchemy.schema.Index`オブジェクトは独自の` `create（）` `メソッドもサポートしています："

#: ../../core/constraints.rst:830
msgid "Functional Indexes"
msgstr "機能インデックス"

#: ../../core/constraints.rst:832
msgid ""
":class:`.Index` supports SQL and function expressions, as supported by "
"the target backend.  To create an index against a column using a "
"descending value, the :meth:`.ColumnElement.desc` modifier may be used::"
msgstr "：class： `.Index`は、ターゲットバックエンドでサポートされているSQLと関数式をサポートしています。降順の値を使用して列に対してインデックスを作成するには、：meth： `.ColumnElement.desc`修飾子を使用することができます::"

#: ../../core/constraints.rst:840
msgid ""
"Or with a backend that supports functional indexes such as PostgreSQL, a "
"\"case insensitive\" index can be created using the ``lower()`` "
"function::"
msgstr "PostgreSQLなどの機能インデックスをサポートするバックエンドでは、 `` lower（） ``関数を使って\ &quot;大文字小文字を区別しない\&quot;インデックスを作成することができます::"

#: ../../core/constraints.rst:847
msgid ""
":class:`.Index` supports SQL expressions and functions as well as plain "
"columns."
msgstr "：class： `.Index`は、SQLの式と関数だけでなくプレーン列もサポートしています。"

#: ../../core/constraints.rst:851
msgid "Index API"
msgstr "インデックスAPI"

#: of sqlalchemy.schema.Index:1
msgid "A table-level INDEX."
msgstr "表レベルの索引。"

#: of sqlalchemy.schema.Index:3
msgid "Defines a composite (one or more column) INDEX."
msgstr "複合（1つ以上の列）INDEXを定義します。"

#: of sqlalchemy.schema.Index:14
msgid ""
"For a no-frills, single column index, adding :class:`.Column` also "
"supports ``index=True``::"
msgstr "no-frills、singleカラムインデックスの場合、class： `.Column`も` `index = True``をサポートしています::"

#: of sqlalchemy.schema.Index:21
msgid "For a composite index, multiple columns can be specified::"
msgstr "複合インデックスの場合、複数の列を指定できます::"

#: of sqlalchemy.schema.Index:25
msgid ""
"Functional indexes are supported as well, typically by using the "
":data:`.func` construct in conjunction with table-bound :class:`.Column` "
"objects::"
msgstr "機能インデックスもサポートされています。通常、table-bound：class： `.Column` objectsと組み合わせて：data：` .func`構造体を使用します。"

#: of sqlalchemy.schema.Index:31
msgid "support for functional and expression-based indexes."
msgstr "機能索引および式ベース索引のサポート。"

#: of sqlalchemy.schema.Index:33
msgid ""
"An :class:`.Index` can also be manually associated with a "
":class:`.Table`, either through inline declaration or using "
":meth:`.Table.append_constraint`.  When this approach is used, the names "
"of the indexed columns can be specified as strings::"
msgstr "An：class： `.Index`は、：class：` .Table`と手動で関連付けることもできます。インライン宣言、または：meth： `.Table.append_constraint`を使用します。この方法を使用すると、索引付けされた列の名前を文字列として指定できます。"

#: of sqlalchemy.schema.Index:44
msgid ""
"To support functional or expression-based indexes in this form, the "
":func:`.text` construct may be used::"
msgstr "この形式で関数型または式ベースの索引をサポートするには、：func： `.text`構文を使用することができます。"

#: of sqlalchemy.schema.Index:55
msgid ""
"the :func:`.text` construct may be used to specify :class:`.Index` "
"expressions, provided the :class:`.Index` is explicitly associated with "
"the :class:`.Table`."
msgstr "：class： `.Index`が：class：` .Table`に明示的に関連付けられている場合、：func： `.text`構造体は：class：` .Index`式を指定するために使われます。"

#: of sqlalchemy.schema.Index:62
msgid ":ref:`schema_indexes` - General information on :class:`.Index`."
msgstr "：ref： `schema_indexes`  -  class：` .Index`に関する一般情報です。"

#: of sqlalchemy.schema.Index:64
msgid ""
":ref:`postgresql_indexes` - PostgreSQL-specific options available for the"
" :class:`.Index` construct."
msgstr "：ref： `postgresql_indexes`  - ：class：` .Index`構造で利用可能なPostgreSQL固有のオプションです。"

#: of sqlalchemy.schema.Index:67
msgid ""
":ref:`mysql_indexes` - MySQL-specific options available for the "
":class:`.Index` construct."
msgstr "：ref： `mysql_indexes`  - ：class：` .Index`構造で使用できるMySQL固有のオプションです。"

#: of sqlalchemy.schema.Index:70
msgid ""
":ref:`mssql_indexes` - MSSQL-specific options available for the "
":class:`.Index` construct."
msgstr "：ref： `mssql_indexes`  - ：class：` .Index`構造で使用できるMSSQL固有のオプションです。"

#: of sqlalchemy.schema.Index.bind:1
msgid "Return the connectable associated with this Index."
msgstr "このインデックスに関連付けられた接続可能なオブジェクトを返します。"

#: of sqlalchemy.schema.Index.create:1
msgid ""
"Issue a ``CREATE`` statement for this :class:`.Index`, using the given "
":class:`.Connectable` for connectivity."
msgstr "接続のために与えられた：class： `.Connectable`を使用して、これに対して：class：` .Index`のための `` CREATE``ステートメントを発行してください。"

#: of sqlalchemy.schema.Index.create:7
msgid ":meth:`.MetaData.create_all`."
msgstr "：meth： `.MetaData.create_all`。"

#: of sqlalchemy.schema.Index.drop:1
msgid ""
"Issue a ``DROP`` statement for this :class:`.Index`, using the given "
":class:`.Connectable` for connectivity."
msgstr "接続のために与えられた：class： `.Connectable`を使用して、これに対して` `DROP``ステートメントを発行します：class：` .Index`。"

#: of sqlalchemy.schema.Index.drop:7
msgid ":meth:`.MetaData.drop_all`."
msgstr "：meth： `.MetaData.drop_all`。"


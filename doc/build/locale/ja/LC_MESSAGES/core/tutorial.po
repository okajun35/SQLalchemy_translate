# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../core/tutorial.rst:5
msgid "SQL Expression Language Tutorial"
msgstr "SQL式言語チュートリアル"

#: ../../core/tutorial.rst:7
msgid ""
"The SQLAlchemy Expression Language presents a system of representing "
"relational database structures and expressions using Python constructs. "
"These constructs are modeled to resemble those of the underlying database"
" as closely as possible, while providing a modicum of abstraction of the "
"various implementation differences between database backends. While the "
"constructs attempt to represent equivalent concepts between backends with"
" consistent structures, they do not conceal useful concepts that are "
"unique to particular subsets of backends. The Expression Language "
"therefore presents a method of writing backend-neutral SQL expressions, "
"but does not attempt to enforce that expressions are backend-neutral."
msgstr "SQLAlchemy Expression Languageは、Pythonの構造を使ってリレーショナルデータベースの構造と表現を表現するシステムを提供します。これらの構成は、データベースのバックエンド間のさまざまな実装の違いを抽象化しながら、できるだけ密接に基盤データベースのものに似せるようにモデル化されています。構築物は、一貫した構造を持つバックエンド間で同等の概念を表現しようとしますが、バックエンドの特定のサブセットに固有の有用な概念を隠すわけではありません。したがって、Expression Languageは、バックエンドに中立なSQL式を記述する方法を提供しますが、式がバックエンドに中立であることを強制しようとしません。"

#: ../../core/tutorial.rst:18
msgid ""
"The Expression Language is in contrast to the Object Relational Mapper, "
"which is a distinct API that builds on top of the Expression Language. "
"Whereas the ORM, introduced in :ref:`ormtutorial_toplevel`, presents a "
"high level and abstracted pattern of usage, which itself is an example of"
" applied usage of the Expression Language, the Expression Language "
"presents a system of representing the primitive constructs of the "
"relational database directly without opinion."
msgstr "Expression Languageは、Object Relational Mapperと対照的です。これは、Expression Languageの上に構築される個別のAPIです。 ：ref： `ormtutorial_toplevel`で導入されたORMは、高いレベルで抽象化された使用パターンを提示しますが、それ自体が表現言語の適用された使い方の例です。表現言語は、リレーショナルのプリミティブ構造を表すシステムを提示します意見なしで直接データベース。"

#: ../../core/tutorial.rst:26
msgid ""
"While there is overlap among the usage patterns of the ORM and the "
"Expression Language, the similarities are more superficial than they may "
"at first appear. One approaches the structure and content of data from "
"the perspective of a user-defined `domain model "
"<http://en.wikipedia.org/wiki/Domain_model>`_ which is transparently "
"persisted and refreshed from its underlying storage model. The other "
"approaches it from the perspective of literal schema and SQL expression "
"representations which are explicitly composed into messages consumed "
"individually by the database."
msgstr "ORMと表現言語の使用パターンには重複がありますが、類似点は最初に現れるよりも表面的です。ユーザ定義のドメインモデルの観点から、データの構造と内容にアプローチする<http://en.wikipedia.org/wiki/Domain_model> `_は透過的に永続化され、その基礎となるストレージモデルからリフレッシュされます。もう1つは、データベースによって個別に消費されるメッセージに明示的に構成されたリテラルスキーマとSQL式表現の観点からアプローチする方法です。"

#: ../../core/tutorial.rst:36
msgid ""
"A successful application may be constructed using the Expression Language"
" exclusively, though the application will need to define its own system "
"of translating application concepts into individual database messages and"
" from individual database result sets. Alternatively, an application "
"constructed with the ORM may, in advanced scenarios, make occasional "
"usage of the Expression Language directly in certain areas where specific"
" database interactions are required."
msgstr "アプリケーションの概念を個々のデータベースメッセージと個々のデータベース結果セットに変換する独自のシステムを定義する必要がありますが、エクスプレッション言語のみを使用してアプリケーションを構築することができます。あるいは、ORMで構築されたアプリケーションは、高度なシナリオでは、特定のデータベースのやりとりが必要な特定の領域で直接Expression Languageを使用することがあります。"

#: ../../core/tutorial.rst:44
msgid ""
"The following tutorial is in doctest format, meaning each ``>>>`` line "
"represents something you can type at a Python command prompt, and the "
"following text represents the expected return value. The tutorial has no "
"prerequisites."
msgstr "次のチュートリアルはdoctest形式です。つまり、 `` &gt;&gt;&gt; ``の行はPythonコマンドプロンプトで入力できるものを表し、次のテキストは期待される戻り値を表します。チュートリアルには前提条件はありません。"

#: ../../core/tutorial.rst:50
msgid "Version Check"
msgstr "バージョンチェック"

#: ../../core/tutorial.rst:53
msgid ""
"A quick check to verify that we are on at least **version 1.3** of "
"SQLAlchemy:"
msgstr "SQLAlchemyのバージョン1.3 **以上であることを確認するためのクイックチェック："

#: ../../core/tutorial.rst:62
msgid "Connecting"
msgstr "接続する"

#: ../../core/tutorial.rst:64
msgid ""
"For this tutorial we will use an in-memory-only SQLite database. This is "
"an easy way to test things without needing to have an actual database "
"defined anywhere. To connect we use :func:`~sqlalchemy.create_engine`:"
msgstr "このチュートリアルでは、メモリ内のSQLiteデータベースを使用します。これは、実際のデータベースをどこにでも定義する必要なく、物をテストする簡単な方法です。接続するには：func： `〜sqlalchemy.create_engine`："

#: ../../core/tutorial.rst:73
msgid ""
"The ``echo`` flag is a shortcut to setting up SQLAlchemy logging, which "
"is accomplished via Python's standard ``logging`` module. With it "
"enabled, we'll see all the generated SQL produced. If you are working "
"through this tutorial and want less output generated, set it to "
"``False``. This tutorial will format the SQL behind a popup window so it "
"doesn't get in our way; just click the \"SQL\" links to see what's being "
"generated."
msgstr "`` echo``フラグは、SQLAlchemyのロギングを設定するためのショートカットです。これは、Pythonの標準の `` logging``モジュールによって実現されます。これを有効にすると、生成されたすべての生成SQLが表示されます。このチュートリアルで作業しており、生成される出力が少なくてすむようなら、 `` False``に設定してください。このチュートリアルでは、SQLをポップアップウィンドウの後ろに書式設定して、私たちのやり方では得られないようにします。 \ &quot;SQL \&quot;リンクをクリックして、何が生成されているかを確認してください。"

#: ../../core/tutorial.rst:80
msgid ""
"The return value of :func:`.create_engine` is an instance of "
":class:`.Engine`, and it represents the core interface to the database, "
"adapted through a :term:`dialect` that handles the details of the "
"database and :term:`DBAPI` in use.  In this case the SQLite dialect will "
"interpret instructions to the Python built-in ``sqlite3`` module."
msgstr "：func： `.create_engine`の戻り値は：class：` .Engine`のインスタンスであり、データベースのコアインタフェースを表し、：term： `dialect`によって適合され、データベースの詳細を処理します。 ：term： `DBAPI`が使用中です。この場合、SQLiteダイアレクトはPythonの組み込み `` sqlite3``モジュールへの命令を解釈します。"

#: ../../core/tutorial.rst:89
msgid ""
"The :class:`.Engine`, when first returned by :func:`.create_engine`, has "
"not actually tried to connect to the database yet; that happens only the "
"first time it is asked to perform a task against the database."
msgstr "：class： `.Engine`は：func：` .create_engine`によって最初に返されたときに、まだデータベースに接続しようとしていません。これは、初めてデータベースに対してタスクを実行するように要求されたときにのみ発生します。"

#: ../../core/tutorial.rst:93
msgid ""
"The first time a method like :meth:`.Engine.execute` or "
":meth:`.Engine.connect` is called, the :class:`.Engine` establishes a "
"real :term:`DBAPI` connection to the database, which is then used to emit"
" the SQL."
msgstr "初めて：meth： `.Engine.execute`や：meth：` .Engine.connect`のようなメソッドが呼び出されると、class： `.Engine`はデータベースへのreal：term：` DBAPI`接続を確立します。これを使用してSQLを発行します。"

#: ../../core/tutorial.rst:99
msgid ""
":ref:`database_urls` - includes examples of :func:`.create_engine` "
"connecting to several kinds of databases with links to more information."
msgstr "：ref： `database_urls`  - いくつかの種類のデータベースに接続する：func：` .create_engine`の例を含んでいます。"

#: ../../core/tutorial.rst:103
msgid "Define and Create Tables"
msgstr "表の定義と作成"

#: ../../core/tutorial.rst:105
msgid ""
"The SQL Expression Language constructs its expressions in most cases "
"against table columns. In SQLAlchemy, a column is most often represented "
"by an object called :class:`~sqlalchemy.schema.Column`, and in all cases "
"a :class:`~sqlalchemy.schema.Column` is associated with a "
":class:`~sqlalchemy.schema.Table`. A collection of "
":class:`~sqlalchemy.schema.Table` objects and their associated child "
"objects is referred to as **database metadata**. In this tutorial we will"
" explicitly lay out several :class:`~sqlalchemy.schema.Table` objects, "
"but note that SA can also \"import\" whole sets of "
":class:`~sqlalchemy.schema.Table` objects automatically from an existing "
"database (this process is called **table reflection**)."
msgstr "SQL式言語は、ほとんどの場合、表の列に対して式を構成します。 SQLAlchemyでは、カラムはclass： `〜sqlalchemy.schema.Column`というオブジェクトで表現されることが最も多く、すべての場合にclass：`〜sqlalchemy.schema.Column`は：class： `〜 sqlalchemy.schema.Table`。 ：class： `〜sqlalchemy.schema.Table`オブジェクトとそれに関連する子オブジェクトのコレクションは、**データベースメタデータ**と呼ばれます。このチュートリアルでは、class： `〜sqlalchemy.schema.Table`オブジェクトを明示的にレイアウトしますが、SAは：class：`〜sqlalchemy.schema.Table`オブジェクトのセット全体を自動的に\ &quot;インポート\&quot;することもできます既存のデータベース（このプロセスを**表反映**と呼びます）。"

#: ../../core/tutorial.rst:117
msgid ""
"We define our tables all within a catalog called "
":class:`~sqlalchemy.schema.MetaData`, using the "
":class:`~sqlalchemy.schema.Table` construct, which resembles regular SQL "
"CREATE TABLE statements. We'll make two tables, one of which represents "
"\"users\" in an application, and another which represents zero or more "
"\"email addresses\" for each row in the \"users\" table:"
msgstr "通常のSQL CREATE TABLE文に似ている：class： `〜sqlalchemy.schema.Table`構文を使用して、class：`〜sqlalchemy.schema.MetaData`というカタログ内にテーブルを定義します。 2つのテーブルを作成します。そのうちの1つはアプリケーション内の\ &quot;users \&quot;を表し、もう1つは\ &quot;users \&quot;テーブルの各行の0以上の\ &quot;電子メールアドレス\&quot;を表します。"

#: ../../core/tutorial.rst:140
msgid ""
"All about how to define :class:`~sqlalchemy.schema.Table` objects, as "
"well as how to create them from an existing database automatically, is "
"described in :ref:`metadata_toplevel`."
msgstr "：class： `〜sqlalchemy.schema.Table`オブジェクトの定義方法と既存のデータベースから自動的に作成する方法については、ref：` metadata_toplevel`を参照してください。"

#: ../../core/tutorial.rst:144
msgid ""
"Next, to tell the :class:`~sqlalchemy.schema.MetaData` we'd actually like"
" to create our selection of tables for real inside the SQLite database, "
"we use :func:`~sqlalchemy.schema.MetaData.create_all`, passing it the "
"``engine`` instance which points to our database. This will check for the"
" presence of each table first before creating, so it's safe to call "
"multiple times:"
msgstr "次に、：class： `〜sqlalchemy.schema.MetaData`を伝えるために、私たちは実際にSQLiteデータベース内のテーブルの選択を作成したいと考えています：func：`〜sqlalchemy.schema.MetaData.create_all`、私たちのデータベースを指す `` engine``インスタンスを渡します。これは、作成する前に各テーブルの存在を最初にチェックするので、複数回呼び出しても安全です。"

#: ../../core/tutorial.rst:174
msgid ""
"Users familiar with the syntax of CREATE TABLE may notice that the "
"VARCHAR columns were generated without a length; on SQLite and "
"PostgreSQL, this is a valid datatype, but on others, it's not allowed. So"
" if running this tutorial on one of those databases, and you wish to use "
"SQLAlchemy to issue CREATE TABLE, a \"length\" may be provided to the "
":class:`~sqlalchemy.types.String` type as below::"
msgstr "CREATE TABLEの構文に精通しているユーザーは、VARCHAR列が長さなしで生成されたことに気付くことがあります。 SQLiteとPostgreSQLでは、これは有効なデータ型ですが、他のものでは許可されていません。したがって、これらのデータベースの1つでこのチュートリアルを実行し、SQLAlchemyを使用してCREATE TABLEを発行する場合は、以下のようにclass： `〜sqlalchemy.types.String`型に\&quot; length \ &quot;を指定することができます。"

#: ../../core/tutorial.rst:183
msgid ""
"The length field on :class:`~sqlalchemy.types.String`, as well as similar"
" precision/scale fields available on :class:`~sqlalchemy.types.Integer`, "
":class:`~sqlalchemy.types.Numeric`, etc. are not referenced by SQLAlchemy"
" other than when creating tables."
msgstr "長さフィールドは：class： `〜sqlalchemy.types.String`と同様の精度/スケールフィールドで利用できます：class：`〜sqlalchemy.types.Integer`、：class： `〜sqlalchemy.types.Numeric`、テーブルの作成時以外はSQLAlchemyによって参照されません。"

#: ../../core/tutorial.rst:187
msgid ""
"Additionally, Firebird and Oracle require sequences to generate new "
"primary key identifiers, and SQLAlchemy doesn't generate or assume these "
"without being instructed. For that, you use the "
":class:`~sqlalchemy.schema.Sequence` construct::"
msgstr "さらに、FirebirdとOracleは新しい主キー識別子を生成するためにシーケンスを必要とし、SQLAlchemyは指示されずにこれらを生成したり仮定したりしません。そのためには、：class： `〜sqlalchemy.schema.Sequence`コンストラクトを使用します："

#: ../../core/tutorial.rst:194
msgid "A full, foolproof :class:`~sqlalchemy.schema.Table` is therefore::"
msgstr "class： `〜sqlalchemy.schema.Table`は次のようになります::"

#: ../../core/tutorial.rst:203
msgid ""
"We include this more verbose :class:`~.schema.Table` construct separately"
" to highlight the difference between a minimal construct geared primarily"
" towards in-Python usage only, versus one that will be used to emit "
"CREATE TABLE statements on a particular set of backends with more "
"stringent requirements."
msgstr "主にin-Pythonの使用法のみを対象とした最小コンストラクトと、特定のセットのCREATE TABLE文を発行するために使用されるものとの違いを強調するために、このより詳細な：class： `〜.schema.Table`構造を個別に組み込みます。より厳しい要件のバックエンド。"

#: ../../core/tutorial.rst:212
msgid "Insert Expressions"
msgstr "式の挿入"

#: ../../core/tutorial.rst:214
msgid ""
"The first SQL expression we'll create is the "
":class:`~sqlalchemy.sql.expression.Insert` construct, which represents an"
" INSERT statement. This is typically created relative to its target "
"table::"
msgstr "最初に作成するSQL式は、：class： `〜sqlalchemy.sql.expression.Insert`です。これはINSERT文を表します。これは、通常、ターゲットテーブルに対して作成されます::"

#: ../../core/tutorial.rst:220
msgid ""
"To see a sample of the SQL this construct produces, use the ``str()`` "
"function::"
msgstr "この構文が生成するSQLのサンプルを見るには、 `` str（） ``関数を使います::"

#: ../../core/tutorial.rst:226
msgid ""
"Notice above that the INSERT statement names every column in the "
"``users`` table. This can be limited by using the ``values()`` method, "
"which establishes the VALUES clause of the INSERT explicitly::"
msgstr "上記のINSERTステートメントは、 `` users``テーブルのすべてのカラムに名前を付けています。これは、INSERTのVALUES句を明示的に確立する `` values（） ``メソッドを使うことで制限できます::"

#: ../../core/tutorial.rst:234
msgid ""
"Above, while the ``values`` method limited the VALUES clause to just two "
"columns, the actual data we placed in ``values`` didn't get rendered into"
" the string; instead we got named bind parameters. As it turns out, our "
"data *is* stored within our :class:`~sqlalchemy.sql.expression.Insert` "
"construct, but it typically only comes out when the statement is actually"
" executed; since the data consists of literal values, SQLAlchemy "
"automatically generates bind parameters for them. We can peek at this "
"data for now by looking at the compiled form of the statement::"
msgstr "上記の `` values``メソッドはVALUES句を2つのカラムに限定していましたが、 `` values``に置かれた実際のデータは文字列にレンダリングされませんでした。代わりに、名前付きのバインドパラメータが取得されます。実際には、私たちのデータ*は*：class： `〜sqlalchemy.sql.expression.Insert`構造体に格納されていますが、通常はその文が実際に実行されたときにのみ出力されます。データはリテラル値で構成されているため、SQLAlchemyは自動的にバインドパラメータを生成します。このデータは、コンパイルされた次のような文を見ればわかります。::"

#: ../../core/tutorial.rst:247
msgid "Executing"
msgstr "実行中"

#: ../../core/tutorial.rst:249
msgid ""
"The interesting part of an :class:`~sqlalchemy.sql.expression.Insert` is "
"executing it. In this tutorial, we will generally focus on the most "
"explicit method of executing a SQL construct, and later touch upon some "
"\"shortcut\" ways to do it. The ``engine`` object we created is a "
"repository for database connections capable of issuing SQL to the "
"database. To acquire a connection, we use the ``connect()`` method::"
msgstr "興味深い：class： `〜sqlalchemy.sql.expression.Insert`がそれを実行しています。このチュートリアルでは、一般に、SQL構造を実行する最も明白な方法に焦点を当て、後でそれを行うためのいくつかの &quot;ショートカット&quot;方法に触れます。作成した `` engine``オブジェクトは、SQLをデータベースに発行できるデータベース接続のリポジトリです。接続を取得するには、 `` connect（） ``メソッドを使用します::"

#: ../../core/tutorial.rst:260
msgid ""
"The :class:`~sqlalchemy.engine.Connection` object represents an actively "
"checked out DBAPI connection resource. Lets feed it our "
":class:`~sqlalchemy.sql.expression.Insert` object and see what happens:"
msgstr "：class： `〜sqlalchemy.engine.Connection`オブジェクトは、アクティブにチェックアウトされたDBAPI接続リソースを表します。 class： `〜sqlalchemy.sql.expression.Insert`オブジェクトをフィードし、何が起こるかを見てみましょう："

#: ../../core/tutorial.rst:271
msgid ""
"So the INSERT statement was now issued to the database. Although we got "
"positional \"qmark\" bind parameters instead of \"named\" bind parameters"
" in the output. How come ? Because when executed, the "
":class:`~sqlalchemy.engine.Connection` used the SQLite **dialect** to "
"help generate the statement; when we use the ``str()`` function, the "
"statement isn't aware of this dialect, and falls back onto a default "
"which uses named parameters. We can view this manually as follows:"
msgstr "そのため、INSERT文がデータベースに発行されました。出力の\ &quot;named \&quot;バインドパラメータの代わりに位置\ &quot;qmark \&quot;バインドパラメータを取得しましたが、どうして ？実行されると、：class： `〜sqlalchemy.engine.Connection`はSQLite **方言**を使ってステートメントを生成します。 `` str（） ``関数を使うと、このステートメントはこの方言を認識せず、名前付きパラメータを使うデフォルトに戻ります。これを手動で次のように表示できます。"

#: ../../core/tutorial.rst:285
msgid ""
"What about the ``result`` variable we got when we called ``execute()`` ? "
"As the SQLAlchemy :class:`~sqlalchemy.engine.Connection` object "
"references a DBAPI connection, the result, known as a "
":class:`~sqlalchemy.engine.ResultProxy` object, is analogous to the DBAPI"
" cursor object. In the case of an INSERT, we can get important "
"information from it, such as the primary key values which were generated "
"from our statement using :attr:`.ResultProxy.inserted_primary_key`:"
msgstr "`` execute（） ``と呼んだときに得た `` result``変数はどうでしょうか？ SQLAlchemy：class： `〜sqlalchemy.engine.Connection`オブジェクトはDBAPI接続を参照するため、a：class：`〜sqlalchemy.engine.ResultProxy`オブジェクトと呼ばれる結果はDBAPIカーソルオブジェクトに似ています。 INSERTの場合、ステートメントから生成された主キーの値（attr： `.ResultProxy.inserted_primary_key`）など、重要な情報を取得できます。"

#: ../../core/tutorial.rst:298
msgid ""
"The value of ``1`` was automatically generated by SQLite, but only "
"because we did not specify the ``id`` column in our "
":class:`~sqlalchemy.sql.expression.Insert` statement; otherwise, our "
"explicit value would have been used. In either case, SQLAlchemy always "
"knows how to get at a newly generated primary key value, even though the "
"method of generating them is different across different databases; each "
"database's :class:`~sqlalchemy.engine.interfaces.Dialect` knows the "
"specific steps needed to determine the correct value (or values; note "
"that :attr:`.ResultProxy.inserted_primary_key` returns a list so that it "
"supports composite primary keys).    Methods here range from using "
"``cursor.lastrowid``, to selecting from a database-specific function, to "
"using ``INSERT..RETURNING`` syntax; this all occurs transparently."
msgstr "`` 1``の値はSQLiteによって自動的に生成されましたが、class： `〜sqlalchemy.sql.expression.Insert`ステートメントで` `id``カラムを指定しなかったためです。それ以外の場合は、明示的な値が使用されます。どちらの場合でも、SQLAlchemyは、新しく生成された主キー値を取得する方法を常に知っています。各データベースのclass： `〜sqlalchemy.engine.interfaces.Dialect`は、正しい値（または値; attr：` .ResultProxy.inserted_primary_key`）が複合主キーをサポートするようにリストを返します）。ここでのメソッドには、 `` cursor.lastrowid``からデータベース固有の関数から `` INSERT..RETURNING``構文の使用までの範囲があります。これはすべて透過的に行われます。"

#: ../../core/tutorial.rst:314
msgid "Executing Multiple Statements"
msgstr "複数のステートメントの実行"

#: ../../core/tutorial.rst:316
msgid ""
"Our insert example above was intentionally a little drawn out to show "
"some various behaviors of expression language constructs. In the usual "
"case, an :class:`~sqlalchemy.sql.expression.Insert` statement is usually "
"compiled against the parameters sent to the ``execute()`` method on "
":class:`~sqlalchemy.engine.Connection`, so that there's no need to use "
"the ``values`` keyword with :class:`~sqlalchemy.sql.expression.Insert`. "
"Lets create a generic :class:`~sqlalchemy.sql.expression.Insert` "
"statement again and use it in the \"normal\" way:"
msgstr "上記の挿入例は、意図的に表現言語構造の様々な振る舞いを示すために描かれたものです。普通の場合、class： `〜sqlalchemy.sql.expression.Insert`文は通常、class：`〜sqlalchemy.engine.Connection`の `` execute（） ``メソッドに送られるパラメータに対してコンパイルされます。 class： `〜sqlalchemy.sql.expression.Insert`で` `values``キーワードを使う必要はありません。 `〜sqlalchemy.sql.expression.Insert`ステートメントを再度作成し、それを\&quot;通常の\ &quot;という形で使用します："

#: ../../core/tutorial.rst:334
msgid ""
"Above, because we specified all three columns in the ``execute()`` "
"method, the compiled :class:`~.expression.Insert` included all three "
"columns. The :class:`~.expression.Insert` statement is compiled at "
"execution time based on the parameters we specified; if we specified "
"fewer parameters, the :class:`~.expression.Insert` would have fewer "
"entries in its VALUES clause."
msgstr "上記では、 `` execute（） ``メソッドで3つのカラムをすべて指定したため、コンパイルされた：class： `〜.expression.Insert`には3つのカラムがすべて含まれていました。 ：class： `〜.expression.Insert`文は、指定されたパラメータに基づいて実行時にコンパイルされます。より少ないパラメータを指定すると、：class： `〜.expression.Insert`はそのVALUES句に含まれるエントリが少なくなります。"

#: ../../core/tutorial.rst:341
msgid ""
"To issue many inserts using DBAPI's ``executemany()`` method, we can send"
" in a list of dictionaries each containing a distinct set of parameters "
"to be inserted, as we do here to add some email addresses:"
msgstr "DBAPIの `` executemany（） ``メソッドを使って多くのインサートを発行するには、いくつかの電子メールアドレスを追加するために、挿入する個別のパラメータセットを含むディクショナリのリストを送ることができます："

#: ../../core/tutorial.rst:358
msgid ""
"Above, we again relied upon SQLite's automatic generation of primary key "
"identifiers for each ``addresses`` row."
msgstr "上記では、各「アドレス」行のSQLiteの主キー識別子の自動生成に再び依存しました。"

#: ../../core/tutorial.rst:361
msgid ""
"When executing multiple sets of parameters, each dictionary must have the"
" **same** set of keys; i.e. you cant have fewer keys in some dictionaries"
" than others. This is because the "
":class:`~sqlalchemy.sql.expression.Insert` statement is compiled against "
"the **first** dictionary in the list, and it's assumed that all "
"subsequent argument dictionaries are compatible with that statement."
msgstr "複数のパラメータセットを実行する場合、各辞書に**同じ**キーセットが必要です。つまり、ある辞書では他の辞書より少ないキーしか持っていません。これは、：class： `〜sqlalchemy.sql.expression.Insert`ステートメントがリストの**最初の**ディクショナリに対してコンパイルされているためで、後続のすべての引数ディクショナリがそのステートメントと互換性があると仮定しています。"

#: ../../core/tutorial.rst:368
msgid ""
"The \"executemany\" style of invocation is available for each of the "
":func:`.insert`, :func:`.update` and :func:`.delete` constructs."
msgstr "\ &quot;executemany \&quot;スタイルの呼び出しは：func： `.insert`、：func：` .update`と：func： `.delete`の各構文で利用できます。"

#: ../../core/tutorial.rst:375
msgid "Selecting"
msgstr "選択"

#: ../../core/tutorial.rst:377
msgid ""
"We began with inserts just so that our test database had some data in it."
" The more interesting part of the data is selecting it! We'll cover "
"UPDATE and DELETE statements later. The primary construct used to "
"generate SELECT statements is the :func:`.select` function:"
msgstr "私たちは、テストデータベースにデータが入っているように、挿入を開始しました。より興味深いのは、データを選択することです！後でUPDATEとDELETE文について説明します。 SELECT文を生成するために使用される主な構文は、：func： `.select`関数です："

#: ../../core/tutorial.rst:391
msgid ""
"Above, we issued a basic :func:`.select` call, placing the ``users`` "
"table within the COLUMNS clause of the select, and then executing. "
"SQLAlchemy expanded the ``users`` table into the set of each of its "
"columns, and also generated a FROM clause for us. The result returned is "
"again a :class:`~sqlalchemy.engine.ResultProxy` object, which acts much "
"like a DBAPI cursor, including methods such as "
":func:`~sqlalchemy.engine.ResultProxy.fetchone` and "
":func:`~sqlalchemy.engine.ResultProxy.fetchall`. The easiest way to get "
"rows from it is to just iterate:"
msgstr "上では、basic：func： `.select`コールを発行し、selectのCOLUMNS句に` `users``テーブルを置き、実行しました。 SQLAlchemyは、 `` users``テーブルを各カラムのセットに展開し、FROM句を生成しました。返される結果は、再び：class： `〜sqlalchemy.engine.ResultProxy`オブジェクトです。このオブジェクトは、func：`〜sqlalchemy.engine.ResultProxy.fetchone`や：func： `〜などのメソッドを含むDBAPIカーソルとよく似た働きをします。 sqlalchemy.engine.ResultProxy.fetchall`。行を取得する最も簡単な方法は、反復処理だけです。"

#: ../../core/tutorial.rst:408
msgid ""
"Above, we see that printing each row produces a simple tuple-like result."
" We have more options at accessing the data in each row. One very common "
"way is through dictionary access, using the string names of columns:"
msgstr "上記のように、各行を印刷すると単純なタプルのような結果が得られることがわかります。各行のデータにアクセスする際の選択肢が増えました。非常に一般的な方法の1つは、列の文字列名を使用した辞書アクセスによるものです。"

#: ../../core/tutorial.rst:423
msgid "Integer indexes work as well:"
msgstr "整数インデックスも同様に動作します。"

#: ../../core/tutorial.rst:431
msgid ""
"But another way, whose usefulness will become apparent later on, is to "
"use the :class:`~sqlalchemy.schema.Column` objects directly as keys:"
msgstr "しかし、後で明白になる別の方法は：class： `〜sqlalchemy.schema.Column`オブジェクトをキーとして直接使うことです："

#: ../../core/tutorial.rst:444
msgid ""
"Result sets which have pending rows remaining should be explicitly closed"
" before discarding. While the cursor and connection resources referenced "
"by the :class:`~sqlalchemy.engine.ResultProxy` will be respectively "
"closed and returned to the connection pool when the object is garbage "
"collected, it's better to make it explicit as some database APIs are very"
" picky about such things:"
msgstr "保留中の行が残っている結果セットは、破棄する前に明示的に閉じておく必要があります。 ：class： `〜sqlalchemy.engine.ResultProxy`で参照されるカーソルと接続リソースは、オブジェクトがガベージコレクトされたときに閉じられ、接続プールに返されますが、一部のデータベースAPIは非常に厄介なので、そのようなことについて："

#: ../../core/tutorial.rst:455
msgid ""
"If we'd like to more carefully control the columns which are placed in "
"the COLUMNS clause of the select, we reference individual "
":class:`~sqlalchemy.schema.Column` objects from our "
":class:`~sqlalchemy.schema.Table`. These are available as named "
"attributes off the ``c`` attribute of the "
":class:`~sqlalchemy.schema.Table` object:"
msgstr "selectのCOLUMNS節に置かれているカラムをもっと慎重に制御したい場合は、class： `〜sqlalchemy.schema.Column`オブジェクトをindividual：class：`〜sqlalchemy.schema.Table`から参照します。 。これらは、class： `〜sqlalchemy.schema.Table`オブジェクトの` `c``属性から名前付き属性として利用できます："

#: ../../core/tutorial.rst:473
msgid ""
"Lets observe something interesting about the FROM clause. Whereas the "
"generated statement contains two distinct sections, a \"SELECT columns\" "
"part and a \"FROM table\" part, our :func:`.select` construct only has a "
"list containing columns. How does this work ? Let's try putting *two* "
"tables into our :func:`.select` statement:"
msgstr "FROM句に関する興味深いことを観察できます。生成されたステートメントは2つの異なるセクション、すなわち &quot;SELECT columns&quot;部分と &quot;FROM table&quot;部分を含んでいますが、私たちの：func： `.select`構造は列を含むリストしか持っていません。これはどのように作動しますか ？ func： `.select`ステートメントに* 2つのテーブルを入れてみましょう："

#: ../../core/tutorial.rst:495
msgid ""
"It placed **both** tables into the FROM clause. But also, it made a real "
"mess. Those who are familiar with SQL joins know that this is a "
"**Cartesian product**; each row from the ``users`` table is produced "
"against each row from the ``addresses`` table. So to put some sanity into"
" this statement, we need a WHERE clause.  We do that using "
":meth:`.Select.where`:"
msgstr "**両方の**テーブルをFROM句に入れました。しかしまた、それは本当の混乱を作りました。 SQLに慣れている人は、これが**デカルト製品**であることを知っています。 `` users``テーブルの各行は `` addresses``テーブルの各行に対して生成されます。したがって、この文にいくつかの正気を置くためには、WHERE句が必要です。これを行うには：meth： `.Select.where`："

#: ../../core/tutorial.rst:516
msgid ""
"So that looks a lot better, we added an expression to our :func:`.select`"
" which had the effect of adding ``WHERE users.id = addresses.user_id`` to"
" our statement, and our results were managed down so that the join of "
"``users`` and ``addresses`` rows made sense. But let's look at that "
"expression? It's using just a Python equality operator between two "
"different :class:`~sqlalchemy.schema.Column` objects. It should be clear "
"that something is up. Saying ``1 == 1`` produces ``True``, and ``1 == 2``"
" produces ``False``, not a WHERE clause. So lets see exactly what that "
"expression is doing:"
msgstr "だからもっと良く見えるように、私たちはfunc： `.select`に式を追加しました。これは` `WHERE users.id = addresses.user_id``を文に追加する効果があり、結果は`` users``と `` addresses``行の結合が意味を成していました。しかし、その表現を見てみましょうか？ 2つの異なるクラス： `〜sqlalchemy.schema.Column`オブジェクトの間でPythonの等価演算子を使用しています。何かが起こっていることは明らかです。 `` 1 == 1``は `` True``を出力し、 `` 1 == 2``はWHERE句ではなく `` False``を出力します。その表現が何をしているのかを正確に見ることができます："

#: ../../core/tutorial.rst:530
msgid ""
"Wow, surprise ! This is neither a ``True`` nor a ``False``. Well what is "
"it ?"
msgstr "うわー、驚き！これは「真」でも「偽」でもない。まあそれは何ですか？"

#: ../../core/tutorial.rst:537
msgid ""
"As you can see, the ``==`` operator is producing an object that is very "
"much like the :class:`~.expression.Insert` and :func:`.select` objects "
"we've made so far, thanks to Python's ``__eq__()`` builtin; you call "
"``str()`` on it and it produces SQL. By now, one can see that everything "
"we are working with is ultimately the same type of object. SQLAlchemy "
"terms the base class of all of these expressions as "
":class:`~.expression.ColumnElement`."
msgstr "ご覧のとおり、 `` == ``演算子は、これまでのところ、class： `〜.expression.Insert`と：func：` .select`オブジェクトに非常によく似たオブジェクトを生成しています。ありがとうPythonの `` __eq __（） ``に組み込みます。あなたは `` str（） ``を呼び出してSQLを生成します。ここまでで、作業しているものはすべて最終的に同じタイプのオブジェクトであることがわかります。 SQLAlchemyは、これらすべての式の基本クラスをclass： `〜.expression.ColumnElement`と呼びます。"

#: ../../core/tutorial.rst:545
msgid "Operators"
msgstr "演算子"

#: ../../core/tutorial.rst:547
msgid ""
"Since we've stumbled upon SQLAlchemy's operator paradigm, let's go "
"through some of its capabilities. We've seen how to equate two columns to"
" each other:"
msgstr "SQLAlchemyの演算子パラダイムを見つけたので、いくつかの機能を試してみましょう。 2つの列を相互に等しくする方法を見てきました。"

#: ../../core/tutorial.rst:555
msgid ""
"If we use a literal value (a literal meaning, not a SQLAlchemy clause "
"object), we get a bind parameter:"
msgstr "リテラル値（SQLAlchemy句オブジェクトではなく文字通りの意味）を使用すると、バインドパラメータが取得されます。"

#: ../../core/tutorial.rst:563
msgid ""
"The ``7`` literal is embedded the resulting "
":class:`~.expression.ColumnElement`; we can use the same trick we did "
"with the :class:`~sqlalchemy.sql.expression.Insert` object to see it:"
msgstr "`` 7``リテラルは次のように埋め込まれます：class： `〜.expression.ColumnElement`; ：class： `〜sqlalchemy.sql.expression.Insert`オブジェクトを使って同じトリックを使用することができます："

#: ../../core/tutorial.rst:572
msgid ""
"Most Python operators, as it turns out, produce a SQL expression here, "
"like equals, not equals, etc.:"
msgstr "ほとんどのPython演算子は、equals、equalsなどのように、ここにSQL式を生成します。"

#: ../../core/tutorial.rst:588
msgid "If we add two integer columns together, we get an addition expression:"
msgstr "2つの整数列を加算すると、加算式が得られます。"

#: ../../core/tutorial.rst:595
msgid ""
"Interestingly, the type of the :class:`~sqlalchemy.schema.Column` is "
"important! If we use ``+`` with two string based columns (recall we put "
"types like :class:`~sqlalchemy.types.Integer` and "
":class:`~sqlalchemy.types.String` on our "
":class:`~sqlalchemy.schema.Column` objects at the beginning), we get "
"something different:"
msgstr "興味深いことに、：class： `〜sqlalchemy.schema.Column`の型は重要です！ 2つの文字列ベースの列を持つ `` + ``を使用する場合（class： `〜sqlalchemy.types.Integer`と：class：`〜sqlalchemy.types.String`のような型をクラス： `〜sqlalchemy最初に.schema.Column`オブジェクト）、私たちは何か違うものを得ます："

#: ../../core/tutorial.rst:606
msgid ""
"Where ``||`` is the string concatenation operator used on most databases."
" But not all of them. MySQL users, fear not:"
msgstr "`` || ``はほとんどのデータベースで使用される文字列連結演算子です。しかし、それらのすべてではありません。 MySQLのユーザーは、恐れていない："

#: ../../core/tutorial.rst:615
msgid ""
"The above illustrates the SQL that's generated for an "
":class:`~sqlalchemy.engine.Engine` that's connected to a MySQL database; "
"the ``||`` operator now compiles as MySQL's ``concat()`` function."
msgstr "上の例は、MySQLデータベースに接続されている：class： `〜sqlalchemy.engine.Engine`に対して生成されたSQLを示しています。 `` || ``演算子はMySQLの `` concat（） ``関数としてコンパイルされるようになりました。"

#: ../../core/tutorial.rst:619
msgid ""
"If you have come across an operator which really isn't available, you can"
" always use the :meth:`.Operators.op` method; this generates whatever "
"operator you need:"
msgstr "実際に利用できない演算子を見つけた場合は、常に：meth： `.Operators.op`メソッドを使用できます。必要な演算子を生成します。"

#: ../../core/tutorial.rst:627
msgid ""
"This function can also be used to make bitwise operators explicit. For "
"example::"
msgstr "この関数は、ビット演算子を明示的にするためにも使用できます。例えば：："

#: ../../core/tutorial.rst:631
msgid "is a bitwise AND of the value in ``somecolumn``."
msgstr "`` somecolumn``の値のビット単位のANDです。"

#: ../../core/tutorial.rst:633
msgid ""
"When using :meth:`.Operators.op`, the return type of the expression may "
"be important, especialy when the operator is used in an expression that "
"will be sent as a result column.   For this case, be sure to make the "
"type explicit, if not what's normally expected, using "
":func:`.type_coerce`::"
msgstr "：meth： `.Operators.op`を使用する場合、演算子が結果列として送られる式で使用されるときは、式の戻り値の型が重要になります。この場合、通常どおりでない場合は、型を明示的に明示してください：func： `.type_coerce` ::"

#: ../../core/tutorial.rst:643
msgid ""
"For boolean operators, use the :meth:`.Operators.bool_op` method, which "
"will ensure that the return type of the expression is handled as "
"boolean::"
msgstr "ブール演算子の場合は、：meth： `.Operators.bool_op`メソッドを使用します。これにより、式の戻り値の型がboolean ::として扱われます"

#: ../../core/tutorial.rst:648
msgid "Added the :meth:`.Operators.bool_op` method."
msgstr "：meth： `.Operators.bool_op`メソッドを追加しました。"

#: ../../core/tutorial.rst:651
msgid "Operator Customization"
msgstr "オペレータのカスタマイズ"

#: ../../core/tutorial.rst:653
msgid ""
"While :meth:`.Operators.op` is handy to get at a custom operator in a "
"hurry, the Core supports fundamental customization and extension of the "
"operator system at the type level.   The behavior of existing operators "
"can be modified on a per-type basis, and new operations can be defined "
"which become available for all column expressions that are part of that "
"particular type.  See the section :ref:`types_operators` for a "
"description."
msgstr "急いでカスタムオペレータを得るには：meth： `.Operators.op`が便利ですが、コアはタイプレベルでのオペレータシステムの基本的なカスタマイズと拡張をサポートします。既存の演算子の動作は、型ごとに変更することができ、新しい演算を定義して、その特定の型の一部であるすべての列式で使用できるようにすることができます。説明については：ref： `types_operators`を参照してください。"

#: ../../core/tutorial.rst:663
msgid "Conjunctions"
msgstr "結合詞"

#: ../../core/tutorial.rst:666
msgid ""
"We'd like to show off some of our operators inside of :func:`.select` "
"constructs. But we need to lump them together a little more, so let's "
"first introduce some conjunctions. Conjunctions are those little words "
"like AND and OR that put things together. We'll also hit upon NOT. "
":func:`.and_`, :func:`.or_`, and :func:`.not_` can work from the "
"corresponding functions SQLAlchemy provides (notice we also throw in a "
":meth:`~.ColumnOperators.like`):"
msgstr "我々は、func： `.select`構造体の中にいくつかの演算子を披露したいと思います。しかし、もう少しまとめる必要があるので、最初に接続詞を紹介しましょう。結合詞は、物事をまとめるANDやORのような小さな言葉です。我々はまた、NOTに当てるでしょう。 ：func： `.and_`、：func：` .or_`、そして：func： `.not_`は、SQLAlchemyが提供する対応する関数から動作することができます（：meth：`〜.ColumnOperators.like`） ："

#: ../../core/tutorial.rst:692
msgid ""
"And you can also use the re-jiggered bitwise AND, OR and NOT operators, "
"although because of Python operator precedence you have to watch your "
"parenthesis:"
msgstr "また、リジグされたビット単位のAND、OR、およびNOT演算子を使用することもできます。ただし、演​​算子の優先順位がPythonのため、カッコを見る必要があります。"

#: ../../core/tutorial.rst:710
msgid ""
"So with all of this vocabulary, let's select all users who have an email "
"address at AOL or MSN, whose name starts with a letter between \"m\" and "
"\"z\", and we'll also generate a column containing their full name "
"combined with their email address. We will add two new constructs to this"
" statement, :meth:`~.ColumnOperators.between` and "
":meth:`~.ColumnElement.label`. :meth:`~.ColumnOperators.between` produces"
" a BETWEEN clause, and :meth:`~.ColumnElement.label` is used in a column "
"expression to produce labels using the ``AS`` keyword; it's recommended "
"when selecting from expressions that otherwise would not have a name:"
msgstr "したがって、このすべての語彙では、AOLまたはMSNのメールアドレスを持つすべてのユーザーを選択しましょう。名前は\ &quot;m \&quot;と\ &quot;z \&quot;の間の文字で始まり、フルネームとメールアドレスを組み合わせたものです。この文には、meth： `〜.ColumnOperators.between`と：meth：`〜.ColumnElement.label`の2つの新しい構造体を追加します。 ：meth： `〜.ColumnOperators.between`はBETWEEN句を生成し、` `AS``キーワードを使ってラベルを生成するために：meth：`〜.ColumnElement.label`を列式で使用します。それ以外の場合は名前を持たない式から選択することをお勧めします："

#: ../../core/tutorial.rst:743
msgid ""
"Once again, SQLAlchemy figured out the FROM clause for our statement. In "
"fact it will determine the FROM clause based on all of its other bits; "
"the columns clause, the where clause, and also some other elements which "
"we haven't covered yet, which include ORDER BY, GROUP BY, and HAVING."
msgstr "もう一度、SQLAlchemyは私たちのステートメントのFROM句を見つけました。実際には、他のすべてのビットに基づいてFROM句を決定します。 columns句、where句、およびORDER BY、GROUP BY、およびHAVINGを含むまだ扱っていない他の要素が含まれています。"

#: ../../core/tutorial.rst:748
msgid ""
"A shortcut to using :func:`.and_` is to chain together multiple "
":meth:`~.Select.where` clauses.   The above can also be written as:"
msgstr "：func： `.and_`を使うショートカットは、複数の：meth：`〜.Select.where`節を連鎖することです。上記は次のように書くこともできます："

#: ../../core/tutorial.rst:772
msgid ""
"The way that we can build up a :func:`.select` construct through "
"successive method calls is called :term:`method chaining`."
msgstr "連続するメソッド呼び出しを通じてa：func： `.select`構造を構築する方法は、term：` method chaining`と呼ばれます。"

#: ../../core/tutorial.rst:778
msgid "Using Textual SQL"
msgstr "テキストSQLの使用"

#: ../../core/tutorial.rst:780
msgid ""
"Our last example really became a handful to type. Going from what one "
"understands to be a textual SQL expression into a Python construct which "
"groups components together in a programmatic style can be hard. That's "
"why SQLAlchemy lets you just use strings, for those cases when the SQL is"
" already known and there isn't a strong need for the statement to support"
" dynamic features.  The :func:`~.expression.text` construct is used to "
"compose a textual statement that is passed to the database mostly "
"unchanged.  Below, we create a :func:`~.expression.text` object and "
"execute it:"
msgstr "私たちの最後の例は実際には少数になりました。理解しているものをテキストのSQL式にすることから、プログラマチックなスタイルでコンポーネントをグループ化するPythonの構造に移行するのは難しいでしょう。そのため、SQLAlchemyでは、SQLがすでにわかっており、ステートメントが動的機能をサポートする必要がない場合に、文字列を使用できます。 ：func： `〜.expression.text`構文は、ほとんど変更されていないデータベースに渡されるテキスト文を作成するために使用されます。以下に、：func： `〜.expression.text`オブジェクトを作成して実行します："

#: ../../core/tutorial.rst:807
msgid ""
"Above, we can see that bound parameters are specified in "
":func:`~.expression.text` using the named colon format; this format is "
"consistent regardless of database backend.  To send values in for the "
"parameters, we passed them into the :meth:`~.Connection.execute` method "
"as additional arguments."
msgstr "上記では、バインドされたパラメータが、指定されたコロン形式を使用して：func： `〜.expression.text`で指定されていることがわかります。この形式は、データベースのバックエンドに関係なく一貫しています。パラメータの値を送るために、それらを追加の引数として：meth： `〜.Connection.execute`メソッドに渡しました。"

#: ../../core/tutorial.rst:814
msgid "Specifying Bound Parameter Behaviors"
msgstr "バウンドパラメータビヘイビアの指定"

#: ../../core/tutorial.rst:816
msgid ""
"The :func:`~.expression.text` construct supports pre-established bound "
"values using the :meth:`.TextClause.bindparams` method::"
msgstr "：func： `〜.expression.text`構造体は、：meth：` .TextClause.bindparams`メソッドを使って事前に設定されたバウンド値をサポートします::"

#: ../../core/tutorial.rst:822
msgid "The parameters can also be explicitly typed::"
msgstr "パラメータは明示的にタイプすることもできます::"

#: ../../core/tutorial.rst:827
msgid ""
"Typing for bound parameters is necessary when the type requires Python-"
"side or special SQL-side processing provided by the datatype."
msgstr "型がデータ型によって提供されるPython側または特別なSQL側の処理を必要とする場合、バインドされたパラメータの型指定が必要です。"

#: ../../core/tutorial.rst:832
msgid ":meth:`.TextClause.bindparams` - full method description"
msgstr "：meth： `.TextClause.bindparams`  - 完全なメソッドの説明"

#: ../../core/tutorial.rst:837
msgid "Specifying Result-Column Behaviors"
msgstr "結果列ビヘイビアの指定"

#: ../../core/tutorial.rst:839
msgid ""
"We may also specify information about the result columns using the "
":meth:`.TextClause.columns` method; this method can be used to specify "
"the return types, based on name::"
msgstr "結果の列に関する情報は、：meth： `.TextClause.columns`メソッドを使って指定することもできます。このメソッドは、名前に基づいて戻り値の型を指定するために使用できます::"

#: ../../core/tutorial.rst:845
msgid ""
"or it can be passed full column expressions positionally, either typed or"
" untyped.  In this case it's a good idea to list out the columns "
"explicitly within our textual SQL, since the correlation of our column "
"expressions to the SQL will be done positionally::"
msgstr "または、型指定されたものと型なしのもののいずれかを、位置的に完全な列式に渡すことができます。この場合、私たちの列式のSQLへの相関関係は位置的に行われるので、テキスト形式のSQL内で明示的に列を列挙することをお勧めします::"

#: ../../core/tutorial.rst:853
msgid ""
"When we call the :meth:`.TextClause.columns` method, we get back a "
":class:`.TextAsFrom` object that supports the full suite of "
":attr:`.TextAsFrom.c` and other \"selectable\" operations::"
msgstr "：meth： `.TextClause.columns`メソッドを呼び出すと、attr：` .TextAsFrom.c`と他の\ &quot;selectable \&quot;オペレーションをサポートする：class： `.TextAsFrom`オブジェクトが返されます::"

#: ../../core/tutorial.rst:862
msgid ""
"The positional form of :meth:`.TextClause.columns` is particularly useful"
" when relating textual SQL to existing Core or ORM models, because we can"
" use column expressions directly without worrying about name conflicts or"
" other issues with the result column names in the textual SQL:"
msgstr "位置形式の：meth： `.TextClause.columns`は、テキストのSQLを既存のCoreまたはORMモデルに関連付けるときに特に便利です。これは、名前の競合やテキストの結果列名に関するその他の問題を気にせずに列式を直接使用できるためですSQL："

#: ../../core/tutorial.rst:886
msgid ""
"Above, there's three columns in the result that are named \"id\", but "
"since we've associated these with column expressions positionally, the "
"names aren't an issue when the result-columns are fetched using the "
"actual column object as a key. Fetching the ``email_address`` column "
"would be::"
msgstr "上の例では、\ &quot;id \&quot;という名前の3つの列がありますが、これらを列式と位置的に関連付けているので、実際の列オブジェクトを使用して結果列を取得したときの名前は問題になりませんキー。 `` email_address``カラムを取得することは::"

#: ../../core/tutorial.rst:895
msgid ""
"If on the other hand we used a string column key, the usual rules of "
"name- based matching still apply, and we'd get an ambiguous column error "
"for the ``id`` value::"
msgstr "一方、文字列の列キーを使用した場合、名前ベースの照合の通常の規則が適用され、 `` id``値に対してあいまいな列エラーが発生します::"

#: ../../core/tutorial.rst:904
msgid ""
"It's important to note that while accessing columns from a result set "
"using :class:`.Column` objects may seem unusual, it is in fact the only "
"system used by the ORM, which occurs transparently beneath the facade of "
"the :class:`~.orm.query.Query` object; in this way, the "
":meth:`.TextClause.columns` method is typically very applicable to "
"textual statements to be used in an ORM context.   The example at "
":ref:`orm_tutorial_literal_sql` illustrates a simple usage."
msgstr "：class： `.Column`オブジェクトを使った結果セットからのカラムへのアクセスは珍しいように見えるかもしれませんが、ORMによって使用される唯一のシステムで、class：`〜 .orm.query.Query`オブジェクト;このように、：meth： `.TextClause.columns`メソッドは、通常、ORMコンテキストで使用されるテキスト文に非常に適用されます。 ：ref： `orm_tutorial_literal_sql`の例は簡単な使い方を示しています。"

#: ../../core/tutorial.rst:914
msgid ""
"The :meth:`.TextClause.columns` method now accepts column expressions "
"which will be matched positionally to a plain text SQL result set, "
"eliminating the need for column names to match or even be unique in the "
"SQL statement when matching table metadata or ORM models to textual SQL."
msgstr "：meth： `.TextClause.columns`メソッドは、テーブルのメタデータまたはORMを一致させるときに、SQL文で列名が一致する必要がなくなるか、またはSQL文中で一意でなくても、プレーンテキストのSQL結果セットと位置的に一致する列式を受け入れるようになりましたモデルをテキストSQLに変換します。"

#: ../../core/tutorial.rst:921
msgid ":meth:`.TextClause.columns` - full method description"
msgstr "：meth： `.TextClause.columns`  - 完全なメソッドの説明"

#: ../../core/tutorial.rst:923
msgid ""
":ref:`orm_tutorial_literal_sql` - integrating ORM-level queries with "
":func:`.text`"
msgstr "：ref： `orm_tutorial_literal_sql`  -  ORMレベルのクエリを：func：` .text`と統合する"

#: ../../core/tutorial.rst:928
msgid "Using text() fragments inside bigger statements"
msgstr "より大きな文の中でのtext（）フラグメントの使用"

#: ../../core/tutorial.rst:930
msgid ""
":func:`~.expression.text` can also be used to produce fragments of SQL "
"that can be freely within a :func:`~.expression.select` object, which "
"accepts :func:`~.expression.text` objects as an argument for most of its "
"builder functions. Below, we combine the usage of "
":func:`~.expression.text` within a :func:`.select` object.  The "
":func:`~.expression.select` construct provides the \"geometry\" of the "
"statement, and the :func:`~.expression.text` construct provides the "
"textual content within this form.  We can build a statement without the "
"need to refer to any pre-established :class:`.Table` metadata:"
msgstr "：func： `〜.expression.text`は、：func：`〜.expression.select`オブジェクト内で自由に使用できるSQLのフラグメントを生成するためにも使用できます。これは：func： `〜.expression.text`オブジェクトを受け入れますそのビルダー関数のほとんどの引数として使用します。以下は、：func： `〜.expression.text`の使用法をa：func：` .select`オブジェクト内で組み合わせたものです。 ：func： `〜.expression.select`構造は文の\&quot; geometry \ &quot;を提供し、：func：`〜.expression.text`構造はこの形式のテキストコンテンツを提供します。あらかじめ設定されたクラス： `.Table`メタデータを参照せずにステートメントを作成することができます："

#: ../../core/tutorial.rst:962
msgid ""
"The :func:`.select` construct emits warnings when string SQL fragments "
"are coerced to :func:`.text`, and :func:`.text` should be used "
"explicitly.  See :ref:`migration_2992` for background."
msgstr "：func： `.select`構文は、文字列SQLフラグメントが強制的に：func：` .text`に、そして：func： `.text`が明示的に使用されるべきときに、警告を出します。背景については：ref： `migration_2992`を参照してください。"

#: ../../core/tutorial.rst:972
msgid ""
"Using More Specific Text with :func:`.table`, :func:`.literal_column`, "
"and :func:`.column`"
msgstr "：func： `.table`、：func：` .literal_column`、および：func： `.column`でより特定のテキストを使用する"

#: ../../core/tutorial.rst:974
msgid ""
"We can move our level of structure back in the other direction too, by "
"using :func:`~.expression.column`, :func:`~.expression.literal_column`, "
"and :func:`~.expression.table` for some of the key elements of our "
"statement.   Using these constructs, we can get some more expression "
"capabilities than if we used :func:`~.expression.text` directly, as they "
"provide to the Core more information about how the strings they store are"
" to be used, but still without the need to get into full :class:`.Table` "
"based metadata.  Below, we also specify the :class:`.String` datatype for"
" two of the key :func:`~.expression.literal_column` objects, so that the "
"string-specific concatenation operator becomes available. We also use "
":func:`~.expression.literal_column` in order to use table-qualified "
"expressions, e.g. ``users.fullname``, that will be rendered as is; using "
":func:`~.expression.column` implies an individual column name that may be"
" quoted:"
msgstr "：func： `〜.expression.column`、：func：`〜.expression.literal_column`、および：func： `〜.expression.table`のために、私たちは構造のレベルを反対方向に戻すこともできます私たちの声明の重要な要素のいくつか。これらの構造体を使用すると、func： `〜.expression.text`を直接使用する場合よりも、より多くの表現能力を得ることができます。これらの構造体は、格納する文字列の使用方法class： `.Table`ベースのメタデータです。以下では、key：func： `〜.expression.literal_column`オブジェクトの2つについて：class：` .String`データ型を指定して、文字列固有の連結演算子を利用できるようにします。また、 `` users.fullname``のようにテーブル修飾された式を使うために：func： `〜.expression.literal_column`を使います。 ：func： `〜.expression.column`は、引用符で囲むことができる個々の列名を意味します："

#: ../../core/tutorial.rst:1018
msgid "Ordering or Grouping by a Label"
msgstr "ラベルによる注文またはグループ化"

#: ../../core/tutorial.rst:1020
msgid ""
"One place where we sometimes want to use a string as a shortcut is when "
"our statement has some labeled column element that we want to refer to in"
" a place such as the \"ORDER BY\" or \"GROUP BY\" clause; other "
"candidates include fields within an \"OVER\" or \"DISTINCT\" clause.  If "
"we have such a label in our :func:`.select` construct, we can refer to it"
" directly by passing the string straight into :meth:`.select.order_by` or"
" :meth:`.select.group_by`, among others.  This will refer to the named "
"label and also prevent the expression from being rendered twice:"
msgstr "文字列をショートカットとして使用したい場合がある場所の1つは、\ &quot;ORDER BY \&quot;または\ &quot;GROUP BY \&quot;節などの場所で参照したいラベル付きの列要素がいくつかある場合です。他の候補には、\ &quot;OVER \&quot;または\ &quot;DISTINCT \&quot;節内のフィールドが含まれます。 ：func： `.select`構造体にこのようなラベルがある場合は、文字列を：meth：` .select.order_by`または：meth： `.select.group_by`に直接渡すことで直接参照することができます。その他。これは名前付きラベルを参照し、式が2回表示されないようにします。"

#: ../../core/tutorial.rst:1043
msgid ""
"We can use modifiers like :func:`.asc` or :func:`.desc` by passing the "
"string name:"
msgstr "文字列名を渡すことによって：func： `.asc`や：func：` .desc`のような修飾子を使うことができます："

#: ../../core/tutorial.rst:1060
msgid ""
"Note that the string feature here is very much tailored to when we have "
"already used the :meth:`~.ColumnElement.label` method to create a "
"specifically-named label.  In other cases, we always want to refer to the"
" :class:`.ColumnElement` object directly so that the expression system "
"can make the most effective choices for rendering.  Below, we illustrate "
"how using the :class:`.ColumnElement` eliminates ambiguity when we want "
"to order by a column name that appears more than once:"
msgstr "ここでの文字列のフィーチャは、：meth： `〜.ColumnElement.label`メソッドを使用して特別な名前のラベルを作成したときに非常に調整されていることに注意してください。他の場合では、表現システムがレンダリングのための最も効果的な選択肢を作ることができるように、常に：class： `.ColumnElement`オブジェクトを直接参照したいと思っています。以下では、：class： `.ColumnElement`を使用すると、複数回出現する列名で並べ替えるときのあいまいさがなくなります。"

#: ../../core/tutorial.rst:1087
msgid "Using Aliases"
msgstr "エイリアスの使用"

#: ../../core/tutorial.rst:1089
msgid ""
"The alias in SQL corresponds to a \"renamed\" version of a table or "
"SELECT statement, which occurs anytime you say \"SELECT .. FROM sometable"
" AS someothername\". The ``AS`` creates a new name for the table. Aliases"
" are a key construct as they allow any table or subquery to be referenced"
" by a unique name. In the case of a table, this allows the same table to "
"be named in the FROM clause multiple times. In the case of a SELECT "
"statement, it provides a parent name for the columns represented by the "
"statement, allowing them to be referenced relative to this name."
msgstr "SQLのエイリアスは、テーブルまたはSELECTステートメントの\ &quot;リネームされた\&quot;バージョンに対応します。これは\ &quot;SELECT。FROM sometable AS someothername \&quot;といつでも言います。 `` AS``はテーブルの新しい名前を作成します。エイリアスは、テーブルやサブクエリを一意の名前で参照できるため、主要な構成要素です。テーブルの場合、FROM句に複数の同じテーブルの名前を付けることができます。 SELECTステートメントの場合は、ステートメントによって表される列の親名を提供します。この名前を基準にして参照できるようにします。"

#: ../../core/tutorial.rst:1098
msgid ""
"In SQLAlchemy, any :class:`.Table`, :func:`.select` construct, or other "
"selectable can be turned into an alias using the "
":meth:`.FromClause.alias` method, which produces a :class:`.Alias` "
"construct.  As an example, suppose we know that our user ``jack`` has two"
" particular email addresses. How can we locate jack based on the "
"combination of those two addresses?   To accomplish this, we'd use a join"
" to the ``addresses`` table, once for each address.   We create two "
":class:`.Alias` constructs against ``addresses``, and then use them both "
"within a :func:`.select` construct:"
msgstr "SQLAlchemyでは、：class： `.Table`、：func：` .select`構造体、またはその他の選択可能なものは、：meth： `.FromClause.alias`メソッドを使用して別名に変換できます。 。アリアの構造。例として、ユーザーの `` jack``に2つの特定の電子メールアドレスがあることを知っているとします。これらの2つのアドレスの組み合わせに基づいて、どのようにジャックを見つけることができますか？これを達成するために、アドレスごとに `` addresses``テーブルへの結合を1回使います。 `` addresses``に対してclass： `.Alias`構造を作り、それをa：func：` .select`構造体の中で使う："

#: ../../core/tutorial.rst:1127
msgid ""
"Note that the :class:`.Alias` construct generated the names "
"``addresses_1`` and ``addresses_2`` in the final SQL result.  The "
"generation of these names is determined by the position of the construct "
"within the statement.   If we created a query using only the second "
"``a2`` alias, the name would come out as ``addresses_1``.  The generation"
" of the names is also *deterministic*, meaning the same SQLAlchemy "
"statement construct will produce the identical SQL string each time it is"
" rendered for a particular dialect."
msgstr "：class： `.Alias`構文は、最終的なSQL結果に` `addresses_1``と` `addresses_2``という名前を生成したことに注意してください。これらの名前の生成は、ステートメント内の構造の位置によって決まります。 2番目の `` a2``エイリアスだけを使ってクエリを作成した場合、その名前は `` addresses_1``として出てきます。名前の生成も*確定的です。つまり、特定の方言に対してレンダリングされるたびに、同じSQLAlchemyステートメント構成で同じSQL文字列が生成されます。"

#: ../../core/tutorial.rst:1135
msgid ""
"Since on the outside, we refer to the alias using the :class:`.Alias` "
"construct itself, we don't need to be concerned about the generated name."
"  However, for the purposes of debugging, it can be specified by passing "
"a string name to the :meth:`.FromClause.alias` method::"
msgstr "外部では：class： `.Alias`構造体を使用してエイリアスを参照するので、生成された名前について心配する必要はありません。しかし、デバッグの目的では、：meth： `.FromClause.alias`メソッドに文字列名を渡すことで指定することができます::"

#: ../../core/tutorial.rst:1142
msgid ""
"Aliases can of course be used for anything which you can SELECT from, "
"including SELECT statements themselves. We can self-join the ``users`` "
"table back to the :func:`.select` we've created by making an alias of the"
" entire statement. The ``correlate(None)`` directive is to avoid "
"SQLAlchemy's attempt to \"correlate\" the inner ``users`` table with the "
"outer one:"
msgstr "エイリアスは、もちろんSELECT文を含め、SELECTから選択できるものに使用できます。文全体のエイリアスを作成して作成した：func： `.select`に` `users``テーブルを自己結合することができます。 `` correlate（None） ``ディレクティブは、内側の `` users``テーブルを外側のテーブルと &quot;相関&quot;させるSQLAlchemyの試みを避けることです："

#: ../../core/tutorial.rst:1165
msgid "Using Joins"
msgstr "結合の使用"

#: ../../core/tutorial.rst:1167
msgid ""
"We're halfway along to being able to construct any SELECT expression. The"
" next cornerstone of the SELECT is the JOIN expression. We've already "
"been doing joins in our examples, by just placing two tables in either "
"the columns clause or the where clause of the :func:`.select` construct. "
"But if we want to make a real \"JOIN\" or \"OUTERJOIN\" construct, we use"
" the :meth:`~.FromClause.join` and :meth:`~.FromClause.outerjoin` "
"methods, most commonly accessed from the left table in the join:"
msgstr "途中でSELECT式を構築できるようになりました。 SELECTの次の基盤はJOIN式です。私たちはすでに、例の中でjoin節を行っています：columns節または：func： `.select`構造のwhere節に2つのテーブルを置くだけです。しかし、実際の\ &quot;JOIN \&quot;または\ &quot;OUTERJOIN \&quot;構造を作成したい場合は、：meth： `〜.FromClause.join`メソッドと：meth：`〜.FromClause.outerjoin`メソッドを使用します。結合の左の表から："

#: ../../core/tutorial.rst:1180
msgid ""
"The alert reader will see more surprises; SQLAlchemy figured out how to "
"JOIN the two tables ! The ON condition of the join, as it's called, was "
"automatically generated based on the "
":class:`~sqlalchemy.schema.ForeignKey` object which we placed on the "
"``addresses`` table way at the beginning of this tutorial. Already the "
"``join()`` construct is looking like a much better way to join tables."
msgstr "アラートリーダーはもっと驚きを見るでしょう。 SQLAlchemyは、2つのテーブルを結合する方法を考え出しました！結合のON条件は、このチュートリアルの冒頭にある `` addresses``テーブルの方法で設定した：class： `〜sqlalchemy.schema.ForeignKey`オブジェクトに基づいて自動的に生成されました。既に `` join（） ``構造はテーブルを結合するもっと良い方法のように見えます。"

#: ../../core/tutorial.rst:1187
msgid ""
"Of course you can join on whatever expression you want, such as if we "
"want to join on all users who use the same name in their email address as"
" their username:"
msgstr "もちろん、自分のユーザー名と同じ名前の電子メールアドレスに参加するすべてのユーザーに参加したい場合など、必要な表現に参加できます。"

#: ../../core/tutorial.rst:1199
msgid ""
"When we create a :func:`.select` construct, SQLAlchemy looks around at "
"the tables we've mentioned and then places them in the FROM clause of the"
" statement. When we use JOINs however, we know what FROM clause we want, "
"so here we make use of the :meth:`~.Select.select_from` method:"
msgstr "：func： `.select`構文を作成すると、SQLAlchemyは前述のテーブルを調べて、それらをステートメントのFROM句に配置します。しかし、JOINを使うときは、私たちが望むFROM句を知っているので、ここで：meth： `〜.Select.select_from`メソッドを使います："

#: ../../core/tutorial.rst:1216
msgid ""
"The :meth:`~.FromClause.outerjoin` method creates ``LEFT OUTER JOIN`` "
"constructs, and is used in the same way as :meth:`~.FromClause.join`:"
msgstr "：meth： `〜.FromClause.outerjoin`メソッドは、` LEFT OUTER JOIN`コンストラクトを作成し、以下のように使用されます：meth： `〜.FromClause.join`："

#: ../../core/tutorial.rst:1227
msgid ""
"That's the output ``outerjoin()`` produces, unless, of course, you're "
"stuck in a gig using Oracle prior to version 9, and you've set up your "
"engine (which would be using ``OracleDialect``) to use Oracle-specific "
"SQL:"
msgstr "これはもちろん、バージョン9より前のOracleを使ってギグに陥っていて、エンジンをセットアップしていない限り（ `` OracleDialect``を使っている）、 `` outerjoin（） ``という出力が生成されます。 Oracle固有のSQLを使用するには："

#: ../../core/tutorial.rst:1239
msgid ""
"If you don't know what that SQL means, don't worry ! The secret tribe of "
"Oracle DBAs don't want their black magic being found out ;)."
msgstr "SQLが何を意味するのかわからない場合は、心配しないでください！ Oracle DBAの秘密の部族は、彼らの黒い魔法を発見したくはありません。"

#: ../../core/tutorial.rst:1244
msgid ":func:`.expression.join`"
msgstr "：func： `.expression.join`"

#: ../../core/tutorial.rst:1246
msgid ":func:`.expression.outerjoin`"
msgstr "：func： `.expression.outerjoin`"

#: ../../core/tutorial.rst:1248
msgid ":class:`.Join`"
msgstr "：クラス： `.Join`"

#: ../../core/tutorial.rst:1251
msgid "Everything Else"
msgstr "ほかのすべて"

#: ../../core/tutorial.rst:1253
msgid ""
"The concepts of creating SQL expressions have been introduced. What's "
"left are more variants of the same themes. So now we'll catalog the rest "
"of the important things we'll need to know."
msgstr "SQL式の作成の概念が導入されました。残っているのは、同じテーマのより多くの変種です。だから今私たちが知る必要がある残りの重要なものをカタログ化します。"

#: ../../core/tutorial.rst:1260
msgid "Bind Parameter Objects"
msgstr "パラメータオブジェクトのバインド"

#: ../../core/tutorial.rst:1262
msgid ""
"Throughout all these examples, SQLAlchemy is busy creating bind "
"parameters wherever literal expressions occur. You can also specify your "
"own bind parameters with your own names, and use the same statement "
"repeatedly. The :func:`.bindparam` construct is used to produce a bound "
"parameter with a given name.  While SQLAlchemy always refers to bound "
"parameters by name on the API side, the database dialect converts to the "
"appropriate named or positional style at execution time, as here where it"
" converts to positional for SQLite:"
msgstr "これらすべての例を通して、SQLAlchemyはリテラル式が出現するたびにバインドパラメータを作成しています。独自の名前で独自のバインド・パラメーターを指定し、同じステートメントを繰り返し使用することもできます。 ：func： `.bindparam`構文は、指定された名前を持つバインドされたパラメータを生成するために使用されます。 SQLAlchemyは常にAPI側で名前でバインドされたパラメータを参照しますが、実行時にデータベースの方言は適切な名前付きまたは位置指定のスタイルに変換されます。ここではSQLiteの定位置に変換されます。"

#: ../../core/tutorial.rst:1282
msgid ""
"Another important aspect of :func:`.bindparam` is that it may be assigned"
" a type. The type of the bind parameter will determine its behavior "
"within expressions and also how the data bound to it is processed before "
"being sent off to the database:"
msgstr "：func： `.bindparam`のもう一つの重要な側面は、型に割り当てられるということです。バインド・パラメータのタイプによって、式内での動作と、バインドされたデータが処理されてデータベースに送信される仕組みが決まります。"

#: ../../core/tutorial.rst:1298
msgid ""
":func:`.bindparam` constructs of the same name can also be used multiple "
"times, where only a single named value is needed in the execute "
"parameters:"
msgstr "同じ名前のfunc： `.bindparam`構造体も複数回使用できます。ここでは、実行パラメータには単一の名前付き値しか必要ありません。"

#: ../../core/tutorial.rst:1325
msgid ":func:`.bindparam`"
msgstr "：機能： `.bindparam`"

#: ../../core/tutorial.rst:1328
msgid "Functions"
msgstr "関数"

#: ../../core/tutorial.rst:1330
msgid ""
"SQL functions are created using the :data:`~.expression.func` keyword, "
"which generates functions using attribute access:"
msgstr "SQL関数は：data： `〜.expression.func`キーワードを使用して作成され、属性アクセスを使用して関数を生成します。"

#: ../../core/tutorial.rst:1342
msgid ""
"By \"generates\", we mean that **any** SQL function is created based on "
"the word you choose::"
msgstr "\ &quot;generate \&quot;とは、**任意の** SQL関数は、選択した単語に基づいて作成されたことを意味します::"

#: ../../core/tutorial.rst:1348
msgid ""
"Certain function names are known by SQLAlchemy, allowing special "
"behavioral rules to be applied. Some for example are \"ANSI\" functions, "
"which mean they don't get the parenthesis added after them, such as "
"CURRENT_TIMESTAMP:"
msgstr "特定の関数名はSQLAlchemyによって認識され、特別な動作規則が適用されます。たとえば、\ &quot;ANSI \&quot;関数があります。つまり、CURRENT_TIMESTAMPのように後に括弧が追加されないという意味です。"

#: ../../core/tutorial.rst:1357
msgid ""
"Functions are most typically used in the columns clause of a select "
"statement, and can also be labeled as well as given a type. Labeling a "
"function is recommended so that the result can be targeted in a result "
"row based on a string name, and assigning it a type is required when you "
"need result-set processing to occur, such as for Unicode conversion and "
"date conversions. Below, we use the result function ``scalar()`` to just "
"read the first column of the first row and then close the result; the "
"label, even though present, is not important in this case:"
msgstr "関数は、通常、select文のcolumns句で使用されます。また、型を指定するだけでなく、ラベル付けすることもできます。文字列名に基づいて結果の行を対象にし、結果セット処理（Unicode変換や日付変換など）が必要な場合は、型を割り当てるために、関数にラベルを付けることをお勧めします。以下では、結果関数 `` scalar（） ``を使用して、最初の行の最初の列を読み込み、結果を閉じます。ラベルは存在していてもこの場合重要ではありません。"

#: ../../core/tutorial.rst:1379
msgid ""
"Databases such as PostgreSQL and Oracle which support functions that "
"return whole result sets can be assembled into selectable units, which "
"can be used in statements. Such as, a database function ``calculate()`` "
"which takes the parameters ``x`` and ``y``, and returns three columns "
"which we'd like to name ``q``, ``z`` and ``r``, we can construct using "
"\"lexical\" column objects as well as bind parameters:"
msgstr "結果セット全体を返す関数をサポートするPostgreSQLやOracleなどのデータベースは、ステートメントで使用できる選択可能なユニットにアセンブルできます。パラメータ `` x``と `` y``をとり、 `` q``、 `` z``という3つのカラムを返すデータベース関数 `` calculate（） `` `と` `r``を使うと、\&quot;字句\ &quot;列オブジェクトとバインドパラメータを使って構築できます："

#: ../../core/tutorial.rst:1403
msgid ""
"If we wanted to use our ``calculate`` statement twice with different bind"
" parameters, the "
":func:`~sqlalchemy.sql.expression.ClauseElement.unique_params` function "
"will create copies for us, and mark the bind parameters as \"unique\" so "
"that conflicting names are isolated. Note we also make two separate "
"aliases of our selectable:"
msgstr "異なったバインドパラメータで `` calculate``ステートメントを2回使いたいなら、：func： `〜sqlalchemy.sql.expression.ClauseElement.unique_params`関数は私たちのためにコピーを作成し、バインドパラメータを\&quot; unique \ &quot;を使用して、競合する名前が分離されるようにします。選択可能なものの2つの別々のエイリアスも作成しています。"

#: ../../core/tutorial.rst:1427
msgid ":data:`.func`"
msgstr "：データ： `.func`"

#: ../../core/tutorial.rst:1432
msgid "Window Functions"
msgstr "ウィンドウ関数"

#: ../../core/tutorial.rst:1434
msgid ""
"Any :class:`.FunctionElement`, including functions generated by "
":data:`~.expression.func`, can be turned into a \"window function\", that"
" is an OVER clause, using the :meth:`.FunctionElement.over` method::"
msgstr "Any：class： `.FunctionElement`は：data：`〜.expression.func`で生成された関数も含めて、：meth： `.FunctionElementを使ってOVER句である&quot;ウィンドウ関数 &quot;に変換できます.over`メソッド::"

#: ../../core/tutorial.rst:1446
msgid ""
":meth:`.FunctionElement.over` also supports range specification using "
"either the :paramref:`.expression.over.rows` or "
":paramref:`.expression.over.range` parameters::"
msgstr "：meth： `.FunctionElement.over`は：paramref：` .expression.over.rows`または：paramref： `.expression.over.range`のいずれかのパラメータを使って範囲指定をサポートしています::"

#: ../../core/tutorial.rst:1461
msgid ""
":paramref:`.expression.over.rows` and :paramref:`.expression.over.range` "
"each accept a two-tuple which contains a combination of negative and "
"positive integers for ranges, zero to indicate \"CURRENT ROW\" and "
"``None`` to indicate \"UNBOUNDED\".  See the examples at :func:`.over` "
"for more detail."
msgstr "：paramref： `.expression.over.rows`と：paramref：` .expression.over.range`はそれぞれ、範囲のための負の整数と正の整数の組み合わせを含む2つのタプルを受け入れ、\ &quot;CURRENT ROW \&quot; \ &quot;UNBOUNDED \&quot;を示す &quot;None&quot;を指定します。詳細については、例：func： `.over`を参照してください。"

#: ../../core/tutorial.rst:1466
msgid "support for \"rows\" and \"range\" specification for window functions"
msgstr "ウィンドウ関数の\ &quot;行\&quot;と\ &quot;範囲\&quot;指定のサポート"

#: ../../core/tutorial.rst:1471
msgid ":func:`.over`"
msgstr "：func： `.over`"

#: ../../core/tutorial.rst:1473
msgid ":meth:`.FunctionElement.over`"
msgstr "：meth： `.FunctionElement.over`"

#: ../../core/tutorial.rst:1476
msgid "Unions and Other Set Operations"
msgstr "組合とその他の集合演算"

#: ../../core/tutorial.rst:1478
msgid ""
"Unions come in two flavors, UNION and UNION ALL, which are available via "
"module level functions :func:`~.expression.union` and "
":func:`~.expression.union_all`:"
msgstr "共用体には、モジュールレベルの関数func： `〜.expression.union`と：func：`〜.expression.union_all`の2つのフレーバーUNIONとUNION ALLがあります。"

#: ../../core/tutorial.rst:1503
msgid ""
"Also available, though not supported on all databases, are "
":func:`~.expression.intersect`, :func:`~.expression.intersect_all`, "
":func:`~.expression.except_`, and :func:`~.expression.except_all`:"
msgstr "func： `〜.expression.intersect`、：func：`〜.expression.intersect_all`、：func： `〜.expression.except_`、および：func：`〜は、すべてのデータベースでサポートされていますが、 .expression.except_all`："

#: ../../core/tutorial.rst:1529
msgid ""
"A common issue with so-called \"compound\" selectables arises due to the "
"fact that they nest with parenthesis. SQLite in particular doesn't like a"
" statement that starts with parenthesis. So when nesting a \"compound\" "
"inside a \"compound\", it's often necessary to apply "
"``.alias().select()`` to the first element of the outermost compound, if "
"that element is also a compound. For example, to nest a \"union\" and a "
"\"select\" inside of \"except\\_\", SQLite will want the \"union\" to be "
"stated as a subquery:"
msgstr "いわゆる「化合物」選択肢の一般的な問題は、かっこでネスティングするという事実のために発生します。特にSQLiteでは、かっこで始まる文が好きではありません。したがって、 &quot;compound&quot;内に\ &quot;compound \&quot;を入れ子にするときは、最も外側の化合物の最初の要素に `` .alias（）。select（） ``を適用する必要があります。たとえば、\ &quot;union \&quot;と\ &quot;select \&quot;を\ &quot;except \\ _ \&quot;の中にネストする場合、SQLiteは\ &quot;union \&quot;をサブクエリとして記述します。"

#: ../../core/tutorial.rst:1569
msgid ":func:`.union`"
msgstr "：func： `.union`"

#: ../../core/tutorial.rst:1571
msgid ":func:`.union_all`"
msgstr "：func： `.union_all`"

#: ../../core/tutorial.rst:1573
msgid ":func:`.intersect`"
msgstr "：func： `.intersect`"

#: ../../core/tutorial.rst:1575
msgid ":func:`.intersect_all`"
msgstr "：func： `.intersect_all`"

#: ../../core/tutorial.rst:1577
msgid ":func:`.except_`"
msgstr "：func： `.except_`"

#: ../../core/tutorial.rst:1579
msgid ":func:`.except_all`"
msgstr "：func： `.except_all`"

#: ../../core/tutorial.rst:1584
msgid "Scalar Selects"
msgstr "スカラ選択"

#: ../../core/tutorial.rst:1586
msgid ""
"A scalar select is a SELECT that returns exactly one row and one column."
"  It can then be used as a column expression.  A scalar select is often a"
" :term:`correlated subquery`, which relies upon the enclosing SELECT "
"statement in order to acquire at least one of its FROM clauses."
msgstr "スカラー選択は、正確に1つの行と1つの列を返すSELECTです。これを列式として使用できます。スカラー選択は、しばしば：関連するサブクエリであり、FROM句の少なくとも1つを取得するために囲むSELECTステートメントに依存します。"

#: ../../core/tutorial.rst:1591
msgid ""
"The :func:`.select` construct can be modified to act as a column "
"expression by calling either the :meth:`~.SelectBase.as_scalar` or "
":meth:`~.SelectBase.label` method:"
msgstr "：func： `.select`構造体は、：meth：`〜.SelectBase.as_scalar`または：meth： `〜.SelectBase.label`メソッドのいずれかを呼び出して、列式として動作するように変更できます："

#: ../../core/tutorial.rst:1601
msgid ""
"The above construct is now a :class:`~.expression.ScalarSelect` object, "
"and is no longer part of the :class:`~.expression.FromClause` hierarchy; "
"it instead is within the :class:`~.expression.ColumnElement` family of "
"expression constructs.  We can place this construct the same as any other"
" column within another :func:`.select`:"
msgstr "上記の構造体はa：class： `〜.expression.ScalarSelect`オブジェクトになり、もはやclass：`〜.expression.FromClause`階層の一部ではなくなりました。その代わりに：class： `〜.expression.ColumnElement`の式構造体の中にあります。この構造体を他の列と同じように配置することができます：func： `.select`："

#: ../../core/tutorial.rst:1617
msgid ""
"To apply a non-anonymous column name to our scalar select, we create it "
"using :meth:`.SelectBase.label` instead:"
msgstr "非匿名の列名をスカラー選択に適用するには、代わりに：meth： `.SelectBase.label`を使用して作成します。"

#: ../../core/tutorial.rst:1635
msgid ":meth:`.Select.as_scalar`"
msgstr "：meth： `.Select.as_scalar`"

#: ../../core/tutorial.rst:1637
msgid ":meth:`.Select.label`"
msgstr "：meth： `.Select.label`"

#: ../../core/tutorial.rst:1642
msgid "Correlated Subqueries"
msgstr "相関サブクエリ"

#: ../../core/tutorial.rst:1644
msgid ""
"Notice in the examples on :ref:`scalar_selects`, the FROM clause of each "
"embedded select did not contain the ``users`` table in its FROM clause. "
"This is because SQLAlchemy automatically :term:`correlates` embedded FROM"
" objects to that of an enclosing query, if present, and if the inner "
"SELECT statement would still have at least one FROM clause of its own.  "
"For example:"
msgstr "：ref： `scalar_selects`の例では、各組み込みselectのFROM句にFROM句に` `users``テーブルが含まれていませんでした。これは、SQLAlchemyが自動的に：term： `correlates`をFROMオブジェクトに埋め込みクエリが存在する場合、内部SELECTステートメントがそれ自身のFROM句を少なくとも1つも持っているためです。例えば："

#: ../../core/tutorial.rst:1666
msgid ""
"Auto-correlation will usually do what's expected, however it can also be "
"controlled. For example, if we wanted a statement to correlate only to "
"the ``addresses`` table but not the ``users`` table, even if both were "
"present in the enclosing SELECT, we use the :meth:`~.Select.correlate` "
"method to specify those FROM clauses that may be correlated:"
msgstr "自己相関は通常予想されることを行いますが、制御することもできます。例えば、ステートメントが `` addresses``テーブルにのみ関連づけられ、 `` users``テーブルには関連しないようにするには、両者が囲まれたSELECTに存在していても、：meth： `〜.Select。 correlate`メソッドを使用して、相関する可能性のあるFROM句を指定します。"

#: ../../core/tutorial.rst:1691
msgid ""
"To entirely disable a statement from correlating, we can pass ``None`` as"
" the argument:"
msgstr "ステートメントの相関を完全に無効にするには、引数として `` None``を渡すことができます："

#: ../../core/tutorial.rst:1710
msgid ""
"We can also control correlation via exclusion, using the "
":meth:`.Select.correlate_except` method.   Such as, we can write our "
"SELECT for the ``users`` table by telling it to correlate all FROM "
"clauses except for ``users``:"
msgstr "：meth： `.Select.correlate_except`メソッドを使用して、除外による相関を制御することもできます。例えば、 `` users``を除くすべてのFROM句を関連付けるように指示することで、 `` users``テーブルのSELECTを書くことができます："

#: ../../core/tutorial.rst:1736
msgid "LATERAL correlation"
msgstr "LATERAL相関"

#: ../../core/tutorial.rst:1738
msgid ""
"LATERAL correlation is a special sub-category of SQL correlation which "
"allows a selectable unit to refer to another selectable unit within a "
"single FROM clause.  This is an extremely special use case which, while "
"part of the SQL standard, is only known to be supported by recent "
"versions of PostgreSQL."
msgstr "LATERAL相関は、選択可能なユニットが単一のFROM句内の別の選択可能なユニットを参照できるようにする、SQL相関の特別なサブカテゴリです。これは、SQL標準の一部ではあるが、最近のバージョンのPostgreSQLでサポートされることが知られている非常に特殊な使用例である。"

#: ../../core/tutorial.rst:1744
msgid ""
"Normally, if a SELECT statement refers to ``table1 JOIN (some SELECT) AS "
"subquery`` in its FROM clause, the subquery on the right side may not "
"refer to the \"table1\" expression from the left side; correlation may "
"only refer to a table that is part of another SELECT that entirely "
"encloses this SELECT.  The LATERAL keyword allows us to turn this "
"behavior around, allowing an expression such as:"
msgstr "通常、SELECT文がFROM句で `` table1 JOIN（some SELECT）AS subquery``を参照する場合、右側のサブクエリは左側の\ &quot;table1 \&quot;式を参照しないことがあります。相関は、このSELECTを完全に囲む別のSELECTの一部である表のみを参照することがあります。 LATERALキーワードは、このような振る舞いを可能にし、次のような表現を可能にします："

#: ../../core/tutorial.rst:1758
msgid ""
"Where above, the right side of the JOIN contains a subquery that refers "
"not just to the \"books\" table but also the \"people\" table, "
"correlating to the left side of the JOIN.   SQLAlchemy Core supports a "
"statement like the above using the :meth:`.Select.lateral` method as "
"follows::"
msgstr "上記のところでは、JOINの右側には、\ &quot;books \&quot;テーブルだけでなく\ &quot;people \&quot;テーブルも参照するサブクエリがあり、JOINの左側に関連付けられています。 SQLAlchemy Coreは、上記のような文を以下のように：meth： `.Select.lateral`メソッドを使用してサポートします::"

#: ../../core/tutorial.rst:1774
msgid ""
"Above, we can see that the :meth:`.Select.lateral` method acts a lot like"
" the :meth:`.Select.alias` method, including that we can specify an "
"optional name.  However the construct is the :class:`.Lateral` construct "
"instead of an :class:`.Alias` which provides for the LATERAL keyword as "
"well as special instructions to allow correlation from inside the FROM "
"clause of the enclosing statement."
msgstr "上記のように、：meth： `.Select.lateral`メソッドは：meth：` .Select.alias`メソッドのように動作します。これには、オプションの名前を指定することもできます。しかし、構造体は：class： `.Lateral`構造体である：class：` .Alias`は、LATERALキーワードと、囲むステートメントのFROM句の内部からの相関を可能にする特別な命令を提供します。"

#: ../../core/tutorial.rst:1781
msgid ""
"The :meth:`.Select.lateral` method interacts normally with the "
":meth:`.Select.correlate` and :meth:`.Select.correlate_except` methods, "
"except that the correlation rules also apply to any other tables present "
"in the enclosing statement's FROM clause.   Correlation is \"automatic\" "
"to these tables by default, is explicit if the table is specified to "
":meth:`.Select.correlate`, and is explicit to all tables except those "
"specified to :meth:`.Select.correlate_except`."
msgstr "：meth： `.Select.lateral`メソッドは：meth：` .Select.correlate`と：meth： `.Select.correlate_except`メソッドと正常にやり取りします。ただし、相関ルールは、他のテーブルにも適用されます。囲む文のFROM句。相関はデフォルトでこれらのテーブルに対して\ &quot;自動\&quot;であり、テーブルが：meth： `.Select.correlate`に指定されている場合は明示的であり、：meth：` .Select.correlate_except` 。"

#: ../../core/tutorial.rst:1792
msgid "Support for the LATERAL keyword and lateral correlation."
msgstr "LATERALキーワードと横方向相関のサポート。"

#: ../../core/tutorial.rst:1796
msgid ":class:`.Lateral`"
msgstr "：クラス： `.Lateral`"

#: ../../core/tutorial.rst:1798
msgid ":meth:`.Select.lateral`"
msgstr "：meth： `.Select.lateral`"

#: ../../core/tutorial.rst:1802
msgid "Ordering, Grouping, Limiting, Offset...ing..."
msgstr "オーダー、グルーピング、制限、オフセット... ing ..."

#: ../../core/tutorial.rst:1804
msgid ""
"Ordering is done by passing column expressions to the "
":meth:`~.SelectBase.order_by` method:"
msgstr "順序付けは、列式を：meth： `〜.SelectBase.order_by`メソッドに渡すことによって行われます。"

#: ../../core/tutorial.rst:1816
msgid ""
"Ascending or descending can be controlled using the "
":meth:`~.ColumnElement.asc` and :meth:`~.ColumnElement.desc` modifiers:"
msgstr "昇順または降順は：meth： `〜.ColumnElement.asc`と：meth：`〜.ColumnElement.desc`修飾子を使って制御できます："

#: ../../core/tutorial.rst:1828
msgid ""
"Grouping refers to the GROUP BY clause, and is usually used in "
"conjunction with aggregate functions to establish groups of rows to be "
"aggregated. This is provided via the :meth:`~.SelectBase.group_by` "
"method:"
msgstr "グループ化はGROUP BY句を参照し、集約する行のグループを確立するために集計関数と一緒に使用されます。これは：meth： `〜.SelectBase.group_by`メソッドによって提供されます："

#: ../../core/tutorial.rst:1845
msgid ""
"HAVING can be used to filter results on an aggregate value, after GROUP "
"BY has been applied.  It's available here via the :meth:`~.Select.having`"
" method:"
msgstr "GROUP BYが適用された後、HAVINGを使用して集計値の結果をフィルタリングできます。これは：meth： `〜.Select.having`メソッドで利用できます："

#: ../../core/tutorial.rst:1864
msgid ""
"A common system of dealing with duplicates in composed SELECT statements "
"is the DISTINCT modifier.  A simple DISTINCT clause can be added using "
"the :meth:`.Select.distinct` method:"
msgstr "合成されたSELECT文で重複を処理する一般的なシステムは、DISTINCT修飾子です。単純なDISTINCT節は：meth： `.Select.distinct`メソッドを使って追加できます："

#: ../../core/tutorial.rst:1881
msgid ""
"Most database backends support a system of limiting how many rows are "
"returned, and the majority also feature a means of starting to return "
"rows after a given \"offset\".   While common backends like PostgreSQL, "
"MySQL and SQLite support LIMIT and OFFSET keywords, other backends need "
"to refer to more esoteric features such as \"window functions\" and row "
"ids to achieve the same effect.  The :meth:`~.Select.limit` and "
":meth:`~.Select.offset` methods provide an easy abstraction into the "
"current backend's methodology:"
msgstr "ほとんどのデータベースバックエンドは、返される行の数を制限するシステムをサポートしています。大半は、指定された\ &quot;オフセット\&quot;の後に行を返す方法もあります。 PostgreSQL、MySQL、SQLiteなどの一般的なバックエンドはLIMITとOFFSETのキーワードをサポートしていますが、他のバックエンドは同じ効果を得るために\ &quot;ウィンドウ関数\&quot;や行IDのようなより秘密の機能を参照する必要があります。 ：meth： `〜.Select.limit`メソッドと：meth：`〜.Select.offset`メソッドは、現在のバックエンドの方法論を簡単に抽象化します："

#: ../../core/tutorial.rst:1906
msgid "Inserts, Updates and Deletes"
msgstr "挿入、更新、および削除"

#: ../../core/tutorial.rst:1908
msgid ""
"We've seen :meth:`~.TableClause.insert` demonstrated earlier in this "
"tutorial.   Where :meth:`~.TableClause.insert` produces INSERT, the "
":meth:`~.TableClause.update` method produces UPDATE.  Both of these "
"constructs feature a method called :meth:`~.ValuesBase.values` which "
"specifies the VALUES or SET clause of the statement."
msgstr "我々は見た：meth： `〜.TableClause.insert`はこのチュートリアルの前半で説明しました。 ：meth： `〜.TableClause.insert`はINSERTを生成し、：meth：`〜.TableClause.update`メソッドはUPDATEを生成します。どちらの構文も、：meth： `〜.ValuesBase.values`というメソッドで、ステートメントのVALUES節またはSET節を指定します。"

#: ../../core/tutorial.rst:1915
msgid ""
"The :meth:`~.ValuesBase.values` method accommodates any column expression"
" as a value:"
msgstr "：meth： `〜.ValuesBase.values`メソッドは、任意の列式を値として扱います："

#: ../../core/tutorial.rst:1928
msgid ""
"When using :meth:`~.TableClause.insert` or :meth:`~.TableClause.update` "
"in an \"execute many\" context, we may also want to specify named bound "
"parameters which we can refer to in the argument list. The two constructs"
" will automatically generate bound placeholders for any column names "
"passed in the dictionaries sent to :meth:`~.Connection.execute` at "
"execution time.  However, if we wish to use explicitly targeted named "
"parameters with composed expressions, we need to use the "
":func:`~.expression.bindparam` construct. When using "
":func:`~.expression.bindparam` with :meth:`~.TableClause.insert` or "
":meth:`~.TableClause.update`, the names of the table's columns themselves"
" are reserved for the \"automatic\" generation of bind names.  We can "
"combine the usage of implicitly available bind names and explicitly named"
" parameters as in the example below:"
msgstr "\ &quot;execute many \&quot;コンテキストで：meth： `〜.TableClause.insert`または：meth：`〜.TableClause.update`を使用する場合、引数で参照できる名前付きバインドパラメータを指定することもできますリスト。 2つの構文は、実行時に：meth： `〜.Connection.execute`に送られた辞書に渡された任意の列名のためのバインドされたプレースホルダを自動的に生成します。しかし、明示的にターゲットとした名前付きパラメータを合成式で使用する場合は、：func： `〜.expression.bindparam`構文を使用する必要があります。 ：meth： `〜.TableClause.insert`または：meth：`〜.TableClause.update`を使用して：func： `〜.expression.bindparam`を使用すると、テーブルのカラム自体の名前は\&quot; automatic \ &quot;バインド名の生成。以下の例のように、暗黙的に使用可能なバインド名と明示的に名前が付けられたパラメータの使用法を組み合わせることができます。"

#: ../../core/tutorial.rst:1957
msgid ""
"An UPDATE statement is emitted using the :meth:`~.TableClause.update` "
"construct.  This works much like an INSERT, except there is an additional"
" WHERE clause that can be specified:"
msgstr "UPDATE文は、：meth： `〜.TableClause.update`構文を使用して生成されます。これは、指定できる追加のWHERE句があることを除いて、INSERTとよく似ています。"

#: ../../core/tutorial.rst:1973
msgid ""
"When using :meth:`~.TableClause.update` in an \"executemany\" context, we"
" may wish to also use explicitly named bound parameters in the WHERE "
"clause.  Again, :func:`~.expression.bindparam` is the construct used to "
"achieve this:"
msgstr "\ &quot;executemany \&quot;コンテキストで：meth： `〜.TableClause.update`を使用する場合、WHERE句で明示的に名前付きのバインドされたパラメータを使用することもできます。ここでも、：func： `〜.expression.bindparam`はこれを達成するために使用される構造体です："

#: ../../core/tutorial.rst:1995
msgid "Correlated Updates"
msgstr "相関関係の更新"

#: ../../core/tutorial.rst:1997
msgid ""
"A correlated update lets you update a table using selection from another "
"table, or the same table:"
msgstr "相関更新では、別の表または同じ表からの選択を使用して表を更新できます。"

#: ../../core/tutorial.rst:2017
msgid "Multiple Table Updates"
msgstr "複数のテーブルの更新"

#: ../../core/tutorial.rst:2021
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"UPDATE statements that refer to multiple tables.   For PG and MSSQL, this"
" is the \"UPDATE FROM\" syntax, which updates one table at a time, but "
"can reference additional tables in an additional \"FROM\" clause that can"
" then be referenced in the WHERE clause directly.   On MySQL, multiple "
"tables can be embedded into a single UPDATE statement separated by a "
"comma. The SQLAlchemy :func:`.update` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr "PostgreSQL、Microsoft SQL Server、およびMySQLバックエンドは、すべて複数のテーブルを参照するUPDATE文をサポートしています。 PGとMSSQLの場合、これは\ &quot;UPDATE FROM \&quot;構文で、一度に1つのテーブルを更新しますが、WHERE句で直接参照できる追加の\ &quot;FROM \&quot;節で追加のテーブルを参照できます。 MySQLでは、カンマで区切られた単一のUPDATE文に複数のテーブルを埋め込むことができます。 SQLAlchemy：func： `.update`構文は、WHERE句で複数のテーブルを指定することによって、これらのモードを暗黙的にサポートします::"

#: ../../core/tutorial.rst:2035
msgid "The resulting SQL from the above statement would render as::"
msgstr "上記の文から得られるSQLは::"

#: ../../core/tutorial.rst:2041
msgid ""
"When using MySQL, columns from each table can be assigned to in the SET "
"clause directly, using the dictionary form passed to "
":meth:`.Update.values`::"
msgstr "MySQLを使用する場合、各テーブルのカラムは、SET句の中で、：meth： `.Update.values`に渡されるディクショナリフォームを使用して直接割り当てることができます::"

#: ../../core/tutorial.rst:2052
msgid "The tables are referenced explicitly in the SET clause::"
msgstr "テーブルはSET節で明示的に参照されます::"

#: ../../core/tutorial.rst:2058 ../../core/tutorial.rst:2163
msgid ""
"When the construct is used on a non-supporting database, the compiler "
"will raise ``NotImplementedError``.   For convenience, when a statement "
"is printed as a string without specification of a dialect, the \"string "
"SQL\" compiler will be invoked which provides a non-working SQL "
"representation of the construct."
msgstr "この構造体がサポートされていないデータベースで使用されると、コンパイラは `` NotImplementedError``を発生させます。便宜上、ステートメントが方言が指定されていない文字列として出力された場合、\ &quot;文字列SQL \&quot;コンパイラが呼び出され、構文の非動作SQL表現が提供されます。"

#: ../../core/tutorial.rst:2067
msgid "Parameter-Ordered Updates"
msgstr "パラメータオーダーの更新"

#: ../../core/tutorial.rst:2069
msgid ""
"The default behavior of the :func:`.update` construct when rendering the "
"SET clauses is to render them using the column ordering given in the "
"originating :class:`.Table` object. This is an important behavior, since "
"it means that the rendering of a particular UPDATE statement with "
"particular columns will be rendered the same each time, which has an "
"impact on query caching systems that rely on the form of the statement, "
"either client side or server side. Since the parameters themselves are "
"passed to the :meth:`.Update.values` method as Python dictionary keys, "
"there is no other fixed ordering available."
msgstr "SET句をレンダリングするときの：func： `.update`のデフォルトの動作は、originating：class：` .Table`オブジェクトで与えられた列の順序付けを使ってレンダリングすることです。これは、特定の列を持つ特定のUPDATE文のレンダリングが毎回同じようにレンダリングされることを意味するため、重要な動作です。これは、クライアント側またはサーバー側の文の形式に依存する問合せキャッシュ・システムに影響します側。パラメータ自体は：meth： `.Update.values`メソッドにPythonのディクショナリキーとして渡されるため、利用可能な他の固定順序はありません。"

#: ../../core/tutorial.rst:2080
msgid ""
"However in some cases, the order of parameters rendered in the SET clause"
" of an UPDATE statement can be significant.  The main example of this is "
"when using MySQL and providing updates to column values based on that of "
"other column values.  The end result of the following statement::"
msgstr "しかし、場合によっては、UPDATEステートメントのSET節に表示されるパラメーターの順序が重要になることがあります。この主な例は、MySQLを使用し、他の列の値に基づいて列の値を更新するときです。次のステートメントの最終結果::"

#: ../../core/tutorial.rst:2087
msgid "Will have a different result than::"
msgstr "::とは異なる結果をもたらすでしょう。"

#: ../../core/tutorial.rst:2091
msgid ""
"This because on MySQL, the individual SET clauses are fully evaluated on "
"a per-value basis, as opposed to on a per-row basis, and as each SET "
"clause is evaluated, the values embedded in the row are changing."
msgstr "これは、MySQLでは個々のSET句が行単位ではなく、値ごとに完全に評価され、各SET句が評価されるときに行に埋め込まれた値が変化しているためです。"

#: ../../core/tutorial.rst:2095
msgid ""
"To suit this specific use case, the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag may be used.  When using this flag, we supply a **Python list of "
"2-tuples** as the argument to the :meth:`.Update.values` method::"
msgstr "この特定のユースケースに合わせて、：paramref： `〜sqlalchemy.sql.expression.update.preserve_parameter_order`フラグを使用することができます。このフラグを使用するときは、：meth： `.Update.values`メソッドの引数として**の2つのタプル**のPythonリストを提供します::"

#: ../../core/tutorial.rst:2103
msgid ""
"The list of 2-tuples is essentially the same structure as a Python "
"dictionary except it is ordered.  Using the above form, we are assured "
"that the \"y\" column's SET clause will render first, then the \"x\" "
"column's SET clause."
msgstr "2タプルのリストは、基本的にPython辞書と同じ構造ですが、順序は異なります。上記の形式を使用すると、\ &quot;y \&quot;列のSET句が最初にレンダリングされ、次に\ &quot;x \&quot;列のSET句がレンダリングされることが保証されます。"

#: ../../core/tutorial.rst:2107
msgid ""
"Added support for explicit ordering of UPDATE parameters using the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag."
msgstr "：paramref： `〜sqlalchemy.sql.expression.update.preserve_parameter_order`フラグを使用して、UPDATEパラメータの明示的な順序付けをサポートしました。"

#: ../../core/tutorial.rst:2113
msgid ""
":ref:`mysql_insert_on_duplicate_key_update` - background on the MySQL "
"``ON DUPLICATE KEY UPDATE`` clause and how to support parameter ordering."
msgstr "：ref： `mysql_insert_on_duplicate_key_update`  -  MySQLの` `ON DUPLICATE KEY UPDATE``節の背景と、パラメータの順序付けをサポートする方法。"

#: ../../core/tutorial.rst:2119
msgid "Deletes"
msgstr "削除"

#: ../../core/tutorial.rst:2121
msgid ""
"Finally, a delete.  This is accomplished easily enough using the "
":meth:`~.TableClause.delete` construct:"
msgstr "最後に、削除。これは：meth： `〜.TableClause.delete`構文を使って簡単に行えます："

#: ../../core/tutorial.rst:2141
msgid "Multiple Table Deletes"
msgstr "複数のテーブルの削除"

#: ../../core/tutorial.rst:2145
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"DELETE statements that refer to multiple tables within the WHERE "
"criteria.   For PG and MySQL, this is the \"DELETE USING\" syntax, and "
"for SQL Server, it's a \"DELETE FROM\" that refers to more than one "
"table.  The SQLAlchemy :func:`.delete` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr "PostgreSQL、Microsoft SQL Server、およびMySQLのバックエンドはすべて、WHERE条件内の複数のテーブルを参照するDELETE文をサポートしています。 PGとMySQLの場合、これは\ &quot;DELETE USING \&quot;構文であり、SQL Serverの場合は複数のテーブルを参照する\ &quot;DELETE FROM \&quot;です。 SQLAlchemy：func： `.delete`構文は、WHERE句で複数のテーブルを指定することによって、これらのモードを暗黙的にサポートします::"

#: ../../core/tutorial.rst:2157
msgid ""
"On a Postgresql backend, the resulting SQL from the above statement would"
" render as::"
msgstr "Postgresqlのバックエンドでは、上記の文から得られるSQLは::"

#: ../../core/tutorial.rst:2170
msgid "Matched Row Counts"
msgstr "一致した行数"

#: ../../core/tutorial.rst:2172
msgid ""
"Both of :meth:`~.TableClause.update` and :meth:`~.TableClause.delete` are"
" associated with *matched row counts*.  This is a number indicating the "
"number of rows that were matched by the WHERE clause. Note that by "
"\"matched\", this includes rows where no UPDATE actually took place. The "
"value is available as :attr:`~.ResultProxy.rowcount`:"
msgstr "：meth： `〜.TableClause.update`と：meth：`〜.TableClause.delete`は*一致する行数*に関連付けられます。これは、WHERE句で一致した行の数を示す数値です。 \ &quot;matched \&quot;によって、UPDATEが実際に行なわれなかった行が含まれていることに注意してください。値は次のように使用できます：attr： `〜.ResultProxy.rowcount`："

#: ../../core/tutorial.rst:2188
msgid "Further Reference"
msgstr "さらなる参照"

#: ../../core/tutorial.rst:2190
msgid "Expression Language Reference: :ref:`expression_api_toplevel`"
msgstr "表現言語リファレンス：：ref： `expression_api_toplevel`"

#: ../../core/tutorial.rst:2192
msgid "Database Metadata Reference: :ref:`metadata_toplevel`"
msgstr "データベースメタデータリファレンス：：ref： `metadata_toplevel`"

#: ../../core/tutorial.rst:2194
msgid "Engine Reference: :doc:`/core/engines`"
msgstr "エンジンリファレンス：：doc： `/ core / engines`"

#: ../../core/tutorial.rst:2196
msgid "Connection Reference: :ref:`connections_toplevel`"
msgstr "接続リファレンス：：ref： `connections_toplevel`"

#: ../../core/tutorial.rst:2198
msgid "Types Reference: :ref:`types_toplevel`"
msgstr "型リファレンス：：ref： `types_toplevel`"


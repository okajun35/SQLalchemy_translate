# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../core/type_api.rst:6
msgid "Base Type API"
msgstr "ベースタイプAPI"

#: of sqlalchemy.types.TypeEngine:1
msgid "The ultimate base class for all SQL datatypes."
msgstr "すべてのSQLデータ型の究極の基底クラスです。"

#: of sqlalchemy.types.TypeEngine:3
msgid ""
"Common subclasses of :class:`.TypeEngine` include :class:`.String`, "
":class:`.Integer`, and :class:`.Boolean`."
msgstr "：class： `.TypeEngine`の共通サブクラスは：class：` .String`、：class： `.Integer`、：class：` .Boolean`です。"

#: of sqlalchemy.types.TypeEngine:6
msgid ""
"For an overview of the SQLAlchemy typing system, see "
":ref:`types_toplevel`."
msgstr "SQLAlchemy型システムの概要は、：ref： `types_toplevel`を参照してください。"

#: of sqlalchemy.types.TypeEngine:11
msgid ":ref:`types_toplevel`"
msgstr "：ref： `types_toplevel`"

#: of sqlalchemy.types.TypeEngine.Comparator:1
msgid ""
"Base class for custom comparison operations defined at the type level.  "
"See :attr:`.TypeEngine.comparator_factory`."
msgstr "型レベルで定義されたカスタム比較演算の基本クラス。参照：attr： `.TypeEngine.comparator_factory`。"

#: of sqlalchemy.types.TypeEngine.adapt:1
msgid ""
"Produce an \"adapted\" form of this type, given an \"impl\" class to work"
" with."
msgstr "この型の\ &quot;適合\&quot;形式を生成する。\ &quot;impl \&quot;クラスで動作する。"

#: of sqlalchemy.types.TypeEngine.adapt:4
msgid ""
"This method is used internally to associate generic types with "
"\"implementation\" types that are specific to a particular dialect."
msgstr "このメソッドは、ジェネリック型を特定の方言に固有の\ &quot;実装\&quot;型に関連付けるために内部的に使用されます。"

#: of sqlalchemy.types.TypeEngine.bind_expression:1
msgid ""
"\"Given a bind value (i.e. a :class:`.BindParameter` instance), return a "
"SQL expression in its place."
msgstr "バインド値（つまり、：class： `.BindParameter`インスタンス）を指定すると、代わりにSQL式を返します。"

#: of sqlalchemy.types.TypeEngine.bind_expression:4
msgid ""
"This is typically a SQL function that wraps the existing bound parameter "
"within the statement.  It is used for special data types that require "
"literals being wrapped in some special database function in order to "
"coerce an application-level value into a database-specific format.  It is"
" the SQL analogue of the :meth:`.TypeEngine.bind_processor` method."
msgstr "これは通常、文の中に既存のバインドされたパラメータをラップするSQL関数です。アプリケーションレベルの値をデータベース固有の形式に変換するために、特別なデータベース関数でリテラルをラップする必要がある特殊なデータ型に使用されます。これは：meth： `.TypeEngine.bind_processor`メソッドのSQLの類義語です。"

#: of sqlalchemy.types.TypeEngine.bind_expression:11
#: sqlalchemy.types.TypeEngine.column_expression:11
msgid ""
"The method is evaluated at statement compile time, as opposed to "
"statement construction time."
msgstr "このメソッドは、文の構築時とは異なり、文のコンパイル時に評価されます。"

#: of sqlalchemy.types.TypeEngine.bind_expression:14
msgid ""
"Note that this method, when implemented, should always return the exact "
"same structure, without any conditional logic, as it may be used in an "
"executemany() call against an arbitrary number of bound parameter sets."
msgstr "このメソッドを実装すると、任意の数のバインドされたパラメータセットに対してexecutemany（）コールで使用できるため、条件付きロジックなしで常に同じ構造体を返す必要があることに注意してください。"

#: of sqlalchemy.types.TypeEngine.bind_expression:19
#: sqlalchemy.types.TypeEngine.column_expression:14
msgid "See also:"
msgstr "参照："

#: of sqlalchemy.types.TypeEngine.bind_expression:21
#: sqlalchemy.types.TypeEngine.column_expression:16
msgid ":ref:`types_sql_value_processing`"
msgstr "：ref： `types_sql_value_processing`"

#: of sqlalchemy.types.TypeEngine.bind_processor:1
msgid "Return a conversion function for processing bind values."
msgstr "バインド値を処理するための変換関数を返します。"

#: of sqlalchemy.types.TypeEngine.bind_processor:3
msgid ""
"Returns a callable which will receive a bind parameter value as the sole "
"positional argument and will return a value to send to the DB-API."
msgstr "バインド・パラメータ値を唯一の位置引数として受け取り、DB-APIに送る値を戻すコール可能オブジェクトを戻します。"

#: of sqlalchemy.types.TypeEngine.bind_processor:7
#: sqlalchemy.types.TypeEngine.result_processor:7
msgid "If processing is not necessary, the method should return ``None``."
msgstr "処理が必要ない場合、メソッドは `` None``を返すべきです。"

#: of sqlalchemy.types.TypeEngine.bind_processor
#: sqlalchemy.types.TypeEngine.compare_against_backend
#: sqlalchemy.types.TypeEngine.compile
#: sqlalchemy.types.TypeEngine.result_processor
#: sqlalchemy.types.TypeEngine.with_variant
msgid "パラメータ"
msgstr "パラメータ"

#: of sqlalchemy.types.TypeEngine.bind_processor:9
#: sqlalchemy.types.TypeEngine.result_processor:9
msgid "Dialect instance in use."
msgstr "使用中の方言インスタンス。"

#: of sqlalchemy.types.TypeEngine.coerce_compared_value:1
msgid "Suggest a type for a 'coerced' Python value in an expression."
msgstr "式で「強制的」なPython値の型を推薦する。"

#: of sqlalchemy.types.TypeEngine.coerce_compared_value:3
msgid ""
"Given an operator and value, gives the type a chance to return a type "
"which the value should be coerced into."
msgstr "与えられた演算子と値は、型に強制的に値を代入する型を返す。"

#: of sqlalchemy.types.TypeEngine.coerce_compared_value:6
msgid ""
"The default behavior here is conservative; if the right-hand side is "
"already coerced into a SQL type based on its Python type, it is usually "
"left alone."
msgstr "ここでのデフォルトの動作は保守的です。右側がすでにPython型に基づいてSQL型に強制的に変換されている場合、通常はそのまま残されます。"

#: of sqlalchemy.types.TypeEngine.coerce_compared_value:10
msgid ""
"End-user functionality extension here should generally be via "
":class:`.TypeDecorator`, which provides more liberal behavior in that it "
"defaults to coercing the other side of the expression into this type, "
"thus applying special Python conversions above and beyond those needed by"
" the DBAPI to both ides. It also provides the public method "
":meth:`.TypeDecorator.coerce_compared_value` which is intended for end-"
"user customization of this behavior."
msgstr "ここでのエンドユーザ機能拡張は、一般的にvia：class： `.TypeDecorator`でなければなりません。これはデフォルトで式の反対側をこの型に強制するというより自由な動作を提供します。両方の側にDBAPI。また、publicメソッドを提供します：meth： `.TypeDecorator.coerce_compared_value`これは、この動作のエンドユーザのカスタマイズを意図しています。"

#: of sqlalchemy.types.TypeEngine.column_expression:1
msgid "Given a SELECT column expression, return a wrapping SQL expression."
msgstr "SELECT列式が指定されている場合、ラッピングSQL式を返します。"

#: of sqlalchemy.types.TypeEngine.column_expression:3
msgid ""
"This is typically a SQL function that wraps a column expression as "
"rendered in the columns clause of a SELECT statement. It is used for "
"special data types that require columns to be wrapped in some special "
"database function in order to coerce the value before being sent back to "
"the application. It is the SQL analogue of the "
":meth:`.TypeEngine.result_processor` method."
msgstr "これは、通常、SELECT文のcolumns句にレンダリングされた列式をラップするSQL関数です。これは、アプリケーションに返される前に値を強制的に使用するために、特別なデータベース関数で列をラップする必要がある特殊なデータ型に使用されます。それは：meth： `.TypeEngine.result_processor`メソッドのSQLの類義語です。"

#: of sqlalchemy.types.TypeEngine.comparator_factory:1
msgid ""
"A :class:`.TypeEngine.Comparator` class which will apply to operations "
"performed by owning :class:`.ColumnElement` objects."
msgstr "A：class： `.TypeEngine.Comparator`クラスです。このクラスは、owning：class：` .ColumnElement`オブジェクトによって実行される操作に適用されます。"

#: of sqlalchemy.types.TypeEngine.comparator_factory:4
msgid ""
"The :attr:`.comparator_factory` attribute is a hook consulted by the core"
" expression system when column and SQL expression operations are "
"performed.   When a :class:`.TypeEngine.Comparator` class is associated "
"with this attribute, it allows custom re-definition of all existing "
"operators, as well as definition of new operators. Existing operators "
"include those provided by Python operator overloading such as "
":meth:`.operators.ColumnOperators.__add__` and "
":meth:`.operators.ColumnOperators.__eq__`, those provided as standard "
"attributes of :class:`.operators.ColumnOperators` such as "
":meth:`.operators.ColumnOperators.like` and "
":meth:`.operators.ColumnOperators.in_`."
msgstr "：attr： `.comparator_factory`属性は、列式とSQL式の演算が実行されるときに、コア式システムによって参照されるフックです。 a：class： `.TypeEngine.Comparator`クラスがこの属性に関連付けられている場合、既存のすべての演算子の新しい定義や新しい演算子の定義を行うことができます。既存の演算子には：meth： `.operators.ColumnOperators .__ add__`と：meth：` .operators.ColumnOperators .__ eq__`のようなPython演算子のオーバーロードによって提供されるものが含まれます：class： `.operators.ColumnOperators` ：meth： `.operators.ColumnOperators.like`と：meth：` .operators.ColumnOperators.in_`のようなものです。"

#: of sqlalchemy.types.TypeEngine.comparator_factory:17
msgid ""
"Rudimentary usage of this hook is allowed through simple subclassing of "
"existing types, or alternatively by using :class:`.TypeDecorator`. See "
"the documentation section :ref:`types_operators` for examples."
msgstr "このフックの基本的な使い方は、既存の型を単純にサブクラス化するか、または：class： `.TypeDecorator`を使用することで可能です。例については、ドキュメンテーションのsection：ref： `types_operators`を参照してください。"

#: of sqlalchemy.types.TypeEngine.comparator_factory:21
msgid ""
"The expression system was enhanced to support customization of operators "
"on a per-type level."
msgstr "表現システムは、タイプごとのレベルでの演算子のカスタマイズをサポートするように拡張されました。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:1
msgid "Compare this type against the given backend type."
msgstr "このタイプを指定されたバックエンドタイプと比較してください。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:3
msgid ""
"This function is currently not implemented for SQLAlchemy types, and for "
"all built in types will return ``None``.  However, it can be implemented "
"by a user-defined type where it can be consumed by schema comparison "
"tools such as Alembic autogenerate."
msgstr "この関数は現在SQLAlchemy型では実装されていません。組み込み型では `` None``が返されます。ただし、Alembicの自動生成などのスキーマ比較ツールで使用できるユーザー定義型で実装できます。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:9
msgid ""
"A future release of SQLAlchemy will potentially impement this method for "
"builtin types as well."
msgstr "SQLAlchemyの今後のリリースでは、組み込み型に対してもこのメソッドを実装する可能性があります。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:12
msgid ""
"The function should return True if this type is equivalent to the given "
"type; the type is typically reflected from the database so should be "
"database specific.  The dialect in use is also passed.   It can also "
"return False to assert that the type is not equivalent."
msgstr "この型が指定された型と等しい場合、この関数はTrueを返さなければなりません。型は通常データベースから反映されるため、データベース固有である必要があります。使用中の方言も渡されます。また、型が等価でないことを宣言するためにFalseを返すこともできます。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:18
msgid "a :class:`.Dialect` that is involved in the comparison."
msgstr "a：class：比較に含まれる `.Dialect`です。"

#: of sqlalchemy.types.TypeEngine.compare_against_backend:20
msgid "the type object reflected from the backend."
msgstr "バックエンドから反映された型オブジェクト"

#: of sqlalchemy.types.TypeEngine.compare_values:1
msgid "Compare two values for equality."
msgstr "2つの値が等しいかどうかを比較する。"

#: of sqlalchemy.types.TypeEngine.compile:1
msgid "Produce a string-compiled form of this :class:`.TypeEngine`."
msgstr "クラス： `.TypeEngine`の文字列でコンパイルされた形式を生成します。"

#: of sqlalchemy.types.TypeEngine.compile:3
msgid ""
"When called with no arguments, uses a \"default\" dialect to produce a "
"string result."
msgstr "引数なしで呼び出された場合、\ &quot;default \&quot;という方言を使用して文字列の結果を生成します。"

#: of sqlalchemy.types.TypeEngine.compile:6
msgid "a :class:`.Dialect` instance."
msgstr "a：class： `.Dialect`インスタンスです。"

#: of sqlalchemy.types.TypeEngine.dialect_impl:1
msgid "Return a dialect-specific implementation for this :class:`.TypeEngine`."
msgstr "このために、方言固有の実装を返します：class： `.TypeEngine`。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:1
msgid ""
"Return a copy of this type which has the :attr:`.should_evaluate_none` "
"flag set to True."
msgstr "：attr： `.should_evaluate_none`フラグがTrueに設定されているこのタイプのコピーを返します。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:4
msgid "E.g.::"
msgstr "例えば：："

#: of sqlalchemy.types.TypeEngine.evaluates_none:14
msgid ""
"The ORM uses this flag to indicate that a positive value of ``None`` is "
"passed to the column in an INSERT statement, rather than omitting the "
"column from the INSERT statement which has the effect of firing off "
"column-level defaults.   It also allows for types which have special "
"behavior associated with the Python None value to indicate that the value"
" doesn't necessarily translate into SQL NULL; a prime example of this is "
"a JSON type which may wish to persist the JSON value ``'null'``."
msgstr "ORMは、このフラグを使用して、列レベルのデフォルトを起動する効果を持つINSERT文から列を省略するのではなく、INSERT文の列に `` None``の正の値が渡されることを示します。また、PythonのNone値に関連付けられた特別な動作を持つ型で、値が必ずしもSQL NULLに変換されないことを示すことができます。 JSON値 `` &#39;null&#39;``を永続化したいJSON型です。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:23
msgid ""
"In all cases, the actual NULL SQL value can be always be persisted in any"
" column by using the :obj:`~.expression.null` SQL construct in an INSERT "
"statement or associated with an ORM-mapped attribute."
msgstr "いずれの場合でも、実際のNULL SQL値は、INSERT文の中で：obj： `〜.expression.null` SQL構文を使用するか、ORMでマップされた属性に関連付けて、いつでも任意の列に永続化することができます。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:30
msgid ""
"The \"evaulates none\" flag does **not** apply to a value of ``None`` "
"passed to :paramref:`.Column.default` or "
":paramref:`.Column.server_default`; in these cases, ``None`` still means "
"\"no default\"."
msgstr "\ &quot;evaulates none \&quot;フラグは、paramref： `.Column.default`または：paramref：` .Column.server_default`;に渡される `` None``の値には適用されません。これらの場合、 `` None``は\ &quot;no default \&quot;を意味します。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:39
msgid ":ref:`session_forcing_null` - in the ORM documentation"
msgstr "：ref： `session_forcing_null`  -  ORMのドキュメント"

#: of sqlalchemy.types.TypeEngine.evaluates_none:41
msgid ""
":paramref:`.postgresql.JSON.none_as_null` - PostgreSQL JSON interaction "
"with this flag."
msgstr "：paramref： `.postgresql.JSON.none_as_null`  -  PostgreSQL JSONはこのフラグと対話します。"

#: of sqlalchemy.types.TypeEngine.evaluates_none:44
msgid ":attr:`.TypeEngine.should_evaluate_none` - class-level flag"
msgstr "：attr： `.TypeEngine.should_evaluate_none`  - クラスレベルのフラグ"

#: of sqlalchemy.types.TypeEngine.get_dbapi_type:1
msgid "Return the corresponding type object from the underlying DB-API, if any."
msgstr "基礎となるDB-APIから対応する型オブジェクトを返します。"

#: of sqlalchemy.types.TypeEngine.get_dbapi_type:4
msgid "This can be useful for calling ``setinputsizes()``, for example."
msgstr "これは例えば `` setinputsizes（） ``を呼び出すのに便利です。"

#: of sqlalchemy.types.TypeEngine.hashable:1
msgid "Flag, if False, means values from this type aren't hashable."
msgstr "フラグがFalseの場合、この型の値はハッシュ可能ではないことを意味します。"

#: of sqlalchemy.types.TypeEngine.hashable:3
msgid "Used by the ORM when uniquing result lists."
msgstr "結果リストを一意にするときにORMによって使用されます。"

#: of sqlalchemy.types.TypeEngine.literal_processor:1
msgid ""
"Return a conversion function for processing literal values that are to be"
" rendered directly without using binds."
msgstr "バインドを使用せずに直接レンダリングされるリテラル値を処理するための変換関数を返します。"

#: of sqlalchemy.types.TypeEngine.literal_processor:4
msgid ""
"This function is used when the compiler makes use of the "
"\"literal_binds\" flag, typically used in DDL generation as well as in "
"certain scenarios where backends don't accept bound parameters."
msgstr "この関数は、コンパイラが\ &quot;literal_binds \&quot;フラグを使用するときに使用されます。通常、DDL生成やバックエンドがバインドされたパラメータを受け付けないシナリオで使用されます。"

#: of sqlalchemy.types.TypeEngine.python_type:1
msgid ""
"Return the Python type object expected to be returned by instances of "
"this type, if known."
msgstr "既知の場合、この型のインスタンスによって返されると予想されるPython型オブジェクトを返します。"

#: of sqlalchemy.types.TypeEngine.python_type:4
msgid ""
"Basically, for those types which enforce a return type, or are known "
"across the board to do such for all common DBAPIs (like ``int`` for "
"example), will return that type."
msgstr "基本的には、戻り値の型を強制する型や、一般的なDBAPI（例えば `` int``など）のために全面的に知られている型の場合、その型を返します。"

#: of sqlalchemy.types.TypeEngine.python_type:8
msgid "If a return type is not defined, raises ``NotImplementedError``."
msgstr "戻り値の型が定義されていない場合、 `` NotImplementedError``が送出されます。"

#: of sqlalchemy.types.TypeEngine.python_type:11
msgid ""
"Note that any type also accommodates NULL in SQL which means you can also"
" get back ``None`` from any type in practice."
msgstr "どんな型もSQLにNULLを格納することに注意してください。つまり、実際にはどの型からでも `` None``を返すことができます。"

#: of sqlalchemy.types.TypeEngine.result_processor:1
msgid "Return a conversion function for processing result row values."
msgstr "結果行の値を処理するための変換関数を返します。"

#: of sqlalchemy.types.TypeEngine.result_processor:3
msgid ""
"Returns a callable which will receive a result row column value as the "
"sole positional argument and will return a value to return to the user."
msgstr "結果行の列値を唯一の位置引数として受け取るコール可能オブジェクトを返し、値を返してユーザーに返します。"

#: of sqlalchemy.types.TypeEngine.result_processor:11
msgid "DBAPI coltype argument received in cursor.description."
msgstr "cursor.descriptionでDBAPI coltype引数を受け取りました。"

#: of sqlalchemy.types.TypeEngine.should_evaluate_none:1
msgid ""
"If True, the Python constant ``None`` is considered to be handled "
"explicitly by this type."
msgstr "Trueの場合、Python定数 `` None``はこの型によって明示的に扱われると考えられます。"

#: of sqlalchemy.types.TypeEngine.should_evaluate_none:4
msgid ""
"The ORM uses this flag to indicate that a positive value of ``None`` is "
"passed to the column in an INSERT statement, rather than omitting the "
"column from the INSERT statement which has the effect of firing off "
"column-level defaults.   It also allows types which have special behavior"
" for Python None, such as a JSON type, to indicate that they'd like to "
"handle the None value explicitly."
msgstr "ORMは、このフラグを使用して、列レベルのデフォルトを起動する効果を持つINSERT文から列を省略するのではなく、INSERT文の列に `` None``の正の値が渡されることを示します。また、JSON型のようなPython Noneの特別な振る舞いを持つ型は、None値を明示的に扱いたいことを示すことができます。"

#: of sqlalchemy.types.TypeEngine.should_evaluate_none:11
msgid ""
"To set this flag on an existing type, use the "
":meth:`.TypeEngine.evaluates_none` method."
msgstr "このフラグを既存の型に設定するには、：meth： `.TypeEngine.evaluates_none`メソッドを使用します。"

#: of sqlalchemy.types.TypeEngine.should_evaluate_none:16
msgid ":meth:`.TypeEngine.evaluates_none`"
msgstr "：meth： `.TypeEngine.evaluates_none`"

#: of sqlalchemy.types.TypeEngine.with_variant:1
msgid ""
"Produce a new type object that will utilize the given type when applied "
"to the dialect of the given name."
msgstr "与えられた名前の方言に適用されたときに、与えられた型を利用する新しい型オブジェクトを生成する。"

#: of sqlalchemy.types.TypeEngine.with_variant:4
msgid "e.g.::"
msgstr "例えば：："

#: of sqlalchemy.types.TypeEngine.with_variant:13
msgid ""
"The construction of :meth:`.TypeEngine.with_variant` is always from the "
"\"fallback\" type to that which is dialect specific. The returned type is"
" an instance of :class:`.Variant`, which itself provides a "
":meth:`.Variant.with_variant` that can be called repeatedly."
msgstr "：meth： `.TypeEngine.with_variant`の構成は、常に「フォールバック」型から、方言固有の型へと変わります。返される型は：class： `.Variant`のインスタンスであり、それ自身が：meth：` .Variant.with_variant`を繰り返し提供することができます。"

#: of sqlalchemy.types.TypeEngine.with_variant:19
msgid ""
"a :class:`.TypeEngine` that will be selected as a variant from the "
"originating type, when a dialect of the given name is in use."
msgstr "a：class： `.TypeEngine`。指定された名前の方言が使用されているときに、元の型からバリアントとして選択されます。"

#: of sqlalchemy.types.TypeEngine.with_variant:22
msgid ""
"base name of the dialect which uses this type. (i.e. ``'postgresql'``, "
"``'mysql'``, etc.)"
msgstr "この型を使用する方言の基底名。 （つまり、 `` &#39;postgresql``、 ``&#39; mysql&#39;``など）"

#: of sqlalchemy.types.Concatenable:1
msgid ""
"A mixin that marks a type as supporting 'concatenation', typically "
"strings."
msgstr "あるタイプを「連結」（通常は文字列）をサポートするものとしてマークするミックスイン。"

#: of sqlalchemy.types.Indexable:1
msgid ""
"A mixin that marks a type as supporting indexing operations, such as "
"array or JSON structures."
msgstr "配列やJSON構造などのインデックス作成操作をサポートする型をマークするmixin。"

#: of sqlalchemy.types.NullType:1
msgid "An unknown type."
msgstr "不明なタイプです。"

#: of sqlalchemy.types.NullType:3
msgid ""
":class:`.NullType` is used as a default type for those cases where a type"
" cannot be determined, including:"
msgstr "：class： `.NullType`は、タイプを特定できない場合のデフォルトタイプとして使用されます。"

#: of sqlalchemy.types.NullType:6
msgid ""
"During table reflection, when the type of a column is not recognized by "
"the :class:`.Dialect`"
msgstr "テーブルリフレクション中に、：class： `.Dialect`によって列の型が認識されないとき"

#: of sqlalchemy.types.NullType:8
msgid ""
"When constructing SQL expressions using plain Python objects of unknown "
"types (e.g. ``somecolumn == my_special_object``)"
msgstr "型が未知のプレーンなPythonオブジェクト（例えば `` somecolumn == my_special_object``）を使ってSQL式を構築するとき、"

#: of sqlalchemy.types.NullType:10
msgid ""
"When a new :class:`.Column` is created, and the given type is passed as "
"``None`` or is not passed at all."
msgstr "new：class： `.Column`が作成され、与えられた型が` `None``として渡されるか、まったく渡されません。"

#: of sqlalchemy.types.NullType:13
msgid ""
"The :class:`.NullType` can be used within SQL expression invocation "
"without issue, it just has no behavior either at the expression "
"construction level or at the bind-parameter/result processing level. "
":class:`.NullType` will result in a :exc:`.CompileError` if the compiler "
"is asked to render the type itself, such as if it is used in a "
":func:`.cast` operation or within a schema creation operation such as "
"that invoked by :meth:`.MetaData.create_all` or the :class:`.CreateTable`"
" construct."
msgstr "：class： `.NullType`は、SQL式の呼び出し内で問題なく使用できます。式の構築レベルまたはバインドパラメータ/結果処理レベルで動作しません。 ：class： `.NullType`は、：func：` .cast`オペレーションやスキーマの作成で使用されている場合など、コンパイラに型自体のレンダリングを要求された場合は：exc： `.CompileError`を返します：meth： `.MetaData.create_all`または：class：` .CreateTable`構造体によって呼び出されるような操作です。"

#: of sqlalchemy.types.Variant:1
msgid ""
"A wrapping type that selects among a variety of implementations based on "
"dialect in use."
msgstr "使用中の方言に基づいてさまざまな実装の中から選択するラッピング型。"

#: of sqlalchemy.types.Variant:4
msgid ""
"The :class:`.Variant` type is typically constructed using the "
":meth:`.TypeEngine.with_variant` method."
msgstr "：class： `.Variant`型は、通常：meth：` .TypeEngine.with_variant`メソッドを使って構築されます。"

#: of sqlalchemy.types.Variant:9
msgid ":meth:`.TypeEngine.with_variant` for an example of use."
msgstr "：meth： `.TypeEngine.with_variant`は使用例です。"

#: ../../core/type_api.rst
msgid "members"
msgstr "メンバー"

#: ../../core/type_api.rst:24
msgid "with_variant, __init__"
msgstr "with_variant、__init__"


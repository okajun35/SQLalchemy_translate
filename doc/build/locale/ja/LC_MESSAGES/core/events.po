# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""

#: ../../core/events.rst:4
msgid "Core Events"
msgstr "コアイベント"

#: ../../core/events.rst:6
msgid ""
"This section describes the event interfaces provided in SQLAlchemy Core. "
"For an introduction to the event listening API, see "
":ref:`event_toplevel`. ORM events are described in "
":ref:`orm_event_toplevel`."
msgstr "このセクションでは、SQLAlchemy Coreで提供されるイベントインターフェイスについて説明します。イベントリスニングAPIの概要については、：ref： `event_toplevel`を参照してください。 ORMイベントは：ref： `orm_event_toplevel`に記述されています。"

#: of sqlalchemy.event.base.Events:1
msgid "Define event listening functions for a particular target type."
msgstr "特定のターゲット・タイプのイベント・リスニング機能を定義します。"

#: ../../core/events.rst:15
msgid "Connection Pool Events"
msgstr "接続プールのイベント"

#: of sqlalchemy.events.PoolEvents:1
msgid "Available events for :class:`.Pool`."
msgstr "：class： `.Pool`に対して利用可能なイベントです。"

#: of sqlalchemy.events.ConnectionEvents:4 sqlalchemy.events.DDLEvents:42
#: sqlalchemy.events.PoolEvents:3
msgid ""
"The methods here define the name of an event as well as the names of "
"members that are passed to listener functions."
msgstr "ここでのメソッドは、リスナー関数に渡されるメンバーの名前だけでなく、イベントの名前も定義します。"

#: of sqlalchemy.events.PoolEvents:7
msgid "e.g.::"
msgstr "例えば：："

#: of sqlalchemy.events.PoolEvents:16
msgid ""
"In addition to accepting the :class:`.Pool` class and :class:`.Pool` "
"instances, :class:`.PoolEvents` also accepts :class:`.Engine` objects and"
" the :class:`.Engine` class as targets, which will be resolved to the "
"``.pool`` attribute of the given engine or the :class:`.Pool` class::"
msgstr "：class： `.Pool`クラスと：class：` .Pool`インスタンスを受け入れることに加えて、：class： `.PoolEvents`は：class：` .Engine`オブジェクトと：class： `.Engine`クラスも受け入れますターゲットとして指定されたエンジンの `` .pool``属性に解決される：class： `.Pool` class ::"

#: of sqlalchemy.events.PoolEvents.checkin:1
msgid "Called when a connection returns to the pool."
msgstr "接続がプールに戻るときに呼び出されます。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:5
#: sqlalchemy.events.ConnectionEvents.after_execute:5
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute:7
#: sqlalchemy.events.ConnectionEvents.before_execute:6
#: sqlalchemy.events.ConnectionEvents.begin:5
#: sqlalchemy.events.ConnectionEvents.begin_twophase:5
#: sqlalchemy.events.ConnectionEvents.commit:6
#: sqlalchemy.events.ConnectionEvents.commit_twophase:5
#: sqlalchemy.events.ConnectionEvents.dbapi_error:5
#: sqlalchemy.events.ConnectionEvents.engine_connect:5
#: sqlalchemy.events.ConnectionEvents.engine_disposed:5
#: sqlalchemy.events.ConnectionEvents.handle_error:5
#: sqlalchemy.events.ConnectionEvents.prepare_twophase:5
#: sqlalchemy.events.ConnectionEvents.release_savepoint:5
#: sqlalchemy.events.ConnectionEvents.rollback:6
#: sqlalchemy.events.ConnectionEvents.rollback_savepoint:5
#: sqlalchemy.events.ConnectionEvents.rollback_twophase:5
#: sqlalchemy.events.ConnectionEvents.savepoint:5
#: sqlalchemy.events.ConnectionEvents.set_connection_execution_options:6
#: sqlalchemy.events.ConnectionEvents.set_engine_execution_options:6
#: sqlalchemy.events.DDLEvents.after_create:5
#: sqlalchemy.events.DDLEvents.after_drop:5
#: sqlalchemy.events.DDLEvents.after_parent_attach:6
#: sqlalchemy.events.DDLEvents.before_create:5
#: sqlalchemy.events.DDLEvents.before_drop:5
#: sqlalchemy.events.DDLEvents.before_parent_attach:6
#: sqlalchemy.events.DDLEvents.column_reflect:6
#: sqlalchemy.events.DialectEvents.do_connect:5
#: sqlalchemy.events.DialectEvents.do_execute:5
#: sqlalchemy.events.DialectEvents.do_execute_no_params:5
#: sqlalchemy.events.DialectEvents.do_executemany:5
#: sqlalchemy.events.DialectEvents.do_setinputsizes:5
#: sqlalchemy.events.PoolEvents.checkin:5
#: sqlalchemy.events.PoolEvents.checkout:5 sqlalchemy.events.PoolEvents.close:5
#: sqlalchemy.events.PoolEvents.close_detached:5
#: sqlalchemy.events.PoolEvents.connect:6 sqlalchemy.events.PoolEvents.detach:5
#: sqlalchemy.events.PoolEvents.first_connect:6
#: sqlalchemy.events.PoolEvents.invalidate:5
#: sqlalchemy.events.PoolEvents.reset:5
#: sqlalchemy.events.PoolEvents.soft_invalidate:5
msgid "Example argument forms::"
msgstr "引数フォームの例::"

#: of sqlalchemy.events.PoolEvents.checkin:17
msgid ""
"Note that the connection may be closed, and may be None if the connection"
" has been invalidated.  ``checkin`` will not be called for detached "
"connections.  (They do not return to the pool.)"
msgstr "接続が閉じられている可能性があります。接続が無効になっている場合は、Noneになることがあります。分離された接続に対して `` checkin``は呼び出されません。 （彼らはプールに戻りません。）"

#: of sqlalchemy.events.ConnectionEvents
#: sqlalchemy.events.ConnectionEvents.after_cursor_execute
#: sqlalchemy.events.ConnectionEvents.after_execute
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute
#: sqlalchemy.events.ConnectionEvents.before_execute
#: sqlalchemy.events.ConnectionEvents.begin
#: sqlalchemy.events.ConnectionEvents.begin_twophase
#: sqlalchemy.events.ConnectionEvents.commit
#: sqlalchemy.events.ConnectionEvents.commit_twophase
#: sqlalchemy.events.ConnectionEvents.dbapi_error
#: sqlalchemy.events.ConnectionEvents.engine_connect
#: sqlalchemy.events.ConnectionEvents.handle_error
#: sqlalchemy.events.ConnectionEvents.prepare_twophase
#: sqlalchemy.events.ConnectionEvents.release_savepoint
#: sqlalchemy.events.ConnectionEvents.rollback
#: sqlalchemy.events.ConnectionEvents.rollback_savepoint
#: sqlalchemy.events.ConnectionEvents.rollback_twophase
#: sqlalchemy.events.ConnectionEvents.savepoint
#: sqlalchemy.events.ConnectionEvents.set_connection_execution_options
#: sqlalchemy.events.ConnectionEvents.set_engine_execution_options
#: sqlalchemy.events.DDLEvents.after_create
#: sqlalchemy.events.DDLEvents.after_drop
#: sqlalchemy.events.DDLEvents.after_parent_attach
#: sqlalchemy.events.DDLEvents.before_create
#: sqlalchemy.events.DDLEvents.before_drop
#: sqlalchemy.events.DDLEvents.before_parent_attach
#: sqlalchemy.events.PoolEvents.checkin sqlalchemy.events.PoolEvents.checkout
#: sqlalchemy.events.PoolEvents.connect
#: sqlalchemy.events.PoolEvents.first_connect
#: sqlalchemy.events.PoolEvents.invalidate sqlalchemy.events.PoolEvents.reset
msgid "パラメータ"
msgstr "パラメータ"

#: of sqlalchemy.events.PoolEvents.checkin:21
#: sqlalchemy.events.PoolEvents.checkout:17
#: sqlalchemy.events.PoolEvents.connect:22
#: sqlalchemy.events.PoolEvents.first_connect:28
#: sqlalchemy.events.PoolEvents.invalidate:24
#: sqlalchemy.events.PoolEvents.reset:28
msgid "a DBAPI connection."
msgstr "DBAPI接続。"

#: of sqlalchemy.events.PoolEvents.checkin:23
#: sqlalchemy.events.PoolEvents.checkout:19
#: sqlalchemy.events.PoolEvents.connect:24
#: sqlalchemy.events.PoolEvents.first_connect:30
#: sqlalchemy.events.PoolEvents.invalidate:26
#: sqlalchemy.events.PoolEvents.reset:30
msgid "the :class:`._ConnectionRecord` managing the DBAPI connection."
msgstr "：class： `._ConnectionRecord`はDBAPI接続を管理します。"

#: of sqlalchemy.events.PoolEvents.checkout:1
msgid "Called when a connection is retrieved from the Pool."
msgstr "接続がプールから取得されたときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.checkout:22
msgid ""
"the :class:`._ConnectionFairy` object which will proxy the public "
"interface of the DBAPI connection for the lifespan of the checkout."
msgstr "：class： `._ConnectionFairy`オブジェクトは、チェックアウトの寿命の間、DBAPI接続のパブリックインターフェイスをプロキシします。"

#: of sqlalchemy.events.PoolEvents.checkout:26
msgid ""
"If you raise a :class:`~sqlalchemy.exc.DisconnectionError`, the current "
"connection will be disposed and a fresh connection retrieved. Processing "
"of all checkout listeners will abort and restart using the new "
"connection."
msgstr "：class： `〜sqlalchemy.exc.DisconnectionError`を発行すると、現在の接続が破棄され、新しい接続が取得されます。すべてのチェックアウトリスナーの処理が中止され、新しい接続を使用して再開されます。"

#: of sqlalchemy.events.PoolEvents.checkout:31
msgid ""
":meth:`.ConnectionEvents.engine_connect` - a similar event which occurs "
"upon creation of a new :class:`.Connection`."
msgstr "：meth： `.ConnectionEvents.engine_connect`  -  new：class：` .Connection`の作成時に発生する同様のイベントです。"

#: of sqlalchemy.events.PoolEvents.close:1
msgid "Called when a DBAPI connection is closed."
msgstr "DBAPI接続が閉じられたときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.close:17
#: sqlalchemy.events.PoolEvents.close_detached:17
msgid "The event is emitted before the close occurs."
msgstr "イベントは、クローズが発生する前に送出されます。"

#: of sqlalchemy.events.PoolEvents.close:19
#: sqlalchemy.events.PoolEvents.close_detached:19
msgid ""
"The close of a connection can fail; typically this is because the "
"connection is already closed.  If the close operation fails, the "
"connection is discarded."
msgstr "接続の終了は失敗する可能性があります。これは通常、接続がすでに閉じられているためです。クローズ操作が失敗した場合、接続は破棄されます。"

#: of sqlalchemy.events.PoolEvents.close:23
msgid ""
"The :meth:`.close` event corresponds to a connection that's still "
"associated with the pool. To intercept close events for detached "
"connections use :meth:`.close_detached`."
msgstr "：meth： `.close`イベントは、まだプールに関連付けられている接続に対応します。分離された接続のcloseイベントを傍受するには：meth： `.close_detached`を使用します。"

#: of sqlalchemy.events.PoolEvents.close_detached:1
msgid "Called when a detached DBAPI connection is closed."
msgstr "切り離されたDBAPI接続が閉じられたときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.connect:1
msgid ""
"Called at the moment a particular DBAPI connection is first created for a"
" given :class:`.Pool`."
msgstr "特定のDBAPI接続が最初に生成されたときに呼び出されます：class： `.Pool`。"

#: of sqlalchemy.events.PoolEvents.connect:18
msgid ""
"This event allows one to capture the point directly after which the DBAPI"
" module-level ``.connect()`` method has been used in order to produce a "
"new DBAPI connection."
msgstr "このイベントにより、新しいDBAPI接続を生成するためにDBAPIモジュールレベルの `` .connect（） ``メソッドが使用された直後のポイントを取得できます。"

#: of sqlalchemy.events.PoolEvents.detach:1
msgid "Called when a DBAPI connection is \"detached\" from a pool."
msgstr "DBAPI接続がプールから「切り離された」ときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.detach:17
msgid ""
"This event is emitted after the detach occurs.  The connection is no "
"longer associated with the given connection record."
msgstr "このイベントは、デタッチが発生した後に発生します。接続は、指定された接続レコードに関連付けられなくなりました。"

#: of sqlalchemy.events.PoolEvents.first_connect:1
msgid ""
"Called exactly once for the first time a DBAPI connection is checked out "
"from a particular :class:`.Pool`."
msgstr "DBAPI接続が特定の：class： `.Pool`から最初にチェックアウトされたときに初めて正確に呼び出されます。"

#: of sqlalchemy.events.PoolEvents.first_connect:18
msgid ""
"The rationale for :meth:`.PoolEvents.first_connect` is to determine "
"information about a particular series of database connections based on "
"the settings used for all connections.  Since a particular :class:`.Pool`"
" refers to a single \"creator\" function (which in terms of a "
":class:`.Engine` refers to the URL and connection options used), it is "
"typically valid to make observations about a single connection that can "
"be safely assumed to be valid about all subsequent connections, such as "
"the database version, the server and client encoding settings, collation "
"settings, and many others."
msgstr "：meth： `.PoolEvents.first_connect`の根拠は、すべての接続で使用される設定に基づいて特定の一連のデータベース接続に関する情報を判断することです。特定の：class： `.Pool`は単一の&quot; creator &quot;関数（class：` .Engine`はURLと接続オプションを指します）を参照するので、通常は観測を行うのに有効ですデータベースのバージョン、サーバーとクライアントのエンコーディング設定、照合設定などの後続のすべての接続について、安全に有効と見なすことができる単一の接続について説明します。"

#: of sqlalchemy.events.PoolEvents.invalidate:1
msgid "Called when a DBAPI connection is to be \"invalidated\"."
msgstr "DBAPI接続が\ &quot;無効化\&quot;されるときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.invalidate:17
msgid ""
"This event is called any time the :meth:`._ConnectionRecord.invalidate` "
"method is invoked, either from API usage or via \"auto-invalidation\", "
"without the ``soft`` flag."
msgstr "このイベントは、APIの使用法または\ &quot;自動無効化\&quot;を介して、 `` soft``フラグなしで：meth： `._ConnectionRecord.invalidate`メソッドが呼び出されたときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.invalidate:21
msgid ""
"The event occurs before a final attempt to call ``.close()`` on the "
"connection occurs."
msgstr "このイベントは、接続時に `` .close（） ``を呼び出す最後の試行が発生する前に発生します。"

#: of sqlalchemy.events.PoolEvents.invalidate:29
msgid ""
"the exception object corresponding to the reason for this invalidation, "
"if any.  May be ``None``."
msgstr "存在する場合、この無効化の理由に対応する例外オブジェクト`` None``かもしれません。"

#: of sqlalchemy.events.PoolEvents.invalidate:32
msgid "Added support for connection invalidation listening."
msgstr "接続無効化リスニングのサポートが追加されました。"

#: of sqlalchemy.events.PoolEvents.invalidate:37
msgid ":ref:`pool_connection_invalidation`"
msgstr "：ref： `pool_connection_invalidation`"

#: of sqlalchemy.events.PoolEvents.reset:1
msgid "Called before the \"reset\" action occurs for a pooled connection."
msgstr "プールされた接続に対して「リセット」アクションが発生する前に呼び出されます。"

#: of sqlalchemy.events.PoolEvents.reset:17
msgid ""
"This event represents when the ``rollback()`` method is called on the "
"DBAPI connection before it is returned to the pool.  The behavior of "
"\"reset\" can be controlled, including disabled, using the "
"``reset_on_return`` pool argument."
msgstr "このイベントは、プールに返される前にDBAPI接続で `` rollback（） ``メソッドが呼び出されたときを表します。 `` reset \ &quot;の動作は、` `reset_on_return``プール引数を使って無効にすることもできます。"

#: of sqlalchemy.events.PoolEvents.reset:24
msgid ""
"The :meth:`.PoolEvents.reset` event is usually followed by the "
":meth:`.PoolEvents.checkin` event is called, except in those cases where "
"the connection is discarded immediately after reset."
msgstr "：meth： `.PoolEvents.reset`イベントの後には通常、リセット直後に接続が破棄される場合を除いて：meth：` .PoolEvents.checkin`イベントが呼び出されます。"

#: of sqlalchemy.events.PoolEvents.reset:37
msgid ":meth:`.ConnectionEvents.rollback`"
msgstr "：meth： `.ConnectionEvents.rollback`"

#: of sqlalchemy.events.PoolEvents.reset:39
msgid ":meth:`.ConnectionEvents.commit`"
msgstr "：meth： `.ConnectionEvents.commit`"

#: of sqlalchemy.events.PoolEvents.soft_invalidate:1
msgid "Called when a DBAPI connection is to be \"soft invalidated\"."
msgstr "DBAPI接続が\ &quot;ソフト無効\&quot;になるときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.soft_invalidate:17
msgid ""
"This event is called any time the :meth:`._ConnectionRecord.invalidate` "
"method is invoked with the ``soft`` flag."
msgstr "このイベントは：meth： `._ConnectionRecord.invalidate`メソッドが` `soft``フラグで呼び出されたときに呼び出されます。"

#: of sqlalchemy.events.PoolEvents.soft_invalidate:20
msgid ""
"Soft invalidation refers to when the connection record that tracks this "
"connection will force a reconnect after the current connection is checked"
" in.   It does not actively close the dbapi_connection at the point at "
"which it is called."
msgstr "ソフト無効化とは、現在の接続がチェックインされた後に、この接続を追跡する接続レコードが強制的に再接続するときのことを指します。dbapi_connectionは、呼び出された時点でアクティブに閉じません。"

#: ../../core/events.rst:21
msgid "SQL Execution and Connection Events"
msgstr "SQLの実行と接続のイベント"

#: of sqlalchemy.events.ConnectionEvents:1
msgid ""
"Available events for :class:`.Connectable`, which includes "
":class:`.Connection` and :class:`.Engine`."
msgstr "class： `.Connectionable`：class：` .Connection`と：class： `.Engine`を含むイベントです。"

#: of sqlalchemy.events.ConnectionEvents:7
msgid ""
"An event listener can be associated with any :class:`.Connectable` class "
"or instance, such as an :class:`.Engine`, e.g.::"
msgstr "イベントリスナーは：class： `.Engine`のようなclass：` .Connectable`クラスまたはインスタンスに関連付けることができます："

#: of sqlalchemy.events.ConnectionEvents:19
msgid "or with a specific :class:`.Connection`::"
msgstr "または特定の：class： `.Connection` ::"

#: of sqlalchemy.events.ConnectionEvents:27
msgid ""
"When the methods are called with a `statement` parameter, such as in "
":meth:`.after_cursor_execute`, :meth:`.before_cursor_execute` and "
":meth:`.dbapi_error`, the statement is the exact SQL string that was "
"prepared for transmission to the DBAPI ``cursor`` in the connection's "
":class:`.Dialect`."
msgstr "メソッドが：meth： `.after_cursor_execute`、：meth：` .before_cursor_execute`と：meth： `.dbapi_error`のような` statement`パラメータで呼び出されたとき、その文は準備された正確なSQL文字列です接続：class： `.Dialect`内のDBAPI` `cursor``への送信。"

#: of sqlalchemy.events.ConnectionEvents:33
msgid ""
"The :meth:`.before_execute` and :meth:`.before_cursor_execute` events can"
" also be established with the ``retval=True`` flag, which allows "
"modification of the statement and parameters to be sent to the database."
"  The :meth:`.before_cursor_execute` event is particularly useful here to"
" add ad-hoc string transformations, such as comments, to all executions::"
msgstr "：meth： `.before_execute`と：meth：` .before_cursor_execute`イベントは、 `` retval = True``フラグで設定することもできます。このフラグは、データベースに送られる文とパラメータの変更を可能にします。 ：meth： `.before_cursor_execute`イベントは、コメントなどの特別な文字列変換をすべての実行に追加するのに特に役に立ちます::"

#: of sqlalchemy.events.ConnectionEvents:49
msgid ""
":class:`.ConnectionEvents` can be established on any combination of "
":class:`.Engine`, :class:`.Connection`, as well as instances of each of "
"those classes.  Events across all four scopes will fire off for a given "
"instance of :class:`.Connection`.  However, for performance reasons, the "
":class:`.Connection` object determines at instantiation time whether or "
"not its parent :class:`.Engine` has event listeners established.   Event "
"listeners added to the :class:`.Engine` class or to an instance of "
":class:`.Engine` *after* the instantiation of a dependent "
":class:`.Connection` instance will usually *not* be available on that "
":class:`.Connection` instance.  The newly added listeners will instead "
"take effect for :class:`.Connection` instances created subsequent to "
"those event listeners being established on the parent :class:`.Engine` "
"class or instance."
msgstr "：class： `.ConnectionEvents`は：class：` .Engine`、：class： `.Connection`、そしてこれらのクラスのそれぞれのインスタンスの任意の組み合わせで確立できます。 4つのスコープのすべてのイベントは、class： `.Connection`のインスタンスに対して起動します。しかし、パフォーマンス上の理由から、：class： `.Connection`オブジェクトは、インスタンス化時にparent：class：` .Engine`にイベントリスナーが設定されているかどうかを判断します。 ：class： `.Engine`クラスに、または：class：` .Engine` *のインスタンスに追加されたイベントリスナーは、従属：class： `.Connection`インスタンスのインスタンス化は*通常* *できません：class： `.Connection`インスタンスです。新しく追加されたリスナーは、親：class： `.Engine`クラスまたはインスタンスで確立されたイベントリスナーの後に作成されるclass：` .Connection`インスタンスに代わり有効です。"

#: of sqlalchemy.events.ConnectionEvents:64
msgid ""
"Applies to the :meth:`.before_execute` and :meth:`.before_cursor_execute`"
" events only.  When True, the user-defined event function must have a "
"return value, which is a tuple of parameters that replace the given "
"statement and parameters.  See those methods for a description of "
"specific return arguments."
msgstr "：meth： `.before_execute`と：meth：` .before_cursor_execute`イベントにのみ適用されます。 Trueの場合、ユーザー定義のイベント関数には戻り値が必要です。戻り値は、指定されたステートメントとパラメーターを置き換えるパラメーターのタプルです。特定の戻り引数については、これらのメソッドを参照してください。"

#: of sqlalchemy.events.ConnectionEvents:71
msgid ""
":class:`.ConnectionEvents` can now be associated with any "
":class:`.Connectable` including :class:`.Connection`, in addition to the "
"existing support for :class:`.Engine`."
msgstr "：class： `.ConnectionEvents`は：class：` .Engine`のための既存のサポートに加えて：class： `.Connection`を含む：class：` .Connectable`に関連付けることができます。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:1
msgid "Intercept low-level cursor execute() events after execution."
msgstr "実行後に低レベルカーソルのexecute（）イベントを代行受信します。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:26
#: sqlalchemy.events.ConnectionEvents.after_execute:27
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute:44
#: sqlalchemy.events.ConnectionEvents.before_execute:40
#: sqlalchemy.events.ConnectionEvents.begin:17
#: sqlalchemy.events.ConnectionEvents.begin_twophase:17
#: sqlalchemy.events.ConnectionEvents.commit:23
#: sqlalchemy.events.ConnectionEvents.commit_twophase:17
#: sqlalchemy.events.ConnectionEvents.dbapi_error:53
#: sqlalchemy.events.ConnectionEvents.prepare_twophase:17
#: sqlalchemy.events.ConnectionEvents.release_savepoint:17
#: sqlalchemy.events.ConnectionEvents.rollback:24
#: sqlalchemy.events.ConnectionEvents.rollback_savepoint:17
#: sqlalchemy.events.ConnectionEvents.rollback_twophase:17
#: sqlalchemy.events.ConnectionEvents.savepoint:17
msgid ":class:`.Connection` object"
msgstr "：class： `.Connection`オブジェクト"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:27
msgid ""
"DBAPI cursor object.  Will have results pending if the statement was a "
"SELECT, but these should not be consumed as they will be needed by the "
":class:`.ResultProxy`."
msgstr "DBAPIカーソルオブジェクト。ステートメントがSELECTであった場合、結果は保留になりますが、これらは：class： `.ResultProxy`で必要となるので消費されるべきではありません。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:30
#: sqlalchemy.events.ConnectionEvents.dbapi_error:55
msgid "string SQL statement, as passed to the DBAPI"
msgstr "DBAPIに渡される文字列SQL文"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:31
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute:47
#: sqlalchemy.events.ConnectionEvents.dbapi_error:56
msgid ""
"Dictionary, tuple, or list of parameters being passed to the "
"``execute()`` or ``executemany()`` method of the DBAPI ``cursor``.  In "
"some cases may be ``None``."
msgstr "DBAPIの `` cursor``の `` execute（） ``や `` executemany（） ``メソッドに渡される、辞書、タプル、またはパラメータのリストです。場合によっては、「なし」とすることができる。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:34
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute:50
#: sqlalchemy.events.ConnectionEvents.dbapi_error:59
msgid ":class:`.ExecutionContext` object in use.  May be ``None``."
msgstr "：class： `.ExecutionContext`オブジェクトが使用中です。 `` None``かもしれません。"

#: of sqlalchemy.events.ConnectionEvents.after_cursor_execute:36
#: sqlalchemy.events.ConnectionEvents.before_cursor_execute:52
msgid ""
"boolean, if ``True``, this is an ``executemany()`` call, if ``False``, "
"this is an ``execute()`` call."
msgstr "boolean、 `` True``の場合は `` executemany（） ``の呼び出し、 `` False``の場合は `` execute（） ``の呼び出しです。"

#: of sqlalchemy.events.ConnectionEvents.after_execute:1
msgid "Intercept high level execute() events after execute."
msgstr "実行後に高水準のexecute（）イベントを代行受信します。"

#: of sqlalchemy.events.ConnectionEvents.after_execute:28
#: sqlalchemy.events.ConnectionEvents.before_execute:41
msgid ""
"SQL expression construct, :class:`.Compiled` instance, or string "
"statement passed to :meth:`.Connection.execute`."
msgstr "SQL式の構文、：class： `.Compiled`インスタンス、または：meth：` .Connection.execute`に渡される文字列ステートメント。"

#: of sqlalchemy.events.ConnectionEvents.after_execute:30
#: sqlalchemy.events.ConnectionEvents.before_execute:43
msgid "Multiple parameter sets, a list of dictionaries."
msgstr "複数のパラメータセット、辞書のリスト"

#: of sqlalchemy.events.ConnectionEvents.after_execute:31
#: sqlalchemy.events.ConnectionEvents.before_execute:44
msgid "Single parameter set, a single dictionary."
msgstr "単一のパラメータセット、単一の辞書。"

#: of sqlalchemy.events.ConnectionEvents.after_execute:32
msgid ":class:`.ResultProxy` generated by the execution."
msgstr "：class：実行によって生成された `.ResultProxy`。"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:1
msgid ""
"Intercept low-level cursor execute() events before execution, receiving "
"the string SQL statement and DBAPI-specific parameter list to be invoked "
"against a cursor."
msgstr "実行前に低レベルカーソルのexecute（）イベントを代行受信し、カーソルに対して呼び出されるSQL文とDBAPI固有のパラメータ文字列を受け取ります。"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:28
msgid ""
"This event is a good choice for logging as well as late modifications to "
"the SQL string.  It's less ideal for parameter modifications except for "
"those which are specific to a target backend."
msgstr "このイベントは、SQL文字列のロギングおよび遅延の変更に適しています。ターゲットバックエンドに固有のものを除き、パラメータの変更にはあまり理想的ではありません。"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:32
msgid ""
"This event can be optionally established with the ``retval=True`` flag.  "
"The ``statement`` and ``parameters`` arguments should be returned as a "
"two-tuple in this case::"
msgstr "このイベントは、 `` retval = True``フラグで任意に設定することができます。この場合、 `` statement``と `` parameters``引数は2タプルとして返されます。"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:42
msgid "See the example at :class:`.ConnectionEvents`."
msgstr "次の例を参照してください：class： `.ConnectionEvents`。"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:45
#: sqlalchemy.events.ConnectionEvents.dbapi_error:54
msgid "DBAPI cursor object"
msgstr "DBAPIカーソルオブジェクト"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:46
msgid "string SQL statement, as to be passed to the DBAPI"
msgstr "DBAPIに渡す文字列SQL文"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:55
#: sqlalchemy.events.ConnectionEvents.before_execute:46
#: sqlalchemy.events.DDLEvents:64
msgid "See also:"
msgstr "参照："

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:57
msgid ":meth:`.before_execute`"
msgstr "：meth： `.before_execute`"

#: of sqlalchemy.events.ConnectionEvents.before_cursor_execute:59
msgid ":meth:`.after_cursor_execute`"
msgstr "：meth： `.after_cursor_execute`"

#: of sqlalchemy.events.ConnectionEvents.before_execute:1
msgid ""
"Intercept high level execute() events, receiving uncompiled SQL "
"constructs and other objects prior to rendering into SQL."
msgstr "高水準のexecute（）イベントを代行受信し、コンパイルされていないSQL構文やその他のオブジェクトをSQLにレンダリングする前に受信します。"

#: of sqlalchemy.events.ConnectionEvents.before_execute:27
msgid ""
"This event is good for debugging SQL compilation issues as well as early "
"manipulation of the parameters being sent to the database, as the "
"parameter lists will be in a consistent format here."
msgstr "このイベントは、パラメータリストがここで一貫したフォーマットになるため、SQLコンパイルの問題のデバッグやデータベースへのパラメータの早期操作に適しています。"

#: of sqlalchemy.events.ConnectionEvents.before_execute:31
msgid ""
"This event can be optionally established with the ``retval=True`` flag.  "
"The ``clauseelement``, ``multiparams``, and ``params`` arguments should "
"be returned as a three-tuple in this case::"
msgstr "このイベントは、 `` retval = True``フラグで任意に設定することができます。この場合、 `` clauseelement``、 `` multiparams``、 `` params``引数は三つ組として返されます。"

#: of sqlalchemy.events.ConnectionEvents.before_execute:48
msgid ":meth:`.before_cursor_execute`"
msgstr "：meth： `.before_cursor_execute`"

#: of sqlalchemy.events.ConnectionEvents.begin:1
msgid "Intercept begin() events."
msgstr "begin（）イベントを傍受します。"

#: of sqlalchemy.events.ConnectionEvents.begin_twophase:1
msgid "Intercept begin_twophase() events."
msgstr "begin_twophase（）イベントを傍受します。"

#: of sqlalchemy.events.ConnectionEvents.begin_twophase:18
#: sqlalchemy.events.ConnectionEvents.commit_twophase:18
#: sqlalchemy.events.ConnectionEvents.prepare_twophase:18
#: sqlalchemy.events.ConnectionEvents.rollback_twophase:18
msgid "two-phase XID identifier"
msgstr "二相XID識別子"

#: of sqlalchemy.events.ConnectionEvents.commit:1
msgid "Intercept commit() events, as initiated by a :class:`.Transaction`."
msgstr "：class： `.Transaction`によって開始されたcommit（）イベントをインターセプトします。"

#: of sqlalchemy.events.ConnectionEvents.commit:18
msgid ""
"Note that the :class:`.Pool` may also \"auto-commit\" a DBAPI connection "
"upon checkin, if the ``reset_on_return`` flag is set to the value "
"``'commit'``.  To intercept this commit, use the "
":meth:`.PoolEvents.reset` hook."
msgstr "`` reset_on_return``フラグが `` &#39;commit```に設定されている場合、class： `.Pool`はチェックイン時にDBAPI接続を自動的にコミットすることもあります。このコミットをインターセプトするには、：meth： `.PoolEvents.reset`フックを使用します。"

#: of sqlalchemy.events.ConnectionEvents.commit_twophase:1
msgid "Intercept commit_twophase() events."
msgstr "commit_twophase（）イベントをインターセプトします。"

#: of sqlalchemy.events.ConnectionEvents.commit_twophase:19
#: sqlalchemy.events.ConnectionEvents.rollback_twophase:19
msgid "boolean, indicates if :meth:`.TwoPhaseTransaction.prepare` was called."
msgstr "booleanは、：meth： `.TwoPhaseTransaction.prepare`が呼び出されたかどうかを示します。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:1
msgid "Intercept a raw DBAPI error."
msgstr "未処理のDBAPIエラーを代行受信します。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:26
msgid ""
"This event is called with the DBAPI exception instance received from the "
"DBAPI itself, *before* SQLAlchemy wraps the exception with it's own "
"exception wrappers, and before any other operations are performed on the "
"DBAPI cursor; the existing transaction remains in effect as well as any "
"state on the cursor."
msgstr "このイベントは、DBAPI自体から受信したDBAPI例外インスタンスを使用して呼び出されます。* SQLAlchemyでは、独自の例外ラッパーを使用して例外がラップされる前、およびDBAPIカーソルに対して他の操作が実行される前に*既存のトランザクションは、カーソル上の任意の状態と同様に有効なままである。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:33
msgid ""
"The use case here is to inject low-level exception handling into an "
":class:`.Engine`, typically for logging and debugging purposes."
msgstr "ここでの使用例は、低レベルの例外処理を：class： `.Engine`に注入することです。通常は、ロギングとデバッグの目的のためです。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:39
msgid ""
"Code should **not** modify any state or throw any exceptions here as this"
" will interfere with SQLAlchemy's cleanup and error handling routines.  "
"For exception modification, please refer to the new "
":meth:`.ConnectionEvents.handle_error` event."
msgstr "コードはSQLAlchemyのクリーンアップとエラー処理ルーチンを妨害するので、**状態**を変更しないで**ここに例外を投げてはいけません。例外の修正については、新しい：meth： `.ConnectionEvents.handle_error`イベントを参照してください。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:45
msgid ""
"Subsequent to this hook, SQLAlchemy may attempt any number of operations "
"on the connection/cursor, including closing the cursor, rolling back of "
"the transaction in the case of connectionless execution, and disposing of"
" the entire connection pool if a \"disconnect\" was detected.   The "
"exception is then wrapped in a SQLAlchemy DBAPI exception wrapper and re-"
"thrown."
msgstr "このフックに続いて、SQLAlchemyは、コネクションレス/カーソルの操作をいくつでも試みることができます。これには、カーソルのクローズ、コネクションレス実行の場合のトランザクションのロールバック、\ &quot;切断\&quot;の場合の接続プール全体の破棄検出された。例外は、SQLAlchemy DBAPI例外ラッパーにラップされ、再スローされます。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:61
msgid ""
"The **unwrapped** exception emitted directly from the DBAPI.  The class "
"here is specific to the DBAPI module in use."
msgstr "** unwrapped **例外はDBAPIから直接出力されます。ここのクラスは、使用中のDBAPIモジュールに固有です。"

#: of sqlalchemy.events.ConnectionEvents.dbapi_error:64
msgid "- replaced by :meth:`.ConnectionEvents.handle_error`"
msgstr "- によって置き換えられました：meth： `.ConnectionEvents.handle_error`"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:1
msgid "Intercept the creation of a new :class:`.Connection`."
msgstr "new：class： `.Connection`の作成を傍受します。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:17
msgid ""
"This event is called typically as the direct result of calling the "
":meth:`.Engine.connect` method."
msgstr "このイベントは、通常：meth： `.Engine.connect`メソッドを呼び出すことによって直接的に呼び出されます。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:20
msgid ""
"It differs from the :meth:`.PoolEvents.connect` method, which refers to "
"the actual connection to a database at the DBAPI level; a DBAPI "
"connection may be pooled and reused for many operations. In contrast, "
"this event refers only to the production of a higher level "
":class:`.Connection` wrapper around such a DBAPI connection."
msgstr "これは：meth： `.PoolEvents.connect`メソッドとは異なります。これはDBAPIレベルのデータベースへの実際の接続を指します。 DBAPI接続をプールして、多くの操作で再利用することができます。対照的に、このイベントはより高いレベルの生成にのみ参照されます：クラス：このようなDBAPI接続の周りの `.Connection`ラッパー。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:26
msgid ""
"It also differs from the :meth:`.PoolEvents.checkout` event in that it is"
" specific to the :class:`.Connection` object, not the DBAPI connection "
"that :meth:`.PoolEvents.checkout` deals with, although this DBAPI "
"connection is available here via the :attr:`.Connection.connection` "
"attribute.  But note there can in fact be multiple "
":meth:`.PoolEvents.checkout` events within the lifespan of a single "
":class:`.Connection` object, if that :class:`.Connection` is invalidated "
"and re-established.  There can also be multiple :class:`.Connection` "
"objects generated for the same already-checked-out DBAPI connection, in "
"the case that a \"branch\" of a :class:`.Connection` is produced."
msgstr "これは、：meth： `.PoolEvents.checkout`イベントとは異なり、：class：` .Connection`オブジェクトに固有であり、：meth： `.PoolEvents.checkout`が扱うDBAPI接続ではありません。 DBAPI接続は、ここでは：attr： `.Connection.connection`属性で利用できます。しかし、実際には：class： `.Connection`が無効化され、再確立された場合、class：` .Connection`オブジェクトの存続期間内に複数の：meth： `.PoolEvents.checkout`イベントが存在することに注意してください。 ：class： `.Connection`の\&quot; branch \ &quot;が生成された場合には、すでにチェックアウトされた同じDBAPI接続に対して生成された複数の：class：` .Connection`オブジェクトが存在することもあります。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:38
msgid ":class:`.Connection` object."
msgstr "：class： `.Connection`オブジェクトです。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:39
msgid ""
"if True, this is a \"branch\" of an existing :class:`.Connection`.  A "
"branch is generated within the course of a statement execution to invoke "
"supplemental statements, most typically to pre-execute a SELECT of a "
"default value for the purposes of an INSERT statement."
msgstr "Trueの場合、これは既存の：class： `.Connection`の\&quot;ブランチ\ &quot;です。分岐は、最も一般的にはINSERTステートメントの目的のためにデフォルト値のSELECTを事前に実行するために、ステートメント実行中に補足ステートメントを呼び出すために生成されます。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:49
msgid ""
":ref:`pool_disconnects_pessimistic` - illustrates how to use "
":meth:`.ConnectionEvents.engine_connect` to transparently ensure pooled "
"connections are connected to the database."
msgstr "：ref： `pool_disconnects_pessimistic`  - プールされた接続が透過的にデータベースに接続されていることを透過的に確認するために：meth：` .ConnectionEvents.engine_connect`を使用する方法を示します。"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:54
msgid ""
":meth:`.PoolEvents.checkout` the lower-level pool checkout event for an "
"individual DBAPI connection"
msgstr "：meth： `.PoolEvents.checkout`個々のDBAPI接続の下位レベルのプールチェックアウトイベント"

#: of sqlalchemy.events.ConnectionEvents.engine_connect:57
msgid ""
":meth:`.ConnectionEvents.set_connection_execution_options` - a copy of a "
":class:`.Connection` is also made when the "
":meth:`.Connection.execution_options` method is called."
msgstr "：meth： `.ConnectionEvents.set_connection_execution_options`  - ：class：` .Connection`のコピーは、：meth： `.Connection.execution_options`メソッドが呼び出されたときにも作成されます。"

#: of sqlalchemy.events.ConnectionEvents.engine_disposed:1
msgid "Intercept when the :meth:`.Engine.dispose` method is called."
msgstr "：meth： `.Engine.dispose`メソッドが呼び出されたときに代行受信を行います。"

#: of sqlalchemy.events.ConnectionEvents.engine_disposed:17
msgid ""
"The :meth:`.Engine.dispose` method instructs the engine to \"dispose\" of"
" it's connection pool (e.g. :class:`.Pool`), and replaces it with a new "
"one.  Disposing of the old pool has the effect that existing checked-in "
"connections are closed.  The new pool does not establish any new "
"connections until it is first used."
msgstr "：meth： `.Engine.dispose`メソッドはエンジンに接続プール（例えば：class：` .Pool`）の\ &quot;dispose \&quot;を指示し、それを新しいものに置き換えます。古いプールを廃棄すると、既存のチェックインされた接続が閉じられるという効果があります。新しいプールは、最初に使用されるまで新しい接続を確立しません。"

#: of sqlalchemy.events.ConnectionEvents.engine_disposed:23
msgid ""
"This event can be used to indicate that resources related to the "
":class:`.Engine` should also be cleaned up, keeping in mind that the "
":class:`.Engine` can still be used for new requests in which case it re-"
"acquires connection resources."
msgstr "このイベントは、：class： `.Engine`に関連するリソースもクリーンアップする必要があることを示すために使用できます：class：` .Engine`は新しいリクエストにも使用できることを覚えておいてください。接続リソースを取得します。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:1
msgid "Intercept all exceptions processed by the :class:`.Connection`."
msgstr "：class： `.Connection`によって処理されたすべての例外を傍受します。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:17
msgid ""
"This includes all exceptions emitted by the DBAPI as well as within "
"SQLAlchemy's statement invocation process, including encoding errors and "
"other statement validation errors.  Other areas in which the event is "
"invoked include transaction begin and end, result row fetching, cursor "
"creation."
msgstr "これには、DBAPIおよびSQLAlchemyの文呼び出しプロセスで発生したすべての例外（エンコードエラーやその他の文の検証エラーなど）が含まれます。イベントが呼び出される他の領域には、トランザクションの開始と終了、結果行のフェッチ、カーソルの作成などがあります。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:23
msgid ""
"Note that :meth:`.handle_error` may support new kinds of exceptions and "
"new calling scenarios at *any time*.  Code which uses this event must "
"expect new calling patterns to be present in minor releases."
msgstr "注意：meth： `.handle_error`は、いつでも*の新しい種類の例外と新しい呼び出しシナリオをサポートするかもしれません。このイベントを使用するコードは、マイナーリリースで新しい呼び出しパターンが存在することを期待する必要があります。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:28
msgid ""
"To support the wide variety of members that correspond to an exception, "
"as well as to allow extensibility of the event without backwards "
"incompatibility, the sole argument received is an instance of "
":class:`.ExceptionContext`.   This object contains data members "
"representing detail about the exception."
msgstr "例外に対応する多種多様なメンバをサポートし、後方互換性のないイベントの拡張性を可能にするために、受信される唯一の引数は：class：`ExceptionContext`のインスタンスです。このオブジェクトには、例外に関する詳細を表すデータメンバーが含まれます。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:34
msgid "Use cases supported by this hook include:"
msgstr "このフックでサポートされているユースケースは次のとおりです。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:36
msgid "read-only, low-level exception handling for logging and debugging purposes"
msgstr "読み取り専用、ロギングおよびデバッグ目的の低レベル例外処理"

#: of sqlalchemy.events.ConnectionEvents.handle_error:38
msgid "exception re-writing"
msgstr "例外の書き換え"

#: of sqlalchemy.events.ConnectionEvents.handle_error:39
msgid ""
"Establishing or disabling whether a connection or the owning connection "
"pool is invalidated or expired in response to a specific exception."
msgstr "特定の例外に応答して、接続または所有接続プールが無効化されるか、期限切れになるかの確立または無効化。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:43
msgid ""
"The hook is called while the cursor from the failed operation (if any) is"
" still open and accessible.   Special cleanup operations can be called on"
" this cursor; SQLAlchemy will attempt to close this cursor subsequent to "
"this hook being invoked.  If the connection is in \"autocommit\" mode, "
"the transaction also remains open within the scope of this hook; the "
"rollback of the per-statement transaction also occurs after the hook is "
"called."
msgstr "フックは、失敗した操作（存在する場合）からのカーソルがまだ開いていてアクセス可能な間に呼び出されます。このクリーンアップでは、特別なクリーンアップ操作を呼び出すことができます。 SQLAlchemyは、このフックが呼び出された後にこのカーソルを閉じることを試みます。接続が\ &quot;自動コミット\&quot;モードの場合、トランザクションはこのフックの範囲内でも開いたままです。文単位トランザクションのロールバックもフックが呼び出された後に発生します。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:51
msgid ""
"For the common case of detecting a \"disconnect\" situation which is not "
"currently handled by the SQLAlchemy dialect, the "
":attr:`.ExceptionContext.is_disconnect` flag can be set to True which "
"will cause the exception to be considered as a disconnect situation, "
"which typically results in the connection pool being invalidated::"
msgstr "SQLAlchemyの方言で現在処理されていない\ &quot;disconnect \&quot;状況を検出する一般的なケースでは、：attr： `.ExceptionContext.is_disconnect`フラグをTrueに設定すると例外が切断とみなされます通常は、接続プールが無効になります。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:67
msgid ""
"A handler function has two options for replacing the SQLAlchemy-"
"constructed exception into one that is user defined.   It can either "
"raise this new exception directly, in which case all further event "
"listeners are bypassed and the exception will be raised, after "
"appropriate cleanup as taken place::"
msgstr "ハンドラ関数には、SQLAlchemyによって構築された例外をユーザ定義のものに置き換えるための2つのオプションがあります。この新しい例外を直接呼び出すことができます。この場合、以降のすべてのイベントリスナーはバイパスされ、適切なクリーンアップが実行された後に例外が発生します::"

#: of sqlalchemy.events.ConnectionEvents.handle_error:81
msgid ""
"Because the :meth:`.ConnectionEvents.handle_error` event specifically "
"provides for exceptions to be re-thrown as the ultimate exception raised "
"by the failed statement, **stack traces will be misleading** if the user-"
"defined event handler itself fails and throws an unexpected exception; "
"the stack trace may not illustrate the actual code line that failed!  It "
"is advised to code carefully here and use logging and/or inline debugging"
" if unexpected exceptions are occurring."
msgstr "：meth： `.ConnectionEvents.handle_error`イベントは、特に失敗したステートメントによって引き起こされる最終的な例外として再スローされる例外を提供するため、**スタックトレースはユーザー定義のイベントハンドラ自体が失敗した場合に誤解を招く**予期しない例外がスローされます。スタックトレースは失敗した実際のコード行を示していないかもしれません！予期しない例外が発生している場合は、ここで注意深くコーディングし、ロギングまたはインラインデバッグを使用することをお勧めします。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:91
msgid ""
"Alternatively, a \"chained\" style of event handling can be used, by "
"configuring the handler with the ``retval=True`` modifier and returning "
"the new exception instance from the function.  In this case, event "
"handling will continue onto the next handler.   The \"chained\" exception"
" is available using :attr:`.ExceptionContext.chained_exception`::"
msgstr "あるいは、ハンドリングを `` retval = True``修飾子で設定し、その関数から新しい例外インスタンスを返すことで、イベントハンドリングの\ &quot;連鎖\&quot;スタイルを使用することができます。この場合、イベントハンドリングは次のハンドラ上で継続されます。 \ &quot;連鎖\&quot;例外は、以下を使用して利用できます：attr： `.ExceptionContext.chained_exception` ::"

#: of sqlalchemy.events.ConnectionEvents.handle_error:105
msgid ""
"Handlers that return ``None`` may be used within the chain; when a "
"handler returns ``None``, the previous exception instance, if any, is "
"maintained as the current exception that is passed onto the next handler."
msgstr "チェーン内で `` None``を返すハンドラを使うことができます。ハンドラが `` None``を返すとき、前の例外インスタンスがあればそれが次のハンドラに渡される現在の例外として維持されます。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:110
msgid ""
"When a custom exception is raised or returned, SQLAlchemy raises this new"
" exception as-is, it is not wrapped by any SQLAlchemy object.  If the "
"exception is not a subclass of :class:`sqlalchemy.exc.StatementError`, "
"certain features may not be available; currently this includes the ORM's "
"feature of adding a detail hint about \"autoflush\" to exceptions raised "
"within the autoflush process."
msgstr "カスタム例外が発生または返されると、SQLAlchemyはこの新しい例外をそのまま引き上げ、SQLAlchemyオブジェクトでラップされません。例外が：class： `sqlalchemy.exc.StatementError`のサブクラスでない場合、特定の機能が利用できない場合があります。現在のところ、これにはORFのautoflushプロセス内で発生した例外に\ &quot;autoflush \&quot;の詳細ヒントを追加する機能が含まれています。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:118
msgid ""
"an :class:`.ExceptionContext` object.  See this class for details on all "
"available members."
msgstr "an：class： `.ExceptionContext`オブジェクトです。使用可能なすべてのメンバーの詳細については、このクラスを参照してください。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:121
msgid "Added the :meth:`.ConnectionEvents.handle_error` hook."
msgstr "：meth： `.ConnectionEvents.handle_error`フックを追加しました。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:124
msgid ""
"The :meth:`.handle_error` event will now receive all exceptions that "
"inherit from ``BaseException``, including ``SystemExit`` and "
"``KeyboardInterrupt``.  The setting for "
":attr:`.ExceptionContext.is_disconnect` is ``True`` in this case and the "
"default for :attr:`.ExceptionContext.invalidate_pool_on_disconnect` is "
"``False``."
msgstr "：meth： `.handle_error`イベントは、` `SystemExit``と` `KeyboardInterrupt``を含む` `BaseException``を継承したすべての例外を受け取ります。この場合、attr： `.ExceptionContext.is_disconnect`の設定は` `True``であり、：attr：` .ExceptionContext.invalidate_pool_on_disconnect`のデフォルトは `` False``です。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:131
msgid ""
"The :meth:`.handle_error` event is now invoked when an :class:`.Engine` "
"fails during the initial call to :meth:`.Engine.connect`, as well as when"
" a :class:`.Connection` object encounters an error during a reconnect "
"operation."
msgstr "：meth： `.Engine.connect`の最初の呼び出しの間に：class：` .Engine`が失敗したとき、：class： `.Connection`オブジェクトのときに：meth：` .handle_error`イベントが呼び出されるようになりました再接続操作中にエラーが発生しました。"

#: of sqlalchemy.events.ConnectionEvents.handle_error:137
msgid ""
"The :meth:`.handle_error` event is not fired off when a dialect makes use"
" of the ``skip_user_error_events`` execution option.   This is used by "
"dialects which intend to catch SQLAlchemy-specific exceptions within "
"specific operations, such as when the MySQL dialect detects a table not "
"present within the ``has_table()`` dialect method. Prior to 1.0.0, code "
"which implements :meth:`.handle_error` needs to ensure that exceptions "
"thrown in these scenarios are re-raised without modification."
msgstr "dialectが `` skip_user_error_events``実行オプションを利用するとき、：meth： `.handle_error`イベントは起動しません。これは、MySQLの方言が `` has_table（） ``方言メソッドの中に存在しないテーブルを検出した場合など、特定の操作の中でSQLAlchemy特有の例外を捕捉しようとする方言によって使用されます。 1.0.0より前のバージョンでは、：meth： `.handle_error`を実装するコードでは、これらのシナリオでスローされた例外が修正されずに確実に再生成される必要があります。"

#: of sqlalchemy.events.ConnectionEvents.prepare_twophase:1
msgid "Intercept prepare_twophase() events."
msgstr "prepare_twophase（）イベントをインターセプトします。"

#: of sqlalchemy.events.ConnectionEvents.release_savepoint:1
msgid "Intercept release_savepoint() events."
msgstr "release_savepoint（）イベントを傍受します。"

#: of sqlalchemy.events.ConnectionEvents.release_savepoint:18
#: sqlalchemy.events.ConnectionEvents.rollback_savepoint:18
#: sqlalchemy.events.ConnectionEvents.savepoint:18
msgid "specified name used for the savepoint."
msgstr "セーブポイントに使用される指定された名前。"

#: of sqlalchemy.events.ConnectionEvents.release_savepoint:19
#: sqlalchemy.events.ConnectionEvents.rollback_savepoint:19
msgid ":class:`.ExecutionContext` in use.  May be ``None``."
msgstr "：class： `.ExecutionContext`が使用中です。 `` None``かもしれません。"

#: of sqlalchemy.events.ConnectionEvents.rollback:1
msgid "Intercept rollback() events, as initiated by a :class:`.Transaction`."
msgstr "：class： `.Transaction`によって開始されたrollback（）イベントを傍受します。"

#: of sqlalchemy.events.ConnectionEvents.rollback:18
msgid ""
"Note that the :class:`.Pool` also \"auto-rolls back\" a DBAPI connection "
"upon checkin, if the ``reset_on_return`` flag is set to its default value"
" of ``'rollback'``. To intercept this rollback, use the "
":meth:`.PoolEvents.reset` hook."
msgstr "`` reset_on_return``フラグが `` &#39;rollback```のデフォルト値に設定されている場合、：class： `.Pool`はチェックイン時にDBAPI接続も自動的にロールバックします。このロールバックをインターセプトするには、：meth： `.PoolEvents.reset`フックを使用します。"

#: of sqlalchemy.events.ConnectionEvents.rollback:28
msgid ":meth:`.PoolEvents.reset`"
msgstr "：meth： `.PoolEvents.reset`"

#: of sqlalchemy.events.ConnectionEvents.rollback_savepoint:1
msgid "Intercept rollback_savepoint() events."
msgstr "rollback_savepoint（）イベントを代行します。"

#: of sqlalchemy.events.ConnectionEvents.rollback_twophase:1
msgid "Intercept rollback_twophase() events."
msgstr "rollback_twophase（）イベントを代行受信します。"

#: of sqlalchemy.events.ConnectionEvents.savepoint:1
msgid "Intercept savepoint() events."
msgstr "savepoint（）イベントを代行します。"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:1
msgid "Intercept when the :meth:`.Connection.execution_options` method is called."
msgstr "：meth： `.Connection.execution_options`メソッドが呼び出されたときに代行受信します。"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:18
msgid ""
"This method is called after the new :class:`.Connection` has been "
"produced, with the newly updated execution options collection, but before"
" the :class:`.Dialect` has acted upon any of those new options."
msgstr "このメソッドは、new：class： `.Connection`が生成された後に、新しく更新された実行オプションのコレクションが呼び出された後、：class：` .Dialect`がそれらの新しいオプションのいずれかに作用する前に呼び出されます。"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:22
msgid ""
"Note that this method is not called when a new :class:`.Connection` is "
"produced which is inheriting execution options from its parent "
":class:`.Engine`; to intercept this condition, use the "
":meth:`.ConnectionEvents.engine_connect` event."
msgstr "このメソッドは、親：class： `.Engine`から実行オプションを継承するnew：class：` .Connection`が生成されたときには呼び出されません。この条件を傍受するには、：meth： `.ConnectionEvents.engine_connect`イベントを使用します。"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:27
msgid "The newly copied :class:`.Connection` object"
msgstr "新たにコピーされた：class： `.Connection`オブジェクト"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:29
#: sqlalchemy.events.ConnectionEvents.set_engine_execution_options:27
msgid ""
"dictionary of options that were passed to the "
":meth:`.Connection.execution_options` method."
msgstr "：meth： `.Connection.execution_options`メソッドに渡されたオプションの辞書。"

#: of sqlalchemy.events.ConnectionEvents.set_connection_execution_options:36
msgid ""
":meth:`.ConnectionEvents.set_engine_execution_options` - event which is "
"called when :meth:`.Engine.execution_options` is called."
msgstr "：meth： `.ConnectionEvents.set_engine_execution_options`  -  meth：` .Engine.execution_options`が呼び出されたときに呼び出されるイベントです。"

#: of sqlalchemy.events.ConnectionEvents.set_engine_execution_options:1
msgid "Intercept when the :meth:`.Engine.execution_options` method is called."
msgstr "：meth： `.Engine.execution_options`メソッドが呼び出されたときにインターセプトします。"

#: of sqlalchemy.events.ConnectionEvents.set_engine_execution_options:18
msgid ""
"The :meth:`.Engine.execution_options` method produces a shallow copy of "
"the :class:`.Engine` which stores the new options.  That new "
":class:`.Engine` is passed here.   A particular application of this "
"method is to add a :meth:`.ConnectionEvents.engine_connect` event handler"
" to the given :class:`.Engine` which will perform some per- "
":class:`.Connection` task specific to these execution options."
msgstr "：meth： `.Engine.execution_options`メソッドは、新しいオプションを格納する：class：` .Engine`の浅いコピーを生成します。その新しい：クラス： `.Engine`がここに渡されます。このメソッドの特定のアプリケーションは、：meth： `.ConnectionEvents.engine_connect`イベントハンドラを与えられた：class：` .Engine`に追加して、これらの実行オプションに固有のper-：class： `.Connection`タスクを実行することです。"

#: of sqlalchemy.events.ConnectionEvents.set_engine_execution_options:25
msgid "The newly copied :class:`.Engine` object"
msgstr "新しくコピーされた：class： `.Engine`オブジェクト"

#: of sqlalchemy.events.ConnectionEvents.set_engine_execution_options:34
msgid ""
":meth:`.ConnectionEvents.set_connection_execution_options` - event which "
"is called when :meth:`.Connection.execution_options` is called."
msgstr "：meth： `.ConnectionEvents.set_connection_execution_options`  - ：meth：` .Connection.execution_options`が呼び出されたときに呼び出されるイベントです。"

#: of sqlalchemy.events.DialectEvents:1
msgid "event interface for execution-replacement functions."
msgstr "実行置換機能のためのイベントインタフェース。"

#: of sqlalchemy.events.DialectEvents:3
msgid ""
"These events allow direct instrumentation and replacement of key dialect "
"functions which interact with the DBAPI."
msgstr "これらのイベントにより、DBAPIと対話する主要な方言関数の直接的な計測と置き換えが可能になります。"

#: of sqlalchemy.events.DialectEvents:8
msgid ""
":class:`.DialectEvents` hooks should be considered **semi-public** and "
"experimental. These hooks are not for general use and are only for those "
"situations where intricate re-statement of DBAPI mechanics must be "
"injected onto an existing dialect.  For general-use statement-"
"interception events, please use the :class:`.ConnectionEvents` interface."
msgstr "：class： `.DialectEvents`フックは** semi-public **とexperimentalとみなされます。これらのフックは一般的な用途ではなく、複雑なDBAPI機構の再記述が既存の方言に注入されなければならない状況にのみ適用されます。一般的なステートメント・インターセプト・イベントの場合は、：class： `.ConnectionEvents`インターフェースを使用してください。"

#: of sqlalchemy.events.DialectEvents:17
msgid ":meth:`.ConnectionEvents.before_cursor_execute`"
msgstr "：meth： `.ConnectionEvents.before_cursor_execute`"

#: of sqlalchemy.events.DialectEvents:19
msgid ":meth:`.ConnectionEvents.before_execute`"
msgstr "：meth： `.ConnectionEvents.before_execute`"

#: of sqlalchemy.events.DialectEvents:21
msgid ":meth:`.ConnectionEvents.after_cursor_execute`"
msgstr "：meth： `.ConnectionEvents.after_cursor_execute`"

#: of sqlalchemy.events.DialectEvents:23
msgid ":meth:`.ConnectionEvents.after_execute`"
msgstr "：meth： `.ConnectionEvents.after_execute`"

#: of sqlalchemy.events.DialectEvents.do_connect:1
msgid "Receive connection arguments before a connection is made."
msgstr "接続が確立される前に接続引数を受け取ります。"

#: of sqlalchemy.events.DialectEvents.do_connect:26
msgid ""
"Return a DBAPI connection to halt further events from invoking; the "
"returned connection will be used."
msgstr "DBAPI接続を戻して、起動した後のイベントを停止します。返された接続が使用されます。"

#: of sqlalchemy.events.DialectEvents.do_connect:29
msgid ""
"Alternatively, the event can manipulate the cargs and/or cparams "
"collections; cargs will always be a Python list that can be mutated in-"
"place and cparams a Python dictionary.  Return None to allow control to "
"pass to the next event handler and ultimately to allow the dialect to "
"connect normally, given the updated arguments."
msgstr "あるいは、イベントは、カーグおよび/またはパラパラコレクションを操作することができます。 cargsは、常に、インプレースで突然変異することができるPythonリストであり、cparamsはPython辞書である。 Noneを返すと、制御は次のイベントハンドラに渡され、最終的に更新された引数が与えられれば、方言が正常に接続できるようになります。"

#: of sqlalchemy.events.DialectEvents.do_execute:1
msgid "Receive a cursor to have execute() called."
msgstr "execute（）を呼び出すためのカーソルを受け取ります。"

#: of sqlalchemy.events.DialectEvents.do_execute:26
#: sqlalchemy.events.DialectEvents.do_execute_no_params:17
#: sqlalchemy.events.DialectEvents.do_executemany:26
msgid ""
"Return the value True to halt further events from invoking, and to "
"indicate that the cursor execution has already taken place within the "
"event handler."
msgstr "値がTrueを返すと、呼び出すことからさらにイベントが停止し、カーソルがイベントハンドラ内で既に実行されたことを示すことができます。"

#: of sqlalchemy.events.DialectEvents.do_execute_no_params:1
msgid "Receive a cursor to have execute() with no parameters called."
msgstr "パラメータを指定せずにexecute（）を実行するカーソルを受け取ります。"

#: of sqlalchemy.events.DialectEvents.do_executemany:1
msgid "Receive a cursor to have executemany() called."
msgstr "executemany（）を呼び出すためにカーソルを受け取ります。"

#: of sqlalchemy.events.DialectEvents.do_setinputsizes:1
msgid "Receive the setinputsizes dictionary for possible modification."
msgstr "可能な変更のためにsetinputsizes辞書を受け取ります。"

#: of sqlalchemy.events.DialectEvents.do_setinputsizes:26
msgid ""
"This event is emitted in the case where the dialect makes use of the "
"DBAPI ``cursor.setinputsizes()`` method which passes information about "
"parameter binding for a particular statement.   The given ``inputsizes`` "
"dictionary will contain :class:`.BindParameter` objects as keys, linked "
"to DBAPI-specific type objects as values; for parameters that are not "
"bound, they are added to the dictionary with ``None`` as the value, which"
" means the parameter will not be included in the ultimate setinputsizes "
"call.   The event may be used to inspect and/or log the datatypes that "
"are being bound, as well as to modify the dictionary in place.  "
"Parameters can be added, modified, or removed from this dictionary.   "
"Callers will typically want to inspect the :attr:`.BindParameter.type` "
"attribute of the given bind objects in order to make decisions about the "
"DBAPI object."
msgstr "このイベントは、特定のステートメントのパラメータバインディングに関する情報を渡すDBAPIの `` cursor.setinputsizes（） ``メソッドを使用する場合に発生します。指定された `` inputsizes``辞書には、class： `.BindParameter`オブジェクトがキーとして含まれ、値としてDBAPI固有の型オブジェクトにリンクされます。バインドされていないパラメータの場合は、 `` None``を値として辞書に追加されます。これは、パラメータが最終的なsetinputsizes呼び出しに含まれないことを意味します。このイベントは、バインドされているデータ型を検査および/またはログ記録するため、およびその場で辞書を変更するために使用することができる。この辞書にパラメータを追加、変更、または削除することができます。呼び出し側は、通常、DBAPIオブジェクトに関する決定を行うために、指定されたバインド・オブジェクトの：attr： `.BindParameter.type`属性を検査する必要があります。"

#: of sqlalchemy.events.DialectEvents.do_setinputsizes:40
msgid ""
"After the event, the ``inputsizes`` dictionary is converted into an "
"appropriate datastructure to be passed to ``cursor.setinputsizes``; "
"either a list for a positional bound parameter execution style, or a "
"dictionary of string parameter keys to DBAPI type objects for a named "
"bound parameter execution style."
msgstr "イベントの後、 `` inputsizes``辞書は適切なデータ構造に変換され、 `` cursor.setinputsizes``に渡されます。位置限定パラメータ実行スタイルのリスト、または名前付きバインドされたパラメータ実行スタイルのDBAPIタイプオブジェクトへの文字列パラメータキーの辞書のいずれかです。"

#: of sqlalchemy.events.DialectEvents.do_setinputsizes:46
msgid ""
"Most dialects **do not use** this method at all; the only built-in "
"dialect which uses this hook is the cx_Oracle dialect.   The hook here is"
" made available so as to allow customization of how datatypes are set up "
"with the  cx_Oracle DBAPI."
msgstr "ほとんどの方言**はこのメソッドをまったく使用しません。このフックを使用する唯一の組み込み方言はcx_Oracle方言です。ここのフックは、cx_Oracle DBAPIを使用してデータ型を設定する方法をカスタマイズできるようになっています。"

#: of sqlalchemy.events.DialectEvents.do_setinputsizes:55
msgid ":ref:`cx_oracle_setinputsizes`"
msgstr "：ref： `cx_oracle_setinputsizes`"

#: ../../core/events.rst:30
msgid "Schema Events"
msgstr "スキーマイベント"

#: of sqlalchemy.events.DDLEvents:1
msgid ""
"Define event listeners for schema objects, that is, :class:`.SchemaItem` "
"and other :class:`.SchemaEventTarget` subclasses, including "
":class:`.MetaData`, :class:`.Table`, :class:`.Column`."
msgstr "スキーマオブジェクトのイベントリスナーを定義します。つまり：class： `.SchemaItem`と他の：class：` .SchemaEventTarget`サブクラス（class： `.MetaData`、：class：` .Table`、：class： `）を定義します。列 &#39;。"

#: of sqlalchemy.events.DDLEvents:6
msgid ""
":class:`.MetaData` and :class:`.Table` support events specifically "
"regarding when CREATE and DROP DDL is emitted to the database."
msgstr "：class： `.MetaData`と：class：` .Table`は、CREATEとDROP DDLがいつデータベースに発行されるかに関するイベントをサポートします。"

#: of sqlalchemy.events.DDLEvents:10
msgid ""
"Attachment events are also provided to customize behavior whenever a "
"child schema element is associated with a parent, such as, when a "
":class:`.Column` is associated with its :class:`.Table`, when a "
":class:`.ForeignKeyConstraint` is associated with a :class:`.Table`, etc."
msgstr "アタッチメントイベントは、a：class： `.Column`がa：class：` .Table`に関連付けられている場合など、子スキーマ要素が親に関連付けられるたびに動作をカスタマイズするためにも提供されます。 ForeignKeyConstraint`は：class： `.Table`などに関連付けられています。"

#: of sqlalchemy.events.DDLEvents:16
msgid "Example using the ``after_create`` event::"
msgstr "`` after_create``イベントを使った例::"

#: of sqlalchemy.events.DDLEvents:30
msgid ""
"DDL events integrate closely with the :class:`.DDL` class and the "
":class:`.DDLElement` hierarchy of DDL clause constructs, which are "
"themselves appropriate as listener callables::"
msgstr "DDLイベントは、：class： `.DDL`クラスと：class：` .DDLElement`階層のDDL句構造体と密接に統合されます。"

#: of sqlalchemy.events.DDLEvents:46
msgid ""
"For all :class:`.DDLEvent` events, the ``propagate=True`` keyword "
"argument will ensure that a given event handler is propagated to copies "
"of the object, which are made when using the :meth:`.Table.tometadata` "
"method::"
msgstr "all：class： `.DDLEvent`イベントの場合、` `propagate = True``キーワード引数は、与えられたイベントハンドラが：meth：` .Table.tometadata `メソッド::"

#: of sqlalchemy.events.DDLEvents:60
msgid ""
"The above :class:`.DDL` object will also be associated with the "
":class:`.Table` object represented by ``new_table``."
msgstr "上記の：class： `.DDL`オブジェクトは、` `new_table``で表される：class：` .Table`オブジェクトにも関連付けられます。"

#: of sqlalchemy.events.DDLEvents:66
msgid ":ref:`event_toplevel`"
msgstr "：ref： `event_toplevel`"

#: of sqlalchemy.events.DDLEvents:68
msgid ":class:`.DDLElement`"
msgstr "：クラス： `.DDLElement`"

#: of sqlalchemy.events.DDLEvents:70
msgid ":class:`.DDL`"
msgstr "：クラス： `.DDL`"

#: of sqlalchemy.events.DDLEvents:72
msgid ":ref:`schema_ddl_sequences`"
msgstr "：ref： `schema_ddl_sequences`"

#: of sqlalchemy.events.DDLEvents.after_create:1
msgid "Called after CREATE statements are emitted."
msgstr "CREATE文が発行された後に呼び出されます。"

#: of sqlalchemy.events.DDLEvents.after_create:17
#: sqlalchemy.events.DDLEvents.after_drop:17
#: sqlalchemy.events.DDLEvents.before_create:17
#: sqlalchemy.events.DDLEvents.before_drop:17
msgid ""
"the :class:`.MetaData` or :class:`.Table` object which is the target of "
"the event."
msgstr "イベントのターゲットである：class： `.MetaData`または：class：` .Table`オブジェクトです。"

#: of sqlalchemy.events.DDLEvents.after_create:19
msgid ""
"the :class:`.Connection` where the CREATE statement or statements have "
"been emitted."
msgstr "：class： `.Connection`ここで、CREATE文は発行されています。"

#: of sqlalchemy.events.DDLEvents.after_create:21
#: sqlalchemy.events.DDLEvents.after_drop:21
#: sqlalchemy.events.DDLEvents.before_create:21
#: sqlalchemy.events.DDLEvents.before_drop:21
msgid ""
"additional keyword arguments relevant to the event.  The contents of this"
" dictionary may vary across releases, and include the list of tables "
"being generated for a metadata-level event, the checkfirst flag, and "
"other elements used by internal events."
msgstr "イベントに関連する追加のキーワード引数。この辞書の内容はリリースによって異なる場合があり、メタデータレベルのイベント、checkfirstフラグ、および内部イベントによって使用されるその他の要素に対して生成されるテーブルのリストが含まれます。"

#: of sqlalchemy.events.DDLEvents.after_create:28
#: sqlalchemy.events.DDLEvents.after_drop:28
#: sqlalchemy.events.DDLEvents.after_parent_attach:21
#: sqlalchemy.events.DDLEvents.before_create:28
#: sqlalchemy.events.DDLEvents.before_drop:28
#: sqlalchemy.events.DDLEvents.before_parent_attach:21
#: sqlalchemy.events.DDLEvents.column_reflect:84
msgid ""
":func:`.event.listen` also accepts the ``propagate=True`` modifier for "
"this event; when True, the listener function will be established for any "
"copies made of the target object, i.e. those copies that are generated "
"when :meth:`.Table.tometadata` is used."
msgstr "：func： `.event.listen`はこのイベントの` `propagate = True``修飾子も受け付けます。 Trueの場合、ターゲットオブジェクトで作成されたコピー、つまり：meth： `.Table.tometadata`が使用されたときに生成されるコピーに対して、リスナー関数が確立されます。"

#: of sqlalchemy.events.DDLEvents.after_drop:1
msgid "Called after DROP statements are emitted."
msgstr "DROP文が発行された後に呼び出されます。"

#: of sqlalchemy.events.DDLEvents.after_drop:19
msgid ""
"the :class:`.Connection` where the DROP statement or statements have been"
" emitted."
msgstr "DROP文が発行された：class： `.Connection`。"

#: of sqlalchemy.events.DDLEvents.after_parent_attach:1
msgid ""
"Called after a :class:`.SchemaItem` is associated with a parent "
":class:`.SchemaItem`."
msgstr "a：class： `.SchemaItem`は親：class：` .SchemaItem`に関連付けられています。"

#: of sqlalchemy.events.DDLEvents.after_parent_attach:18
#: sqlalchemy.events.DDLEvents.before_parent_attach:18
msgid "the target object"
msgstr "ターゲットオブジェクト"

#: of sqlalchemy.events.DDLEvents.after_parent_attach:19
#: sqlalchemy.events.DDLEvents.before_parent_attach:19
msgid "the parent to which the target is being attached."
msgstr "ターゲットが接続されている親。"

#: of sqlalchemy.events.DDLEvents.before_create:1
msgid "Called before CREATE statements are emitted."
msgstr "CREATE文が発行される前に呼び出されます。"

#: of sqlalchemy.events.DDLEvents.before_create:19
msgid ""
"the :class:`.Connection` where the CREATE statement or statements will be"
" emitted."
msgstr "：class： `.Connection`ここで、CREATE文が発行されます。"

#: of sqlalchemy.events.DDLEvents.before_drop:1
msgid "Called before DROP statements are emitted."
msgstr "DROP文が発行される前に呼び出されます。"

#: of sqlalchemy.events.DDLEvents.before_drop:19
msgid ""
"the :class:`.Connection` where the DROP statement or statements will be "
"emitted."
msgstr "：class： `.Connection`ここでDROP文が発行されます。"

#: of sqlalchemy.events.DDLEvents.before_parent_attach:1
msgid ""
"Called before a :class:`.SchemaItem` is associated with a parent "
":class:`.SchemaItem`."
msgstr "before：class： `.SchemaItem`は親：class：` .SchemaItem`に関連付けられています。"

#: of sqlalchemy.events.DDLEvents.column_reflect:1
msgid ""
"Called for each unit of 'column info' retrieved when a :class:`.Table` is"
" being reflected."
msgstr "：class： `.Table`が反映されているときに取得される &#39;列情報&#39;の各ユニットに対して呼び出されます。"

#: of sqlalchemy.events.DDLEvents.column_reflect:18
msgid ""
"The dictionary of column information as returned by the dialect is "
"passed, and can be modified.  The dictionary is that returned in each "
"element of the list returned by "
":meth:`.reflection.Inspector.get_columns`:"
msgstr "ダイアレクトによって返された列情報の辞書は渡され、変更することができます。辞書は：meth： `.reflection.Inspector.get_columns`によって返されたリストの各要素で返されます。"

#: of sqlalchemy.events.DDLEvents.column_reflect:23
msgid "``name`` - the column's name"
msgstr "`` name``  - 列の名前"

#: of sqlalchemy.events.DDLEvents.column_reflect:25
msgid ""
"``type`` - the type of this column, which should be an instance of "
":class:`~sqlalchemy.types.TypeEngine`"
msgstr "`` type``  - この列の型で、class： `〜sqlalchemy.types.TypeEngine`のインスタンスにする必要があります。"

#: of sqlalchemy.events.DDLEvents.column_reflect:28
msgid "``nullable`` - boolean flag if the column is NULL or NOT NULL"
msgstr "`` nullable``  - カラムがNULLかNOT NULLの場合のブールフラグ"

#: of sqlalchemy.events.DDLEvents.column_reflect:30
msgid ""
"``default`` - the column's server default value.  This is normally "
"specified as a plain string SQL expression, however the event can pass a "
":class:`.FetchedValue`, :class:`.DefaultClause`, or "
":func:`.sql.expression.text` object as well."
msgstr "`` default``  - カラムのサーバのデフォルト値です。これは通常、普通の文字列SQL式として指定されますが、イベントは：class： `.FetchedValue`、：class：` .DefaultClause`、または：func： `.sql.expression.text`オブジェクトを渡すことができます。"

#: of sqlalchemy.events.DDLEvents.column_reflect:37
msgid ""
"The :meth:`.DDLEvents.column_reflect` event allows a non string "
":class:`.FetchedValue`, :func:`.sql.expression.text`, or derived object "
"to be specified as the value of ``default`` in the column dictionary."
msgstr "：meth： `.DDLEvents.column_reflect`イベントは、class：` .FetchedValue`、：func： `.sql.expression.text`、または` `default``の値として指定される派生オブジェクトの非文字列を許可します。列の辞書に"

#: of sqlalchemy.events.DDLEvents.column_reflect:43
msgid "``attrs``  - dict containing optional column attributes"
msgstr "`` attrs``  - オプションのカラム属性を含むdict"

#: of sqlalchemy.events.DDLEvents.column_reflect:45
msgid ""
"The event is called before any action is taken against this dictionary, "
"and the contents can be modified. The :class:`.Column` specific arguments"
" ``info``, ``key``, and ``quote`` can also be added to the dictionary and"
" will be passed to the constructor of :class:`.Column`."
msgstr "このディクショナリに対してアクションが実行される前にイベントが呼び出され、内容を変更できます。 ：class： `.Column`固有の引数` `info``、` `key``、` `quote``も辞書に追加することができ、class：` .Column`のコンストラクタに渡されます。 。"

#: of sqlalchemy.events.DDLEvents.column_reflect:51
msgid ""
"Note that this event is only meaningful if either associated with the "
":class:`.Table` class across the board, e.g.::"
msgstr "このイベントは、：class： `.Table`クラスに関連していれば意味があります。例："

#: of sqlalchemy.events.DDLEvents.column_reflect:67
msgid ""
"...or with a specific :class:`.Table` instance using the ``listeners`` "
"argument::"
msgstr "...または `` listeners``引数を使って特定の：class： `.Table`インスタンスを使用しています::"

#: of sqlalchemy.events.DDLEvents.column_reflect:81
msgid ""
"This because the reflection process initiated by ``autoload=True`` "
"completes within the scope of the constructor for :class:`.Table`."
msgstr "これは、 `` autoload = True``で開始されたリフレクションプロセスが：class： `.Table`のコンストラクタのスコープ内で完了するためです。"

#: of sqlalchemy.events.SchemaEventTarget:1
msgid ""
"Base class for elements that are the targets of :class:`.DDLEvents` "
"events."
msgstr "class： `.DDLEvents`イベントの対象となる要素の基本クラスです。"

#: of sqlalchemy.events.SchemaEventTarget:4
msgid "This includes :class:`.SchemaItem` as well as :class:`.SchemaType`."
msgstr "これには、class： `.SchemaItem`と：class：` .SchemaType`が含まれます。"


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    列とデータ型
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="列とデータ型" href="types.html" />
        <link rel="next" title="カスタムタイプ" href="custom_types.html" />
        <link rel="prev" title="列とデータ型" href="types.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemyコア">SQLAlchemyコア</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">SQL式言語チュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="expression_api.html">SQL Statements and Expressions API(SQL文とAPI式)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="schema.html">スキーマ定義言語</a></span></li>
<li><span class="link-container first"><a class="reference external" href="types.html">列とデータ型</a></span><ul>
<li class="selected"><span class="link-container first"><strong>列とデータ型</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#generic-types">一般的なタイプ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#sql-standard-and-multiple-vendor-types">SQL標準および複数のベンダータイプ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#vendor-specific-types">ベンダー固有のタイプ</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="custom_types.html">カスタムタイプ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="type_api.html">ベースタイプAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="engines_connections.html">エンジンと接続の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="api_basics.html">コアAPIの基礎</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.types">
<span id="column-and-data-types"></span><h1>列とデータ型<a class="headerlink" href="#module-sqlalchemy.types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>SQLAlchemyは、最も一般的なデータベースデータ型の抽象化と、独自のカスタムデータ型を指定するためのメカニズムを提供します。</p>
<p>型オブジェクトのメソッドと属性は、ほとんど直接使用されません。型オブジェクトは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.schema.Table`定義に渡され、データベースドライバが間違った型を返す場合に`関数 <a href="#id3"><span class="problematic" id="id4">`</span></a>に型ヒントとして提供することができます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">... </span>              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
<span class="gp">... </span>             <span class="p">)</span></pre></div>
</div>
<p>SQLAlchemyは、 `` Integer``と `` String（32） <a href="#id1"><span class="problematic" id="id2">``</span></a>型情報を `` CREATE TABLE``文を発行するときに使用し、データベースから `` SELECTED``行を読み戻すときに再び使用します。型を受け入れる関数（：func： <cite>〜sqlalchemy.schema.Column`など）は、通常、型クラスまたはインスタンスを受け入れます。 `</cite> Integer``は、この場合は構造引数を持たない `` Integer（） <a href="#id3"><span class="problematic" id="id4">``</span></a>に相当します。</p>
<div class="section" id="generic-types">
<span id="types-generic"></span><h2>一般的なタイプ<a class="headerlink" href="#generic-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>汎用タイプは、特定のタイプのPythonデータを読み書きし、格納できるカラムを指定します。 SQLAlchemyは、 `` CREATE TABLE``文を発行するときに、ターゲットデータベース上で利用可能な最良のデータベースカラムタイプを選択します。 `` VARCHAR``のような `` CREATE TABLE``でどのカラム型が出力されるかを完全に制御するには：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>types_sqlstandard`とこの章の他のセクションを参照してください。</p>
<dl class="class">
<dt id="sqlalchemy.types.BigInteger">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">BigInteger</code><a class="headerlink" href="#sqlalchemy.types.BigInteger" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Integer</span></code></a></p>
<p>より大きい `` int``整数の型。</p>
<p>通常はDDLに `` BIGINT``を生成し、そうでない場合はPython側でclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Integer`のように動作します。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Boolean">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Boolean</code><span class="sig-paren">(</span><em>create_constraint=True</em>, <em>name=None</em>, <em>_create_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Boolean" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Emulated</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a>, <a class="reference internal" href="#sqlalchemy.types.SchemaType" title="sqlalchemy.types.SchemaType"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.SchemaType</span></code></a></p>
<p>boolデータ型。</p>
<p>：class： <cite>.Boolean`は通常DDL側でBOOLEANまたはSMALLINTを使い、Python側では</cite> <cite>True``や</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>False``を扱います。</p>
<p>：class： <cite>.Boolean`データ型は現在、2つのレベルのアサーションを持ち、永続化された値は単純な真偽値です。すべてのバックエンドについて、Pythonの値 `</cite> None``````````````````````````````````または `` `` `` `` 0``のみがパラメータ値として受け入れられます。 &amp;quot;ネイティブブール&amp;quot;データ型をサポートしていないバックエンドの場合、CHECK制約もターゲット列に作成されます。 CHECK制約の生成は、：paramref： <cite>.Boolean.create_constraint`フラグを</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>False``に設定することで無効にすることができます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2 で変更: </span>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Boolean`データ型は、入ってくるPythonの値が既に純粋なブール形式になっていることを宣言します。</p>
</div>
<dl class="method">
<dt id="sqlalchemy.types.Boolean.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>create_constraint=True</em>, <em>name=None</em>, <em>_create_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Boolean.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a Boolean.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Boolean.params.create_constraint"></span><strong>create_constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Boolean.params.create_constraint">¶</a> -- defaults to True.  If the boolean
is generated as an int/smallint, also create a CHECK constraint
on the table that ensures 1 or 0 as a value.</li>
<li><span class="target" id="sqlalchemy.types.Boolean.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Boolean.params.name">¶</a> -- if a CHECK constraint is generated, specify
the name of the constraint.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Boolean.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Boolean.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.Boolean.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Boolean.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Boolean.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Boolean.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing literal values that are
to be rendered directly without using binds.</p>
<p>This function is used when the compiler makes use of the
&quot;literal_binds&quot; flag, typically used in DDL generation as well
as in certain scenarios where backends don't accept bound parameters.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Boolean.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Boolean.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Boolean.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Boolean.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Boolean.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Boolean.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.Boolean.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Boolean.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Date">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Date</code><a class="headerlink" href="#sqlalchemy.types.Date" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._LookupExpressionAdapter</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>`` datetime.date（） <a href="#id1"><span class="problematic" id="id2">``</span></a>オブジェクトの型。</p>
<dl class="method">
<dt id="sqlalchemy.types.Date.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Date.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Date.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Date.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.DateTime">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">DateTime</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.DateTime" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._LookupExpressionAdapter</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>`` datetime.datetime（） <a href="#id1"><span class="problematic" id="id2">``</span></a>オブジェクトの型。</p>
<p>日付と時刻の型は、Pythonの `` datetime``モジュールからオブジェクトを返します。ほとんどのDBAPIはdatetimeモジュールをサポートしていますが、SQLiteの例外はあります。 SQLiteの場合、日付と時刻の型は文字列として格納され、行が返されるとdatetimeオブジェクトに変換されます。</p>
<p>datetime型の時間表現の場合、バックエンドの中には、タイムゾーンのサポートや分数秒のサポートなどの追加オプションがあります。分数秒の場合は、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.mysql.TIME`のような方言固有のデータ型を使用します。タイムゾーンをサポートするには、少なくとも：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.types.TIMESTAMP`データ型を使用してください（もし方言固有のデータ型オブジェクトでない場合）。</p>
<dl class="method">
<dt id="sqlalchemy.types.DateTime.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.DateTime.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a new <a class="reference internal" href="#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.DateTime.params.timezone"></span><strong>timezone</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.DateTime.params.timezone">¶</a> -- boolean.  Indicates that the datetime type should
enable timezone support, if available on the
<strong>base date/time-holding type only</strong>.   It is recommended
to make use of the <a class="reference internal" href="#sqlalchemy.types.TIMESTAMP" title="sqlalchemy.types.TIMESTAMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">TIMESTAMP</span></code></a> datatype directly when
using this flag, as some databases include separate generic
date/time-holding types distinct from the timezone-capable
TIMESTAMP datatype, such as Oracle.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.DateTime.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.DateTime.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.DateTime.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.DateTime.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Enum">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Enum</code><span class="sig-paren">(</span><em>*enums</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Enum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Emulated</span></code>, <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.String</span></code></a>, <a class="reference internal" href="#sqlalchemy.types.SchemaType" title="sqlalchemy.types.SchemaType"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.SchemaType</span></code></a></p>
<p>一般的な列挙型。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Enum`型は、列が制約されている可能性のある文字列値のセットを提供します。</p>
<p>：class： <cite>.Enum`タイプは、バックエンドのネイティブ&amp;quot; ENUM &amp;quot;タイプが利用可能な場合はそのタイプを使用します。それ以外の場合は、VARCHARデータ型を使用してCHECK制約が生成されます。バックエンドネイティブenum型の使用は、：paramref： `.Enum.native_enum`フラグを使用して無効にすることができ、CHECK制約の生成は：paramref：</cite> .Enum.create_constraint`フラグを使用して設定できます。</p>
<p>：class： <cite>.Enum`型は、読み取りと書き込みの両方の操作中に文字列値をPythonで検証します。結果セット内のデータベースから値を読み取るとき、文字列値は常に可能な値のリストと照合され、一致するものが見つからなければ `</cite> LookupError``が生成されます。 ：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Enum.validate_strings`パラメータがTrueに設定されていると、SQL文内のプレーンな文字列としてデータベースに値を渡すと、その文字列の値に&amp;quot; LookupError &amp;quot;が生成されます。可能な値のリストを指定します。これは列挙された値を持つLIKE式の使用に影響を与えることに注意してください（珍しい使用例）。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.1 で変更: </span>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Enum`型は、入力値とデータベースから返されるデータのPythonでの妥当性検証を提供するようになりました。</p>
</div>
<p>列挙された値のソースは、文字列値のリスト、あるいはPEP-435に準拠した列挙されたクラスです。 ：class： <cite>.Enum`データ型のために、このクラスは</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>__members__``メソッドを提供するだけです。</p>
<p>列挙型クラスを使用する場合、列挙型オブジェクトは文字列ではなく入力と出力の両方に使用されます。単純文字列の列挙型の場合と同様です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">enum</span>
<span class="k">class</span> <span class="nc">MyEnum</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">two</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">three</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">(),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">Enum</span><span class="p">(</span><span class="n">MyEnum</span><span class="p">))</span>
<span class="p">)</span>

<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">MyEnum</span><span class="o">.</span><span class="n">two</span><span class="p">})</span>
<span class="k">assert</span> <span class="n">connection</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">select</span><span class="p">())</span> <span class="ow">is</span> <span class="n">MyEnum</span><span class="o">.</span><span class="n">two</span></pre></div>
</div>
<p>上の例では、&amp;quot;one &amp;quot;、&amp;quot;two &amp;quot;、&amp;quot;three &amp;quot;などの各要素の文字列名はデータベースに保持されます。ここで整数として示されるPython Enumの値は**使用されません**。したがって、各列挙型の値は、永続性があるかどうかに関係なく、あらゆる種類のPythonオブジェクトにすることができます。</p>
<p>名前ではなく値を永続化するために、：paramref： <cite>.Enum.values_callable`パラメータを使用することができます。このパラメータの値は、PEP-435準拠の列挙型クラスで使用することを目的とし、永続化する文字列値のリストを返す、ユーザー提供の呼び出し可能です。文字列の値を使用する単純な列挙では、 `</cite> lambda x：[e.value in e]のような呼び出し可能で十分です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>- support for PEP-435-style enumerated
classes.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：class： <cite>.postgresql.ENUM</cite>  - 追加の機能を持つPostgreSQL固有の型。</p>
<p class="last">：class： <cite>.mysql.ENUM</cite>  -  MySQL固有の型</p>
</div>
<dl class="method">
<dt id="sqlalchemy.types.Enum.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*enums</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Enum.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>列挙型を構築します。</p>
<p>特定のバックエンドに適用されないキーワード引数は、そのバックエンドによって無視されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Enum.params.*enums"></span><strong>*enums</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.*enums">¶</a> -- 厳密に1つのPEP-435準拠の列挙型または1つ以上の文字列またはユニコード列挙ラベルのいずれかです。ユニコードラベルが存在する場合、 <a href="#id1"><span class="problematic" id="id2">`</span></a>convert_unicode`フラグは自動的に有効になります。 .. versionadded :: 1.1 PEP-435スタイルの列挙型クラスを渡すことができます。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.convert_unicode">¶</a> -- この列挙型のデータに対するユニコード対応のバインドパラメータと結果セットの処理を有効にします。これは、Unicodeラベル文字列の存在に基づいて自動的に設定されます。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.create_constraint"></span><strong>create_constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.create_constraint">¶</a> -- デフォルトはTrueです。非ネイティブの列挙型を作成する場合は、有効な値に対してデータベースに対してCHECK制約を作成します。 .. versionadded :: 1.1  - 追加：paramref： <cite>.Enum.create_constraint</cite>  - 非ネイティブな列挙型のCHECK制約の生成を無効にするオプションを提供します。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.metadata"></span><strong>metadata</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.metadata">¶</a> -- この型を直接 `` MetaData``オブジェクトに関連付けます。ターゲットデータベースに独立したスキーマ構造（PostgreSQL）として存在する型の場合、この型は `` create_all（） <a href="#id1"><span class="problematic" id="id2">``</span></a>と `` drop_all（） <a href="#id3"><span class="problematic" id="id4">``</span></a>操作で作成され、削除されます。型が `` MetaData``オブジェクトに関連付けられていない場合は、それが使用されている各 `` Table``に自身を関連づけ、チェックが行われた後にそれらの個々のテーブルのいずれかが作成されると作成されますその存在のために。ただし、 `` Table``オブジェクトのメタデータに対して `` drop_all（） <a href="#id5"><span class="problematic" id="id6">``</span></a>が呼び出されたときにのみ型が削除されます。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.name">¶</a> -- このタイプの名前。これは、明示的に名前付きの型または明示的に名前付きの制約を必要とするPostgreSQLおよび将来サポートされるデータベースで、型および/またはそれを使用するテーブルを生成するために必要です。 PEP-435列挙型クラスが使用された場合、その名前（小文字に変換されます）がデフォルトで使用されます。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.native_enum"></span><strong>native_enum</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.native_enum">¶</a> -- 使用可能な場合は、データベースのネイティブENUMタイプを使用します。デフォルトはTrueです。 Falseの場合、すべてのバックエンドに対してVARCHAR + check制約を使用します。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.schema"></span><strong>schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.schema">¶</a> -- この型のスキーマ名ターゲットデータベースに独立したスキーマ構造（PostgreSQL）として存在する型の場合、このパラメータは型が存在する名前付きスキーマを指定します。 .. note :: class： <cite>.Enum`型の</cite> <cite>schema``は、デフォルトでは、owning：class：</cite> .Table`で確立された `` schema``を使用しません。この動作が必要な場合は、 `` inherit_schema``フラグを `` True``に設定してください。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.quote"></span><strong>quote</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.quote">¶</a> -- 型の名前に明示的な引用設定を設定します。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.inherit_schema"></span><strong>inherit_schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.inherit_schema">¶</a> -- `` True``を指定すると、owning：class： <cite>.Table`の&amp;quot; schema &amp;quot;がclass：</cite> .Enum`属性にコピーされます。 `` schema``属性です。これは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Table.tometadata`操作を使用するときにも有効です。</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.validate_strings"></span><strong>validate_strings</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.validate_strings">¶</a> -- Trueの場合、SQL文でデータベースに渡される文字列値は、列挙値のリストに対して有効かどうかがチェックされます。認識できない値は `` LookupError``が発生します。 .. versionadded :: 1.1.0b2</li>
<li><span class="target" id="sqlalchemy.types.Enum.params.values_callable"></span><strong>values_callable</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Enum.params.values_callable">¶</a> -- PEP-435に準拠した列挙型を渡すコール可能オブジェクト。永続化する文字列値のリストを返す必要があります。これにより、列挙型の文字列値を名前の代わりにデータベースに保持するなどの代替的な使用が可能になります。 .. versionadded :: 1.2.3</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Enum.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>bind=None</em>, <em>checkfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Enum.create" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="#sqlalchemy.types.SchemaType.create" title="sqlalchemy.types.SchemaType.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> <em>method of</em> <a class="reference internal" href="#sqlalchemy.types.SchemaType" title="sqlalchemy.types.SchemaType"><code class="xref py py-class docutils literal notranslate"><span class="pre">SchemaType</span></code></a></div>
<p>該当する場合は、このタイプのCREATE ddlを発行します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Enum.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>bind=None</em>, <em>checkfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Enum.drop" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="#sqlalchemy.types.SchemaType.drop" title="sqlalchemy.types.SchemaType.drop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">drop()</span></code></a> <em>method of</em> <a class="reference internal" href="#sqlalchemy.types.SchemaType" title="sqlalchemy.types.SchemaType"><code class="xref py py-class docutils literal notranslate"><span class="pre">SchemaType</span></code></a></div>
<p>該当する場合は、このタイプのDROP ddlを発行します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Float">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Float</code><span class="sig-paren">(</span><em>precision=None</em>, <em>asdecimal=False</em>, <em>decimal_return_scale=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Numeric</span></code></a></p>
<p>`` FLOAT``や `` REAL``のような浮動小数点型を表す型です。</p>
<p>この型は、：paramref： <cite>.Float.asdecimal`フラグがTrueに設定されていない限り、デフォルトでPythonの</cite> <cite>float``オブジェクトを返します。この場合、それらは</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>decimal.Decimal``オブジェクトに強制されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：class： <cite>.Float`型は、明示的に浮動小数点型（例えば、</cite> <cite>FLOAT`</cite>、` <cite>REAL``など）で、十進数型ではないことが知られているデータベース型からデータを受け取るように設計されています`</cite> DECIMAL``、 `` NUMERIC``など）を使用することができます。サーバ上のデータベースカラムが実際に `` DECIMAL``や `` NUMERIC``のような数値型である場合は、：class： <cite>.Numeric`型またはサブクラスを使用します。それ以外の場合は</cite> <cite>float</cite> <cite>/</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Decimal``は期待どおりに機能するかもしれません。</p>
</div>
<dl class="method">
<dt id="sqlalchemy.types.Float.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>precision=None</em>, <em>asdecimal=False</em>, <em>decimal_return_scale=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Float.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a Float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Float.params.precision"></span><strong>precision</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.params.precision">¶</a> -- the numeric precision for use in DDL <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code>.</li>
<li><span class="target" id="sqlalchemy.types.Float.params.asdecimal"></span><strong>asdecimal</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.params.asdecimal">¶</a> -- the same flag as that of <a class="reference internal" href="#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a>, but
defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.   Note that setting this flag to <code class="docutils literal notranslate"><span class="pre">True</span></code>
results in floating point conversion.</li>
<li><span class="target" id="sqlalchemy.types.Float.params.decimal_return_scale"></span><strong>decimal_return_scale</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.params.decimal_return_scale">¶</a> -- <p>Default scale to use when converting
from floats to Python decimals.  Floating point values will typically
be much longer due to decimal inaccuracy, and most floating point
database types don't have a notion of &quot;scale&quot;, so by default the
float type looks for the first ten decimal places when converting.
Specfiying this value will override that length.  Note that the
MySQL float types, which do include &quot;scale&quot;, will use &quot;scale&quot;
as the default for decimal_return_scale, if not otherwise specified.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.Float.params.**kwargs"></span><strong>**kwargs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.params.**kwargs">¶</a> -- deprecated.  Additional arguments here are ignored
by the default <a class="reference internal" href="#sqlalchemy.types.Float" title="sqlalchemy.types.Float"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float</span></code></a> type.  For database specific
floats that support additional arguments, see that dialect's
documentation for details, such as
<a class="reference internal" href="../dialects/mysql.html#sqlalchemy.dialects.mysql.FLOAT" title="sqlalchemy.dialects.mysql.FLOAT"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.mysql.FLOAT</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Float.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Float.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Float.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.Float.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Float.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Integer">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Integer</code><a class="headerlink" href="#sqlalchemy.types.Integer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._LookupExpressionAdapter</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>`` int``型の型です。</p>
<dl class="method">
<dt id="sqlalchemy.types.Integer.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Integer.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Integer.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Integer.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing literal values that are
to be rendered directly without using binds.</p>
<p>This function is used when the compiler makes use of the
&quot;literal_binds&quot; flag, typically used in DDL generation as well
as in certain scenarios where backends don't accept bound parameters.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Integer.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Integer.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Interval">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Interval</code><span class="sig-paren">(</span><em>native=True</em>, <em>second_precision=None</em>, <em>day_precision=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Interval" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Emulated</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._AbstractInterval</span></code>, <a class="reference internal" href="custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeDecorator</span></code></a></p>
<p>`` datetime.timedelta（） <a href="#id1"><span class="problematic" id="id2">``</span></a>オブジェクトの型。</p>
<p>Interval型は `` datetime.timedelta``オブジェクトを扱います。 PostgreSQLでは、ネイティブの `` INTERVAL``型が使用されます。他の場合、値は&amp;quot;epoch &amp;quot;（1970年1月1日）に関連する日付として格納されます。</p>
<p>`` Interval``型は現在インターバル型をネイティブにサポートしていないプラットフォームでは日付演算を提供していないことに注意してください。このような操作では、通常、現在の手続き（via：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.func`など）である式の両辺の変換（最初に両辺を整数エポック値に変換するなど）が必要です。</p>
<dl class="method">
<dt id="sqlalchemy.types.Interval.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>native=True</em>, <em>second_precision=None</em>, <em>day_precision=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Interval.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct an Interval object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Interval.params.native"></span><strong>native</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.params.native">¶</a> -- when True, use the actual
INTERVAL type provided by the database, if
supported (currently PostgreSQL, Oracle).
Otherwise, represent the interval data as
an epoch value regardless.</li>
<li><span class="target" id="sqlalchemy.types.Interval.params.second_precision"></span><strong>second_precision</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.params.second_precision">¶</a> -- For native interval types
which support a &quot;fractional seconds precision&quot; parameter,
i.e. Oracle and PostgreSQL</li>
<li><span class="target" id="sqlalchemy.types.Interval.params.day_precision"></span><strong>day_precision</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.params.day_precision">¶</a> -- for native interval types which
support a &quot;day precision&quot; parameter, i.e. Oracle.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Interval.adapt_to_emulated">
<code class="descname">adapt_to_emulated</code><span class="sig-paren">(</span><em>impltype</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Interval.adapt_to_emulated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Given an impl class, adapt this type to the impl assuming &quot;emulated&quot;.</p>
<p>The impl should also be an &quot;emulated&quot; version of this type,
most likely the same class as this type itself.</p>
<p>e.g.: sqltypes.Enum adapts to the Enum class.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Interval.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Interval.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.Interval.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Interval.impl">
<code class="descname">impl</code><a class="headerlink" href="#sqlalchemy.types.Interval.impl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> のエイリアス</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Interval.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Interval.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Interval.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Interval.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Interval.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.Interval.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Interval.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.LargeBinary">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">LargeBinary</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.LargeBinary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._Binary</span></code></p>
<p>大きなバイナリバイトデータの型。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.LargeBinary`型は、MySQL上のBLOBやPostgreSQL用のBYTEAのように、ターゲットプラットフォームのための大きなバイナリ型や無限型のバイナリ型に対応します。また、DBAPIに必要な変換も処理します。</p>
<dl class="method">
<dt id="sqlalchemy.types.LargeBinary.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.LargeBinary.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a LargeBinary type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.LargeBinary.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.LargeBinary.params.length">¶</a> -- optional, a length for the column for use in
DDL statements, for those binary types that accept a length,
such as the MySQL BLOB type.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.MatchType">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">MatchType</code><span class="sig-paren">(</span><em>create_constraint=True</em>, <em>name=None</em>, <em>_create_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.MatchType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Boolean</span></code></a></p>
<p>MATCH演算子の戻り値の型を参照します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ColumnOperators.match`は多分一般的なSQLAlchemy Coreの中で最もオープンな演算子であるため、MySQLが浮動小数点を返すので、SQLの評価時には返り値の型を仮定することはできません。バックエンドは何か違うことがあります。したがって、この型はプレースホルダとして機能し、現在はclass： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Boolean`をサブクラス化しています。この型では、必要に応じて方言が結果処理機能を注入することができ、MySQLは浮動小数点値を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Numeric">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Numeric</code><span class="sig-paren">(</span><em>precision=None</em>, <em>scale=None</em>, <em>decimal_return_scale=None</em>, <em>asdecimal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._LookupExpressionAdapter</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>`` NUMERIC``や `` DECIMAL``のような固定精度の数値の型です。</p>
<p>この型は：paramref： <cite>.Numeric.asdecimal`フラグがFalseに設定されていない限り、デフォルトでPythonの</cite> <cite>decimal.Decimal``オブジェクトを返します。この場合、それらはPythonの</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>float``オブジェクトに強制されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：class： <cite>.Numeric`型は、明示的に小数点型（例えば</cite> DECIMAL`、 <cite>NUMERIC`など）であり、浮動小数点型ではないというデータ型からデータを受け取るように設計されています「FLOAT」、「REAL」など）。サーバのデータベースカラムが実際に `</cite> FLOAT``や `` REAL``のような浮動小数点タイプの型である場合、：class： <cite>.Float`型またはサブクラスを使用します。それ以外の場合は</cite> <cite>float`</cite> /` <a href="#id1"><span class="problematic" id="id2">`</span></a>Decimal``は期待どおりに機能するかもしれません。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>Pythonの `` decimal.Decimal``クラスは一般的に遅いです。 cPython 3.3は、現在、 <cite>cdecimal &lt;http://pypi.python.org/pypi/cdecimal/&gt; `_ライブラリネイティブ。古いPythonバージョンでは、 `</cite> decimal``ライブラリを完全に置き換えるアプリケーションに `` cdecimal``ライブラリをパッチすることができますが、これはグローバルに適用され、他のモジュールがインポートされる前に、 ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">cdecimal</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;decimal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdecimal</span></pre></div>
</div>
<p class="last">`` cdecimal``と `` decimal``ライブラリは**互いに互換性がありません**ので、グローバルレベルで `` cdecimal``をパッチすることは、それがさまざまなDBAPIで効果的に使用できる唯一の方法です`` decimal``ライブラリをインポートするためのハードコードです。</p>
</div>
<dl class="method">
<dt id="sqlalchemy.types.Numeric.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>precision=None</em>, <em>scale=None</em>, <em>decimal_return_scale=None</em>, <em>asdecimal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a Numeric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Numeric.params.precision"></span><strong>precision</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.params.precision">¶</a> -- the numeric precision for use in DDL <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code>.</li>
<li><span class="target" id="sqlalchemy.types.Numeric.params.scale"></span><strong>scale</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.params.scale">¶</a> -- the numeric scale for use in DDL <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code>.</li>
<li><span class="target" id="sqlalchemy.types.Numeric.params.asdecimal"></span><strong>asdecimal</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.params.asdecimal">¶</a> -- default True.  Return whether or not
values should be sent as Python Decimal objects, or
as floats.   Different DBAPIs send one or the other based on
datatypes - the Numeric type will ensure that return values
are one or the other across DBAPIs consistently.</li>
<li><span class="target" id="sqlalchemy.types.Numeric.params.decimal_return_scale"></span><strong>decimal_return_scale</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.params.decimal_return_scale">¶</a> -- <p>Default scale to use when converting
from floats to Python decimals.  Floating point values will typically
be much longer due to decimal inaccuracy, and most floating point
database types don't have a notion of &quot;scale&quot;, so by default the
float type looks for the first ten decimal places when converting.
Specfiying this value will override that length.  Types which
do include an explicit &quot;.scale&quot; value, such as the base
<a class="reference internal" href="#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a> as well as the MySQL float types, will use the
value of &quot;.scale&quot; as the default for decimal_return_scale, if not
otherwise specified.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>When using the <code class="docutils literal notranslate"><span class="pre">Numeric</span></code> type, care should be taken to ensure
that the asdecimal setting is apppropriate for the DBAPI in use -
when Numeric applies a conversion from Decimal-&gt;float or float-&gt;
Decimal, this conversion incurs an additional performance overhead
for all result columns received.</p>
<p>DBAPIs that return Decimal natively (e.g. psycopg2) will have
better accuracy and higher performance with a setting of <code class="docutils literal notranslate"><span class="pre">True</span></code>,
as the native translation to Decimal reduces the amount of floating-
point issues at play, and the Numeric type itself doesn't need
to apply any further conversions.  However, another DBAPI which
returns floats natively <em>will</em> incur an additional conversion
overhead, and is still subject to floating point data loss - in
which case <code class="docutils literal notranslate"><span class="pre">asdecimal=False</span></code> will at least remove the extra
conversion overhead.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Numeric.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.Numeric.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Numeric.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Numeric.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing literal values that are
to be rendered directly without using binds.</p>
<p>This function is used when the compiler makes use of the
&quot;literal_binds&quot; flag, typically used in DDL generation as well
as in certain scenarios where backends don't accept bound parameters.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Numeric.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Numeric.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.Numeric.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Numeric.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.Numeric.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.Numeric.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.Numeric.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.PickleType">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">PickleType</code><span class="sig-paren">(</span><em>protocol=4</em>, <em>pickler=None</em>, <em>comparator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.PickleType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeDecorator</span></code></a></p>
<p>pickleを使用してシリアル化されるPythonオブジェクトを保持します。</p>
<p>Pythonの `` pickle.dumps（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を入ってくるオブジェクトに適用するために、PickleTypeはバイナリ型をベースに構築され、ピック可能なPythonオブジェクトを直列化されたバイナリフィールドとして格納できるようにするために、 `` pickle.loads（） 。</p>
<p>：class： <cite>.PickleType`に関連する要素のORM変更イベントを伝播させるには、：ref：</cite> mutable_toplevel`を参照してください。</p>
<dl class="method">
<dt id="sqlalchemy.types.PickleType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>protocol=4</em>, <em>pickler=None</em>, <em>comparator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.PickleType.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a PickleType.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.PickleType.params.protocol"></span><strong>protocol</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.params.protocol">¶</a> -- defaults to <code class="docutils literal notranslate"><span class="pre">pickle.HIGHEST_PROTOCOL</span></code>.</li>
<li><span class="target" id="sqlalchemy.types.PickleType.params.pickler"></span><strong>pickler</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.params.pickler">¶</a> -- defaults to cPickle.pickle or pickle.pickle if
cPickle is not available.  May be any object with
pickle-compatible <code class="docutils literal notranslate"><span class="pre">dumps`</span> <span class="pre">and</span> <span class="pre">``loads</span></code> methods.</li>
<li><span class="target" id="sqlalchemy.types.PickleType.params.comparator"></span><strong>comparator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.params.comparator">¶</a> -- a 2-arg callable predicate used
to compare values of this type.  If left as <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the Python &quot;equals&quot; operator is used to compare values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.PickleType.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.PickleType.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Provide a bound value processing function for the
given <a class="reference internal" href="internals.html#sqlalchemy.engine.interfaces.Dialect" title="sqlalchemy.engine.interfaces.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a>.</p>
<p>This is the method that fulfills the <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>
contract for bound value conversion.   <a class="reference internal" href="custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>
will wrap a user-defined implementation of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">process_bind_param()</span></code> here.</p>
<p>User-defined code can override this method directly,
though its likely best to use <code class="xref py py-meth docutils literal notranslate"><span class="pre">process_bind_param()</span></code> so that
the processing provided by <code class="docutils literal notranslate"><span class="pre">self.impl</span></code> is maintained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.PickleType.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
<p>This method is the reverse counterpart to the
<a class="reference internal" href="#sqlalchemy.types.PickleType.result_processor" title="sqlalchemy.types.PickleType.result_processor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">result_processor()</span></code></a> method of this class.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.PickleType.compare_values">
<code class="descname">compare_values</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.PickleType.compare_values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Given two values, compare them for equality.</p>
<p>By default this calls upon <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.compare_values" title="sqlalchemy.types.TypeEngine.compare_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.compare_values()</span></code></a>
of the underlying &quot;impl&quot;, which in turn usually
uses the Python equals operator <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
<p>This function is used by the ORM to compare
an original-loaded value with an intercepted
&quot;changed&quot; value, to determine if a net change
has occurred.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.PickleType.impl">
<code class="descname">impl</code><a class="headerlink" href="#sqlalchemy.types.PickleType.impl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">LargeBinary</span></code></a> のエイリアス</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.PickleType.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.PickleType.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Provide a result value processing function for the given
<a class="reference internal" href="internals.html#sqlalchemy.engine.interfaces.Dialect" title="sqlalchemy.engine.interfaces.Dialect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dialect</span></code></a>.</p>
<p>This is the method that fulfills the <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a>
contract for result value conversion.   <a class="reference internal" href="custom_types.html#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>
will wrap a user-defined implementation of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">process_result_value()</span></code> here.</p>
<p>User-defined code can override this method directly,
though its likely best to use <code class="xref py py-meth docutils literal notranslate"><span class="pre">process_result_value()</span></code> so that
the processing provided by <code class="docutils literal notranslate"><span class="pre">self.impl</span></code> is maintained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.PickleType.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.PickleType.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.PickleType.result_processor.params.coltype">¶</a> -- A SQLAlchemy data type</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This method is the reverse counterpart to the
<a class="reference internal" href="#sqlalchemy.types.PickleType.bind_processor" title="sqlalchemy.types.PickleType.bind_processor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind_processor()</span></code></a> method of this class.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.SchemaType">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">SchemaType</code><span class="sig-paren">(</span><em>name=None</em>, <em>schema=None</em>, <em>metadata=None</em>, <em>inherit_schema=False</em>, <em>quote=None</em>, <em>_create_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.SchemaType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.SchemaEventTarget</span></code></p>
<p>タイプに、使用のためにスキーマレベルのDDLが必要な可能性があるとマークします。</p>
<p>明示的に作成/削除する必要のあるタイプ（つまり、PG ENUMタイプ）と、テーブルやスキーマレベルの制約、トリガ、その他のルールによって補完されるタイプをサポートします。</p>
<p>：class： <cite>.SchemaType`クラスは、：meth：</cite> .DDLEvents.before_parent_attach`と：meth： <cite>.DDLEvents.after_parent_attach`イベントのターゲットにすることもできます。イベントは、タイプオブジェクトと親：クラス： `.Column</cite>。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：class： <cite>.Enum</cite></p>
<p class="last">：クラス： <cite>.Boolean</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.types.SchemaType.adapt">
<code class="descname">adapt</code><span class="sig-paren">(</span><em>impltype</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.SchemaType.adapt" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.SchemaType.bind">
<code class="descname">bind</code><a class="headerlink" href="#sqlalchemy.types.SchemaType.bind" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.SchemaType.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.SchemaType.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.SchemaType.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>bind=None</em>, <em>checkfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.SchemaType.create" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>該当する場合は、このタイプのCREATE ddlを発行します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.SchemaType.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>bind=None</em>, <em>checkfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.SchemaType.drop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>該当する場合は、このタイプのDROP ddlを発行します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.SmallInteger">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">SmallInteger</code><a class="headerlink" href="#sqlalchemy.types.SmallInteger" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Integer</span></code></a></p>
<p>より小さい `` int``整数の型です。</p>
<p>通常、DDLに `` SMALLINT``を生成し、そうでなければPython側でclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Integer`のように動作します。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.String">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">String</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="type_api.html#sqlalchemy.types.Concatenable" title="sqlalchemy.types.Concatenable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Concatenable</span></code></a>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>すべての文字列と文字種のベース。</p>
<p>SQLでは、VARCHARに対応します。 PythonのUnicodeオブジェクトを取得し、バインドパラメータでデータベースのエンコーディングにエンコードすることもできます（結果セットの逆も可能です）。</p>
<p><cite>length`フィールドは、通常、VARCHARがほとんどのデータベースで長さを必要とするため、CREATE TABLEステートメント内で</cite> String`タイプが使用されるときに必要です。</p>
<dl class="method">
<dt id="sqlalchemy.types.String.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Create a string-holding type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.String.params.length"></span><strong>length</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.params.length">¶</a> -- optional, a length for the column for use in
DDL and CAST expressions.  May be safely omitted if no <code class="docutils literal notranslate"><span class="pre">CREATE</span>
<span class="pre">TABLE</span></code> will be issued.  Certain databases may require a
<code class="docutils literal notranslate"><span class="pre">length</span></code> for use in DDL, and will raise an exception when
the <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> DDL is issued if a <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>
with no length is included.  Whether the value is
interpreted as bytes or characters is database specific.</li>
<li><span class="target" id="sqlalchemy.types.String.params.collation"></span><strong>collation</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.params.collation">¶</a> -- <p>Optional, a column-level collation for
use in DDL and CAST expressions.  Renders using the
COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">select</span><span class="p">([</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;some string&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))])</span>
<span class="go">SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加: </span>Added support for COLLATE to all
string types.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.String.params.convert_unicode"></span><strong>convert_unicode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.params.convert_unicode">¶</a> -- <p>When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
<a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> type will assume that
input is to be passed as Python <code class="docutils literal notranslate"><span class="pre">unicode</span></code> objects,
and results returned as Python <code class="docutils literal notranslate"><span class="pre">unicode</span></code> objects.
If the DBAPI in use does not support Python unicode
(which is fewer and fewer these days), SQLAlchemy
will encode/decode the value, using the
value of the <code class="docutils literal notranslate"><span class="pre">encoding</span></code> parameter passed to
<a class="reference internal" href="engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a> as the encoding.</p>
<p>When using a DBAPI that natively supports Python
unicode objects, this flag generally does not
need to be set.  For columns that are explicitly
intended to store non-ASCII data, the <a class="reference internal" href="#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a>
or <a class="reference internal" href="#sqlalchemy.types.UnicodeText" title="sqlalchemy.types.UnicodeText"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeText</span></code></a>
types should be used regardless, which feature
the same behavior of <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code> but
also indicate an underlying column type that
directly supports unicode, such as <code class="docutils literal notranslate"><span class="pre">NVARCHAR</span></code>.</p>
<p>For the extremely rare case that Python <code class="docutils literal notranslate"><span class="pre">unicode</span></code>
is to be encoded/decoded by SQLAlchemy on a backend
that does natively support Python <code class="docutils literal notranslate"><span class="pre">unicode</span></code>,
the value <code class="docutils literal notranslate"><span class="pre">force</span></code> can be passed here which will
cause SQLAlchemy's encode/decode services to be
used unconditionally.</p>
</li>
<li><span class="target" id="sqlalchemy.types.String.params.unicode_error"></span><strong>unicode_error</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.params.unicode_error">¶</a> -- Optional, a method to use to handle Unicode
conversion errors. Behaves like the <code class="docutils literal notranslate"><span class="pre">errors</span></code> keyword argument to
the standard library's <code class="docutils literal notranslate"><span class="pre">string.decode()</span></code> functions.   This flag
requires that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code> is set to <code class="docutils literal notranslate"><span class="pre">force</span></code> - otherwise,
SQLAlchemy is not guaranteed to handle the task of unicode
conversion.   Note that this flag adds significant performance
overhead to row-fetching operations for backends that already
return unicode objects natively (which most DBAPIs do).  This
flag should only be used as a last resort for reading
strings from a column with varied or corrupted encodings.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.String.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.String.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.String.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.String.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing literal values that are
to be rendered directly without using binds.</p>
<p>This function is used when the compiler makes use of the
&quot;literal_binds&quot; flag, typically used in DDL generation as well
as in certain scenarios where backends don't accept bound parameters.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.String.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.String.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.String.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.String.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.String.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.String.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.String.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Text">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Text</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Text" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.String</span></code></a></p>
<p>可変サイズの文字列型。</p>
<p>SQLでは、通常、CLOBまたはTEXTに対応します。 PythonのUnicodeオブジェクトを取得し、bind paramsでデータベースのエンコーディングにエンコードすることもできます（結果セットの逆もあります）。一般に、TEXTオブジェクトには長さがありません。一部のデータベースはここで長さの引数を受け入れますが、他のデータベースによって拒否されます。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Time">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Time</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Time" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._LookupExpressionAdapter</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>`` datetime.time（） <a href="#id1"><span class="problematic" id="id2">``</span></a>オブジェクトの型。</p>
<dl class="method">
<dt id="sqlalchemy.types.Time.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Time.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.Time.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.Time.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.Unicode">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">Unicode</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Unicode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.String</span></code></a></p>
<p>可変長のUnicode文字列型。</p>
<p>：class： <cite>.Unicode`型は、Pythonの</cite> <cite>unicode``データとしての入出力を前提とした</cite> class： <cite>.String`サブクラスであり、</cite> <cite>convert_unicode``フラグの使用法と同じです：class： `.String`型を使います。しかし、plain：class： `.String`とは異なり、OracleやSQL Server上の</cite> <cite>NVARCHAR``のように、非ASCIIデータを明示的にサポートしている基底のカラム型をも意味します。これは、方言レベルでの `</cite> CREATE TABLE``文と `` CAST``関数の出力に影響を与える可能性があり、特定のDBAPIシナリオではバインドされたパラメータの処理にも影響します。</p>
<p>：class： <cite>.Unicode`型で使用されるエンコーディングは通常、DBAPI自体によって決まります。最新のDBAPIは、Pythonの `</cite> unicode``オブジェクトをバウンド値と結果セットの値としてサポートしています：エンコーディングは、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>dialect_toplevel`セクションのターゲットDBAPIの注釈で詳細に設定されていなければなりません。</p>
<p>Pythonの `` unicode``オブジェクトを直接サポートするように構成されていないDBAPIの場合、SQLAlchemyはDBAPIの外部でエンコードとデコードを行います。このシナリオでのエンコーディングは：func： <cite>.create_engine`に渡される</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>encoding``フラグによって決まります。</p>
<p>：class： <cite>.Unicode`型を使うときは、Pythonの</cite> <cite>unicode``オブジェクトを渡すのが適切で、</cite> <cite>str``は普通ではありません。普通の `</cite> str``がPython 2の下で渡されると、警告が出されます。あなたのアプリケーションがこれらの警告を出すが、そのソースが分からない場合は、<a class="reference external" href="http://docs.python.org/library/warnings">http://docs.python.org/library/warnings</a>.htmlに記載されているPythonの `` warnings``フィルタを使用できますこれらの警告をスタックトレースを示す例外にする：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span></pre></div>
</div>
<p>プレーンなバイトコードとPythonの `` unicode``オブジェクトを `` Unicode``型に等しく渡したいアプリケーションでは、バイトコードを最初にUnicodeにデコードする必要があります。レシピ：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>coerce_to_unicode`はこれがどのように行われるかを示しています。</p>
<p>参照：</p>
<blockquote>
<div>：class： <cite>.UnicodeText</cite>  -  class：` .Unicode`のテキストに対応しています。</div></blockquote>
<dl class="method">
<dt id="sqlalchemy.types.Unicode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.Unicode.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unicode</span></code></a> object.</p>
<p>Parameters are the same as that of <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>,
with the exception that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code>
defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.UnicodeText">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">UnicodeText</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.UnicodeText" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Text</span></code></a></p>
<p>無限の長さのUnicode文字列型です。</p>
<p>このオブジェクトのユニコード動作の詳細については、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Unicode`を参照してください。</p>
<p>class： <cite>.Unicode`のように、use：class：</cite> .UnicodeText`型は、 `` NCLOB``、 `` NTEXT``など、バックエンドで使用されているUnicode対応型を意味します。</p>
<dl class="method">
<dt id="sqlalchemy.types.UnicodeText.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.UnicodeText.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Create a Unicode-converting Text type.</p>
<p>Parameters are the same as that of <a class="reference internal" href="#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code></a>,
with the exception that <code class="docutils literal notranslate"><span class="pre">convert_unicode</span></code>
defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sql-standard-and-multiple-vendor-types">
<span id="types-sqlstandard"></span><h2>SQL標準および複数のベンダータイプ<a class="headerlink" href="#sql-standard-and-multiple-vendor-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このタイプのタイプは、SQL標準の一部であるか、データベースバックエンドのサブセット内に潜在的に存在するタイプを指します。 &amp;quot;一般的な&amp;quot;タイプとは異なり、SQL標準/マルチベンダタイプはすべてのバックエンドで**の**保証を保証しており、明示的にサポートするバックエンドでのみ動作します。つまり、型は常に `` CREATE TABLE``が発行されたDDLで正確な名前を出します。</p>
<dl class="class">
<dt id="sqlalchemy.types.ARRAY">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">ARRAY</code><span class="sig-paren">(</span><em>item_type</em>, <em>as_tuple=False</em>, <em>dimensions=None</em>, <em>zero_indexes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.SchemaEventTarget</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.Indexable" title="sqlalchemy.types.Indexable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Indexable</span></code></a>, <a class="reference internal" href="type_api.html#sqlalchemy.types.Concatenable" title="sqlalchemy.types.Concatenable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Concatenable</span></code></a>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>SQL配列型を表します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このタイプは、すべてのARRAY操作の基礎となります。しかし、現在** PostgreSQLバックエンドだけがSQLAlchemy <a href="#id1"><span class="problematic" id="id2">**</span></a>のSQL配列をサポートしています。 PostgreSQLでARRAY型を使用する場合は、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.postgresql.ARRAY`型を直接使用することをお勧めします。これは、そのバックエンドに固有の追加演算子を提供するためです。</p>
</div>
<p>：class： <cite>.types.ARRAY`は、明示的に配列を含むclass：</cite> .array_agg`のようなさまざまなSQL標準関数をサポートするCoreの一部です。しかし、PostgreSQLのバックエンドと場合によってはサードパーティの方言を除いて、他のSQLAlchemy組み込み方言はこのタイプをサポートしていません。</p>
<p>An：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.ARRAY`型は、要素の&amp;quot;型&amp;quot;を指定して構築されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mytable</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;mytable&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">))</span>
    <span class="p">)</span></pre></div>
</div>
<p>上記の型はN次元の配列を表します。つまり、PostgreSQLなどのサポートバックエンドは自動的に任意の次元数の値を解釈します。 1次元の整数配列を渡すINSERT構文を生成するには:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">mytable</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span>
        <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">)</span></pre></div>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.ARRAY`型は、固定数の次元を与えて構築することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mytable</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;mytable&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="p">)</span></pre></div>
</div>
<p>複数のディメンションを送信することはオプションですが、データ型が複数のディメンションの配列を表す場合に推奨されます。この番号が使用されます：</p>
<ul>
<li><p class="first">型宣言自体をデータベースに出力するときは、 `` INTEGER [] [] ``</p>
</li>
<li><p class="first">：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Unicode`オブジェクトのARRAYのようにPythonの値をデータベースの値に変換するときは、行ごとの型検査に頼らずに配列構造内の文字列値に効率的にアクセスするためにこの値を使用します</p>
</li>
<li><p class="first">Pythonの `` getitem``アクセサで使用する場合、ディメンションの数は、 `` [] <a href="#id1"><span class="problematic" id="id2">``</span></a>演算子が返すべき型の種類を定義するのに役立ちます。例えば、2次元のINTEGERのARRAYの場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># returns ARRAY(Integer, dimensions=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="c1"># returns Integer</span></pre></div>
</div>
</li>
</ul>
<p>1次元配列の場合、次元パラメータを持たないclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.ARRAY`インスタンスは、一般に一次元の動作を仮定します。</p>
<p>：class： <cite>.types.ARRAY`型のSQL式は、&amp;quot; index &amp;quot;と&amp;quot; slice &amp;quot;の動作をサポートしています。整数インデックスやスライスを指定すると、Pythonの `</cite> [] <a href="#id1"><span class="problematic" id="id2">``</span></a>演算子は通常ここで動作します。配列の既定値は1から始まります。演算子は、適切なSQLを生成するバイナリ式の構文を生成します。両方のSELECT文には</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select</span><span class="p">([</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]])</span></pre></div>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Update.values`メソッドが使用されているときのUPDATE文</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mytable</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">({</span>
    <span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">})</span></pre></div>
</div>
<p>：class： <cite>.types.ARRAY`型は：meth：</cite> .types.ARRAY.Comparator.any`と：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.ARRAY.Comparator.all`の演算子も提供します。 PostgreSQL固有のバージョン：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.types.ARRAY`は、追加の演算子も提供します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：クラス： <cite>.postgresql.ARRAY</cite></p>
</div>
<dl class="class">
<dt id="sqlalchemy.types.ARRAY.Comparator">
<em class="property">class </em><code class="descname">Comparator</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.Comparator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code></p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.ARRAY`の比較演算を定義します。</p>
<p>このタイプの方言固有の形式では、より多くの演算子を使用できます。参照：class： <cite>.postgresql.ARRAY.Comparator</cite>。</p>
<dl class="method">
<dt id="sqlalchemy.types.ARRAY.Comparator.all">
<code class="descname">all</code><span class="sig-paren">(</span><em>elements</em>, <em>other</em>, <em>operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.Comparator.all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a href="#id1"><span class="problematic" id="id2">``</span></a>他の演算子ALL（配列） <a href="#id3"><span class="problematic" id="id4">``</span></a>節を返します。</p>
<p>ALLは配列式が右辺にある必要があるため、引数の場所が切り替わります。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">operators</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>
        <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.all.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.all.params.other">¶</a> -- 比較される式</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.all.params.operator"></span><strong>operator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.all.params.operator">¶</a> -- ：mod： <cite>sqlalchemy.sql.operators`パッケージの演算子オブジェクトは、デフォルトで：func：</cite> .operators.eq`になります。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：func： <cite>.sql.expression.all_</cite></p>
<p class="last">：meth： <cite>.types.ARRAY.Comparator.any</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.ARRAY.Comparator.any">
<code class="descname">any</code><span class="sig-paren">(</span><em>elements</em>, <em>other</em>, <em>operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.Comparator.any" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a href="#id1"><span class="problematic" id="id2">``</span></a>他の演算子ANY（配列） <a href="#id3"><span class="problematic" id="id4">``</span></a>節を返します。</p>
<p>ANYでは配列式が右辺にある必要があるため、引数の場所が切り替わります。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">operators</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>
        <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.any.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.any.params.other">¶</a> -- 比較される式</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.any.params.operator"></span><strong>operator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.any.params.operator">¶</a> -- ：mod： <cite>sqlalchemy.sql.operators`パッケージの演算子オブジェクトは、デフォルトで：func：</cite> .operators.eq`になります。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：func： <cite>.sql.expression.any_</cite></p>
<p class="last">：meth： <cite>.types.ARRAY.Comparator.all</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.ARRAY.Comparator.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.Comparator.contains" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implement the 'contains' operator.</p>
<p>Produces a LIKE expression that tests against a match for the middle
of a string value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">column</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="o">&lt;</span><span class="n">other</span><span class="o">&gt;</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">))</span></pre></div>
</div>
<p>Since the operator uses <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, wildcard characters
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> flag
may be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to apply escaping to occurences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.escape</span></code></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.contains.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.contains.params.other">¶</a> -- expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> are not escaped by default unless
the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> flag is
set to True.</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.contains.params.autoescape"></span><strong>autoescape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.contains.params.autoescape">¶</a> -- <p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo%bar&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;/&#39;</span></pre></div>
</div>
<p>With the value of :param as <code class="docutils literal notranslate"><span class="pre">&quot;foo/%bar&quot;</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2.0 で変更: </span>The
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> parameter is
 now a simple boolean rather than a character; the escape
 character itself is also escaped, and defaults to a forwards
 slash, which itself can be customized using the
 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.escape</span></code></a> parameter.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.Comparator.contains.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.Comparator.contains.params.escape">¶</a> -- <p>a character which when given will render with the
<code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;^&#39;</span></pre></div>
</div>
<p>The parameter may also be combined with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo%bar^bat&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Where above, the given literal parameter will be converted to
<code class="docutils literal notranslate"><span class="pre">&quot;foo^%bar^^bat&quot;</span></code> before being passed to the database.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.startswith()</span></code></a></p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.endswith()</span></code></a></p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.ARRAY.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>item_type</em>, <em>as_tuple=False</em>, <em>dimensions=None</em>, <em>zero_indexes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct an <a class="reference internal" href="#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ARRAY</span></code></a>.</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;myarray&#39;</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">(</span><span class="n">Integer</span><span class="p">))</span></pre></div>
</div>
<p>Arguments are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.ARRAY.params.item_type"></span><strong>item_type</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.params.item_type">¶</a> -- The data type of items of this array. Note that
dimensionality is irrelevant here, so multi-dimensional arrays like
<code class="docutils literal notranslate"><span class="pre">INTEGER[][]</span></code>, are constructed as <code class="docutils literal notranslate"><span class="pre">ARRAY(Integer)</span></code>, not as
<code class="docutils literal notranslate"><span class="pre">ARRAY(ARRAY(Integer))</span></code> or such.</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.params.as_tuple"></span><strong>as_tuple=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.params.as_tuple">¶</a> -- Specify whether return results
should be converted to tuples from lists.  This parameter is
not generally needed as a Python list corresponds well
to a SQL array.</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.params.dimensions"></span><strong>dimensions</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.params.dimensions">¶</a> -- if non-None, the ARRAY will assume a fixed
number of dimensions.   This impacts how the array is declared
on the database, how it goes about interpreting Python and
result values, as well as how expression behavior in conjunction
with the &quot;getitem&quot; operator works.  See the description at
<a class="reference internal" href="#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ARRAY</span></code></a> for additional detail.</li>
<li><span class="target" id="sqlalchemy.types.ARRAY.params.zero_indexes"></span><strong>zero_indexes=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.ARRAY.params.zero_indexes">¶</a> -- when True, index values will be converted
between Python zero-based and SQL one-based indexes, e.g.
a value of one will be added to all index values before passing
to the database.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.ARRAY.comparator_factory">
<code class="descname">comparator_factory</code><a class="headerlink" href="#sqlalchemy.types.ARRAY.comparator_factory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.types.ARRAY.Comparator" title="sqlalchemy.types.ARRAY.Comparator"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY.Comparator</span></code></a> のエイリアス</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.ARRAY.compare_values">
<code class="descname">compare_values</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.ARRAY.compare_values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Compare two values for equality.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.ARRAY.hashable">
<code class="descname">hashable</code><a class="headerlink" href="#sqlalchemy.types.ARRAY.hashable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.ARRAY.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.ARRAY.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.ARRAY.zero_indexes">
<code class="descname">zero_indexes</code><em class="property"> = False</em><a class="headerlink" href="#sqlalchemy.types.ARRAY.zero_indexes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Trueの場合、Pythonのゼロベースのインデックスは、SQL式の側で1に基づいて解釈される必要があります。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.BIGINT">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">BIGINT</code><a class="headerlink" href="#sqlalchemy.types.BIGINT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.BigInteger" title="sqlalchemy.types.BigInteger"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.BigInteger</span></code></a></p>
<p>SQL BIGINT型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.BINARY">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">BINARY</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.BINARY" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._Binary</span></code></p>
<p>SQL BINARY型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.BLOB">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">BLOB</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.BLOB" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.LargeBinary" title="sqlalchemy.types.LargeBinary"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.LargeBinary</span></code></a></p>
<p>SQL BLOB型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.BOOLEAN">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">BOOLEAN</code><span class="sig-paren">(</span><em>create_constraint=True</em>, <em>name=None</em>, <em>_create_events=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.BOOLEAN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Boolean</span></code></a></p>
<p>SQL BOOLEAN型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.CHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">CHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.CHAR" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.String</span></code></a></p>
<p>SQL CHAR型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.CLOB">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">CLOB</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.CLOB" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Text</span></code></a></p>
<p>CLOBタイプ。</p>
<p>このタイプは、OracleおよびInformixにあります。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.DATE">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">DATE</code><a class="headerlink" href="#sqlalchemy.types.DATE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Date" title="sqlalchemy.types.Date"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Date</span></code></a></p>
<p>SQL DATE型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.DATETIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">DATETIME</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.DATETIME" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.DateTime</span></code></a></p>
<p>SQL DATETIME型です。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.DECIMAL">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">DECIMAL</code><span class="sig-paren">(</span><em>precision=None</em>, <em>scale=None</em>, <em>decimal_return_scale=None</em>, <em>asdecimal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.DECIMAL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Numeric</span></code></a></p>
<p>SQL DECIMAL型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.FLOAT">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">FLOAT</code><span class="sig-paren">(</span><em>precision=None</em>, <em>asdecimal=False</em>, <em>decimal_return_scale=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.FLOAT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Float" title="sqlalchemy.types.Float"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Float</span></code></a></p>
<p>SQLのFLOAT型。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.INT">
<code class="descclassname">sqlalchemy.types.</code><code class="descname">INT</code><a class="headerlink" href="#sqlalchemy.types.INT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.sqltypes.INTEGER</span></code> のエイリアス</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.JSON">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">JSON</code><span class="sig-paren">(</span><em>none_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="type_api.html#sqlalchemy.types.Indexable" title="sqlalchemy.types.Indexable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Indexable</span></code></a>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>SQL JSON型を表します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.JSON`はベンダー固有のJSON型のファサードとして提供されています。 JSON SQL操作をサポートしているので、実際のJSONタイプを持つバックエンドでのみ動作します。</p>
<ul class="last simple">
<li>PostgreSQL</li>
<li>バージョン5.7のMySQL（10.2シリーズのMariaDBはありません）</li>
<li>バージョン3.9以降のSQLite</li>
</ul>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.JSON`は、ネイティブJSONデータ型の人気が高まる中、Coreの一部です。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.JSON`型は任意のJSON形式のデータを格納します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;data_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="n">data_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key1&quot;</span><span class="p">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">:</span> <span class="s2">&quot;value2&quot;</span><span class="p">}</span>
    <span class="p">)</span></pre></div>
</div>
<p>base：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.JSON`は、次の2つの操作を提供します。</p>
<ul>
<li><p class="first">キー付きインデックス操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some key&#39;</span><span class="p">]</span></pre></div>
</div>
</li>
<li><p class="first">整数インデックス操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></pre></div>
</div>
</li>
<li><p class="first">パスインデックス操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[(</span><span class="s1">&#39;key_1&#39;</span><span class="p">,</span> <span class="s1">&#39;key_2&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="s1">&#39;key_n&#39;</span><span class="p">)]</span></pre></div>
</div>
</li>
</ul>
<p>追加の操作は：class： <cite>.types.JSON`のような：：class：</cite> .postgresql.JSON`と：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.postgresql.JSONB`の方言固有のバージョンから利用できます。ちょうど基本的なタイプ。</p>
<p>インデックス操作は、デフォルトでtypeが：class： <cite>.JSON`に設定されている式オブジェクトを返します。これにより、JSON指向のさらなる命令が結果タイプに対して呼び出されるようになります。 PostgreSQLデータベースは、一般に、型キャストなしで&amp;quot;json &amp;quot;構造と&amp;quot;json &amp;quot;構造を比較しないことを含め、バックエンド固有の特異性があることに注意してください。これらの特質は、：func： `.cast`と：func：</cite> .type_coerce`構造を明示的に使用することで、バックエンドに中立な方法で対応できます。 a：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.JSON`オブジェクトの特定のインデックス要素と他のオブジェクトとの比較は、左辺が文字列**にキャストされ、<a href="#id3"><span class="problematic" id="id4">**</span></a>右辺がjson文字列**としてレンダリングされる場合に最も効果的です。ジェネリック&amp;quot;astext &amp;quot;修飾子のような将来のSQLAlchemy機能は、ある時点でこれを単純化するかもしれません：</p>
<ul>
<li><p class="first">** JSON構造体の要素を文字列と比較**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">type_coerce</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">String</span><span class="p">,</span> <span class="n">JSON</span>

<span class="n">cast</span><span class="p">(</span>
    <span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span>
<span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;&quot;some_value&quot;&#39;</span>

<span class="n">cast</span><span class="p">(</span>
    <span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span>
<span class="p">)</span> <span class="o">==</span> <span class="n">type_coerce</span><span class="p">(</span><span class="s2">&quot;some_value&quot;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p class="first">** JSON構造体の要素を整数と比較する**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">type_coerce</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">String</span><span class="p">,</span> <span class="n">JSON</span>

<span class="n">cast</span><span class="p">(</span><span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;55&#39;</span>

<span class="n">cast</span><span class="p">(</span>
    <span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span>
<span class="p">)</span> <span class="o">==</span> <span class="n">type_coerce</span><span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p class="first">** JSON構造体の要素を他のJSON構造体と比較する**  -  Python辞書は通常は順序付けされていないので、ここではJSON構造体が同一であることを注意してください。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">type_coerce</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">String</span><span class="p">,</span> <span class="n">JSON</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="n">cast</span><span class="p">(</span>
    <span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span>
<span class="p">)</span> <span class="o">==</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">})</span>

<span class="n">cast</span><span class="p">(</span>
    <span class="n">data_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">],</span> <span class="n">String</span>
<span class="p">)</span> <span class="o">==</span> <span class="n">type_coerce</span><span class="p">({</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">},</span> <span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.JSON`型は、SQLAlchemy ORMと一緒に使用すると、構造体に対するインプレースの突然変異を検出しません。これらを検出するには、：mod： <a href="#id3"><span class="problematic" id="id4">`</span></a>sqlalchemy.ext.mutable`拡張子を使用する必要があります。この拡張は、作業単位によって検出されるイベントを生成するために、データ構造に対する&amp;quot;インプレース&amp;quot;の変更を可能にします。辞書を含む簡単な例については、class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.HSTORE`の例を参照してください。</p>
<p>NULL値を扱う場合、：class： <cite>.JSON`型は、SQL NULLに評価される列（例えば値なし）とJSONでエンコードされた文字列</cite> <cite>&amp;#39;&amp;#39;を区別するために、2つの特定の定数の使用を推奨します。 &amp;quot;null &amp;quot; `</cite>。 SQL NULL値を挿入または選択するには、定数：func： <cite>.null</cite> ::を使用します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">null</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">json_value</span><span class="o">=</span><span class="n">null</span><span class="p">())</span></pre></div>
</div>
<p>JSON `` &amp;quot;null &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>の値を挿入または選択するには、定数attr： <cite>.JSON.NULL</cite> ::を使用します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">json_value</span><span class="o">=</span><span class="n">JSON</span><span class="o">.</span><span class="n">NULL</span><span class="p">)</span></pre></div>
</div>
<p>：class： <cite>.JSON`型は、フラグ：paramref：</cite> .JSON.none_as_null`をサポートします。これをTrueに設定すると、SQL NULLの値を評価するPython定数 `` None``が生成され、False JSONの `` &amp;quot;null &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>の値に評価されるPython定数 `` None``が返されます。 Pythonの値 `` None``は、NULL値を示すために：attr： <cite>.JSON.NULL`と：func：</cite> .null`のどちらかと一緒に使うことができますが、 ：paramref： <a href="#id3"><span class="problematic" id="id4">`</span></a>.JSON.none_as_null`これらの場合</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：クラス： <cite>.postgresql.JSON</cite></p>
<p>：クラス： <cite>.postgresql.JSONB</cite></p>
<p class="last">：クラス： <cite>.mysql.JSON</cite></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<dl class="class">
<dt id="sqlalchemy.types.JSON.Comparator">
<em class="property">class </em><code class="descname">Comparator</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.Comparator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code></p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.types.JSON`の比較演算を定義します。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.JSON.JSONElementType">
<em class="property">class </em><code class="descname">JSONElementType</code><a class="headerlink" href="#sqlalchemy.types.JSON.JSONElementType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>JSON式のインデックス/パス要素の共通関数です。</p>
<dl class="method">
<dt id="sqlalchemy.types.JSON.JSONElementType.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.JSONElementType.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.JSON.JSONElementType.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.JSON.JSONElementType.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.JSON.JSONElementType.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.JSONElementType.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing literal values that are
to be rendered directly without using binds.</p>
<p>This function is used when the compiler makes use of the
&quot;literal_binds&quot; flag, typically used in DDL generation as well
as in certain scenarios where backends don't accept bound parameters.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.JSON.JSONIndexType">
<em class="property">class </em><code class="descname">JSONIndexType</code><a class="headerlink" href="#sqlalchemy.types.JSON.JSONIndexType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.JSONElementType</span></code></p>
<p>JSONインデックス値のデータ型のプレースホルダ。</p>
<p>これにより、特殊な構文のJSONインデックス値の実行時処理が可能になります。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.JSON.JSONPathType">
<em class="property">class </em><code class="descname">JSONPathType</code><a class="headerlink" href="#sqlalchemy.types.JSON.JSONPathType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.JSONElementType</span></code></p>
<p>JSONパス操作のプレースホルダタイプ。</p>
<p>これにより、パスベースのインデックス値を特定のSQL構文に実行時処理することができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.JSON.NULL">
<code class="descname">NULL</code><em class="property"> = symbol('JSON_NULL')</em><a class="headerlink" href="#sqlalchemy.types.JSON.NULL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>NULLのjson値を記述します。</p>
<p>この値は、 `` &amp;quot;null&amp;quot; &amp;quot;のJSON値を強制的に値として使用するために使用されます。 Pythonの `` None``の値は：paramref： <cite>.JSON.none_as_null`フラグの設定に基づいて、SQL NULLまたはJSON</cite> <cite>&amp;quot; null &amp;quot;</cite> <cite>として認識されます。 ：attr： `.JSON.NULL`定数は、この設定に関係なく常にJSON</cite> <cite>&amp;quot; null &amp;quot;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>に解決するために使用できます。これは：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.sql.null`構文とは対照的です。これは常にSQL NULLに解決されます。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">null</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="n">JSON</span>

<span class="n">obj1</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">json_value</span><span class="o">=</span><span class="n">null</span><span class="p">())</span>  <span class="c1"># will *always* insert SQL NULL</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">json_value</span><span class="o">=</span><span class="n">JSON</span><span class="o">.</span><span class="n">NULL</span><span class="p">)</span>  <span class="c1"># will *always* insert JSON string &quot;null&quot;</span>

<span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">])</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>列のデフォルト値としてJSON NULLを設定するには、最も透過的な方法は：func： <cite>.text</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;my_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;json_data&#39;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;null&#39;&quot;</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>このコンテキストでは：attr： <cite>.JSON.NULL`を使用することができますが、：attr：</cite> .JSON.NULL`の値は列の値として返されます。これは、ORMやその他の再利用デフォルト値の、望ましくない可能性があります。 SQL式を使用すると、生成されたデフォルト値を取得するコンテキスト内で値がデータベースから再フェッチされることを意味します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.JSON.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>none_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.JSON</span></code></a> type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.JSON.params.none_as_null"></span><strong>none_as_null=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.JSON.params.none_as_null">¶</a> -- <p>if True, persist the value <code class="docutils literal notranslate"><span class="pre">None</span></code> as a
SQL NULL value, not the JSON encoding of <code class="docutils literal notranslate"><span class="pre">null</span></code>.   Note that
when this flag is False, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.null" title="sqlalchemy.sql.expression.null"><code class="xref py py-func docutils literal notranslate"><span class="pre">null()</span></code></a> construct can still
be used to persist a NULL value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">null</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">data</span><span class="o">=</span><span class="n">null</span><span class="p">())</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.types.JSON.params.none_as_null" title="sqlalchemy.types.JSON"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">JSON.none_as_null</span></code></a> does <strong>not</strong> apply to the
values passed to <a class="reference internal" href="metadata.html#sqlalchemy.schema.Column.params.default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.default</span></code></a> and
<a class="reference internal" href="metadata.html#sqlalchemy.schema.Column.params.server_default" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.server_default</span></code></a>; a value of <code class="docutils literal notranslate"><span class="pre">None</span></code> passed for
these parameters means &quot;no default present&quot;.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.types.JSON.NULL" title="sqlalchemy.types.JSON.NULL"><code class="xref py py-attr docutils literal notranslate"><span class="pre">types.JSON.NULL</span></code></a></p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.JSON.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing bind values.</p>
<p>Returns a callable which will receive a bind parameter value
as the sole positional argument and will return a value to
send to the DB-API.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.JSON.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.JSON.bind_processor.params.dialect">¶</a> -- Dialect instance in use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.JSON.comparator_factory">
<code class="descname">comparator_factory</code><a class="headerlink" href="#sqlalchemy.types.JSON.comparator_factory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.types.JSON.Comparator" title="sqlalchemy.types.JSON.Comparator"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON.Comparator</span></code></a> のエイリアス</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.JSON.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.JSON.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the Python type object expected to be returned
by instances of this type, if known.</p>
<p>Basically, for those types which enforce a return type,
or are known across the board to do such for all common
DBAPIs (like <code class="docutils literal notranslate"><span class="pre">int</span></code> for example), will return that type.</p>
<p>If a return type is not defined, raises
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.</p>
<p>Note that any type also accommodates NULL in SQL which
means you can also get back <code class="docutils literal notranslate"><span class="pre">None</span></code> from any type
in practice.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.JSON.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.JSON.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a conversion function for processing result row values.</p>
<p>Returns a callable which will receive a result row column
value as the sole positional argument and will return a value
to return to the user.</p>
<p>If processing is not necessary, the method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.JSON.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.JSON.result_processor.params.dialect">¶</a> -- Dialect instance in use.</li>
<li><span class="target" id="sqlalchemy.types.JSON.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.JSON.result_processor.params.coltype">¶</a> -- DBAPI coltype argument received in cursor.description.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.JSON.should_evaluate_none">
<code class="descname">should_evaluate_none</code><a class="headerlink" href="#sqlalchemy.types.JSON.should_evaluate_none" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.INTEGER">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">INTEGER</code><a class="headerlink" href="#sqlalchemy.types.INTEGER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Integer</span></code></a></p>
<p>SQL INTまたはINTEGER型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.NCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">NCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.NCHAR" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Unicode</span></code></a></p>
<p>SQL NCHAR型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.NVARCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">NVARCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.NVARCHAR" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Unicode" title="sqlalchemy.types.Unicode"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Unicode</span></code></a></p>
<p>SQLのNVARCHAR型です。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.NUMERIC">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">NUMERIC</code><span class="sig-paren">(</span><em>precision=None</em>, <em>scale=None</em>, <em>decimal_return_scale=None</em>, <em>asdecimal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.NUMERIC" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Numeric</span></code></a></p>
<p>SQL NUMERIC型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.REAL">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">REAL</code><span class="sig-paren">(</span><em>precision=None</em>, <em>asdecimal=False</em>, <em>decimal_return_scale=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.REAL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Float" title="sqlalchemy.types.Float"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Float</span></code></a></p>
<p>SQL REAL型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.SMALLINT">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">SMALLINT</code><a class="headerlink" href="#sqlalchemy.types.SMALLINT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.SmallInteger" title="sqlalchemy.types.SmallInteger"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.SmallInteger</span></code></a></p>
<p>SQL SMALLINT型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.TEXT">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">TEXT</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TEXT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Text" title="sqlalchemy.types.Text"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Text</span></code></a></p>
<p>SQL TEXT型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.TIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">TIME</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TIME" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.Time" title="sqlalchemy.types.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Time</span></code></a></p>
<p>SQL TIME型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.TIMESTAMP">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">TIMESTAMP</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TIMESTAMP" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.DateTime</span></code></a></p>
<p>SQL TIMESTAMP型。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.TIMESTAMP`データ型は、PostgreSQLやOracleなどのいくつかのバックエンドでのタイムゾーン格納をサポートしています。これらのバックエンドに&amp;quot;TIMESTAMP WITH TIMEZONE &amp;quot;を有効にするには、：paramref： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜types.TIMESTAMP.timezone`引数を使用します。</p>
<dl class="method">
<dt id="sqlalchemy.types.TIMESTAMP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>timezone=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TIMESTAMP.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a new <a class="reference internal" href="#sqlalchemy.types.TIMESTAMP" title="sqlalchemy.types.TIMESTAMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">TIMESTAMP</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.TIMESTAMP.params.timezone"></span><strong>timezone</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TIMESTAMP.params.timezone">¶</a> -- boolean.  Indicates that the TIMESTAMP type should
enable timezone support, if available on the target database.
On a per-dialect basis is similar to &quot;TIMESTAMP WITH TIMEZONE&quot;.
If the target database does not support timezones, this flag is
ignored.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TIMESTAMP.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TIMESTAMP.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the corresponding type object from the underlying DB-API, if
any.</p>
<blockquote>
<div>This can be useful for calling <code class="docutils literal notranslate"><span class="pre">setinputsizes()</span></code>, for example.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.VARBINARY">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">VARBINARY</code><span class="sig-paren">(</span><em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.VARBINARY" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types._Binary</span></code></p>
<p>SQL VARBINARY型。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.types.VARCHAR">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">VARCHAR</code><span class="sig-paren">(</span><em>length=None</em>, <em>collation=None</em>, <em>convert_unicode=False</em>, <em>unicode_error=None</em>, <em>_warn_on_bytestring=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.VARCHAR" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.String</span></code></a></p>
<p>SQL VARCHAR型。</p>
</dd></dl>

</div>
<div class="section" id="vendor-specific-types">
<span id="types-vendor"></span><h2>ベンダー固有のタイプ<a class="headerlink" href="#vendor-specific-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>データベース固有の型は、各データベースのダイアレクトモジュールからインポートすることもできます。興味のあるデータベースの：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>dialect_toplevel`リファレンスを参照してください。</p>
<p>たとえば、MySQLには `` BIGINT``型があり、PostgreSQLには `` INET``型があります。これらを使用するには、モジュールから明示的にインポートする:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">mysql</span>

<span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">mysql</span><span class="o">.</span><span class="n">BIGINT</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;enumerates&#39;</span><span class="p">,</span> <span class="n">mysql</span><span class="o">.</span><span class="n">ENUM</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>またはいくつかのPostgreSQLの種類:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">postgresql</span>

<span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;ipaddress&#39;</span><span class="p">,</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">INET</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;elements&#39;</span><span class="p">,</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">ARRAY</span><span class="p">(</span><span class="n">String</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>各方言は、そのバックエンドが <cite>__all__`コレクション内でサポートしている完全な型名を提供します。そのため、単純な</cite> import * <a href="#id1"><span class="problematic" id="id2">`</span></a>や類似のものは、そのバックエンドに実装されたすべてのサポートされている型をインポートします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="o">*</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
           <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">INTEGER</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
           <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">300</span><span class="p">)),</span>
           <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;inetaddr&#39;</span><span class="p">,</span> <span class="n">INET</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記の場合、INTEGER型とVARCHAR型は最終的にsqlalchemy.typesにあり、INETはPostgreSQL方言に固有の型です。</p>
<p>いくつかの方言レベル型は、SQL標準型と同じ名前を持つだけでなく、追加の引数を提供します。例えば、MySQLは、 <cite>collat​​ion`や</cite> charset` ::などの追加の引数を含む、文字列と文字列型の全範囲を実装しています</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.mysql</span> <span class="k">import</span> <span class="n">VARCHAR</span><span class="p">,</span> <span class="n">TEXT</span>

<span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">collation</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="n">charset</span><span class="o">=</span><span class="s1">&#39;latin1&#39;</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="types.html" title="previous chapter">列とデータ型</a>
        Next:
        <a href="custom_types.html" title="next chapter">カスタムタイプ</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



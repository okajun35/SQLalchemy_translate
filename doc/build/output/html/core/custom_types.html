<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    カスタムタイプ
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="列とデータ型" href="types.html" />
        <link rel="next" title="ベースタイプAPI" href="type_api.html" />
        <link rel="prev" title="列とデータ型" href="type_basics.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemyコア">SQLAlchemyコア</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">SQL式言語チュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="expression_api.html">SQL Statements and Expressions API(SQL文とAPI式)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="schema.html">スキーマ定義言語</a></span></li>
<li><span class="link-container first"><a class="reference external" href="types.html">列とデータ型</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="type_basics.html">列とデータ型</a></span></li>
<li class="selected"><span class="link-container first"><strong>カスタムタイプ</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#overriding-type-compilation">型コンパイルのオーバーライド</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#augmenting-existing-types">既存のタイプの拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#typedecorator-recipes">TypeDecoratorのレシピ</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#coercing-encoded-strings-to-unicode">エンコードされた文字列をUnicodeに変換する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#rounding-numerics">丸め数値</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#backend-agnostic-guid-type">バックエンドに依存しないGUIDタイプ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#marshal-json-strings">JSONストリングを整列化する</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#adding-mutability">変更可能性の追加</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#dealing-with-comparison-operations">比較操作の処理</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#replacing-the-bind-result-processing-of-existing-types">既存の型のバインド/結果処理の置換</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#applying-sql-level-bind-result-processing">SQLレベルのバインド/結果処理の適用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#redefining-and-creating-new-operators">新しい演算子の再定義と作成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#creating-new-types">新しいタイプの作成</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="type_api.html">ベースタイプAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="engines_connections.html">エンジンと接続の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="api_basics.html">コアAPIの基礎</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<span class="target" id="module-sqlalchemy.types"></span><div class="section" id="custom-types">
<span id="types-custom"></span><h1>カスタムタイプ<a class="headerlink" href="#custom-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>既存の型の動作を再定義し、新しい型を提供するためのさまざまなメソッドが存在します。</p>
<div class="section" id="overriding-type-compilation">
<h2>型コンパイルのオーバーライド<a class="headerlink" href="#overriding-type-compilation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>CREATE TABLEステートメントやCASTのような他のSQL関数でレンダリングされる型の&amp;quot;文字列&amp;quot;バージョンを強制的に変更する必要が頻繁にあります。例えば、アプリケーションは、 `` BLOB``がレンダリングされることを望むプラットフォーム以外のすべてのプラットフォームで `` BINARY``のレンダリングを強制したいかもしれません。既存のジェネリック型（この場合は：class： <cite>.LargeBinary</cite>）の使用法は、ほとんどのユースケースで優先されます。しかし、型をより正確に制御するために、方言ごとのコンパイルディレクティブを任意の型に関連付けることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.compiler</span> <span class="k">import</span> <span class="n">compiles</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">BINARY</span>

<span class="nd">@compiles</span><span class="p">(</span><span class="n">BINARY</span><span class="p">,</span> <span class="s2">&quot;sqlite&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compile_binary_sqlite</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;BLOB&quot;</span></pre></div>
</div>
<p>上記のコードでは：class： <cite>.types.BINARY`を使用できます。これは、SQLite以外のすべてのバックエンドに対して文字列</cite> <cite>BINARY``を生成します。この場合、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>BLOB``が生成されます。</p>
<p>追加の例は：ref： <cite>sqlalchemy.ext.compiler_toplevel`のサブセクション：ref：</cite> type_compilation_extension`の節を参照してください。</p>
</div>
<div class="section" id="augmenting-existing-types">
<span id="types-typedecorator"></span><h2>既存のタイプの拡張<a class="headerlink" href="#augmenting-existing-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`は、バインドパラメータと結果処理の振る舞いを既存の型オブジェクトに追加するカスタム型の作成を可能にします。これは、データベース内の追加のPythonマーシャリングが必要な場合に使用されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`のバインドと結果の処理は、ホスト型によって既に実行されている処理に加えて*です。この処理は、DBAPIごとにSQLAlchemyによってカスタマイズされ、そのDBAPIに固有の処理を実行します。既存の型のDBAPIレベルの処理を変更するには、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>replacement_processors`を参照してください。</p>
</div>
<dl class="class">
<dt id="sqlalchemy.types.TypeDecorator">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">TypeDecorator</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.SchemaEventTarget</span></code>, <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>既存のタイプに追加の機能を追加するタイプの作成を可能にします。</p>
<p>このメソッドは、SQLAlchemyの組み込み型のサブクラス化を指示するのに適しているため、基本型のすべての必要な機能が確実に保持されます。</p>
<p>典型的な使用法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy.types</span> <span class="k">as</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">MyType</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Prefixes Unicode values with &quot;PREFIX:&quot; on the way in and</span>
<span class="sd">    strips it off on the way out.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">Unicode</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;PREFIX:&quot;</span> <span class="o">+</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MyType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">length</span><span class="p">)</span></pre></div>
</div>
<p>クラスレベルの&amp;quot;impl &amp;quot;属性は必須であり、任意のTypeEngineクラスを参照できます。代わりに、load_dialect_impl（）メソッドを使用して、与えられた方言に基づいて異なるタイプのクラスを提供することができます。この場合、&amp;quot;impl &amp;quot;変数は `` TypeEngine``をプレースホルダとして参照できます。</p>
<p>使用される最終的な型に似ていないPython型を受け取る型は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>TypeDecorator.coerce_compared_value`メソッドを定義したいかもしれません。これは、Pythonオブジェクトを式内のバインドパラメータに変換する際にヒントを与えるために使用されます。次の式を考えてみましょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">somecol</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span></pre></div>
</div>
<p>上記の&amp;quot;somecol &amp;quot;が &amp;quot;Integer&amp;quot;型である場合は、日付演算を行うことが理にかなっています。式システムは、&amp;quot;date（）&amp;quot;の値を整数指向のバインドパラメータに変換しようとしないことで正しいことを行います。</p>
<p>しかし、 `` TypeDecorator``の場合、普通は入ってくるPython型を何か新しいものに変更しています - デフォルトで `` TypeDecorator``は、型指定されていない側がそれ自身と同じ型になるよう強制します。以下のように、日付値を整数として格納する&amp;quot;epoch &amp;quot;型を定義します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyEpochType</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="n">impl</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">Integer</span>

    <span class="n">epoch</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">days</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></pre></div>
</div>
<p>上記の型の `` somecol + date``の式は、右側の&amp;quot;date &amp;quot;を &amp;quot;MyEpochType&amp;quot;として扱うよう強制します。</p>
<p>この動作は：meth： <cite>〜TypeDecorator.coerce_compared_value`メソッドでオーバーライドできます。このメソッドは、式の値に使用する型を返します。以下では整数値を `</cite> Integer``として扱い、他の値は日付とみなして `` MyEpochType`` ::として扱います。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">coerce_compared_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>coerce_compared_valueの**動作は、基本型**の動作からデフォルトで継承されないことに注意してください。 ：class： <cite>.TypeDecorator`が特定の型の演算子に対して特別なロジックを必要とする型を増やしている場合、このメソッドは**オーバーライドする必要があります。重要な例は、：class： `.postgresql.JSON`と：class：</cite> .postgresql.JSONB`型を装飾するときです。インデックス操作のような演算子を扱うために：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeEngine.coerce_compared_value`のデフォルトルールを使用する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyJsonType</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="n">impl</span> <span class="o">=</span> <span class="n">postgresql</span><span class="o">.</span><span class="n">JSON</span>

    <span class="k">def</span> <span class="nf">coerce_compared_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">coerce_compared_value</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></pre></div>
</div>
<p class="last">上記の手順がなければ、 `` mycol [&amp;#39;foo&amp;#39;] <a href="#id1"><span class="problematic" id="id2">``</span></a>などのインデックス操作によってインデックス値 `` &amp;#39;foo&amp;#39;``がJSONエンコードされます。</p>
</div>
<dl class="class">
<dt id="sqlalchemy.types.TypeDecorator.Comparator">
<em class="property">class </em><code class="descname">Comparator</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code></p>
<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__eq__" title="sqlalchemy.sql.operators.ColumnOperators.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>.
If the target is <code class="docutils literal notranslate"><span class="pre">None</span></code>, produces <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">IS</span> <span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.__le__">
<code class="descname">__le__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__le__" title="sqlalchemy.sql.operators.ColumnOperators.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.__lt__">
<code class="descname">__lt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__lt__" title="sqlalchemy.sql.operators.ColumnOperators.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__ne__" title="sqlalchemy.sql.operators.ColumnOperators.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">!=</span></code> operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code>.
If the target is <code class="docutils literal notranslate"><span class="pre">None</span></code>, produces <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.all_">
<code class="descname">all_</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.all_" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.all_" title="sqlalchemy.sql.operators.ColumnOperators.all_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all_()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.all_" title="sqlalchemy.sql.expression.all_"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_()</span></code></a> clause against the
parent object.</p>
<p>This operator is only appropriate against a scalar subquery
object, or for some backends an column expression that is
against the ARRAY type, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># postgresql &#39;5 = ALL (somearray)&#39;</span>
<span class="n">expr</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">==</span> <span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">somearray</span><span class="o">.</span><span class="n">all_</span><span class="p">()</span>

<span class="c1"># mysql &#39;5 = ALL (SELECT value FROM table)&#39;</span>
<span class="n">expr</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">==</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">])</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span><span class="o">.</span><span class="n">all_</span><span class="p">()</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.all_" title="sqlalchemy.sql.expression.all_"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_()</span></code></a> - standalone version</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.any_" title="sqlalchemy.sql.expression.any_"><code class="xref py py-func docutils literal notranslate"><span class="pre">any_()</span></code></a> - ANY operator</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.any_">
<code class="descname">any_</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.any_" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.any_" title="sqlalchemy.sql.operators.ColumnOperators.any_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any_()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.any_" title="sqlalchemy.sql.expression.any_"><code class="xref py py-func docutils literal notranslate"><span class="pre">any_()</span></code></a> clause against the
parent object.</p>
<p>This operator is only appropriate against a scalar subquery
object, or for some backends an column expression that is
against the ARRAY type, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># postgresql &#39;5 = ANY (somearray)&#39;</span>
<span class="n">expr</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">==</span> <span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">somearray</span><span class="o">.</span><span class="n">any_</span><span class="p">()</span>

<span class="c1"># mysql &#39;5 = ANY (SELECT value FROM table)&#39;</span>
<span class="n">expr</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">==</span> <span class="n">select</span><span class="p">([</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">])</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span><span class="o">.</span><span class="n">any_</span><span class="p">()</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.any_" title="sqlalchemy.sql.expression.any_"><code class="xref py py-func docutils literal notranslate"><span class="pre">any_()</span></code></a> - standalone version</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.all_" title="sqlalchemy.sql.expression.all_"><code class="xref py py-func docutils literal notranslate"><span class="pre">all_()</span></code></a> - ALL operator</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.asc">
<code class="descname">asc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.asc" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.asc" title="sqlalchemy.sql.operators.ColumnOperators.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asc()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.asc" title="sqlalchemy.sql.expression.asc"><code class="xref py py-func docutils literal notranslate"><span class="pre">asc()</span></code></a> clause against the
parent object.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.between">
<code class="descname">between</code><span class="sig-paren">(</span><em>cleft</em>, <em>cright</em>, <em>symmetric=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.between" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.between" title="sqlalchemy.sql.operators.ColumnOperators.between"><code class="xref py py-meth docutils literal notranslate"><span class="pre">between()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.between" title="sqlalchemy.sql.expression.between"><code class="xref py py-func docutils literal notranslate"><span class="pre">between()</span></code></a> clause against
the parent object, given the lower and upper range.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.bool_op">
<code class="descname">bool_op</code><span class="sig-paren">(</span><em>opstring</em>, <em>precedence=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.bool_op" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.bool_op" title="sqlalchemy.sql.operators.Operators.bool_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bool_op()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators" title="sqlalchemy.sql.operators.Operators"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a></div>
<p>Return a custom boolean operator.</p>
<p>This method is shorthand for calling
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Operators.op()</span></code></a> and passing the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op.params.is_comparison" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.is_comparison</span></code></a>
flag with True.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2.0b3 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Operators.op</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.collate">
<code class="descname">collate</code><span class="sig-paren">(</span><em>collation</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.collate" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.collate" title="sqlalchemy.sql.operators.ColumnOperators.collate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collate()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.collate" title="sqlalchemy.sql.expression.collate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collate()</span></code></a> clause against
the parent object, given the collation string.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.collate" title="sqlalchemy.sql.expression.collate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.concat">
<code class="descname">concat</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.concat" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.concat" title="sqlalchemy.sql.operators.ColumnOperators.concat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">concat()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the 'concat' operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>,
or uses the <code class="docutils literal notranslate"><span class="pre">concat()</span></code> operator on MySQL.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.contains" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">contains()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the 'contains' operator.</p>
<p>Produces a LIKE expression that tests against a match for the middle
of a string value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">column</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="o">&lt;</span><span class="n">other</span><span class="o">&gt;</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">))</span></pre></div>
</div>
<p>Since the operator uses <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, wildcard characters
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> flag
may be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to apply escaping to occurences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.escape</span></code></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.contains.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.contains.params.other">¶</a> -- expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> are not escaped by default unless
the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> flag is
set to True.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.contains.params.autoescape"></span><strong>autoescape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.contains.params.autoescape">¶</a> -- <p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo%bar&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;/&#39;</span></pre></div>
</div>
<p>With the value of :param as <code class="docutils literal notranslate"><span class="pre">&quot;foo/%bar&quot;</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2.0 で変更: </span>The
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a> parameter is
 now a simple boolean rather than a character; the escape
 character itself is also escaped, and defaults to a forwards
 slash, which itself can be customized using the
 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.escape</span></code></a> parameter.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.contains.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.contains.params.escape">¶</a> -- <p>a character which when given will render with the
<code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;^&#39;</span></pre></div>
</div>
<p>The parameter may also be combined with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.contains.autoescape</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;foo%bar^bat&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Where above, the given literal parameter will be converted to
<code class="docutils literal notranslate"><span class="pre">&quot;foo^%bar^^bat&quot;</span></code> before being passed to the database.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.startswith()</span></code></a></p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.endswith()</span></code></a></p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.desc">
<code class="descname">desc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.desc" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.desc" title="sqlalchemy.sql.operators.ColumnOperators.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">desc()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.desc" title="sqlalchemy.sql.expression.desc"><code class="xref py py-func docutils literal notranslate"><span class="pre">desc()</span></code></a> clause against the
parent object.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.distinct">
<code class="descname">distinct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.distinct" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.distinct" title="sqlalchemy.sql.operators.ColumnOperators.distinct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distinct()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.distinct" title="sqlalchemy.sql.expression.distinct"><code class="xref py py-func docutils literal notranslate"><span class="pre">distinct()</span></code></a> clause against the
parent object.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.endswith">
<code class="descname">endswith</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the 'endswith' operator.</p>
<p>Produces a LIKE expression that tests against a match for the end
of a string value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">column</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="o">&lt;</span><span class="n">other</span><span class="o">&gt;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">))</span></pre></div>
</div>
<p>Since the operator uses <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, wildcard characters
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.autoescape</span></code></a> flag
may be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to apply escaping to occurences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.escape</span></code></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.endswith.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.endswith.params.other">¶</a> -- expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> are not escaped by default unless
the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.autoescape</span></code></a> flag is
set to True.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.endswith.params.autoescape"></span><strong>autoescape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.endswith.params.autoescape">¶</a> -- <p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;foo%bar&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="n">ESCAPE</span> <span class="s1">&#39;/&#39;</span></pre></div>
</div>
<p>With the value of :param as <code class="docutils literal notranslate"><span class="pre">&quot;foo/%bar&quot;</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2.0 で変更: </span>The
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.autoescape</span></code></a> parameter is
 now a simple boolean rather than a character; the escape
 character itself is also escaped, and defaults to a forwards
 slash, which itself can be customized using the
 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.escape</span></code></a> parameter.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.endswith.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.endswith.params.escape">¶</a> -- <p>a character which when given will render with the
<code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">||</span> <span class="p">:</span><span class="n">param</span> <span class="n">ESCAPE</span> <span class="s1">&#39;^&#39;</span></pre></div>
</div>
<p>The parameter may also be combined with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.endswith.autoescape</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;foo%bar^bat&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Where above, the given literal parameter will be converted to
<code class="docutils literal notranslate"><span class="pre">&quot;foo^%bar^^bat&quot;</span></code> before being passed to the database.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.startswith()</span></code></a></p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.contains()</span></code></a></p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.ilike">
<code class="descname">ilike</code><span class="sig-paren">(</span><em>other</em>, <em>escape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.ilike" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ilike()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">ilike</span></code> operator, e.g. case insensitive LIKE.</p>
<p>In a column context, produces an expression either of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lower</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">LIKE</span> <span class="n">lower</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></pre></div>
</div>
<p>Or on backends that support the ILIKE operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">ILIKE</span> <span class="n">other</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">ilike</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2">oobar%&quot;</span><span class="p">))</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.ilike.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.ilike.params.other">¶</a> -- expression to be compared</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.ilike.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.ilike.params.escape">¶</a> -- <p>optional escape character, renders the <code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code>
keyword, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">ilike</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.in_">
<code class="descname">in_</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.in_" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">in_()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">in</span></code> operator.</p>
<p>In a column context, produces the clause <code class="docutils literal notranslate"><span class="pre">column</span> <span class="pre">IN</span> <span class="pre">&lt;other&gt;</span></code>.</p>
<p>The given parameter <code class="docutils literal notranslate"><span class="pre">other</span></code> may be:</p>
<ul>
<li><p class="first">A list of literal values, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span></pre></div>
</div>
<p>In this calling form, the list of items is converted to a set of
bound parameters the same length as the list given:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>WHERE COL IN (?, ?, ?)</pre></div>
</div>
</li>
<li><p class="first">An empty list, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">in_</span><span class="p">([]))</span></pre></div>
</div>
<p>In this calling form, the expression renders a &quot;false&quot; expression,
e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WHERE</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">1</span></pre></div>
</div>
<p>This &quot;false&quot; expression has historically had different behaviors
in older SQLAlchemy versions, see
<a class="reference internal" href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.empty_in_strategy</span></code></a> for behavioral options.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2 で変更: </span>simplified the behavior of &quot;empty in&quot;
expressions</p>
</div>
</li>
<li><p class="first">A bound parameter, e.g. <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a>, may be used if it
includes the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam.params.expanding" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">bindparam.expanding</span></code></a> flag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">expanding</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span></pre></div>
</div>
<p>In this calling form, the expression renders a special non-SQL
placeholder expression that looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WHERE</span> <span class="n">COL</span> <span class="n">IN</span> <span class="p">([</span><span class="n">EXPANDING_value</span><span class="p">])</span></pre></div>
</div>
<p>This placeholder expression is intercepted at statement execution
time to be converted into the variable number of bound parameter
form illustrated earlier.   If the statement were executed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span></pre></div>
</div>
<p>The database would be passed a bound parameter for each value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>WHERE COL IN (?, ?, ?)</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加: </span>added &quot;expanding&quot; bound parameters</p>
</div>
<p>If an empty list is passed, a special &quot;empty list&quot; expression,
which is specific to the database in use, is rendered.  On
SQLite this would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WHERE</span> <span class="n">COL</span> <span class="n">IN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="mi">1</span> <span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="mi">1</span><span class="p">)</span> <span class="n">WHERE</span> <span class="mi">1</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.3 で追加: </span>&quot;expanding&quot; bound parameters now support
empty lists</p>
</div>
</li>
<li><p class="first">a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct, which is usually a correlated
scalar select:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">column</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span>
        <span class="n">select</span><span class="p">([</span><span class="n">othertable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">])</span><span class="o">.</span>
        <span class="n">where</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">othertable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>In this calling form, <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a> renders as given:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WHERE</span> <span class="n">COL</span> <span class="n">IN</span> <span class="p">(</span><span class="n">SELECT</span> <span class="n">othertable</span><span class="o">.</span><span class="n">y</span>
<span class="n">FROM</span> <span class="n">othertable</span> <span class="n">WHERE</span> <span class="n">othertable</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.in_.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.in_.params.other">¶</a> -- a list of literals, a <a class="reference internal" href="selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct,
or a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-func docutils literal notranslate"><span class="pre">bindparam()</span></code></a> construct that includes the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.bindparam.params.expanding" title="sqlalchemy.sql.expression.bindparam"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">bindparam.expanding</span></code></a> flag set to True.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.is_">
<code class="descname">is_</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.is_" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.is_" title="sqlalchemy.sql.operators.ColumnOperators.is_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">IS</span></code> operator.</p>
<p>Normally, <code class="docutils literal notranslate"><span class="pre">IS</span></code> is generated automatically when comparing to a
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>, which resolves to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  However, explicit
usage of <code class="docutils literal notranslate"><span class="pre">IS</span></code> may be desirable if comparing to boolean values
on certain platforms.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.9 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.isnot" title="sqlalchemy.sql.operators.ColumnOperators.isnot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.isnot()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.is_distinct_from">
<code class="descname">is_distinct_from</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.is_distinct_from" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.is_distinct_from" title="sqlalchemy.sql.operators.ColumnOperators.is_distinct_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_distinct_from()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">DISTINCT</span> <span class="pre">FROM</span></code> operator.</p>
<p>Renders &quot;a IS DISTINCT FROM b&quot; on most platforms;
on some such as SQLite may render &quot;a IS NOT b&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.isnot">
<code class="descname">isnot</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.isnot" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.isnot" title="sqlalchemy.sql.operators.ColumnOperators.isnot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isnot()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span></code> operator.</p>
<p>Normally, <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span></code> is generated automatically when comparing to a
value of <code class="docutils literal notranslate"><span class="pre">None</span></code>, which resolves to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  However, explicit
usage of <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span></code> may be desirable if comparing to boolean values
on certain platforms.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.9 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.is_" title="sqlalchemy.sql.operators.ColumnOperators.is_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.is_()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.isnot_distinct_from">
<code class="descname">isnot_distinct_from</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.isnot_distinct_from" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.isnot_distinct_from" title="sqlalchemy.sql.operators.ColumnOperators.isnot_distinct_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isnot_distinct_from()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">DISTINCT</span> <span class="pre">FROM</span></code> operator.</p>
<p>Renders &quot;a IS NOT DISTINCT FROM b&quot; on most platforms;
on some such as SQLite may render &quot;a IS b&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.like">
<code class="descname">like</code><span class="sig-paren">(</span><em>other</em>, <em>escape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.like" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">like()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">like</span></code> operator.</p>
<p>In a column context, produces the expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">LIKE</span> <span class="n">other</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2">oobar%&quot;</span><span class="p">))</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.like.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.like.params.other">¶</a> -- expression to be compared</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.like.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.like.params.escape">¶</a> -- <p>optional escape character, renders the <code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code>
keyword, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">)</span></pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.ilike()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.match" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match" title="sqlalchemy.sql.operators.ColumnOperators.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implements a database-specific 'match' operator.</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match" title="sqlalchemy.sql.operators.ColumnOperators.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> attempts to resolve to
a MATCH-like function or operator provided by the backend.
Examples include:</p>
<ul class="simple">
<li>PostgreSQL - renders <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&#64;&#64;</span> <span class="pre">to_tsquery(y)</span></code></li>
<li>MySQL - renders <code class="docutils literal notranslate"><span class="pre">MATCH</span> <span class="pre">(x)</span> <span class="pre">AGAINST</span> <span class="pre">(y</span> <span class="pre">IN</span> <span class="pre">BOOLEAN</span> <span class="pre">MODE)</span></code></li>
<li>Oracle - renders <code class="docutils literal notranslate"><span class="pre">CONTAINS(x,</span> <span class="pre">y)</span></code></li>
<li>other backends may provide special implementations.</li>
<li>Backends without any special implementation will emit
the operator as &quot;MATCH&quot;.  This is compatible with SQlite, for
example.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.notilike">
<code class="descname">notilike</code><span class="sig-paren">(</span><em>other</em>, <em>escape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.notilike" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notilike" title="sqlalchemy.sql.operators.ColumnOperators.notilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notilike()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>implement the <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">ILIKE</span></code> operator.</p>
<p>This is equivalent to using negation with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.ilike()</span></code></a>, i.e. <code class="docutils literal notranslate"><span class="pre">~x.ilike(y)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.ilike" title="sqlalchemy.sql.operators.ColumnOperators.ilike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.ilike()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.notin_">
<code class="descname">notin_</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.notin_" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notin_" title="sqlalchemy.sql.operators.ColumnOperators.notin_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notin_()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>implement the <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">IN</span></code> operator.</p>
<p>This is equivalent to using negation with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a>, i.e. <code class="docutils literal notranslate"><span class="pre">~x.in_(y)</span></code>.</p>
<p>In the case that <code class="docutils literal notranslate"><span class="pre">other</span></code> is an empty sequence, the compiler
produces an &quot;empty not in&quot; expression.   This defaults to the
expression &quot;1 = 1&quot; to produce true in all cases.  The
<a class="reference internal" href="engines.html#sqlalchemy.create_engine.params.empty_in_strategy" title="sqlalchemy.create_engine"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">create_engine.empty_in_strategy</span></code></a> may be used to
alter this behavior.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2 で変更: </span>The <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a> and
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notin_" title="sqlalchemy.sql.operators.ColumnOperators.notin_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.notin_()</span></code></a> operators
now produce a &quot;static&quot; expression for an empty IN sequence
by default.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_" title="sqlalchemy.sql.operators.ColumnOperators.in_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.in_()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.notlike">
<code class="descname">notlike</code><span class="sig-paren">(</span><em>other</em>, <em>escape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.notlike" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notlike" title="sqlalchemy.sql.operators.ColumnOperators.notlike"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notlike()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>implement the <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">LIKE</span></code> operator.</p>
<p>This is equivalent to using negation with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a>, i.e. <code class="docutils literal notranslate"><span class="pre">~x.like(y)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.nullsfirst">
<code class="descname">nullsfirst</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.nullsfirst" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.nullsfirst" title="sqlalchemy.sql.operators.ColumnOperators.nullsfirst"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nullsfirst()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.nullsfirst" title="sqlalchemy.sql.expression.nullsfirst"><code class="xref py py-func docutils literal notranslate"><span class="pre">nullsfirst()</span></code></a> clause against the
parent object.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.nullslast">
<code class="descname">nullslast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.nullslast" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.nullslast" title="sqlalchemy.sql.operators.ColumnOperators.nullslast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nullslast()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Produce a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.nullslast" title="sqlalchemy.sql.expression.nullslast"><code class="xref py py-func docutils literal notranslate"><span class="pre">nullslast()</span></code></a> clause against the
parent object.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.op">
<code class="descname">op</code><span class="sig-paren">(</span><em>opstring</em>, <em>precedence=0</em>, <em>is_comparison=False</em>, <em>return_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.op" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators" title="sqlalchemy.sql.operators.Operators"><code class="xref py py-class docutils literal notranslate"><span class="pre">Operators</span></code></a></div>
<p>produce a generic operator function.</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>produces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="o">*</span> <span class="mi">5</span></pre></div>
</div>
<p>This function can also be used to make bitwise operators explicit. For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)(</span><span class="mh">0xff</span><span class="p">)</span></pre></div>
</div>
<p>is a bitwise AND of the value in <code class="docutils literal notranslate"><span class="pre">somecolumn</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.op.params.operator"></span><strong>operator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.op.params.operator">¶</a> -- a string which will be output as the infix operator
between this element and the expression passed to the
generated function.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.op.params.precedence"></span><strong>precedence</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.op.params.precedence">¶</a> -- <p>precedence to apply to the operator, when
parenthesizing expressions.  A lower number will cause the expression
to be parenthesized when applied against another operator with
higher precedence.  The default value of <code class="docutils literal notranslate"><span class="pre">0</span></code> is lower than all
operators except for the comma (<code class="docutils literal notranslate"><span class="pre">,</span></code>) and <code class="docutils literal notranslate"><span class="pre">AS</span></code> operators.
A value of 100 will be higher or equal to all operators, and -100
will be lower than or equal to all operators.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加: </span>- added the 'precedence' argument.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.op.params.is_comparison"></span><strong>is_comparison</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.op.params.is_comparison">¶</a> -- <p>if True, the operator will be considered as a
&quot;comparison&quot; operator, that is which evaluates to a boolean
true/false value, like <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, etc.  This flag should be set
so that ORM relationships can establish that the operator is a
comparison operator when used in a custom join condition.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.2 で追加: </span>- added the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op.params.is_comparison" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.is_comparison</span></code></a> flag.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.op.params.return_type"></span><strong>return_type</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.op.params.return_type">¶</a> -- <p>a <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> class or object that will
force the return type of an expression produced by this operator
to be of that type.   By default, operators that specify
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op.params.is_comparison" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.is_comparison</span></code></a> will resolve to
<a class="reference internal" href="type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code></a>, and those that do not will be of the same
type as the left-hand operand.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2.0b3 で追加: </span>- added the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.Operators.op.params.return_type" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.return_type</span></code></a> argument.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="#types-operators"><span class="std std-ref">新しい演算子の再定義と作成</span></a></p>
<p class="last"><a class="reference internal" href="../orm/join_conditions.html#relationship-custom-operator"><span class="std std-ref">結合条件でカスタム演算子を使用する</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.operate">
<code class="descname">operate</code><span class="sig-paren">(</span><em>op</em>, <em>*other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.operate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Operate on an argument.</p>
<p>This is the lowest level of operation, raises
<code class="xref py py-class docutils literal notranslate"><span class="pre">NotImplementedError</span></code> by default.</p>
<p>Overriding this on a subclass can allow common
behavior to be applied to all operations.
For example, overriding <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a>
to apply <code class="docutils literal notranslate"><span class="pre">func.lower()</span></code> to the left and right
side:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyComparator</span><span class="p">(</span><span class="n">ColumnOperators</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.operate.params.op"></span><strong>op</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.operate.params.op">¶</a> -- Operator callable.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.operate.params.*other"></span><strong>*other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.operate.params.*other">¶</a> -- the 'other' side of the operation. Will
be a single scalar for most operations.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.operate.params.**kwargs"></span><strong>**kwargs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.operate.params.**kwargs">¶</a> -- modifiers.  These may be passed by special
operators such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.contains()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.reverse_operate">
<code class="descname">reverse_operate</code><span class="sig-paren">(</span><em>op</em>, <em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.reverse_operate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Reverse operate on an argument.</p>
<p>Usage is the same as <a class="reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.operate" title="sqlalchemy.types.TypeDecorator.Comparator.operate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">operate()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.Comparator.startswith">
<code class="descname">startswith</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.Comparator.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code></a> <em>method of</em> <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators" title="sqlalchemy.sql.operators.ColumnOperators"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnOperators</span></code></a></div>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">startswith</span></code> operator.</p>
<p>Produces a LIKE expression that tests against a match for the start
of a string value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">column</span> <span class="n">LIKE</span> <span class="o">&lt;</span><span class="n">other</span><span class="o">&gt;</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">sometable</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">where</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">))</span></pre></div>
</div>
<p>Since the operator uses <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, wildcard characters
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> that are present inside the &lt;other&gt; expression
will behave like wildcards as well.   For literal string
values, the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.autoescape</span></code></a> flag
may be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to apply escaping to occurences of these
characters within the string value so that they match as themselves
and not as wildcard characters.  Alternatively, the
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.escape</span></code></a> parameter will establish
a given character as an escape character which can be of use when
the target expression is not a literal string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.startswith.params.other"></span><strong>other</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.startswith.params.other">¶</a> -- expression to be compared.   This is usually a plain
string value, but can also be an arbitrary SQL expression.  LIKE
wildcard characters <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> are not escaped by default unless
the <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.autoescape</span></code></a> flag is
set to True.</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.startswith.params.autoescape"></span><strong>autoescape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.startswith.params.autoescape">¶</a> -- <p>boolean; when True, establishes an escape character
within the LIKE expression, then applies it to all occurrences of
<code class="docutils literal notranslate"><span class="pre">&quot;%&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;_&quot;</span></code> and the escape character itself within the
comparison value, which is assumed to be a literal string and not a
SQL expression.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;foo%bar&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;/&#39;</span></pre></div>
</div>
<p>With the value of :param as <code class="docutils literal notranslate"><span class="pre">&quot;foo/%bar&quot;</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.2.0 で変更: </span>The
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.autoescape</span></code></a> parameter is
 now a simple boolean rather than a character; the escape
 character itself is also escaped, and defaults to a forwards
 slash, which itself can be customized using the
 <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.escape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.escape</span></code></a> parameter.</p>
</div>
</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.Comparator.startswith.params.escape"></span><strong>escape</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.Comparator.startswith.params.escape">¶</a> -- <p>a character which when given will render with the
<code class="docutils literal notranslate"><span class="pre">ESCAPE</span></code> keyword to establish that character as the escape
character.  This character can then be placed preceding occurrences
of <code class="docutils literal notranslate"><span class="pre">%</span></code> and <code class="docutils literal notranslate"><span class="pre">_</span></code> to allow them to act as themselves and not
wildcard characters.</p>
<p>An expression such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;foo/%bar&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">)</span></pre></div>
</div>
<p>Will render as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span> <span class="n">LIKE</span> <span class="p">:</span><span class="n">param</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span> <span class="n">ESCAPE</span> <span class="s1">&#39;^&#39;</span></pre></div>
</div>
<p>The parameter may also be combined with
<a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.startswith.params.autoescape" title="sqlalchemy.sql.operators.ColumnOperators.startswith"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ColumnOperators.startswith.autoescape</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;foo%bar^bat&quot;</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">autoescape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>Where above, the given literal parameter will be converted to
<code class="docutils literal notranslate"><span class="pre">&quot;foo^%bar^^bat&quot;</span></code> before being passed to the database.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.endswith" title="sqlalchemy.sql.operators.ColumnOperators.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.endswith()</span></code></a></p>
<p><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.contains" title="sqlalchemy.sql.operators.ColumnOperators.contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.contains()</span></code></a></p>
<p class="last"><a class="reference internal" href="sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like" title="sqlalchemy.sql.operators.ColumnOperators.like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnOperators.like()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__eq__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#sqlalchemy.types.TypeDecorator" title="sqlalchemy.types.TypeDecorator"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeDecorator</span></code></a>.</p>
<p>Arguments sent here are passed to the constructor
of the class assigned to the <code class="docutils literal notranslate"><span class="pre">impl</span></code> class level attribute,
assuming the <code class="docutils literal notranslate"><span class="pre">impl</span></code> is a callable, and the resulting
object is assigned to the <code class="docutils literal notranslate"><span class="pre">self.impl</span></code> instance attribute
(thus overriding the class attribute of the same name).</p>
<p>If the class level <code class="docutils literal notranslate"><span class="pre">impl</span></code> is not a callable (the unusual case),
it will be assigned to the same instance attribute 'as-is',
ignoring those arguments passed to the constructor.</p>
<p>Subclasses can override this to customize the generation
of <code class="docutils literal notranslate"><span class="pre">self.impl</span></code> entirely.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__le__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__lt__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__ne__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.adapt">
<code class="descname">adapt</code><span class="sig-paren">(</span><em>cls</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.adapt" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.adapt" title="sqlalchemy.types.TypeEngine.adapt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adapt()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>この型の&amp;quot;適合&amp;quot;形式を生成する。&amp;quot;impl &amp;quot;クラスで動作する。</p>
<p>このメソッドは、ジェネリック型を特定の方言に固有の&amp;quot;実装&amp;quot;型に関連付けるために内部的に使用されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.bind_expression">
<code class="descname">bind_expression</code><span class="sig-paren">(</span><em>bindparam</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.bind_expression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&quot;Given a bind value (i.e. a <a class="reference internal" href="sqlelement.html#sqlalchemy.sql.expression.BindParameter" title="sqlalchemy.sql.expression.BindParameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BindParameter</span></code></a> instance),
return a SQL expression in its place.</p>
<p>This is typically a SQL function that wraps the existing bound
parameter within the statement.  It is used for special data types
that require literals being wrapped in some special database function
in order to coerce an application-level value into a database-specific
format.  It is the SQL analogue of the
<a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.bind_processor" title="sqlalchemy.types.TypeEngine.bind_processor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.bind_processor()</span></code></a> method.</p>
<p>The method is evaluated at statement compile time, as opposed
to statement construction time.</p>
<p>Note that this method, when implemented, should always return
the exact same structure, without any conditional logic, as it
may be used in an executemany() call against an arbitrary number
of bound parameter sets.</p>
<p>参照：</p>
<p><a class="reference internal" href="#types-sql-value-processing"><span class="std std-ref">SQLレベルのバインド/結果処理の適用</span></a></p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.bind_processor">
<code class="descname">bind_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.bind_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`のためのバウンド値処理関数を提供します。</p>
<p>これは、バウンド値変換のための：class： <cite>.TypeEngine`契約を満たすメソッドです。 ：class： `.TypeDecorator`は：meth：</cite> process_bind_param`のユーザ定義の実装をここでラップします。</p>
<p>ユーザ定義コードはこのメソッドを直接オーバーライドすることができますが、 `` self.impl``で提供される処理が維持されるようにmeth： <a href="#id1"><span class="problematic" id="id2">`</span></a>process_bind_param`を使用するのが最善です。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.TypeDecorator.bind_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.bind_processor.params.dialect">¶</a> -- 使用中の方言インスタンス。</td>
</tr>
</tbody>
</table>
<p>このメソッドは、このクラスの：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>result_processor`メソッドと逆の対応です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.coerce_compared_value">
<code class="descname">coerce_compared_value</code><span class="sig-paren">(</span><em>op</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.coerce_compared_value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>式で「強制的」なPython値の型を推薦する。</p>
<p>デフォルトでは、selfを返します。このメソッドは、この型を使用するオブジェクトが、式の左辺または右辺に、まだSQLAlchemy型が割り当てられていないプレーンなPythonオブジェクトに対して、式システムによって呼び出されます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">somecolumn</span> <span class="o">+</span> <span class="mi">35</span></pre></div>
</div>
<p>上記の場合、 `` somecolumn``がこの型を使用する場合、このメソッドは値 `` operator.add``と `` 35``で呼び出されます。戻り値は、この特定の操作に対して `` 35``に使用されるSQLAlchemy型が何であれです。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.coerce_to_is_types">
<code class="descname">coerce_to_is_types</code><em class="property"> = (&lt;class 'NoneType'&gt;,)</em><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.coerce_to_is_types" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>式レベルで&amp;quot;ISに強制されるべきPython型を指定する&lt;constant&gt; `` == <a href="#id1"><span class="problematic" id="id2">``</span></a>を使用して比較した場合（および <a href="#id3"><span class="problematic" id="id4">``</span></a>！= <a href="#id5"><span class="problematic" id="id6">``</span></a>と組み合わせて `` IS NOT &amp;#39;&amp;#39;と同じ場合）</p>
<p>ほとんどのSQLAlchemy型では、 `` NoneType``と `` bool``があります。</p>
<p>：class： <cite>.TypeDecorator`は、ブール型を扱うtypedecoratorの実装が一般的なので、このリストを</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>NoneType``だけを含むように変更します。</p>
<p>カスタム：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`クラスは、この属性をオーバーライドして空のタプルを返すことができます。その場合、値は定数に強制されません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8.2 で追加: </span>追加された：attr： <cite>.TypeDecorator.coerce_to_is_types`は、</cite> <cite>__eq __（）</cite> `` <cite>__ne __（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>操作を簡単に制御できるようにしました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.column_expression">
<code class="descname">column_expression</code><span class="sig-paren">(</span><em>column</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.column_expression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Given a SELECT column expression, return a wrapping SQL expression.</p>
<p>This is typically a SQL function that wraps a column expression
as rendered in the columns clause of a SELECT statement.
It is used for special data types that require
columns to be wrapped in some special database function in order
to coerce the value before being sent back to the application.
It is the SQL analogue of the <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.result_processor" title="sqlalchemy.types.TypeEngine.result_processor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TypeEngine.result_processor()</span></code></a>
method.</p>
<p>The method is evaluated at statement compile time, as opposed
to statement construction time.</p>
<p>参照：</p>
<p><a class="reference internal" href="#types-sql-value-processing"><span class="std std-ref">SQLレベルのバインド/結果処理の適用</span></a></p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.comparator_factory">
<code class="descname">comparator_factory</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.comparator_factory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Base class for custom comparison operations defined at the
type level.  See <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.comparator_factory" title="sqlalchemy.types.TypeEngine.comparator_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TypeEngine.comparator_factory</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.compare_against_backend">
<code class="descname">compare_against_backend</code><span class="sig-paren">(</span><em>dialect</em>, <em>conn_type</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.compare_against_backend" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.compare_against_backend" title="sqlalchemy.types.TypeEngine.compare_against_backend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_against_backend()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>このタイプを指定されたバックエンドタイプと比較してください。</p>
<p>この関数は現在SQLAlchemy型では実装されていません。組み込み型では `` None``が返されます。ただし、Alembicの自動生成などのスキーマ比較ツールで使用できるユーザー定義型で実装できます。</p>
<p>SQLAlchemyの今後のリリースでは、組み込み型に対してもこのメソッドを実装する可能性があります。</p>
<p>この型が指定された型と等しい場合、この関数はTrueを返さなければなりません。型は通常データベースから反映されるため、データベース固有である必要があります。使用中の方言も渡されます。また、型が等価でないことを宣言するためにFalseを返すこともできます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.compare_against_backend.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.compare_against_backend.params.dialect">¶</a> -- a：class：比較に含まれる <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`です。</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.compare_against_backend.params.conn_type"></span><strong>conn_type</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.compare_against_backend.params.conn_type">¶</a> -- バックエンドから反映された型オブジェクト</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.compare_values">
<code class="descname">compare_values</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.compare_values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つの値が与えられたら、それらの値を比較し</p>
<p>デフォルトでは、この関数は、基礎となる&amp;quot;impl &amp;quot;の：meth： <cite>.TypeEngine.compare_values`を呼び出します。これは通常、Python equals演算子</cite> <cite>==</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を使用します。</p>
<p>この関数はORMによって元の読み込み値とインターセプトされた&amp;quot;変更された値&amp;quot;を比較して、正味の変更が発生したかどうかを判断するために使用されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>dialect=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.compile" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.compile" title="sqlalchemy.types.TypeEngine.compile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compile()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeEngine`の文字列でコンパイルされた形式を生成します。</p>
<p>引数なしで呼び出された場合、&amp;quot;default &amp;quot;という方言を使用して文字列の結果を生成します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.types.TypeDecorator.compile.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.compile.params.dialect">¶</a> -- a：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`インスタンスです。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`インスタンスのコピーを作成します。</p>
<p>これは浅いコピーで、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeEngine`契約の一部を満たすために提供されています。これは通常、ユーザ定義の：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.TypeDecorator`がディープコピーされるべきローカル状態を持たない限り、オーバーライドする必要はありません。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.dialect_impl">
<code class="descname">dialect_impl</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.dialect_impl" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.dialect_impl" title="sqlalchemy.types.TypeEngine.dialect_impl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dialect_impl()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>このために、方言固有の実装を返します：class： <cite>.TypeEngine</cite>。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.evaluates_none">
<code class="descname">evaluates_none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.evaluates_none" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.evaluates_none" title="sqlalchemy.types.TypeEngine.evaluates_none"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evaluates_none()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.should_evaluate_none`フラグがTrueに設定されているこのタイプのコピーを返します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;some_table&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span>
        <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">evaluates_none</span><span class="p">(),</span>
        <span class="n">nullable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">server_default</span><span class="o">=</span><span class="s1">&#39;no value&#39;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>ORMは、このフラグを使用して、列レベルのデフォルトを起動する効果を持つINSERT文から列を省略するのではなく、INSERT文の列に `` None``の正の値が渡されることを示します。また、PythonのNone値に関連付けられた特別な動作を持つ型で、値が必ずしもSQL NULLに変換されないことを示すことができます。 JSON値 `` &amp;#39;null&amp;#39;``を永続化したいJSON型です。</p>
<p>いずれの場合でも、実際のNULL SQL値は、INSERT文の中で：obj： <cite>〜.expression.null</cite> SQL構文を使用するか、ORMでマップされた属性に関連付けて、いつでも任意の列に永続化することができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">&amp;quot;evaulates none &amp;quot;フラグは、paramref： <cite>.Column.default`または：paramref：</cite> .Column.server_default`;に渡される `` None``の値には適用されません。これらの場合、 `` None``は&amp;quot;no default &amp;quot;を意味します。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>session_forcing_null</cite>  -  ORMのドキュメント</p>
<p>：paramref： <cite>.postgresql.JSON.none_as_null</cite>  -  PostgreSQL JSONはこのフラグと対話します。</p>
<p class="last">：attr： <cite>.TypeEngine.should_evaluate_none</cite>  - クラスレベルのフラグ</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.get_dbapi_type">
<code class="descname">get_dbapi_type</code><span class="sig-paren">(</span><em>dbapi</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.get_dbapi_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`で表されるDBAPI型オブジェクトを返します。</p>
<p>デフォルトでは、これは、基礎となる&amp;quot;impl &amp;quot;の：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeEngine.get_dbapi_type`を呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.literal_processor">
<code class="descname">literal_processor</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.literal_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`にリテラル処理関数を提供します。</p>
<p>ここでのサブクラスは、通常、このメソッドの代わりに：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator.process_literal_param`をオーバーライドします。</p>
<p>デフォルトでは、このメソッドは、：meth： <cite>.TypeDecorator.process_literal_param`がそうでない場合、そのメソッドが実装されている場合は：meth：</cite> .TypeDecorator.process_bind_param`を使用します。ここでの理論的根拠は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`は、典型的には、データベースプレゼンテーションのレイヤーの上にあるデータのPython変換を扱います。値は：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.TypeDecorator.process_bind_param`で変換され、基底型はバインドされたパラメータとしてDBAPIに渡す必要があるのか​​、インラインSQL値としてデータベースに渡す必要があるのか​​を処理します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.load_dialect_impl">
<code class="descname">load_dialect_impl</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.load_dialect_impl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>方言に対応するa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeEngine`オブジェクトを返します。</p>
<p>これは、指定された方言に応じて異なる型を提供するために使用できるエンドユーザオーバーライドフックです。これは：meth： <cite>type_engine`の：class：</cite> .TypeDecorator`実装によって使用され、与えられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`に対して最終的にどの型を返すべきかを判断するのに役立ちます。</p>
<p>デフォルトで `` self.impl``を返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.process_bind_param">
<code class="descname">process_bind_param</code><span class="sig-paren">(</span><em>value</em>, <em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.process_bind_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>変換するバインドされたパラメータ値を受け取ります。</p>
<p>サブクラスはこのメソッドをオーバーライドして渡されるべき値を基礎クラス：class： <cite>.TypeEngine`オブジェクトに返し、そこからDBAPI</cite> <cite>execute（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>メソッドに返します。</p>
<p>操作は、データの変換やシリアル化など、カスタム動作を実行するために必要なものであれば何でもかまいません。これは、ロジックを検証するためのフックとしても使用できます。</p>
<p>この操作は、このクラスのprocess_result_valueメソッドである逆の操作を念頭に置いて設計する必要があります。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.process_bind_param.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.process_bind_param.params.value">¶</a> -- サブクラスでこのメソッドによって予期される任意の型の操作対象のデータ。 「なし」にすることができます。</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.process_bind_param.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.process_bind_param.params.dialect">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`が使用中です。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.process_literal_param">
<code class="descname">process_literal_param</code><span class="sig-paren">(</span><em>value</em>, <em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.process_literal_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ステートメント内でインラインでレンダリングされるリテラルパラメータ値を受け取ります。</p>
<p>このメソッドは、コンパイラーがバインドを使用しないリテラル値（通常は列の「サーバーのデフォルト」またはCHECK制約内の式）のDDL内でレンダリングする場合に使用されます。</p>
<p>返された文字列は出力文字列にレンダリングされます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.process_result_value">
<code class="descname">process_result_value</code><span class="sig-paren">(</span><em>value</em>, <em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.process_result_value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>変換される結果行の列値を受け取ります。</p>
<p>サブクラスは、このメソッドを実装して、データベースからフェッチされたデータを処理する必要があります。</p>
<p>元々DBAPIカーソルメソッドの `` fetchone（） <a href="#id1"><span class="problematic" id="id2">``</span></a>または `` fetchone（） <a href="#id3"><span class="problematic" id="id4">``</span></a>の元のclass： <a href="#id5"><span class="problematic" id="id6">`</span></a>.TypeEngine`オブジェクトによってすでに処理されている値を与えられた場合、サブクラスはこのメソッドをオーバーライドしてアプリケーションに返すべき値を返します。類似。</p>
<p>操作は、データの変換やシリアル化など、カスタム動作を実行するために必要なものであれば何でもかまいません。これは、ロジックを検証するためのフックとしても使用できます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.process_result_value.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.process_result_value.params.value">¶</a> -- サブクラスでこのメソッドによって予期される任意の型の操作対象のデータ。 「なし」にすることができます。</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.process_result_value.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.process_result_value.params.dialect">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`が使用中です。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>この操作は、このクラスの&amp;quot;process_bind_param &amp;quot;メソッドで元に戻せるように設計する必要があります。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.TypeDecorator.python_type">
<code class="descname">python_type</code><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.python_type" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.python_type" title="sqlalchemy.types.TypeEngine.python_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">python_type</span></code></a> <em>attribute of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>既知の場合、この型のインスタンスによって返されると予想されるPython型オブジェクトを返します。</p>
<p>基本的には、戻り値の型を強制する型や、一般的なDBAPI（例えば `` int``など）のために全面的に知られている型の場合、その型を返します。</p>
<p>戻り値の型が定義されていない場合、 `` NotImplementedError``が送出されます。</p>
<p>どんな型もSQLにNULLを格納することに注意してください。つまり、実際にはどの型からでも `` None``を返すことができます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.result_processor">
<code class="descname">result_processor</code><span class="sig-paren">(</span><em>dialect</em>, <em>coltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.result_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`に対して結果値処理関数を提供します。</p>
<p>これは、結果値変換のための：class： <cite>.TypeEngine`契約を満たすメソッドです。 ：class： `.TypeDecorator`は：meth：</cite> process_result_value`のユーザ定義の実装をここでラップします。</p>
<p>ユーザ定義コードはこのメソッドを直接オーバーライドすることができますが、 `` self.impl &amp;#39;&amp;#39;によって提供される処理が維持されるようにmeth： <a href="#id1"><span class="problematic" id="id2">`</span></a>process_result_value`を使用するのが最善です。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.result_processor.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.result_processor.params.dialect">¶</a> -- 使用中の方言インスタンス。</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.result_processor.params.coltype"></span><strong>coltype</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.result_processor.params.coltype">¶</a> -- SQLAlchemyデータ型</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>このメソッドは、このクラスの：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>bind_processor`メソッドと逆の対応です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.type_engine">
<code class="descname">type_engine</code><span class="sig-paren">(</span><em>dialect</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.type_engine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Dialect特有の：class： <cite>.TypeEngine`インスタンスを返します：class：</cite> .TypeDecorator`。</p>
<p>ほとんどの場合、これは `` self.impl``で表される：class： <cite>.TypeEngine`型のダイアレクトに適合した形式を返します。 ：meth： `dialect_impl`の使用を行いますが、wrapped：class：</cite> .TypeDecorator`インスタンスにも移動します。ここでの動作は、meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>load_dialect_impl`をオーバーライドすることでカスタマイズできます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.TypeDecorator.with_variant">
<code class="descname">with_variant</code><span class="sig-paren">(</span><em>type_</em>, <em>dialect_name</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.TypeDecorator.with_variant" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine.with_variant" title="sqlalchemy.types.TypeEngine.with_variant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">with_variant()</span></code></a> <em>method of</em> <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a></div>
<p>与えられた名前の方言に適用されたときに、与えられた型を利用する新しい型オブジェクトを生成する。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">String</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">mysql</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">with_variant</span><span class="p">(</span><span class="n">mysql</span><span class="o">.</span><span class="n">VARCHAR</span><span class="p">(</span><span class="n">collation</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="s1">&#39;mysql&#39;</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.TypeEngine.with_variant`の構成は、常に「フォールバック」型から、方言固有の型へと変わります。返される型は：class： `.Variant`のインスタンスであり、それ自身が：meth：</cite> .Variant.with_variant`を繰り返し提供することができます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.types.TypeDecorator.with_variant.params.type_"></span><strong>type_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.with_variant.params.type_">¶</a> -- a：class： <cite>.TypeEngine</cite>。指定された名前の方言が使用されているときに、元の型からバリアントとして選択されます。</li>
<li><span class="target" id="sqlalchemy.types.TypeDecorator.with_variant.params.dialect_name"></span><strong>dialect_name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.types.TypeDecorator.with_variant.params.dialect_name">¶</a> -- この型を使用する方言の基底名。 （つまり、 `` &amp;#39;postgresql``、 <a href="#id1"><span class="problematic" id="id2">``</span></a>&amp;#39; mysql&amp;#39;``など）</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.2 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="typedecorator-recipes">
<h2>TypeDecoratorのレシピ<a class="headerlink" href="#typedecorator-recipes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかのキー：クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`レシピが続きます。</p>
<div class="section" id="coercing-encoded-strings-to-unicode">
<span id="coerce-to-unicode"></span><h3>エンコードされた文字列をUnicodeに変換する<a class="headerlink" href="#coercing-encoded-strings-to-unicode" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <cite>.Unicode`型に関するよくある混乱の原因は、Python側でPythonの</cite> <cite>unicode``オブジェクトを扱うことのみを意図しているということです。 Python 2ではなく3を使用している場合は `</cite> u&amp;#39;some string&amp;#39;``を作成します。これが実行するエンコード/デコード機能は、使用されているDBAPIに合ったもので、主にプライベートな実装の詳細です。</p>
<p>Pythonのバイナリを安全に受け取ることができるタイプのユースケース、つまり非ASCII文字を含み、Python 2の `` u&amp;#39;&amp;#39;``オブジェクトではない文字列は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`を使って実現できます。必要に応じて強制する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">TypeDecorator</span><span class="p">,</span> <span class="n">Unicode</span>

<span class="k">class</span> <span class="nc">CoerceUTF8</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Safely coerce Python bytestrings to Unicode</span>
<span class="sd">    before passing off to the database.&quot;&quot;&quot;</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">Unicode</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
</div>
<div class="section" id="rounding-numerics">
<h3>丸め数値<a class="headerlink" href="#rounding-numerics" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SQL Serverのデータベースコネクタのように、小数点以下の桁数が多いDecimalが渡された場合、一部のデータベースコネクタでは問題が発生します。それらを丸めるレシピがあります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">TypeDecorator</span><span class="p">,</span> <span class="n">Numeric</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span>

<span class="k">class</span> <span class="nc">SafeNumeric</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds quantization to Numeric.&quot;&quot;&quot;</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">Numeric</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">TypeDecorator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantize_int</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantize</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantize_int</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">value</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantize_int</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quantize</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
</div>
<div class="section" id="backend-agnostic-guid-type">
<span id="custom-guid-type"></span><h3>バックエンドに依存しないGUIDタイプ<a class="headerlink" href="#backend-agnostic-guid-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonのuuid（）オブジェクトを受け取って返します。 PostgreSQLを使用する場合はPG UUIDタイプを使用し、他のバックエンドではCHAR（32）を使用してストリング形式の16進形式で格納します。必要に応じて、バイナリをCHAR（16）に格納するように変更できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">TypeDecorator</span><span class="p">,</span> <span class="n">CHAR</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="n">UUID</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="k">class</span> <span class="nc">GUID</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Platform-independent GUID type.</span>

<span class="sd">    Uses PostgreSQL&#39;s UUID type, otherwise uses</span>
<span class="sd">    CHAR(32), storing as stringified hex values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">impl</span> <span class="o">=</span> <span class="n">CHAR</span>

    <span class="k">def</span> <span class="nf">load_dialect_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dialect</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;postgresql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dialect</span><span class="o">.</span><span class="n">type_descriptor</span><span class="p">(</span><span class="n">UUID</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dialect</span><span class="o">.</span><span class="n">type_descriptor</span><span class="p">(</span><span class="n">CHAR</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">dialect</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;postgresql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">):</span>
                <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%.32x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># hexstring</span>
                <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%.32x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">value</span><span class="o">.</span><span class="n">int</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
</div>
<div class="section" id="marshal-json-strings">
<h3>JSONストリングを整列化する<a class="headerlink" href="#marshal-json-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このタイプは `` simplejson``を使ってPythonデータ構造をJSONとの間でマーシャリングします。 Pythonの組み込みjsonエンコーダを使用するように変更することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">TypeDecorator</span><span class="p">,</span> <span class="n">VARCHAR</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">JSONEncodedDict</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an immutable structure as a json-encoded string.</span>

<span class="sd">    Usage::</span>

<span class="sd">        JSONEncodedDict(255)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">VARCHAR</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
<div class="section" id="adding-mutability">
<h4>変更可能性の追加<a class="headerlink" href="#adding-mutability" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>デフォルトでORMは上記のような型の&amp;quot;mutability &amp;quot;を検出しません。つまり、値のインプレース変更は検出されず、フラッシュされません。これ以上の手順を行わなければ、既存の値を各親オブジェクトの新しい値に置き換えて変更を検出する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">.</span><span class="n">json_value</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span>  <span class="c1"># will *not* be detected by the ORM</span>

<span class="n">obj</span><span class="o">.</span><span class="n">json_value</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">}</span>  <span class="c1"># *will* be detected by the ORM</span></pre></div>
</div>
<p>多くのアプリケーションでは、一度作成されると値が変更されることを必要としないため、上記の制限は問題ありません。この要件を持っている人にとっては、 `` sqlalchemy.ext.mutable``拡張を使ってmutabilityをサポートするのが最も効果的です。辞書指向のJSON構造については、これを:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">json_type</span> <span class="o">=</span> <span class="n">MutableDict</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1">#  ...</span>

    <span class="n">json_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">json_type</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>mutable_toplevel</cite></p>
</div>
</div>
<div class="section" id="dealing-with-comparison-operations">
<h4>比較操作の処理<a class="headerlink" href="#dealing-with-comparison-operations" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>：class： <cite>.TypeDecorator`のデフォルトの動作は、任意の式の&amp;quot;右辺&amp;quot;を同じ型に強制することです。 JSONのような型の場合、使用される演算子はすべてJSONの意味で意味を持つ必要があります。場合によっては、タイプによってはJSONのような振る舞いをすることがあります。 1つの例は、JSONタイプのLIKE演算子を処理したい場合です。 LIKEはJSON構造に対しては意味がありませんが、基礎となるテキスト表現には意味があります。これを `</cite> JSONEncodedDict``のような型で取得するには、この演算子を使用する前に：func： <cite>.cast`または：func：</cite> .type_coerce`を使用して、列をテキスト形式に変換する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">type_coerce</span><span class="p">,</span> <span class="n">String</span>

<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">my_table</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
    <span class="n">type_coerce</span><span class="p">(</span><span class="n">my_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">json_data</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1">oo%&#39;</span><span class="p">))</span></pre></div>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`は、演算子に基づいた型変換のような型変換を組み込むための組み込みシステムを提供します。文字列として解釈されるJSONオブジェクトでLIKE演算子を頻繁に使用したい場合は、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.TypeDecorator.coerce_compared_value`メソッドをオーバーライドすることにより、その型に構造体を構築できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">operators</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">String</span>

<span class="k">class</span> <span class="nc">JSONEncodedDict</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">VARCHAR</span>

    <span class="k">def</span> <span class="nf">coerce_compared_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">like_op</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">notlike_op</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">String</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
<p>上記は&amp;quot;LIKE &amp;quot;のような演算子を扱う方法の1つに過ぎません。他のアプリケーションでは、自動的にテキストに強制変換するのではなく、&amp;quot;LIKE &amp;quot;などのJSONオブジェクトで意味を持たない演算子に対して `` NotImplementedError``を発生させたいかもしれません。</p>
</div>
</div>
</div>
<div class="section" id="replacing-the-bind-result-processing-of-existing-types">
<span id="replacing-processors"></span><h2>既存の型のバインド/結果処理の置換<a class="headerlink" href="#replacing-the-bind-result-processing-of-existing-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>バインド/結果レベルでの型の振る舞いの増加は、class： <cite>.TypeDecorator`を使って実現します。 SQLAlchemyによってDBAPIレベルで適用される特定の処理を置き換える必要がある場合、SQLAlchemy型は直接サブクラス化でき、 `</cite> bind_processor（） <a href="#id1"><span class="problematic" id="id2">``</span></a>または `` result_processor（） <a href="#id3"><span class="problematic" id="id4">``</span></a>メソッドはオーバーライドできます。これを行うには、 `` adapt（） <a href="#id5"><span class="problematic" id="id6">``</span></a>メソッドもオーバーライドする必要があります。このメソッドは、SQLAlchemyがステートメント実行中にDBAPI固有の型の動作を生成するメカニズムです。これをオーバーライドすると、DBAPI固有の型の代わりにカスタム型のコピーを使用することができます。以下では、class： <cite>.types.TIME`型をサブクラス化して、カスタム結果処理の振る舞いをします。 `</cite> process（） <a href="#id7"><span class="problematic" id="id8">``</span></a>関数はDBAPIカーソルから直接 `` value``を受け取ります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySpecialTime</span><span class="p">(</span><span class="n">TIME</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">special_argument</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MySpecialTime</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_argument</span> <span class="o">=</span> <span class="n">special_argument</span>

    <span class="k">def</span> <span class="nf">result_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">coltype</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">datetime</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span>
        <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">microseconds</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">microseconds</span>
                <span class="n">seconds</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">seconds</span>
                <span class="n">minutes</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">/</span> <span class="mi">60</span>
                <span class="k">return</span> <span class="n">time</span><span class="p">(</span>
                          <span class="n">minutes</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span>
                          <span class="n">minutes</span> <span class="o">%</span> <span class="mi">60</span><span class="p">,</span>
                          <span class="n">seconds</span> <span class="o">-</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">,</span>
                          <span class="n">microseconds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">process</span>

    <span class="k">def</span> <span class="nf">adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">impltype</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MySpecialTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_argument</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="applying-sql-level-bind-result-processing">
<span id="types-sql-value-processing"></span><h2>SQLレベルのバインド/結果処理の適用<a class="headerlink" href="#applying-sql-level-bind-result-processing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyは、ref： <cite>types_typedecorator`と：ref：</cite> replaced_processors`の節で見られるように、SQLAlchemyはパラメータが文に送られたときと、結果行がデータベースからロードされたとき、変換を適用するときの両方でPython関数を呼び出すことができますデータベースへのまたはデータベースからの送信時の値に変換します。また、SQLレベルの変換も定義することができます。ここでの論理的根拠は、リレーショナルデータベースだけが、アプリケーションと永続化形式の間で送受信データを強制するのに必要な特定の一連の関数を含む場合です。例としては、データベース定義の暗号化/復号化関数、地理データを扱うストアドプロシージャの使用などがあります。 PostgreSQLへのPostGISエクステンションには、データを特定のフォーマットに強制するために必要な広範なSQL関数が含まれています。</p>
<p>任意の：class： <cite>.TypeEngine</cite>、：class：` .UserDefinedType`または：class： <cite>.TypeDecorator`サブクラスは：meth：</cite> .TypeEngine.bind_expression`や：meth： <cite>.TypeEngine.column_expression`の実装を含むことができます。 `</cite> None``以外の値を返すように定義されている場合は、：class： <cite>.ColumnElement`式を、SQLステートメントに、バインドされたパラメタを囲むか、列式のいずれかに注入する必要があります。たとえばPostGIS関数 `</cite> ST_GeomFromText``をすべての発信値に適用し、関数 `` ST_AsText``をすべての着信データに適用する `` Geometry``型を構築するには、次の独自のサブクラスを作成できます：class：これらのメソッドを提供する <cite>.UserDefinedType</cite>：data：<cite>〜.sqlalchemy.sql.expression.func</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">func</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">UserDefinedType</span>

<span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">UserDefinedType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_col_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;GEOMETRY&quot;</span>

    <span class="k">def</span> <span class="nf">bind_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindvalue</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">bindvalue</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">column_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">ST_AsText</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></pre></div>
</div>
<p>`` Geometry``型を：class： <cite>.Table`メタデータに適用し、それをa：func：</cite> .select`構造体に使用することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;geom_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;geom_data&#39;</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)</span>
            <span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">geometry</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
  <span class="n">geometry</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">geom_data</span> <span class="o">==</span> <span class="s1">&#39;LINESTRING(189412 252431,189631 259122)&#39;</span><span class="p">))</span></pre></div>
</div>
<p>結果として得られるSQLは、両方の関数を適切なものとして組み込みます。 `` ST_AsText``はcolumns節に適用され、結果セットに渡される前に戻り値が関数で実行され、渡された値が変換されるように `` ST_GeomFromText``が実行されます。 ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geom_id</span><span class="p">,</span> <span class="n">ST_AsText</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">geom_data</span><span class="p">)</span> <span class="n">AS</span> <span class="n">geom_data_1</span>
<span class="n">FROM</span> <span class="n">geometry</span>
<span class="n">WHERE</span> <span class="n">geometry</span><span class="o">.</span><span class="n">geom_data</span> <span class="o">=</span> <span class="n">ST_GeomFromText</span><span class="p">(:</span><span class="n">geom_data_2</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.TypeEngine.column_expression`メソッドは、SQL式がラップされた式のラベリングに干渉しないようにコンパイラの仕組みとやりとりします。たとえば、式の：func： `.label`に対して：func：</cite> .select`をレンダリングすると、文字列ラベルはラップされた式の外側に移動します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">geometry</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">geom_data</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;my_data&#39;</span><span class="p">)]))</span></pre></div>
</div>
<p>出力：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">ST_AsText</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">geom_data</span><span class="p">)</span> <span class="n">AS</span> <span class="n">my_data</span>
<span class="n">FROM</span> <span class="n">geometry</span></pre></div>
</div>
<p>組み込み型を直接サブクラス化する例については、class： <cite>.postgresql.BYTEA`をサブクラス化してPostgreSQLの</cite> <cite>pgcrypto``拡張を使って値を透過的に暗号化/復号化する</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>PGPString``を提供します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> \
        <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">type_coerce</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="n">BYTEA</span>

<span class="k">class</span> <span class="nc">PGPString</span><span class="p">(</span><span class="n">BYTEA</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">passphrase</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PGPString</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passphrase</span> <span class="o">=</span> <span class="n">passphrase</span>

    <span class="k">def</span> <span class="nf">bind_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindvalue</span><span class="p">):</span>
        <span class="c1"># convert the bind&#39;s type from PGPString to</span>
        <span class="c1"># String, so that it&#39;s passed to psycopg2 as is without</span>
        <span class="c1"># a dbapi.Binary wrapper</span>
        <span class="n">bindvalue</span> <span class="o">=</span> <span class="n">type_coerce</span><span class="p">(</span><span class="n">bindvalue</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">pgp_sym_encrypt</span><span class="p">(</span><span class="n">bindvalue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">passphrase</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">column_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">pgp_sym_decrypt</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">passphrase</span><span class="p">)</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">message</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span>
                    <span class="n">PGPString</span><span class="p">(</span><span class="s2">&quot;this is my passphrase&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1000</span><span class="p">)),</span>
            <span class="p">)</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql://scott:tiger@localhost/test&quot;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">username</span><span class="o">=</span><span class="s2">&quot;some user&quot;</span><span class="p">,</span>
                                <span class="n">message</span><span class="o">=</span><span class="s2">&quot;this is my message&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span>
            <span class="n">select</span><span class="p">([</span><span class="n">message</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">message</span><span class="p">])</span><span class="o">.</span>\
                <span class="n">where</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s2">&quot;some user&quot;</span><span class="p">)</span>
        <span class="p">))</span></pre></div>
</div>
<p>`` pgp_sym_encrypt``と `` pgp_sym_decrypt``関数は、INSERT文とSELECT文に適用されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">message</span> <span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
  <span class="n">VALUES</span> <span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">username</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="n">pgp_sym_encrypt</span><span class="p">(</span><span class="o">%</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="o">%</span><span class="p">(</span><span class="n">pgp_sym_encrypt_1</span><span class="p">)</span><span class="n">s</span><span class="p">))</span>
  <span class="p">{</span><span class="s1">&#39;username&#39;</span><span class="p">:</span> <span class="s1">&#39;some user&#39;</span><span class="p">,</span> <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s1">&#39;this is my message&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pgp_sym_encrypt_1&#39;</span><span class="p">:</span> <span class="s1">&#39;this is my passphrase&#39;</span><span class="p">}</span>

<span class="n">SELECT</span> <span class="n">pgp_sym_decrypt</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="o">%</span><span class="p">(</span><span class="n">pgp_sym_decrypt_1</span><span class="p">)</span><span class="n">s</span><span class="p">)</span> <span class="n">AS</span> <span class="n">message_1</span>
  <span class="n">FROM</span> <span class="n">message</span>
  <span class="n">WHERE</span> <span class="n">message</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="o">%</span><span class="p">(</span><span class="n">username_1</span><span class="p">)</span><span class="n">s</span>
  <span class="p">{</span><span class="s1">&#39;pgp_sym_decrypt_1&#39;</span><span class="p">:</span> <span class="s1">&#39;this is my passphrase&#39;</span><span class="p">,</span> <span class="s1">&#39;username_1&#39;</span><span class="p">:</span> <span class="s1">&#39;some user&#39;</span><span class="p">}</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加: </span>：meth： <cite>.TypeEngine.bind_expression`と：meth：</cite> .TypeEngine.column_expression`メソッドを追加しました。</p>
</div>
<p>参照：</p>
<p>：ref： <cite>examples_postgis</cite></p>
</div>
<div class="section" id="redefining-and-creating-new-operators">
<span id="types-operators"></span><h2>新しい演算子の再定義と作成<a class="headerlink" href="#redefining-and-creating-new-operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemy Coreは、すべての列式で使用可能な式演算子の固定セットを定義します。これらの演算の中には、Pythonに組み込まれた演算子のオーバーロードの影響があります。このような演算子の例には、meth： <cite>.ColumnOperators .__ eq__`（</cite> <cite>table.c.somecolumn == &amp;#39;foo&amp;#39;`</cite>）、：meth：` .ColumnOperators .__ invert__`（ <code class="docutils literal notranslate"><span class="pre">〜table.c.flag`</span> <span class="pre">`）、および：meth：`</span> <span class="pre">.ColumnOperators</span> <span class="pre">.__</span> <span class="pre">add__`（</span> <span class="pre">``</span> <span class="pre">table.cx</span> <span class="pre">+</span> <span class="pre">table.cy</span></code>）です。他の演算子は：meth： <cite>.ColumnOperators.in_`（</cite> <cite>table.c.value.in _（[&amp;#39;x&amp;#39;、 &amp;#39;y&amp;#39;]）</cite> <cite>）や：meth： `.ColumnOperators.like`（</cite> <cite>table.c.value.like（ &amp;#39;％ed％&amp;#39;）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>）です。</p>
<p>既存の演算子の振る舞いを決定するために、また組み込みセットの一部ではない追加の演算子を見つけるために、すべてのケースでコア式の構文が式の型を調べます。 ：class： <cite>.TypeEngine`基本クラスはルート&amp;quot;比較&amp;quot;の実装：class：</cite> .TypeEngine.Comparator`を定義し、多くの特定の型はこのクラスの独自のサブ実装を提供します。ユーザ定義：クラス： <cite>.TypeEngine.Comparator`実装は、新しい操作をオーバーライドまたは定義するために、特定の型の単純なサブクラスに直接構築できます。以下に、：meth： `.ColumnOperators .__ add__`演算子をオーバーライドする：class：</cite> .Integer`サブクラスを作成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span>

<span class="k">class</span> <span class="nc">MyInt</span><span class="p">(</span><span class="n">Integer</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">Integer</span><span class="o">.</span><span class="n">Comparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;goofy&quot;</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span></pre></div>
</div>
<p>上記の設定は新しいクラスを参照するための：attr： <cite>.TypeEngine.comparator_factory`属性を設定する新しいクラス</cite> <cite>MyInt``を作成し、：class：</cite> .TypeEngine.Comparator`クラスにサブクラス化します：class ： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Integer`型です。</p>
<p>使用法：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sometable</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;sometable&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">MyInt</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">sometable.data goofy :data_1</span></pre></div>
</div>
<p>：meth： <cite>.ColumnOperators .__ add__`の実装は：class：</cite> .TypeEngine.Comparator`を `` expr``属性としてインスタンス化することで、所有するSQL式によって参照されます。式システムの仕組みは、式オブジェクトが新しいSQL式構成を生成するまで、操作が再帰的に継続するようなものです。上の例では、 `` self.ex（&amp;quot;goofy &amp;quot;）（他） <a href="#id1"><span class="problematic" id="id2">``</span></a>の代わりに `` self.expr.op（&amp;quot;goofy &amp;quot;）</p>
<p>ブール結果を返す比較演算に：meth： <cite>.Operators.op`を使用する場合、：paramref：</cite> .Operators.op.is_comparison`フラグを `` True``に設定する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyInt</span><span class="p">(</span><span class="n">Integer</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">Integer</span><span class="o">.</span><span class="n">Comparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">is_frobnozzled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;--is_frobnozzled-&gt;&quot;</span><span class="p">,</span> <span class="n">is_comparison</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span></pre></div>
</div>
<p>class： <cite>.TypeEngine.Comparator`に追加された新しいメソッドは、所有しているSQL式で、</cite>：__getattr__``スキームを使って公開されます。 <cite>.ColumnElement</cite>。例えば、整数に `` log（） <a href="#id1"><span class="problematic" id="id2">``</span></a>関数を追加するには:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">func</span>

<span class="k">class</span> <span class="nc">MyInt</span><span class="p">(</span><span class="n">Integer</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">Integer</span><span class="o">.</span><span class="n">Comparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></pre></div>
</div>
<p>上記のタイプを使用する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sometable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">log(:log_1, :log_2)</span></pre></div>
</div>
<p>単項演算も可能です。例えば、PostgreSQL階乗演算子の実装を追加するために、：class： <cite>.UnaryExpression`構造体と：class：</cite> .custom_op`を組み合わせて階乗式を生成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.expression</span> <span class="k">import</span> <span class="n">UnaryExpression</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">operators</span>

<span class="k">class</span> <span class="nc">MyInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">Integer</span><span class="o">.</span><span class="n">Comparator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                        <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">custom_op</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span>
                        <span class="n">type_</span><span class="o">=</span><span class="n">MyInteger</span><span class="p">)</span></pre></div>
</div>
<p>上記のタイプを使用する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="k">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">column</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">MyInteger</span><span class="p">)</span><span class="o">.</span><span class="n">factorial</span><span class="p">())</span>
<span class="go">x !</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Operators.op</cite></p>
<p class="last">：attr： <cite>.TypeEngine.comparator_factory</cite></p>
</div>
</div>
<div class="section" id="creating-new-types">
<h2>新しいタイプの作成<a class="headerlink" href="#creating-new-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.UserDefinedType`クラスは、全く新しいデータベース型を定義するための単純な基本クラスとして提供されています。これを使用して、SQLAlchemyには知られていないネイティブデータベースタイプを表します。 Pythonの変換動作のみが必要な場合は、代わりに：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.TypeDecorator`を使用してください。</p>
<dl class="class">
<dt id="sqlalchemy.types.UserDefinedType">
<em class="property">class </em><code class="descclassname">sqlalchemy.types.</code><code class="descname">UserDefinedType</code><a class="headerlink" href="#sqlalchemy.types.UserDefinedType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.TypeEngine</span></code></a></p>
<p>ユーザー定義型のベース。</p>
<p>これは新しいタイプの基盤でなければなりません。ほとんどの場合、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator`はおそらくもっと適切です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy.types</span> <span class="k">as</span> <span class="nn">types</span>

<span class="k">class</span> <span class="nc">MyType</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">UserDefinedType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="mi">8</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>

    <span class="k">def</span> <span class="nf">get_col_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;MYTYPE(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span>

    <span class="k">def</span> <span class="nf">bind_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">process</span>

    <span class="k">def</span> <span class="nf">result_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">coltype</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">process</span></pre></div>
</div>
<p>タイプが作成されるとすぐに使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">MyType</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="p">)</span></pre></div>
</div>
<p>`` get_col_spec（） <code class="docutils literal notranslate"><span class="pre">メソッドは、大抵の場合、キーワードの引数</span> <span class="pre">``</span> <span class="pre">type_expression``を受け取ります。これは、type：class：</span> <span class="pre">`.Column`や：func：`のように、</span> <span class="pre">.castコンストラクト。このキーワードは、引数シグネチャにキーワード引数（例えば</span> <span class="pre">``</span> <span class="pre">**</span> <span class="pre">kw</span></code>）を受け入れる場合にのみ送信されます。この機能のレガシー形式をサポートするために、これをチェックするためにイントロスペクションが使用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加: </span>所有する式は、その署名に `` ** kw``を受け取った場合、キーワード引数 `` type_expression``を介して `` get_col_spec（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドに渡されます。</p>
</div>
<dl class="class">
<dt id="sqlalchemy.types.UserDefinedType.Comparator">
<em class="property">class </em><code class="descname">Comparator</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.UserDefinedType.Comparator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Comparator</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.types.UserDefinedType.coerce_compared_value">
<code class="descname">coerce_compared_value</code><span class="sig-paren">(</span><em>op</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.types.UserDefinedType.coerce_compared_value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>式で「強制的」なPython値の型を推薦する。</p>
<p>：class： <cite>.UserDefinedType`のデフォルトの振る舞いは：class：</cite> .TypeDecorator`;と同じです。デフォルトでは、比較値をこの型と同じ型に強制する必要があると仮定して、 `` self``を返します。詳細は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TypeDecorator.coerce_compared_value`を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.8 で変更: </span>：meth： <cite>.UserDefinedType.coerce_compared_value`は：meth：</cite> .TypeEngine.coerce_compared_value`のより基本的な動作に陥るのではなく、デフォルトで `` self``を返すようになりました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.types.UserDefinedType.comparator_factory">
<code class="descname">comparator_factory</code><a class="headerlink" href="#sqlalchemy.types.UserDefinedType.comparator_factory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.types.UserDefinedType.Comparator" title="sqlalchemy.types.UserDefinedType.Comparator"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserDefinedType.Comparator</span></code></a> のエイリアス</p>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="type_basics.html" title="previous chapter">列とデータ型</a>
        Next:
        <a href="type_api.html" title="next chapter">ベースタイプAPI</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



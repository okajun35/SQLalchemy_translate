<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    トランザクションと接続管理
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="セッションの使用" href="session.html" />
        <link rel="next" title="追加の永続化手法" href="persistence_techniques.html" />
        <link rel="prev" title="カスケード" href="cascades.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="session_basics.html">セッションの基礎</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_state_management.html">状態管理</a></span></li>
<li><span class="link-container first"><a class="reference external" href="cascades.html">カスケード</a></span></li>
<li class="selected"><span class="link-container first"><strong>トランザクションと接続管理</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#managing-transactions">トランザクションの管理</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-savepoint">SAVEPOINTの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#autocommit-mode">自動コミットモード</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-subtransactions-with-autocommit">自動コミットでのサブトランザクションの使用</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#enabling-two-phase-commit">2フェーズコミットの有効化</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#setting-transaction-isolation-levels">トランザクション分離レベルの設定</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#setting-isolation-engine-wide">分離エンジン全体を設定する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#setting-isolation-for-individual-sessions">個々のセッションの分離を設定する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#setting-isolation-for-individual-transactions">個々のトランザクションの隔離の設定</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#tracking-transaction-state-with-events">イベントによるトランザクション状態の追跡</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#joining-a-session-into-an-external-transaction-such-as-for-test-suites">外部トランザクションへのセッションの参加（テストスイートなど）</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="persistence_techniques.html">追加の永続化手法</a></span></li>
<li><span class="link-container first"><a class="reference external" href="contextual.html">コンテキスト/スレッドローカルセッション</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_events.html">イベントによるオブジェクトおよびセッションの変更の追跡</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_api.html">セッションAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="transactions-and-connection-management">
<h1>トランザクションと接続管理<a class="headerlink" href="#transactions-and-connection-management" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="managing-transactions">
<span id="unitofwork-transaction"></span><h2>トランザクションの管理<a class="headerlink" href="#managing-transactions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しく構築された：class： <cite>.Session`は&amp;quot; begin &amp;quot;状態にあると言えるでしょう。この状態では、：class： `.Session`は：class：</cite> .Engine`オブジェクトのどれかと結びついていたり、接続状態やトランザクション状態を確立していません。</p>
<p>：class： <cite>.Session`はデータベース接続時の操作要求を受け取ります。通常、これは：class： `.Engine`（これは：meth：</cite> .Session.query`、：meth： <cite>.Session.execute</cite>、またはa：の中にあるかもしれない）を使用してSQLステートメントを実行するよう呼び出されます。この状態が存在し、：meth： <cite>.Session.commit`または：meth：</cite> .Session.flush`が呼び出されたときに発生する保留中のデータの操作をフラッシュします。</p>
<p>これらの要求が受け取られると、新しい：class： <cite>.Engine`が発生しました：class：</cite> .Session`によって維持されている進行中のトランザクション状態に関連付けられます。最初の：class： <cite>.Engine`が操作されると、：class：</cite> .Session`はbegin状態を残し、transactional 状態に入ったと言えるでしょう。それぞれ：class： <cite>.Engine`が見つかりました。：class：</cite> .Connection`は：meth： <cite>.Engine.contextual_connect`メソッドを介して取得された、それに関連付けられています。 a：class： `.Connection`が：class：</cite> .Session`（これの例については：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_external_transaction`を参照）に直接関連付けられていた場合、それはトランザクション状態に直接追加されます。</p>
<p>それぞれ：class： <cite>.Connection`の場合、：class：</cite> .Session`は：class： <cite>.Transaction`オブジェクトも保持します。これは、それぞれ：meth：</cite> .Connection.begin`を呼び出すことによって取得されます：class： ` `` Twophase = True``を使って：class： <cite>.Session`オブジェクトが確立されていれば、：class：</cite> .TwoPhaseTransaction`オブジェクトは：meth： <cite>.Connection.begin_twophase`で取得されます。これらのトランザクションは、：meth： `.Session.commit`メソッドと：meth：</cite> .Session.rollback`メソッドの呼び出しに対応して、すべてコミットまたはロールバックされます。該当する場合、コミット操作はすべてのトランザクションに対して：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TwoPhaseTransaction.prepare`メソッドも呼び出します。</p>
<p>トランザクション状態がロールバックまたはコミット後に完了すると、：class： <cite>.Session</cite>：term：` releases` all：class： <cite>.Transaction`と：class：</cite> .Connection`リソースが返され、 &amp;quot;begin&amp;quot;ステートで、新しい：class： <cite>.Connection`と：class：</cite> .Transaction`オブジェクトを、SQL文を発行する新しいリクエストとして再度呼び出すことになります。</p>
<p>以下の例はこのライフサイクルを示しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># new session.   no connections are in use.</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># first query.  a Connection is acquired</span>
    <span class="c1"># from the Engine, and a Transaction</span>
    <span class="c1"># started.</span>
    <span class="n">item1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># second query.  the same Connection/Transaction</span>
    <span class="c1"># are used.</span>
    <span class="n">item2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># pending changes are created.</span>
    <span class="n">item1</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
    <span class="n">item2</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>

    <span class="c1"># commit.  The pending changes above</span>
    <span class="c1"># are flushed via flush(), the Transaction</span>
    <span class="c1"># is committed, the Connection object closed</span>
    <span class="c1"># and discarded, the underlying DBAPI connection</span>
    <span class="c1"># returned to the connection pool.</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># on rollback, the same closure of state</span>
    <span class="c1"># as that of commit proceeds.</span>
    <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
    <span class="k">raise</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># close the Session.  This will expunge any remaining</span>
    <span class="c1"># objects as well as reset any existing SessionTransaction</span>
    <span class="c1"># state.  Neither of these steps are usually essential.</span>
    <span class="c1"># However, if the commit() or rollback() itself experienced</span>
    <span class="c1"># an unanticipated internal failure (such as due to a mis-behaved</span>
    <span class="c1"># user-defined event handler), .close() will ensure that</span>
    <span class="c1"># invalid state is removed.</span>
    <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<div class="section" id="using-savepoint">
<span id="session-begin-nested"></span><h3>SAVEPOINTの使用<a class="headerlink" href="#using-savepoint" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>基盤となるエンジンでサポートされている場合、SAVEPOINTトランザクションは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.begin_nested`メソッドを使用して記述することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span> <span class="c1"># establish a savepoint</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u3</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>  <span class="c1"># rolls back u3, keeps u1 and u2</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span> <span class="c1"># commits u1 and u2</span></pre></div>
</div>
<p>：meth： <cite>〜.Session.begin_nested`は何度も呼び出すことができ、呼び出しごとに一意の識別子を持つ新しいSAVEPOINTを発行します。それぞれ：meth： `〜.Session.begin_nested`呼び出しに対して、対応する：meth：</cite>〜.Session.rollback`または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.commit`を発行する必要があります。 （ただし、戻り値がコンテキストマネージャ、つまりwith文で使用される場合、このロールバック/コミットはコンテキストを終了するときにコンテキストマネージャによって発行されるため、明示的に追加しないでください。</p>
<p>：meth： <cite>〜.Session.begin_nested`が呼び出されると、</cite> <cite>autoflush``の設定に関係なく、：meth：</cite>〜.Session.flush`が無条件で発行されます。これは、a：meth： <cite>〜.Session.rollback`が発生したときにセッションの完全状態が満了し、それ以降のすべての属性/インスタンスアクセスが：class：</cite>〜sqlalchemy.orm .session.Session`の直前：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜。Session.begin_nested`が呼び出されました。</p>
<p>：meth： <cite>〜。Session.begin_nested`は、less：meth：</cite>〜.Session.begin`メソッドと同じように、コンテキストマネージャとして機能する：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SessionTransaction`オブジェクトを返します。ユニークな制約の例外のようなものを捕まえるために、個々のレコードの挿入の周りで簡潔に使用することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">():</span>
            <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipped record </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">record</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
</div>
<div class="section" id="autocommit-mode">
<span id="session-autocommit"></span><h3>自動コミットモード<a class="headerlink" href="#autocommit-mode" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：ref： <cite>unitofwork_transaction`のセッションライフサイクルの例は、</cite> <cite>autocommit = False``のデフォルトモードで動作するclass：</cite> .Session`を参照しています。このモードでは、：class： <cite>.Session`は、データベース接続時に作業が必要になると自動的に新しいトランザクションを開始します。 ：meth： `.Session.commit`または：meth：</cite> .Session.rollback`メソッドが呼び出されるまで、トランザクションは進行中です。</p>
<p>：class： <cite>.Session`は、トランザクションが暗黙的に開始されない、** autocommitモード**と呼ばれる古いレガシー使用モードも備えています。：meth：</cite> .Session.begin`メソッドが呼び出されない限り、 ：class： <cite>.Session`は、接続プールからチェックアウトされた新しい接続上で各データベース操作を実行し、操作が完了した直後にプールに戻されます。これは、：meth： `.Session.query`で返されたクエリを実行するときと同様に：meth：</cite>。Session.execute`のようなメソッドを参照します。フラッシュ操作の場合、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`は、フラッシュ中に新しいトランザクションを開始し、完了するとコミットします。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>&amp;quot;autocommit &amp;quot;モードは**従来の使用モード**であり、新しいプロジェクトでは使用しないでください。自動コミットモードが使用されている場合、純粋な自動コミットモードでセッションを使用するのではなく、少なくとも：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.begin`メソッドを使用して、トランザクションのスコープが存在することを確認することを強くお勧めします。</p>
<p class="last">：meth： <cite>.Session.begin`メソッドが使用されておらず、即時の自動コミットを伴うアドホック接続を使用して操作を続行できる場合、アプリケーションはおそらく</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>autoflush = False、expire_on_commit = False``を設定する必要があります。これらの機能は、データベーストランザクションのコンテキスト内でのみ使用されることを意図しています。</p>
</div>
<p>最近の&amp;quot;自動コミットモード&amp;quot;の使用は、&amp;quot;開始&amp;quot;状態が発生したときに特に制御したいフレームワーク統合の傾向があります。 `` autocommit = True``で設定されたセッションは：meth： <cite>.Session.begin`メソッドを使って&amp;quot; begin &amp;quot;状態に置くことができます。サイクルが：meth： `.Session.commit`または：meth：</cite> .Session.rollback`で完了すると、接続およびトランザクションリソースはterm： <cite>released`で、：class：</cite> .Session`はautocommit &amp;quot;mode、until：meth：` .Session.begin`をもう一度呼び出す:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">item1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">item2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">item1</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
    <span class="n">item2</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
    <span class="k">raise</span></pre></div>
</div>
<p>：meth： <cite>.Session.begin`メソッドは</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>with``ステートメントと互換性のあるトランザクショントークンを返します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
    <span class="n">item1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">item2</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">item1</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
    <span class="n">item2</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span></pre></div>
</div>
<div class="section" id="using-subtransactions-with-autocommit">
<span id="session-subtransactions"></span><h4>自動コミットでのサブトランザクションの使用<a class="headerlink" href="#using-subtransactions-with-autocommit" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>サブトランザクションは：meth： <cite>.Session.begin`メソッドを</cite> <cite>subtransactions = True``フラグと共に使用することを示します。これにより、非トランザクション型の区切り構造が生成され、：meth： `〜.Session.begin`と：meth：</cite>〜.Session.commit`の呼び出しをネストすることができます。その目的は、トランザクションを開始する外部コードと、トランザクションを既に定義したブロック内の両方とは独立して、トランザクション内で機能するコードの構築を可能にすることです。</p>
<p>`` subtransactions = True``は一般的に自動コミットとの組み合わせでのみ有効で、ref： <cite>connections_nested_transactions`に記述されているパターンと同等です。ここで任意の数の関数が：meth：</cite> .Connection.begin`と：meth ： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction.commit`があたかもトランザクションのイニシエータであるかのように、実際には既に進行中のトランザクションに参加している可能性があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># method_a starts a transaction and calls method_b</span>
<span class="k">def</span> <span class="nf">method_a</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">method_b</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># transaction is committed here</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span> <span class="c1"># rolls back the transaction</span>
        <span class="k">raise</span>

<span class="c1"># method_b also starts a transaction, but when</span>
<span class="c1"># called from method_a participates in the ongoing</span>
<span class="c1"># transaction.</span>
<span class="k">def</span> <span class="nf">method_b</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SomeObject</span><span class="p">(</span><span class="s1">&#39;bat&#39;</span><span class="p">,</span> <span class="s1">&#39;lala&#39;</span><span class="p">))</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># transaction is not committed yet</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span> <span class="c1"># rolls back the transaction, in this case</span>
                           <span class="c1"># the one that was initiated in method_a().</span>
        <span class="k">raise</span>

<span class="c1"># create a Session and call method_a</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">method_a</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>サブトランザクションは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.flush`プロセスによって使用され、自動コミットに関係なく、トランザクション内でフラッシュ操作が確実に行われます。自動コミットが無効になっているときは、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`を強制的に&amp;quot; pending rollback &amp;quot;状態にしておくと便利です。途中で失敗したフラッシュを再開することはできません。トランザクションの全体的な &amp;quot;スコープ&amp;quot;。</p>
</div>
</div>
<div class="section" id="enabling-two-phase-commit">
<span id="session-twophase"></span><h3>2フェーズコミットの有効化<a class="headerlink" href="#enabling-two-phase-commit" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>2フェーズオペレーション（現在のMySQLとPostgreSQL）をサポートするバックエンドの場合、セッションは2フェーズコミットセマンティクスを使用するように指示できます。これは、トランザクションがすべてのデータベースでコミットまたはロールバックされるように、データベース間のトランザクションのコミットを調整します。 SQLAlchemyによって管理されていないトランザクションと対話するためのセッションをmeth： <cite>〜.Session.prepare`することもできます。 2つのフェーズトランザクションを使用するには、セッションでフラグ `</cite> twophase = True``を設定します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine1</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://db1&#39;</span><span class="p">)</span>
<span class="n">engine2</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://db2&#39;</span><span class="p">)</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">twophase</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># bind User operations to engine 1, Account operations to engine 2</span>
<span class="n">Session</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">binds</span><span class="o">=</span><span class="p">{</span><span class="n">User</span><span class="p">:</span><span class="n">engine1</span><span class="p">,</span> <span class="n">Account</span><span class="p">:</span><span class="n">engine2</span><span class="p">})</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>

<span class="c1"># .... work with accounts and users</span>

<span class="c1"># commit.  session will issue a flush to all DBs, and a prepare step to all DBs,</span>
<span class="c1"># before committing both transactions</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
</div>
<div class="section" id="setting-transaction-isolation-levels">
<span id="session-transaction-isolation"></span><h3>トランザクション分離レベルの設定<a class="headerlink" href="#setting-transaction-isolation-levels" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>Isolation`は、並行して発生する他のトランザクションに関連した、データベースレベルでのトランザクションの振る舞いを指します。 4つのよく知られた分離モードがあります。通常、Python DBAPIでは、明示的なAPIまたはデータベース固有の呼び出しを介して、接続ごとにこれらを設定できます。</p>
<p>SQLAlchemyの方言は：：class： <cite>.Engine`またはper-：class：</cite> .Connection`ベースで設定可能な分離モードをサポートしています。：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine`レベルと：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Connection.execution_options`レベルです。</p>
<p>ORM：class： <cite>.Session`を使用すると、エンジンと接続の* facade *として機能しますが、トランザクションの分離は直接的には公開されません。だから、トランザクションの分離レベルに影響を与えるためには、必要に応じて：class： `.Engine`または：class：</cite> .Connection`を実行する必要があります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：paramref： <cite>.create_engine.isolation_level</cite></p>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>SQLiteトランザクションの分離&lt;sqlite_isolation_level&gt; `</p>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>PostgreSQLの分離レベル&lt;postgresql_isolation_level&gt; `</p>
<p class="last">：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>MySQL分離レベル&lt;mysql_isolation_level&gt; `</p>
</div>
<div class="section" id="setting-isolation-engine-wide">
<h4>分離エンジン全体を設定する<a class="headerlink" href="#setting-isolation-engine-wide" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>class： <cite>.Session`または：class：</cite> .sessionmaker`を特定の分離レベルでグローバルに設定するには、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine.isolation_level`パラメータを使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>

<span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
    <span class="s2">&quot;postgresql://scott:tiger@localhost/test&quot;</span><span class="p">,</span>
    <span class="n">isolation_level</span><span class="o">=</span><span class="s1">&#39;REPEATABLE_READ&#39;</span><span class="p">)</span>

<span class="n">maker</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">eng</span><span class="p">)</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">maker</span><span class="p">()</span></pre></div>
</div>
</div>
<div class="section" id="setting-isolation-for-individual-sessions">
<h4>個々のセッションの分離を設定する<a class="headerlink" href="#setting-isolation-for-individual-sessions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>new：class： <cite>.Session`をコンストラクタを直接使用するか、または：class：</cite> .sessionmaker`によって生成された呼び出し可能関数を呼び出すときに、 `` bind``引数を直接渡すことができます。既存のバインド。これを：meth： <cite>.Engine.execution_options`メソッドと組み合わせて、元の：class：</cite> .Engine`のコピーを生成することができます。これはこのオプションを追加します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">maker</span><span class="p">(</span>
    <span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">isolation_level</span><span class="o">=</span><span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">))</span></pre></div>
</div>
<p>：class： <cite>.Session`や：class：</cite> .sessionmaker`が複数の &amp;quot;binds&amp;quot;で構成されている場合、 `` binds``引数を完全に再指定するか、あるいは特定のバインドを置き換えるだけで、：meth： <cite>.Session.bind_mapper`または：meth：</cite> .Session.bind_table`メソッドを使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">maker</span><span class="p">()</span>
<span class="n">session</span><span class="o">.</span><span class="n">bind_mapper</span><span class="p">(</span>
    <span class="n">User</span><span class="p">,</span> <span class="n">user_engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">isolation_level</span><span class="o">=</span><span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">))</span></pre></div>
</div>
<p>後続の個々のトランザクションメソッドを使用することもできます。</p>
</div>
<div class="section" id="setting-isolation-for-individual-transactions">
<h4>個々のトランザクションの隔離の設定<a class="headerlink" href="#setting-isolation-for-individual-transactions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>分離レベルに関する重要な注意点は、トランザクションが既に開始されているクラス： <cite>.Connection`で設定を安全に変更できないことです。データベースは進行中のトランザクションの分離レベルを変更することができず、一部のDBAPIとSQLAlchemyの方言はこの領域で矛盾した動作をします。いくつかは暗黙的にROLLBACKを発行し、あるものは暗黙的にCOMMITを発行し、他のものは次のトランザクションまで設定を無視することがあります。したがって、SQLAlchemyは、トランザクションが既に実行されているときにこのオプションが設定されていると警告を出します。 ：class： `.Session`オブジェクトは、トランザクションがまだ開始されていないトランザクションで使用するためにclass：</cite> .Connection`を提供しません。ここでは、：meth： <cite>.Session.connection`メソッドによって提供された：paramref：</cite> .Session.connection.execution_options`を渡すことによって、トランザクションの開始時に：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`に実行オプションを渡す必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>

<span class="n">sess</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="n">sess</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span><span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;isolation_level&#39;</span><span class="p">:</span> <span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">})</span>

<span class="c1"># work with session</span>

<span class="c1"># commit transaction.  the connection is released</span>
<span class="c1"># and reverted to its previous isolation level.</span>
<span class="n">sess</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>上では、まず、：class： <cite>.session`をコンストラクタまたはa：class：</cite> .sessionmaker`を使って生成します。次に、：meth： <cite>.Session.connection`を呼び出して明示的にトランザクションの開始を設定します。これは、トランザクションが開始される前に接続に渡される実行オプションを提供します。複数のバインドや：meth： `.Session.get_bind`のカスタムスキームを持つ：class：</cite> .Session`を使って作業している場合は、meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.connection`に追加の引数を順番に渡すことができますバインドの調達方法に影響を与える:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span> <span class="o">=</span> <span class="n">my_sesssionmaker</span><span class="p">()</span>

<span class="c1"># set up a transaction for the bind associated with</span>
<span class="c1"># the User mapper</span>
<span class="n">sess</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span>
    <span class="n">mapper</span><span class="o">=</span><span class="n">User</span><span class="p">,</span>
    <span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;isolation_level&#39;</span><span class="p">:</span> <span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">})</span>

<span class="c1"># work with session</span>

<span class="c1"># commit transaction.  the connection is released</span>
<span class="c1"># and reverted to its previous isolation level.</span>
<span class="n">sess</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>：paramref： <cite>.Session.connection.execution_options`引数は、トランザクション内の特定のバインドに対して：meth：</cite> .Session.connection`への**最初の**呼び出しでのみ受け入れられます。ターゲット接続ですでにトランザクションが開始されている場合、警告が発行されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">eng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select 1&quot;</span><span class="p">)</span>
<span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x1017a6c50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">connection</span><span class="p">(</span><span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;isolation_level&#39;</span><span class="p">:</span> <span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">})</span>
<span class="go">sqlalchemy/orm/session.py:310: SAWarning: Connection is already established</span>
<span class="go">for the given bind; execution_options ignored</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.9 で追加: </span>：meth： <cite>.Session.connection`に：paramref：</cite> .Session.connection.execution_options`パラメータを追加しました。</p>
</div>
</div>
</div>
<div class="section" id="tracking-transaction-state-with-events">
<h3>イベントによるトランザクション状態の追跡<a class="headerlink" href="#tracking-transaction-state-with-events" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>セッショントランザクション状態の変更のための利用可能なイベントフックの概要については、参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_transaction_events`を参照してください。</p>
</div>
</div>
<div class="section" id="joining-a-session-into-an-external-transaction-such-as-for-test-suites">
<span id="session-external-transaction"></span><h2>外部トランザクションへのセッションの参加（テストスイートなど）<a class="headerlink" href="#joining-a-session-into-an-external-transaction-such-as-for-test-suites" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>もし：class： <cite>.Connection`がすでにトランザクション状態にある（すなわち、：class：</cite> .Transaction`が設定されています）場合、：class： <cite>.Session`をそのトランザクション内に参加させることができます。 ：class： `.Session`をそれにバインドするだけです：class：</cite> .Connection`。このための通常の論理的根拠は、ORMコードが：class： <cite>.Session`で自由に動作することを可能にするテストスイートです：meth：</cite> .Session.commit`を呼び出す機能を含みます。その後、データベース相互作用全体がロールバックされます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">TestCase</span>

<span class="c1"># global application scope.  create Session class, engine</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SomeTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># connect to the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

        <span class="c1"># begin a non-ORM transaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="c1"># bind an individual Session to the connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># use the session in tests.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Foo</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># rollback - everything that happened with the</span>
        <span class="c1"># Session above (including calls to commit())</span>
        <span class="c1"># is rolled back.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="c1"># return connection to the Engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>上では、：meth： <cite>.Session.commit`と：meth：</cite> .Transaction.rollback`を発行します。これは、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトの* subtransactions <a href="#id3"><span class="problematic" id="id4">*</span></a>を維持する機能、または一番外側のbegin / commitペアのみが実際にトランザクションをコミットするネストされたbegin / commitまたはrollbackのペアを利用する例です。一番外側のブロックがロールバックすると、すべてがロールバックされます。</p>
<div class="topic">
<p class="topic-title first">Supporting Tests with Rollbacks</p>
<p>上記のレシピは、テスト自体のスコープ内で：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.rollback`を実際に呼び出す必要があるテストを除いて、あらゆる種類のデータベース対応テストでうまく機能します。上記のレシピは展開することができます：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`は、各トランザクションの開始時に確立されるSAVEPOINTのスコープ内のすべての操作を常に実行するので、&amp;quot;トランザクション&amp;quot;もロールバックできます。 2つの余分なイベントを使って決してコミットされないより大きな&amp;quot;トランザクション&amp;quot;の範囲にとどまっています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>


<span class="k">class</span> <span class="nc">SomeTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># connect to the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

        <span class="c1"># begin a non-ORM transaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="c1"># bind an individual Session to the connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>

        <span class="c1"># start the session in a SAVEPOINT...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>

        <span class="c1"># then each time that SAVEPOINT ends, reopen it</span>
        <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;after_transaction_end&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">restart_savepoint</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transaction</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>

                <span class="c1"># ensure that state is expired the way</span>
                <span class="c1"># session.commit() at the top level normally does</span>
                <span class="c1"># (optional step)</span>
                <span class="n">session</span><span class="o">.</span><span class="n">expire_all</span><span class="p">()</span>

                <span class="n">session</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>

    <span class="c1"># ... the tearDown() method stays the same</span></pre></div>
</div>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="cascades.html" title="previous chapter">カスケード</a>
        Next:
        <a href="persistence_techniques.html" title="next chapter">追加の永続化手法</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



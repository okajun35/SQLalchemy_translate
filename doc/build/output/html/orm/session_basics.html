<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    セッションの基礎
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="セッションの使用" href="session.html" />
        <link rel="next" title="状態管理" href="session_state_management.html" />
        <link rel="prev" title="セッションの使用" href="session.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span><ul>
<li class="selected"><span class="link-container first"><strong>セッションの基礎</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#what-does-the-session-do">セッションは何をしていますか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#getting-a-session">セッションの取得</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#adding-additional-configuration-to-an-existing-sessionmaker">既存のsessionmaker（）に追加の設定を追加する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#creating-ad-hoc-session-objects-with-alternate-arguments">代替引数を使用したAd-Hocセッションオブジェクトの作成</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#session-frequently-asked-questions">セッションに関するよくある質問</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#when-do-i-make-a-sessionmaker">いつ私は：class： `.sessionmaker`を作るのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it">いつ：class： `.Session`を構築すればいいですか？いつコミットしますか？いつ閉じるのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#is-the-session-a-cache">セッションはキャッシュですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-can-i-get-the-session-for-a-certain-object">特定のオブジェクトに対して：class： `〜sqlalchemy.orm.session.Session`を取得するにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#is-the-session-thread-safe">セッションはスレッドセーフですか？</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#basics-of-using-a-session">セッションの基本</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#querying">クエリ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#adding-new-or-existing-items">新しいアイテムまたは既存のアイテムの追加</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#deleting">削除</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#deleting-objects-referenced-from-collections-and-scalar-relationships">コレクションとスカラーの関係から参照されるオブジェクトの削除</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#deleting-based-on-filter-criterion">フィルタ条件に基づいた削除</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#flushing">フラッシング</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#committing">コミット</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#rolling-back">ロールバック</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#closing">閉鎖</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="session_state_management.html">状態管理</a></span></li>
<li><span class="link-container first"><a class="reference external" href="cascades.html">カスケード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_transaction.html">トランザクションと接続管理</a></span></li>
<li><span class="link-container first"><a class="reference external" href="persistence_techniques.html">追加の永続化手法</a></span></li>
<li><span class="link-container first"><a class="reference external" href="contextual.html">コンテキスト/スレッドローカルセッション</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_events.html">イベントによるオブジェクトおよびセッションの変更の追跡</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_api.html">セッションAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="session-basics">
<h1>セッションの基礎<a class="headerlink" href="#session-basics" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="what-does-the-session-do">
<h2>セッションは何をしていますか？<a class="headerlink" href="#what-does-the-session-do" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最も一般的な意味で、：class： <cite>〜.Session`は、データベースとのすべての会話を確立し、あなたがそのライフスパンの間にロードまたは関連づけたすべてのオブジェクトの&amp;quot;保持ゾーン&amp;quot;を表します。 ：class： `〜.Session`オブジェクトの現在のデータベース接続を使用してクエリをデータベースに送信し、result行を：classに格納されたオブジェクトに取り込むa：class：</cite> .Query`オブジェクトを取得するためのエントリポイントを提供します： <cite>.Session</cite>、<a href="#id1"><span class="problematic" id="id2">`</span></a>アイデンティティマップ&lt;<a class="reference external" href="http://martinfowler.com/eaaCatalog/identityMap.html">http://martinfowler.com/eaaCatalog/identityMap.html</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  - 各オブジェクトの一意のコピーを保持するデータ構造。&amp;quot;ユニーク&amp;quot;は&amp;quot;特定のプライマリキーを持つ1つのオブジェクト&amp;quot;を意味します。</p>
<p>：class： <cite>.Session`は基本的にステートレスな形式で始まります。クエリが発行されるか、他のオブジェクトがそれと共に永続化されると、：class： `.Session`自体またはmapped：class：</cite> .Tableのいずれかに関連付けられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`から接続リソースを要求します。オブジェクトが操作されます。この接続は進行中のトランザクションを表し、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`が保留状態をコミットまたはロールバックするように指示されるまで有効です。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`によって管理されているオブジェクトに対するすべての変更が追跡されます。データベースが再度照会される前、または現在のトランザクションがコミットされる前に**、保留中のすべての変更がデータベースにフラッシュされます。これは <a href="#id3"><span class="problematic" id="id4">`</span></a>作業単位（Unit of Work） &lt;<a class="reference external" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">http://martinfowler.com/eaaCatalog/unitOfWork.html</a>&gt; <a href="#id5"><span class="problematic" id="id6">`</span></a>_パターン。</p>
<p>：class： <cite>.Session`を使用する場合、関連するオブジェクトは：class：</cite> .Session`が保持するトランザクションの**プロキシオブジェクト**であることに注意することが重要です。同期を維持するためにオブジェクトがデータベースに再アクセスする原因となるイベント。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`からオブジェクトを切り離して使用することは可能ですが、このプラクティスには注意が必要です。通常、デタッチされたオブジェクトを別のクラス： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`に再度関連付けることで、データベースの状態を表す通常のタスクを再開できるようにします。</p>
</div>
<div class="section" id="getting-a-session">
<span id="session-getting"></span><h2>セッションの取得<a class="headerlink" href="#getting-a-session" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <cite>.Session`は、直接インスタンス化できる通常のPythonクラスです。しかし、セッションがどのように設定され取得されるかを標準化するために、：class： `.sessionmaker`クラスは、トップレベルを作成するために通常使用されます：class：</cite> .Session`設定。構成的な議論。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`の使い方を以下に示します：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="c1"># an Engine, which the Session will use for connection</span>
<span class="c1"># resources</span>
<span class="n">some_engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://scott:tiger@localhost/&#39;</span><span class="p">)</span>

<span class="c1"># create a configured &quot;Session&quot; class</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">some_engine</span><span class="p">)</span>

<span class="c1"># create a Session</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>

<span class="c1"># work with sess</span>
<span class="n">myobject</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">myobject</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>上の：class： <cite>.sessionmaker`呼び出しは、私たちのために</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Session``という名前に割り当てるファクトリを作成します。このファクトリが呼び出されると、ファクトリを与えたコンフィグレーション引数を使用してnew：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`オブジェクトを作成します。この場合、典型的には、接続リソースに対して特定の：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Engine`を指定するようにファクトリを構成しました。</p>
<p>典型的なセットアップでは、：class： <cite>.sessionmaker`を：class：</cite> .Engine`に関連付けます。これにより、それぞれ：class： <cite>.Session`で生成される：class：</cite> .Engine`が接続リソースを取得します。この関連付けは、上記の例のように `` bind``引数を使って設定できます。</p>
<p>アプリケーションを書くときは、：class： <cite>.sessionmaker`ファクトリをグローバルレベルに置きます。このファクトリは、アプリケーションの残りの部分でnew：class： `.Session`インスタンスのソースとして使用することができ、how：class：</cite> .Session`オブジェクトの設定は1つの場所に構築されます。</p>
<p>：class： <cite>.sessionmaker`ファクトリは、他のヘルパーと一緒に使うこともできます。このヘルパーには、ユーザ定義の：class：</cite> .sessionmaker`が渡され、ヘルパーによって維持されます。これらのヘルパーのいくつかは、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_faq_whentocreate`セクションで議論されています。</p>
<div class="section" id="adding-additional-configuration-to-an-existing-sessionmaker">
<h3>既存のsessionmaker（）に追加の設定を追加する<a class="headerlink" href="#adding-additional-configuration-to-an-existing-sessionmaker" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的なシナリオは、：class： <cite>.sessionmaker`がモジュールのインポート時に呼び出されるところですが、：class：</cite> .sessionmaker`に関連付けられるclass： <cite>.Engine`インスタンスがまだ生成されていません進んだ。このuseの場合、：class： `.sessionmaker`構造体は：meth：</cite> .sessionmaker.configure`メソッドを提供します。これは追加の設定指令を既存の：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`に置きます。これは、呼び出される:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="c1"># configure Session class with desired options</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>

<span class="c1"># later, we create the engine</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://...&#39;</span><span class="p">)</span>

<span class="c1"># associate it with our custom Session class</span>
<span class="n">Session</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># work with the session</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span></pre></div>
</div>
</div>
<div class="section" id="creating-ad-hoc-session-objects-with-alternate-arguments">
<h3>代替引数を使用したAd-Hocセッションオブジェクトの作成<a class="headerlink" href="#creating-ad-hoc-session-objects-with-alternate-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>アプリケーションが、アプリケーション全体で通常使用されているものとは異なる特殊な引数を持つ新しい：class： <cite>.Session`を作成する必要があるユースケースについては、：class：</cite> .Session`などの代替ソースにバインドします。 `` .sessionmaker`ファクトリの：meth：.sessionmaker`ファクトリに渡すことができます。 ： <cite>.sessionmaker .__ call__`メソッド。これらの引数は、以下のように既に配置されている設定を上書きします：new：class： `.Session`が特定のクラスに対して構築されます：class：</cite> .Connection`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># at the module level, the global sessionmaker,</span>
<span class="c1"># bound to a specific Engine</span>
<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># later, some unit of code wants to create a</span>
<span class="c1"># Session that is bound to a specific Connection</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span></pre></div>
</div>
<p>a：class： <cite>.Session`と特定の：class：</cite> .Connection`の関連付けの典型的な根拠は、外部トランザクションを維持するテストフィクスチャのものです。この例は：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_external_transaction`を参照してください。</p>
</div>
</div>
<div class="section" id="session-frequently-asked-questions">
<span id="session-faq"></span><h2>セッションに関するよくある質問<a class="headerlink" href="#session-frequently-asked-questions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この時点で、多くのユーザーが既にセッションに関する質問をしています。このセクションでは、ミニFAQを紹介しています（注：doc： <cite>本当のFAQ &lt;/faq/index&gt; `）：class：</cite> .Session`を使うときに表示される最も基本的な問題の <a href="#id1"><span class="problematic" id="id2">``</span></a>）です。</p>
<div class="section" id="when-do-i-make-a-sessionmaker">
<h3>いつ私は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`を作るのですか？<a class="headerlink" href="#when-do-i-make-a-sessionmaker" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>アプリケーションのグローバルスコープのどこかで、たったの1回です。これは、アプリケーションの構成の一部として検討する必要があります。あなたのアプリケーションがパッケージ内に3つの.pyファイルを持っている場合、たとえば：class： <cite>.sessionmaker`行を</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>__init __。py``ファイルに置くことができます。あなたの他のモジュールのその時点から&amp;quot;from mypackage import Session &amp;quot;と言います。そうすれば、誰もが：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>。Session（）`を使い、そのセッションの設定はその中心点によって制御されます。</p>
<p>あなたのアプリケーションが起動し、インポートを行いますが、どのデータベースに接続しようとしているのかわからない場合は、：class： <cite>.Session`を後でエンジンにバインドすることができます：meth ： `.sessionmaker.configure</cite>。</p>
<p>このセクションの例では、class： <cite>.Sessionmaker`が実際に呼び出される行のすぐ上に作成されることを頻繁に示します：class：</cite> .Session`。しかし、それは単なる例のためです！実際には：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`はモジュールレベルのどこかにあります。 instantiate：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`への呼び出しは、データベース会話が始まるアプリケーション内の場所に置かれます。</p>
</div>
<div class="section" id="when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it">
<span id="session-faq-whentocreate"></span><h3>いつ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`を構築すればいいですか？いつコミットしますか？いつ閉じるのですか？<a class="headerlink" href="#when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="topic">
<p class="topic-title first">tl;dr;</p>
<ol class="arabic simple">
<li>原則として、セッション**のライフサイクルは、データベースデータにアクセスおよび/または操作する関数およびオブジェクトから分離し、外部**にしてください。これは、予測可能で一貫性のあるトランザクションスコープの達成に大きく役立ちます。</li>
<li>トランザクションの開始と終了の明確な概念があることを確認し、トランザクション**を短く**維持します。つまり、無期限に開かれるのではなく、一連の一連の操作で終了します。</li>
</ol>
</div>
<p>A：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`は通常、データベースアクセスが潜在的に予想される論理操作の開始時に構築されます。</p>
<p>：class： <cite>.Session`は、データベースとの会話に使用されるたびに、通信を開始するとすぐにデータベーストランザクションを開始します。 `</cite> autocommit``フラグが推奨デフォルトの `` False``になっていると仮定すると、このトランザクションは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`がロールバック、コミット、クローズされるまで実行され続けます。 ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`は前回のトランザクションが終了した後に再び使用されると新しいトランザクションを開始します。このことから、：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Session`は一度に1つのみではあるが、多くのトランザクションで寿命を持つことができます。これらの2つの概念を**トランザクションスコープ**および**セッションスコープ**と呼びます。</p>
<p>SQLAlchemy ORMは、スコープの開始時と終了時だけでなく、これらのスコープの広がりも含めて、アプリケーションにこれら2つのスコープを設定するようにSQLAlchemy ORMが奨励しています。class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session <a href="#id3"><span class="problematic" id="id4">`</span></a>インスタンスは、アプリケーション全体またはその2つの間のどこかで使用されるグローバルオブジェクトでなければ、関数またはメソッド内の実行フローに対してローカルでなければなりません。</p>
<p>このスコープを決定するために開発者に課される負担は、SQLAlchemy ORMがデータベースの使用方法について強い意見を持っている分野の1つです。 ：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>作業単位（unit of work） &amp;#39;パターンは、時間の経過と共に変化を累積し、定期的にそれらをフラッシュして、メモリ内の状態をローカルトランザクションに存在するものと同期して保持するものです。このパターンは、意味のあるトランザクションスコープが存在する場合にのみ有効です。</p>
<p>クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`のスコープを開始したり終了したりする最良のポイントを決定することは、通常困難ではありませんが、アプリケーションアーキテクチャの幅広い可能性は、困難な状況を招く可能性があります。</p>
<p>一般的な選択は、トランザクションが終了すると同時に：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`を破棄することです。これは、トランザクションとセッションのスコープが同じであることを意味します。これは、セッションスコープをトランザクションスコープとは別のものとして考慮する必要性を取り除くので、まず始めにすばらしい選択です。</p>
<p>トランザクションスコープをどのように決定すべきかについてのすべての推奨事項はありませんが、一般的なパターンがあります。特にWebアプリケーションを作成している場合、その選択肢はかなり確立されています。</p>
<p>このようなアプリケーションはすでに単一の一貫したスコープの周りに構築されているため、Webアプリケーションは最も簡単なケースです。これは、ブラウザからの着信要求を表す**要求**、応答を作成するためのその要求の処理、および最終的にその応答をクライアントに送り返します。 ：class： <cite>.Session`でWebアプリケーションを統合することは：class：</cite> .Session`のスコープをリクエストのスコープにリンクする簡単な作業です。 ：class： <cite>.Session`はリクエストの開始時に、または：term：</cite> lazy initialization`パターンを使用して確立することができます。アプリケーションロジックが現在の：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`に実際の要求オブジェクトがどのようにアクセスされるかに関連した方法でアクセスすることができるシステムがある場所で、リクエストが次に進みます。要求が終了すると、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`も通常、Webフレームワークによって提供されるイベントフックを使用して取り除かれます。 ：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Session`によって使用されるトランザクションは、この時点でコミットされてもよいし、アプリケーションが明示的なコミットパターンを選択して、保証されている要求に対してのみコミットすることもできますが、 ：最後に無条件に <a href="#id7"><span class="problematic" id="id8">`</span></a>.Session`を実行します。</p>
<p>いくつかのWebフレームワークには：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`の長さとWebリクエストの長さを調整するためのインフラストラクチャが含まれています。これには、 <a href="#id3"><span class="problematic" id="id4">`</span></a>Flask-SQLAlchemy &lt;<a class="reference external" href="http://flask-sqlalchemy.pocoo.org">http://flask-sqlalchemy.pocoo.org</a>&gt; FlaskのWebフレームワークと併用するための <a href="#id5"><span class="problematic" id="id6">`</span></a>_、Zope-SQLAlchemy &lt;<a class="reference external" href="http://pypi.python.org/pypi/zope.sqlalchemy">http://pypi.python.org/pypi/zope.sqlalchemy</a>&gt; <a href="#id7"><span class="problematic" id="id8">`</span></a>_、通常はPyramidフレームワークで使用されます。 SQLAlchemyは、これらの製品を使用可能な状態で使用することをお勧めします。</p>
<p>統合ライブラリが提供されていないか不十分な状況では、SQLAlchemyには、class： <cite>.scoped_session`という独自の&amp;quot;ヘルパー&amp;quot;クラスが含まれています。このオブジェクトの使い方に関するチュートリアルは：ref： `unitofwork_contextual`です。 ：class： `.Session`を現在のスレッドと関連付ける素早い方法と、class：</cite> .Session`オブジェクトを他の種類のスコープと関連付けるパターンの両方を提供します。</p>
<p>前にも述べたように、Web以外のアプリケーションでは、アプリケーション自体にアーキテクチャのパターンが1つしかないため、明確なパターンはありません。最善の戦略は、特定のスレッドが一連の操作を一定期間実行し始め、最後にコミットできるポイントである「操作」を画定しようとすることです。いくつかの例：</p>
<ul class="simple">
<li>子フォークを起動するバックグラウンドデーモンは、各子プロセスに対してローカルな：class： <cite>.Session`を作成し、フォークが存在する&amp;quot;仕事&amp;quot;の人生を通してclass：</cite> .Session`を使って作業したいでしょう。その後、ジョブが完了したときにそれを引き裂きます。</li>
<li>コマンドラインスクリプトの場合、アプリケーションは、プログラムが作業を開始するときに確立される単一のグローバル：クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`を作成し、プログラムがそのタスクを完了するとすぐにコミットします。</li>
<li>GUIインタフェース駆動アプリケーションの場合、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`のスコープは、ボタンプッシュなどのユーザー生成イベントの範囲内にあるのが最善です。または、スコープは、ユーザーが一連のレコードを開き &amp;quot;保存する&amp;quot;などの明示的なユーザー対話に対応することができます。</li>
</ul>
<p>原則として、アプリケーションは特定のデータを扱う関数に対してセッションのライフサイクルを外部から管理する必要があります。これは、データに固有の操作を、データにアクセスして操作するコンテキストには無関係に保つ懸念の基本的な分離です。</p>
<p>例：<strong>これをしない</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### this is the **wrong way to do it** ###</span>

<span class="k">class</span> <span class="nc">ThingOne</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">FooBar</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="k">raise</span>

<span class="k">class</span> <span class="nc">ThingTwo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Widget</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;q&quot;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span>
            <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="k">raise</span>

<span class="k">def</span> <span class="nf">run_my_program</span><span class="p">():</span>
    <span class="n">ThingOne</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">()</span>
    <span class="n">ThingTwo</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">()</span></pre></div>
</div>
<p>セッション（通常はトランザクション）のライフサイクルを**分離して外部に維持**：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### this is a **better** (but not the only) way to do it ###</span>

<span class="k">class</span> <span class="nc">ThingOne</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">FooBar</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>

<span class="k">class</span> <span class="nc">ThingTwo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">):</span>
        <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Widget</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;q&quot;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span>

<span class="k">def</span> <span class="nf">run_my_program</span><span class="p">():</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ThingOne</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">ThingTwo</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>より包括的なアプリケーションに推奨される最も包括的なアプローチは、セッション、トランザクション、および例外管理の詳細を、その作業を行うプログラムの詳細からできるだけ遠ざけようとします。例えば、コンテキストマネージャを使用して懸念をさらに分離することができます&lt;<a class="reference external" href="http://docs.python.org/3/library/co">http://docs.python.org/3/library/co</a> ntextlib.html#contextlib.contextmanager&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### another way (but again *not the only way*) to do it ###</span>

<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">session_scope</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Provide a transactional scope around a series of operations.&quot;&quot;&quot;</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">session</span>
        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">run_my_program</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">session_scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="n">ThingOne</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>
        <span class="n">ThingTwo</span><span class="p">()</span><span class="o">.</span><span class="n">go</span><span class="p">(</span><span class="n">session</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="is-the-session-a-cache">
<h3>セッションはキャッシュですか？<a class="headerlink" href="#is-the-session-a-cache" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Yeee ...いいえ。これは：term： <cite>identity map`パターンを実装し、主キーにキーを設定したオブジェクトを格納するという点で、キャッシュとして多少使用されています。ただし、どのような種類のクエリキャッシングも行いません。これは、 `</cite> session.query（Foo）.filter_by（name = &amp;#39;bar&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>と言うと、 `` Foo（name = &amp;#39;bar&amp;#39;） <a href="#id3"><span class="problematic" id="id4">``</span></a>がアイデンティティマップの右にあっても、セッションはそれについて全く分かりません。データベースにSQLを発行し、行を戻してから、行の主キーを見たときに*ローカルIDマップを調べて、そのオブジェクトがすでに存在することを確認する必要があります。 ：class： <cite>〜sqlalchemy.orm.session.Session`がクエリを発行する必要がない</cite> <cite>query.get（{何らかの主キー}）</cite> <a href="#id5"><span class="problematic" id="id6">`</span></a>としか言いません。</p>
<p>さらに、セッションは、デフォルトで弱い参照を使用してオブジェクトインスタンスを格納します。これはまた、セッションをキャッシュとして使用する目的を無効にします。</p>
<p>：class： <cite>.Session`は、誰もがオブジェクトの&amp;quot;レジストリ &amp;quot;として参照するグローバルオブジェクトであるようには設計されていません。それは**第2レベルのキャッシュ**の仕事です。 SQLAlchemyは、 `dogpile.cacheを使って第2レベルのキャッシングを実装するためのパターンを提供します&lt;https://dogpilecache.readthedocs.io/&gt; `_：：ref：</cite> examples_caching`の例を参照してください。</p>
</div>
<div class="section" id="how-can-i-get-the-session-for-a-certain-object">
<h3>特定のオブジェクトに対して：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session`を取得するにはどうすればよいですか？<a class="headerlink" href="#how-can-i-get-the-session-for-a-certain-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>利用できる：meth： <cite>〜.Session.object_session`クラスメソッド：class：</cite>〜sqlalchemy.orm.session.Session`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">object_session</span><span class="p">(</span><span class="n">someobject</span><span class="p">)</span></pre></div>
</div>
<p>新しい：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>core_inspection_toplevel`システムも使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">someobject</span><span class="p">)</span><span class="o">.</span><span class="n">session</span></pre></div>
</div>
</div>
<div class="section" id="is-the-session-thread-safe">
<span id="session-faq-threadsafe"></span><h3>セッションはスレッドセーフですか？<a class="headerlink" href="#is-the-session-thread-safe" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`は**非同時**の方法で使用されることが非常に意図されています。通常は一度に1つのスレッドしか意味しません。</p>
<p>：class： <cite>.Session`は、1つのトランザクション内の一連の操作に対して1つのインスタンスが存在するような方法で使用する必要があります。この効果を得るための便利な方法の1つは、：class： `.Session`を現在のスレッドに関連付けることです（背景については：ref：</cite> unitofwork_contextual`を参照してください）。もう一つは、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`が関数間で渡され、そうでなければ他のスレッドと共有されていないパターンを使うことです。</p>
<p>より大きなポイントは、複数の同時スレッドでセッションを使用する必要がないことです。それはレストランのみんながすべて同じ食器から食べるようなものです。セッションは、特定のタスクセットに使用するローカルの「作業領域」です。そのセッションを他のスレッドと共有したくない、または共有する必要がありません。</p>
<p>：class： <cite>.Session`が一度に1つの同時スレッドでのみ使用されることを確認することは、&amp;quot;シェア・ナッシング・エス &amp;quot;という並行性へのアプローチと呼ばれます。しかし、実際には：class： `.Session`を共有しない方がより重要なパターンを意味します。 ：class： `.Session`オブジェクトそのものだけでなく、**そのSession **に関連付けられているすべてのオブジェクトも単一の並行スレッドのスコープ内に保持されなければなりません。 a：class： `.Session`に関連付けられたマップされたオブジェクトのセットは、データベース接続を介してアクセスされるデータベース行内のデータのためのプロキシです。つまり：class：</cite> .Session`自体と同じように、データベース接続（または接続）用の大規模なプロキシです。結局のところ、それは主に同時アクセスから遠ざかっているDBAPI接続自体です。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`とそれに関連付けられたすべてのオブジェクトがそのDBAPI接続のすべてのプロキシであるため、グラフ全体は本質的に並行アクセスにとって安全ではありません。</p>
<p>実際に複数のスレッドが同じタスクに参加している場合、それらのスレッド間でセッションとそのオブジェクトを共有することを検討することができます。しかし、この非常に珍しいシナリオでは、アプリケーションは：class： <cite>.Session`またはその状態への同時アクセス*がないように、適切なロックスキームが実装されていることを保証する必要があります。この状況のより一般的なアプローチは、並行スレッドごとに：class： `.Session`を1つ：class：</cite> .Session`から：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>を使用して別のものにコピー*することです。 Session.merge`メソッドを使用して、オブジェクトの状態を別の：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`の新しいオブジェクトにコピーします。</p>
</div>
</div>
<div class="section" id="basics-of-using-a-session">
<h2>セッションの基本<a class="headerlink" href="#basics-of-using-a-session" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最も基本的な：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`の使用パターンをここに示します。</p>
<div class="section" id="querying">
<h3>クエリ<a class="headerlink" href="#querying" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜.Session.query`関数は、1つ以上の*エンティティ*をとり、このセッションのコンテキスト内でマッパークエリを発行するnew：class：</cite>〜sqlalchemy.orm.query.Query`オブジェクトを返します。エンティティはマップされたクラス、：class： <cite>〜sqlalchemy.orm.mapper.Mapper`オブジェクト、orm対応*記述子*、または</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>AliasedClass``オブジェクトとして定義されます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># query from a class</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># query with multiple classes, returns tuples</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># query using orm-enabled descriptors</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># query from a mapper</span>
<span class="n">user_mapper</span> <span class="o">=</span> <span class="n">class_mapper</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">user_mapper</span><span class="p">)</span></pre></div>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query`は結果を返します。インスタンス化された各オブジェクトはアイデンティティマップに格納されます。行が既に存在するオブジェクトと一致すると、同じオブジェクトが返されます。後者の場合、行が既存のオブジェクトに移入されるかどうかは、インスタンスの属性が*失効*されているかどうかによって異なります。 default-configured：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.session.Session`はトランザクション境界に沿ってすべてのインスタンスを自動的に期限切れにするので、通常は分離されたトランザクションでは、古いデータを表すインスタンスの問題は発生しません現在の取引。</p>
<p>：class： <cite>.Query`オブジェクトは：ref：</cite> ormtutorial_toplevel`で非常に詳細に紹介されています：さらに：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>query_api_toplevel`にも書かれています。</p>
</div>
<div class="section" id="adding-new-or-existing-items">
<h3>新しいアイテムまたは既存のアイテムの追加<a class="headerlink" href="#adding-new-or-existing-items" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.add`は、セッションにインスタンスを配置するために使用されます。 <a href="#id3"><span class="problematic" id="id4">*</span></a>一時的な（すなわち、新しい）インスタンスの場合、これは、次回のフラッシュ時にそれらのインスタンスに対してINSERTが行われることになります。 * persistent <a href="#id5"><span class="problematic" id="id6">*</span></a>（このセッションによってロードされたインスタンス）の場合、それらはすでに存在しており、追加する必要はありません。 * detached <a href="#id7"><span class="problematic" id="id8">*</span></a>（つまりセッションから削除された）インスタンスは、このメソッドを使用してセッションに再関連付けできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;user1&#39;</span><span class="p">)</span>
<span class="n">user2</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;user2&#39;</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user2</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>     <span class="c1"># write changes to the database</span></pre></div>
</div>
<p>セッションのリストを一度にセッションに追加するには、：meth： <cite>〜.Session.add_all</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span><span class="p">])</span></pre></div>
</div>
<p>`` save-update``カスケードに沿った：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.add`操作**カスケード**。詳細は、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>unitofwork_cascades`を参照してください。</p>
</div>
<div class="section" id="deleting">
<h3>削除<a class="headerlink" href="#deleting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.delete`メソッドは、Sessionのオブジェクトリストにインスタンスを配置し、deletedとしてマークします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># mark two objects to be deleted</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>

<span class="c1"># commit (or flush)</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<div class="section" id="deleting-objects-referenced-from-collections-and-scalar-relationships">
<span id="session-deleting-from-collections"></span><h4>コレクションとスカラーの関係から参照されるオブジェクトの削除<a class="headerlink" href="#deleting-objects-referenced-from-collections-and-scalar-relationships" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ORMは、一般に、フラッシュ処理中にコレクションまたはスカラー関係の内容を変更することはありません。つまり、クラスにオブジェクトのコレクションを参照する：func： <cite>.relationship`がある場合、または多対1のような単一のオブジェクトへの参照がある場合、この属性の内容はフラッシュ時には変更されません処理が行われます。代わりに、：class： `.Session`が後で期限切れになった場合、：meth：</cite> .Session.commit`のコミット時動作または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>。Session.expire`の明示的な使用によって、クラス： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`はクリアされ、次のアクセス時に再ロードされます。</p>
<p>この動作は、外部キーと主キー列を参照する列バインド属性へのフラッシュプロセスの影響と混同しないでください。これらの属性は、フラッシュプロセスが管理しようとする属性であるため、フラッシュ内で自由に変更されます。また：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>relationships_backref`で説明されているように、逆参照の振る舞いと混同しないでください。後方参照イベントはコレクションまたはスカラーの属性参照を変更しますが、この動作は関連するコレクションおよびオブジェクト参照を直接操作する際に発生します。呼び出し元のアプリケーション内では明示的で、フラッシュ処理の外にあります。</p>
<p>この動作に関する一般的な混乱は：meth： <cite>〜.Session.delete`メソッドの使用を伴います。オブジェクト上で：meth： `.Session.delete`が呼び出され、：class：</cite> .Session`がフラッシュされると、その行はデータベースから削除されます。外部キーを介してターゲット行を参照する行は、2つのマップされたオブジェクト型の間で：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`を使用して追跡されると仮定して、外部キー属性もNULLに更新されます。関連する行も削除されます。ただし、削除されたオブジェクトに関連する行自体も変更される可能性がありますが、フラッシュのスコープ内の操作に関連するオブジェクト**のリレーションシップバインドコレクションまたはオブジェクト参照には何も変更はありません。これは、オブジェクトが関連するコレクションのメンバーであった場合、そのコレクションが期限切れになるまで、Python側に存在することを意味します。同様に、オブジェクトが他のオブジェクトから多対1または一対一で参照された場合、その参照はオブジェクトが期限切れになるまでそのオブジェクトにも存在し続けます。</p>
<p>以下では、 `` Address``オブジェクトが削除のためにマークされた後でも、それがフラッシュの後であっても親の `` User``に関連付けられたコレクションにまだ残っていることを示しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">address</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address</span> <span class="ow">in</span> <span class="n">user</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">True</span></pre></div>
</div>
<p>上記のセッションがコミットされると、すべての属性が期限切れになります。 `` user.addresses``の次回のアクセスはコレクションを再ロードし、目的の状態を明らかにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address</span> <span class="ow">in</span> <span class="n">user</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">False</span></pre></div>
</div>
<p>インターセプトのためのレシピがあります：meth： <cite>.Session.delete`と自動的にこの有効期限を呼び出します。 `ExpireRelationshipOnFKChangeを参照してください&lt;http://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange&gt; `_これのために。しかし、コレクション内のアイテムを削除する通常の方法は、：meth： `〜.Session.delete`の使用を直接避け、カスケード動作を使用して、親コレクションからオブジェクトを削除した結果として自動的に削除を呼び出すことです。以下の例に示すように、 `</cite> delete-orphan``カスケードはこれを実行します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="c1"># ...</span>

    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete, delete-orphan&quot;</span><span class="p">)</span>

<span class="c1"># ...</span>

<span class="k">del</span> <span class="n">user</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></pre></div>
</div>
<p>上記の場合、 `` User.addresses``コレクションから `` Address``オブジェクトを削除すると、 `` Delete-orphan``カスケードは、 `` Address``オブジェクトを削除するために同じ方法でマークする効果がありますそれを：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.delete`に渡します。</p>
<p>`` delete-orphan``カスケードは多対1または一対一関係にも適用できるので、オブジェクトがその親から分離されたときに自動的に削除マークが付けられます。 many-to-oneまたはone-to-oneで `` delete-orphan``カスケードを使うには、この関連オブジェクトが他と共有されないというアサーションを呼び出すparamref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship.single_parent`フラグが必要です親は同時に:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">preference</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Preference&quot;</span><span class="p">,</span> <span class="n">cascade</span><span class="o">=</span><span class="s2">&quot;all, delete, delete-orphan&quot;</span><span class="p">,</span>
        <span class="n">single_parent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>上記の `` Preference``オブジェクトが `` User``から削除された場合、そのオブジェクトはflush ::で削除されます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_user</span><span class="o">.</span><span class="n">preference</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c1"># will delete the Preference object</span></pre></div>
</div>
<p>カスケードの詳細については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>unitofwork_cascades`も参照してください。</p>
</div>
<div class="section" id="deleting-based-on-filter-criterion">
<h4>フィルタ条件に基づいた削除<a class="headerlink" href="#deleting-based-on-filter-criterion" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>`` Session.delete（） <a href="#id1"><span class="problematic" id="id2">``</span></a>の警告は、削除するためにオブジェクトを手元に置く必要があるということです。クエリには、フィルタリング基準に基づいて削除するa：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.query.Query.delete`メソッドが含まれています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span></pre></div>
</div>
<p>`` Query.delete（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドには、すでに条件に一致するセッション内のオブジェクトを &amp;quot;期限切れにする&amp;quot;機能が含まれています。しかし、すでにロードされているコレクションに対して&amp;quot;delete &amp;quot;と&amp;quot;delete-orphan &amp;quot;カスケードは完全には表現されないなど、いくつかの注意点があります。詳細については、API docs：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.query.Query.delete`を参照してください。</p>
</div>
</div>
<div class="section" id="flushing">
<span id="session-flushing"></span><h3>フラッシング<a class="headerlink" href="#flushing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <cite>〜sqlalchemy.orm.session.Session`がデフォルト設定で使用されている場合、フラッシュステップはほぼ常に透過的に行われます。具体的には、クラス： `〜sqlalchemy.orm.query.Query`が発行される前に、トランザクションがコミットされる前に：meth：</cite>〜.Session.commit`の呼び出しの前にフラッシュが発生します。これは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.begin_nested`が使用されたときにSAVEPOINTが発行される前に発生します。</p>
<p>autoflushの設定にかかわらず、フラッシュを強制するには、meth： <cite>〜.Session.flush</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></pre></div>
</div>
<p>振る舞いの&amp;quot;flush-on-Query &amp;quot;は、フラグ `` autoflush = False``を使って：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`を作ることで無効にすることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">autoflush</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></pre></div>
</div>
<p>さらに、autoflushは、いつでも `` autoflush``フラグをセットすることで一時的に無効にすることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mysession</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">mysession</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span></pre></div>
</div>
<p>一部の自動フラッシュ無効化レシピは、DisableAutoFlush &lt;<a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/DisableAutoflush">http://www.sqlalchemy.org/trac/wiki/UsageRecipes/DisableAutoflush</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_。</p>
<p>：class： <cite>〜sqlalchemy.orm.session.Session`が</cite> <cite>autocommit = True``で設定されていても、セッションの永続的なトランザクション状態を無効にする設定です。トランザクションが存在しない場合、：meth： `〜.Session.flush`はそれ自身のトランザクションを作成し、それをコミットします。フラッシュ中にエラーが発生すると、トランザクションが存在する場合でも常にロールバックされます。 Sessionが `</cite> autocommit = True``モードでない場合、基底のトランザクションがすでにロールバックされていても、フラッシュが失敗した後に：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.rollback`を明示的に呼び出す必要があります。いわゆる「サブトランザクション」の全体的なネストパターンが一貫して維持されるようにします。</p>
</div>
<div class="section" id="committing">
<span id="session-committing"></span><h3>コミット<a class="headerlink" href="#committing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜.Session.commit`は、現在のトランザクションをコミットするために使用されます。それは、常に：meth： `〜。Session.flush`を発行して、残りの状態をデータベースにフラッシュします。これは&amp;quot;autoflush &amp;quot;設定とは無関係です。トランザクションが存在しない場合は、エラーが発生します。 ：class： `〜sqlalchemy.orm.session.Session`のデフォルトの動作は&amp;quot;トランザクション&amp;quot;が常に存在することです。この動作は `</cite> autocommit = True``をセットすることで無効にすることができます。自動コミットモードでは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.begin`メソッドを呼び出すことでトランザクションを開始できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ここでの「トランザクション」という用語は、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`自体のトランザクション構造を指し、0以上の実際のデータベース（DBAPI）トランザクションを維持している可能性があります。個々のDBAPI接続は、SQL文の実行に最初に使用されたときに&amp;quot;トランザクション&amp;quot;への参加を開始し、セッション・レベルの&amp;quot;トランザクション&amp;quot;が完了するまで存在し続けます。詳細はref： <a href="#id3"><span class="problematic" id="id4">`</span></a>unitofwork_transaction`を参照してください。</p>
</div>
<p>：meth： <cite>〜.Session.commit`の別の振る舞いは、デフォルトで、コミットが完了した後に存在するすべてのインスタンスの状態を失効させるということです。これは、インスタンスが次回アクセスされるときに、属性アクセスまたはa：class： `〜sqlalchemy.orm.query.Query`の結果セットに存在する場合に、それらは最も新しい状態を受け取るようになっています。この動作を無効にするには、 `</cite> expire_on_commit = False``で：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sessionmaker`を設定してください。</p>
<p>通常、：class： <cite>〜sqlalchemy.orm.session.Session`にロードされたインスタンスは、後続のクエリによって決して変更されません。現在のトランザクションは分離されているため、トランザクションが継続されている限り、直前にロードされた状態は正しいと仮定します。 `</cite> autocommit = True``を設定することは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session`はトランザクションが存在しないことを除いて、属性状態に関してまったく同じように動作するので、このモデルに対してある程度は機能します。</p>
</div>
<div class="section" id="rolling-back">
<span id="session-rollback"></span><h3>ロールバック<a class="headerlink" href="#rolling-back" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.rollback`は、現在のトランザクションをロールバックします。デフォルトの構成セッションでは、セッションのポストロールバック状態は次のようになります。</p>
<blockquote>
<div><ul class="simple">
<li>セッションがConnectionに直接バインドされている場合を除き、すべてのトランザクションがロールバックされ、すべての接続が接続プールに返されます。この場合、接続はまだ維持されますが、ロールバックされます。</li>
<li>最初に* pending <a href="#id1"><span class="problematic" id="id2">*</span></a>状態にあったオブジェクトは、トランザクションの有効期間内に：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.session.Session`に追加されたときに、それらのINSERT文がロールバックされることに対応して、削除されます。属性の状態は変更されません。</li>
<li>トランザクションの有効期間内に* deleted <em>とマークされたオブジェクトは、DELETE文がロールバックされることに応じて</em> persistent <a href="#id1"><span class="problematic" id="id2">*</span></a>状態に戻されます。これらのオブジェクトがトランザクション内で最初に保留中だった場合は、その操作が優先されます。</li>
<li>期限切れでないオブジェクトはすべて期限切れです。</li>
</ul>
</div></blockquote>
<p>その状態を理解すると、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session`は、ロールバックが発生しても安全に使用を続けることができます。</p>
<p>プライマリキー、外部キー、またはnullではない制約違反のような理由で、：meth： <cite>〜.Session.flush`が失敗すると、：meth：</cite>〜.Session.rollback`が自動的に発行されます現在部分的な障害の後でフラッシュを継続することは不可能です）。しかし、フラッシュ・プロセスは、常に*：サブトランザクション*と呼ばれる独自のトランザクション・デマレーターを使用します。これについては、class： <cite>〜sqlalchemy.orm.session.Session`のdocstringで詳しく説明しています。つまり、データベーストランザクションがロールバックされても、エンドユーザーは：meth： `〜.Session.rollback`を発行して：class：</cite>〜sqlalchemy.orm.sessionの状態を完全にリセットする必要があります。セッション &amp;#39;。</p>
</div>
<div class="section" id="closing">
<h3>閉鎖<a class="headerlink" href="#closing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜.Session.close`メソッドは、：meth：</cite>〜.Session.expunge_all`を発行し、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>任意のトランザクション/接続リソースを解放します。接続プールに接続が戻されると、トランザクション状態もロールバックされます。</p>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="session.html" title="previous chapter">セッションの使用</a>
        Next:
        <a href="session_state_management.html" title="next chapter">状態管理</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



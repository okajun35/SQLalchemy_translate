<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    継承階層のロード
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="オブジェクトの読み込み" href="loading_objects.html" />
        <link rel="next" title="コンストラクタとオブジェクトの初期化" href="constructors.html" />
        <link rel="prev" title="関係の読み込み手法" href="loading_relationships.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="loading_columns.html">列の読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_relationships.html">関係の読み込み手法</a></span></li>
<li class="selected"><span class="link-container first"><strong>継承階層のロード</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-with-polymorphic">with_polymorphicの使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-aliasing-with-with-polymorphic">with_polymorphicでのエイリアシングの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#referring-to-specific-subclass-attributes">特定のサブクラス属性の参照</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#setting-with-polymorphic-at-mapper-configuration-time">マッパー設定時にwith_polymorphicを設定する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#setting-with-polymorphic-against-a-query">with_polymorphicをクエリに対して設定する</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#polymorphic-selectin-loading">多型セレクチンのローディング</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#combining-selectin-and-with-polymorphic">selectinとwith_polymorphicの組み合わせ</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#referring-to-specific-subtypes-on-relationships">関係の特定のサブタイプを参照する</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#eager-loading-of-specific-or-polymorphic-subtypes">特定または多型サブタイプのEager読み込み</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#loading-objects-with-joined-table-inheritance">テーブル継承を結合したオブジェクトのロード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#loading-objects-with-single-table-inheritance">1つのテーブル継承を持つオブジェクトのロード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#inheritance-loading-api">継承ロードAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="constructors.html">コンストラクタとオブジェクトの初期化</a></span></li>
<li><span class="link-container first"><a class="reference external" href="query.html">クエリAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="loading-inheritance-hierarchies">
<span id="inheritance-loading-toplevel"></span><h1>継承階層のロード<a class="headerlink" href="#loading-inheritance-hierarchies" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>inheritance_toplevel`で説明されているように継承階層で&amp;quot; joined &amp;quot;、&amp;quot; single &amp;quot;、&amp;quot; concrete &amp;quot;テーブルの継承スタイルを使用してマッピングされている場合、通常の動作は、サブクラスに対応するオブジェクトも生成されます。単一の問合せが結果クラスごとに異なるクラスまたはサブクラスを持つ結果を返すことができる場合は、「ポリモーフィック・ロード」という用語を使用します。</p>
<p>多相ローディングの領域内、特に結合された単一のテーブル継承では、サブクラス属性を前に照会し、後でロードするという追加の問題があります。特定のサブクラスの属性が前面に照会されると、それを照会でフィルターにかけることができ、オブジェクトを戻すときにもロードされます。正面まで問い合わせなければ、最初にアクセスする必要があるときに後で読み込まれます。この動作の基本的な制御は、：func： <cite>.orm.with_polymorphic`関数と、マッパー設定の2つのバリエーション、paramref：</cite> .mapper.with_polymorphic`と：paramref： <cite>.mapper.polymorphic_load `オプション、：class：</cite> .Query` -level：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.with_polymorphic`メソッドです。 &amp;quot;with_polymorphic &amp;quot;ファミリは、クエリ内に特定の基本クラスのどの特定のサブクラスを含めるかを指定する手段を提供します。これは、SELECTで使用できる列とテーブルを示します。</p>
<div class="section" id="using-with-polymorphic">
<span id="with-polymorphic"></span><h2>with_polymorphicの使用<a class="headerlink" href="#using-with-polymorphic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のセクションでは、ref： <cite>inheritance_toplevel`に導入された</cite> <cite>Employee`</cite> /` <cite>Engineer`</cite> /` <a href="#id1"><span class="problematic" id="id2">`</span></a>Manager``の例を想定しています。</p>
<p>通常、a：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`が継承階層の基本クラスを指定すると、その基本クラスに対してローカルな列だけが照会されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上では、単一テーブル継承と結合テーブル継承の両方で、 `` Employee``にローカルな列だけがSELECTに存在します。 `` Engineer``や `` Manager``のインスタンスを返すかもしれませんが、最初にアクセスするまで追加の属性をロードすることはありません。その時点で遅延ロードが発生します。</p>
<p>同様に、 `` Engineer``や `` Manager``にマップされたクエリを `` Employee``に照らして照会したい場合、これらのカラムは単一の継承ケースまたは結合されたテーブルの継承ケースでは直接利用できません。 `` Employee``エンティティはこれらの列を参照しないので（単一テーブルの継承の場合、Declarativeが使用される場合は一般的ですが、古典的なマッピングの場合は一般的ではないことに注意してください）。</p>
<p>これらの問題を解決するため、：func： <cite>.orm.with_polymorphic`関数は、サブクラス間の列の範囲を表す特別な：class：</cite> .AliasedClass`を提供します。このオブジェクトは他のエイリアスと同様に、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`で使用できます。照会すると、与えられたクラスに存在するすべての列を表します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span>

<span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span></pre></div>
</div>
<p>上記のマッピングが結合テーブルの継承を使用していた場合、上記のSELECTステートメントは次のようになります。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT employee.id AS employee_id,
    engineer.id AS engineer_id,
    manager.id AS manager_id,
    employee.name AS employee_name,
    employee.type AS employee_type,
    engineer.engineer_info AS engineer_engineer_info,
    manager.manager_data AS manager_manager_data
FROM employee
    LEFT OUTER JOIN engineer
    ON employee.id = engineer.id
    LEFT OUTER JOIN manager
    ON employee.id = manager.id
[]</div></pre></div>
</div>
<p>上記の場合、&amp;quot;engineer &amp;quot;と&amp;quot;manager &amp;quot;の追加テーブル/列が含まれています。単一のテーブル継承の場合も同様の動作が発生します。</p>
<p>：func： <cite>.orm.with_polymorphic`は、単一のクラスまたはマッパー、クラス/マッパーのリスト、またはすべてのサブクラスを示す文字列</cite> <cite>&amp;#39;*&amp;#39;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を受け取ります：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="c1"># include columns for Engineer</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">)</span>

<span class="c1"># include columns for Engineer, Manager</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="c1"># include columns for all mapped subclasses</span>
<span class="n">entity</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span></pre></div>
</div>
<div class="section" id="using-aliasing-with-with-polymorphic">
<h3>with_polymorphicでのエイリアシングの使用<a class="headerlink" href="#using-aliasing-with-with-polymorphic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.orm.with_polymorphic`関数は、多相選択可能オブジェクト自体の&amp;quot;エイリアシング&amp;quot;も提供します。つまり、同じクラス階層を参照する2つの異なる：func：</cite> .orm.with_polymorphic`エンティティを一緒に使用できます。これは、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic.aliased`フラグを使って利用できます。複数の表にまたがるポリモーフィック選択可能な場合、デフォルトの振る舞いは選択可能項目をサブクエリにラップすることです。以下では、同じ名前を持つ従業員の&amp;quot;従業員またはエンジニア&amp;quot;とペアになった&amp;quot;従業員またはマネージャ&amp;quot;を選択するクエリを発行します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engineer_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">],</span> <span class="n">aliased</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">manager_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">],</span> <span class="n">aliased</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">engineer_employee</span><span class="p">,</span> <span class="n">manager_employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span>
        <span class="n">manager_employee</span><span class="p">,</span>
        <span class="n">and_</span><span class="p">(</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
<span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT
    anon_1.employee_id AS anon_1_employee_id,
    anon_1.employee_name AS anon_1_employee_name,
    anon_1.employee_type AS anon_1_employee_type,
    anon_1.engineer_id AS anon_1_engineer_id,
    anon_1.engineer_engineer_name AS anon_1_engineer_engineer_name,
    anon_2.employee_id AS anon_2_employee_id,
    anon_2.employee_name AS anon_2_employee_name,
    anon_2.employee_type AS anon_2_employee_type,
    anon_2.manager_id AS anon_2_manager_id,
    anon_2.manager_manager_name AS anon_2_manager_manager_name
FROM (
    SELECT
        employee.id AS employee_id,
        employee.name AS employee_name,
        employee.type AS employee_type,
        engineer.id AS engineer_id,
        engineer.engineer_name AS engineer_engineer_name
    FROM employee
    LEFT OUTER JOIN engineer ON employee.id = engineer.id
) AS anon_1
JOIN (
    SELECT
        employee.id AS employee_id,
        employee.name AS employee_name,
        employee.type AS employee_type,
        manager.id AS manager_id,
         manager.manager_name AS manager_manager_name
    FROM employee
    LEFT OUTER JOIN manager ON employee.id = manager.id
) AS anon_2
ON anon_1.employee_id &gt; anon_2.employee_id
AND anon_1.employee_name = anon_2.employee_name</div></pre></div>
</div>
<p>上記のサブクエリの作成は非常に冗長です。 2つの異なるクエリの最適なカプセル化を作成しますが、非効率的な場合があります。 ：func： <cite>.orm.with_polymorphic`は、この状況を助けるための追加のフラグを含みます：paramref：</cite> .orm.with_polymorphic.flat`：サブクエリ/ジョインの組み合わせをストレートジョインにフラット化し、代わりに個々のテーブル。設定：paramref： <cite>.orm.with_polymorphic.flat`は：paramref：</cite> .orm.with_polymorphic.aliased`を意味するので、フラグは1つだけ必要です。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engineer_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">],</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">manager_employee</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
    <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">],</span> <span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">engineer_employee</span><span class="p">,</span> <span class="n">manager_employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span>
        <span class="n">manager_employee</span><span class="p">,</span>
        <span class="n">and_</span><span class="p">(</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">engineer_employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">manager_employee</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>
<span class="p">)</span>
<span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT
    employee_1.id AS employee_1_id,
    employee_1.name AS employee_1_name,
    employee_1.type AS employee_1_type,
    engineer_1.id AS engineer_1_id,
    engineer_1.engineer_name AS engineer_1_engineer_name,
    employee_2.id AS employee_2_id,
    employee_2.name AS employee_2_name,
    employee_2.type AS employee_2_type,
    manager_1.id AS manager_1_id,
    manager_1.manager_name AS manager_1_manager_name
FROM employee AS employee_1
LEFT OUTER JOIN engineer AS engineer_1
ON employee_1.id = engineer_1.id
JOIN (
    employee AS employee_2
    LEFT OUTER JOIN manager AS manager_1
    ON employee_2.id = manager_1.id
)
ON employee_1.id &gt; employee_2.id
AND employee_1.name = employee_2.name</div></pre></div>
</div>
<p>上記の注意：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic.flat`を使用すると、結合されたテーブルの継承と組み合わせて使用​​することがよくあります。これは、ステートメント内で正しいネストされたJOINを取得します。事実上すべての現代のデータベースバージョンでこの構文がサポートされていますが、一部の古いデータベース、特に古いバージョンのSQLiteではこの構文に問題がある可能性があります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：paramref： <cite>.orm.with_polymorphic.flat`フラグは、** paramref：</cite> .with_polymorphic`と** joined table inheritance <a href="#id1"><span class="problematic" id="id2">**</span></a>の使用にのみ適用されます。：paramref： <a href="#id3"><span class="problematic" id="id4">`</span></a>.with_polymorphic.selectable`引数が**の場合使用されていない。</p>
</div>
</div>
<div class="section" id="referring-to-specific-subclass-attributes">
<h3>特定のサブクラス属性の参照<a class="headerlink" href="#referring-to-specific-subclass-attributes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.orm.with_polymorphic`によって返されるエンティティは、：class：</cite> .AliasedClass`オブジェクトです。これは、他のエイリアスと同様に：class： <cite>.Query`で使用できます。 「従業員」クラス。前の例では、 `</cite> eng_plus_manager``は上記の3-way外部結合を参照するために使用するエンティティになります。また、クラスのリストに名前が付けられた各クラスの名前空間も含まれているため、それらのサブクラスに固有の属性も呼び出すことができます。次の例は、 `` Engineer``と `` Manager``に固有の属性を `` eng_plus_manager``で呼び出す方法を示しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">or_</span><span class="p">(</span>
                    <span class="n">eng_plus_manager</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                    <span class="n">eng_plus_manager</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span><span class="o">==</span><span class="s1">&#39;y&#39;</span>
                <span class="p">)</span>
            <span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="setting-with-polymorphic-at-mapper-configuration-time">
<span id="with-polymorphic-mapper-config"></span><h3>マッパー設定時にwith_polymorphicを設定する<a class="headerlink" href="#setting-with-polymorphic-at-mapper-configuration-time" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.orm.with_polymorphic`関数は、サブクラステーブルからの属性の読み込みを可能にする目的と、クエリ時にサブクラステーブルの属性を参照する機能を提供します。歴史的には、列の熱心な読み込みは、方程式のより重要な部分でした。したがって、関係のための熱心な読み込みをコンフィグレーションオプションとして指定することができるように、：paramref： `.mapper.with_polymorphic`設定パラメータは、エンティティがデフォルトで多態的な読み込みを使用できるようにします。最初にref： `joined_inheritance</cite> ::で導入した` <a href="#id1"><span class="problematic" id="id2">`</span></a>Employee``マッピングにパラメータを追加することができます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span>
        <span class="s1">&#39;with_polymorphic&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
    <span class="p">}</span></pre></div>
</div>
<p>上記は共通の設定です：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.mapper.with_polymorphic`はすべてのサブクラス列をロードするアスタリスクを示します。結合された表の継承の場合、このオプションは、マッピングが常に（多くの場合、大きな）一連のLEFT OUTER JOINを多くの表に放出することを暗に意味するため、控えめに使用する必要があります。単一テーブルの継承では、アスタリスクを指定することはしばしば良い考えです。なぜなら、ロードは依然として単一のテーブルに対してのみですが、サブクラスにマップされた列の追加の遅延負荷が防止されるからです。</p>
<p>：func： <cite>.orm.with_polymorphic`または：meth：</cite> .Query.with_polymorphic`を使うと、マッパーレベル：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.mapper.with_polymorphic`の設定が上書きされます。</p>
<p>：paramref： <cite>.mapper.with_polymorphic`オプションは、func：</cite> .orm.with_polymorphic`のようなクラスのリストを受け入れて、クラスのサブセット間で多態的にロードします。ただし、Declarativeを使用する場合は、追加するサブクラスがまだ使用できないため、このリストにクラスを提供することは直接できません。代わりに、各サブクラスで、デフォルトで：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.mapper.polymorphic_load`パラメータを使用して、多型ロードに個別に関与する必要があることを指定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;inline&#39;</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;inline&#39;</span>
    <span class="p">}</span></pre></div>
</div>
<p>：paramref： <cite>.mapper.polymorphic_load`パラメータを値</cite> <cite>&amp;quot; inline &amp;quot;</cite> <cite>に設定すると、上記の</cite> <cite>Engineer``と</cite> <cite>Manager``クラスは&amp;quot;多形性ロード &amp;quot;の一部です。 ：class：paramref： `.mapper.with_polymorphic`クラスに追加されたかのように、デフォルトで</cite> <cite>Employee``クラスの</cite></p>
</div>
<div class="section" id="setting-with-polymorphic-against-a-query">
<h3>with_polymorphicをクエリに対して設定する<a class="headerlink" href="#setting-with-polymorphic-against-a-query" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.orm.with_polymorphic`関数は、クエリレベルのメソッド：meth：</cite> .Query.with_polymorphic`から進化しました。このメソッドは：func： <cite>.orm.with_polymorphic`と同じ目的を持っていますが、：class：</cite> .Query`の最初のエンティティにのみ適用されるという点で、その使用パターンに柔軟性があります。次に、そのエンティティのすべての発生に対して有効になるので、エイリアスオブジェクトを使用するのではなく、エンティティ（およびそのサブクラス）を直接参照できます。単純なケースの場合、より簡潔であると考えられるかもしれません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">with_polymorphic</span><span class="p">([</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span>
        <span class="n">or_</span><span class="p">(</span>
            <span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
            <span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span><span class="o">==</span><span class="s1">&#39;q&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.Query.with_polymorphic`メソッドは、</cite> <cite>Engineer``や</cite> <cite>Manager``のようなエンティティを適切に変換する必要があるため、：func：</cite> .orm.with_polymorphic`関数よりも複雑です。他のエンティティに干渉することはありません。柔軟性が欠けている場合は、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic`を使用します。</p>
</div>
</div>
<div class="section" id="polymorphic-selectin-loading">
<span id="polymorphic-selectin"></span><h2>多型セレクチンのローディング<a class="headerlink" href="#polymorphic-selectin-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主に結合されたテーブルの継承を使用する場合、継承マッピングで追加のサブクラスを読み込むために：func： <cite>.orm.with_polymorphic`ファミリの関数を使用する代わりに、多形&amp;quot; selectin &amp;quot;ロードを使用することができます。これは、関係ロードの：ref： `selectin_eager_loading`機能と同様に動作する熱心なローディング機能です。サンプルマッピングが与えられた場合、：func： `.orm.selectin_polymorphic`ローダーオプションを使用して、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Employee``のロードにサブクラスごとに追加のSELECTを出すように指示できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">selectin_polymorphic</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">])</span>
<span class="p">)</span></pre></div>
</div>
<p>上記のクエリが実行されると、2つの追加のSELECTステートメントが発行されます。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><div class='show_sql'>query.all()
SELECT
    employee.id AS employee_id,
    employee.name AS employee_name,
    employee.type AS employee_type
FROM employee
()

SELECT
    engineer.id AS engineer_id,
    employee.id AS employee_id,
    employee.type AS employee_type,
    engineer.engineer_name AS engineer_engineer_name
FROM employee JOIN engineer ON employee.id = engineer.id
WHERE employee.id IN (?, ?) ORDER BY employee.id
(1, 2)

SELECT
    manager.id AS manager_id,
    employee.id AS employee_id,
    employee.type AS employee_type,
    manager.manager_name AS manager_manager_name
FROM employee JOIN manager ON employee.id = manager.id
WHERE employee.id IN (?) ORDER BY employee.id
(3,)</div></pre></div>
</div>
<p>同様に：paramref： <cite>.mapper.polymorphic_load`パラメータを指定して、デフォルトで行われる上記のロードスタイルを、サブクラスごとに</cite> <cite>&amp;quot; selectin &amp;quot;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を使って設定することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;employee&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span> <span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">engineer_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;manager&#39;</span><span class="p">,</span>
    <span class="p">}</span></pre></div>
</div>
<p>：func： <cite>.orm.with_polymorphic`を使用する場合とは異なり、：func：</cite> .orm.selectin_polymorphic`スタイルの読み込みを使用する場合、私たちは `` Engineer``または `` Engineer``を参照する能力を持っていません。これらのエンティティは結果を特定するために使用される最初のクエリには存在しないため、フィルタ、オーダー、またはその他の基準としてメインクエリ内の「マネージャ」エンティティを削除します。しかし、セカンダリSELECTが発行されたときに有効になる `` Engineer``または `` Manager``に適用されるローダオプションを適用できます。以下では、 <a href="#id1"><span class="problematic" id="id2">``</span></a>マネージャー <a href="#id3"><span class="problematic" id="id4">``</span></a>と <a href="#id5"><span class="problematic" id="id6">``</span></a>マネージャー・ペーパーワーク <a href="#id7"><span class="problematic" id="id8">``</span></a>という追加の関係があり、私たちも熱心にロードしたいと思っています。 ：func： <a href="#id9"><span class="problematic" id="id10">`</span></a>.joinedload`関数を介してeagerにロードするなど、あらゆるタイプのeagerロードを使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">joinedload</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">selectin_polymorphic</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">]),</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Manager</span><span class="o">.</span><span class="n">paperwork</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記のクエリを使用すると、3つのSELECT文が発行されますが、 `` Manager``に対するものは次のようになります。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">manager_id</span><span class="p">,</span>
    <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span>
    <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span><span class="p">,</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">manager_name</span> <span class="k">AS</span> <span class="n">manager_manager_name</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">paperwork_1_id</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="n">manager_id</span> <span class="k">AS</span> <span class="n">paperwork_1_manager_id</span><span class="p">,</span>
    <span class="n">paperwork_1</span><span class="p">.</span><span class="k">data</span> <span class="k">AS</span> <span class="n">paperwork_1_data</span>
<span class="k">FROM</span> <span class="n">employee</span> <span class="k">JOIN</span> <span class="n">manager</span> <span class="k">ON</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">paperwork</span> <span class="k">AS</span> <span class="n">paperwork_1</span>
<span class="k">ON</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">paperwork_1</span><span class="p">.</span><span class="n">manager_id</span>
<span class="k">WHERE</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,)</span></pre></div>
</div>
<p>セレクチン多型負荷は、セレクチン関係負荷と同様の警告を有することに留意されたい。複合主キーを使用するエンティティでは、使用されているデータベースは、現在MySQLとPostgreSQLで動作することが知られている&amp;quot;IN &amp;quot;のタプルをサポートしている必要があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">selectin多型ロード機能は、1.2シリーズの初期リリースでは**実験的**とみなされるべきです。</p>
</div>
<div class="section" id="combining-selectin-and-with-polymorphic">
<span id="polymorphic-selectin-and-withpoly"></span><h3>selectinとwith_polymorphicの組み合わせ<a class="headerlink" href="#combining-selectin-and-with-polymorphic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">1.2.0b3から動作します</p>
</div>
<p>注意深い計画では、&amp;quot;with_polymorphic &amp;quot;を使用する階層に対してselectinローディングを適用できます。特定のユースケースはselectinの読み込みを使用して継承継承サブテーブルをロードすることです。この継承サブテーブルは継承サブテーブルまたは単一テーブル継承のサブクラスを参照するために&amp;quot;with_polymorphic &amp;quot;を使用します。単一テーブル継承を使用して `` Manager`を拡張したクラス `` VicePresident``を追加した場合、 `` Manager``のロードでも `` VicePidentident``サブタイプを同時に読み込むことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># use &quot;Employee&quot; example from the enclosing section</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_load&#39;</span><span class="p">:</span> <span class="s1">&#39;selectin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span> <span class="s1">&#39;manager&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">VicePresident</span><span class="p">(</span><span class="n">Manager</span><span class="p">):</span>
    <span class="n">vp_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;polymorphic_load&quot;</span><span class="p">:</span> <span class="s2">&quot;inline&quot;</span><span class="p">,</span>
        <span class="s2">&quot;polymorphic_identity&quot;</span><span class="p">:</span> <span class="s2">&quot;vp&quot;</span>
    <span class="p">}</span></pre></div>
</div>
<p>上記では、 `` VicePresident``サブクラスの `` manager``テーブルに `` vp_info``カラムを追加しています。このサブクラスは、このデータを持つ行を参照する多相識別情報 `` &amp;quot;vp &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>にリンクされています。ロードスタイルを&amp;quot;inline &amp;quot;に設定すると、 `` Manager``オブジェクトのロードによって、同じSELECT文で `` vp_info``カラムが照会されるようになります。 `` Employee``に対する `` Manager``行に遭遇するクエリは、以下のように出力されます：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">employee</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">employee_name</span><span class="p">,</span>
       <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span>
<span class="k">FROM</span> <span class="n">employee</span>
<span class="p">)</span>

<span class="k">SELECT</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">manager_id</span><span class="p">,</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">employee_id</span><span class="p">,</span>
       <span class="n">employee</span><span class="p">.</span><span class="k">type</span> <span class="k">AS</span> <span class="n">employee_type</span><span class="p">,</span>
       <span class="n">manager</span><span class="p">.</span><span class="n">manager_name</span> <span class="k">AS</span> <span class="n">manager_manager_name</span><span class="p">,</span>
       <span class="n">manager</span><span class="p">.</span><span class="n">vp_info</span> <span class="k">AS</span> <span class="n">manager_vp_info</span>
<span class="k">FROM</span> <span class="n">employee</span> <span class="k">JOIN</span> <span class="n">manager</span> <span class="k">ON</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">employee</span><span class="p">.</span><span class="n">id</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span></pre></div>
</div>
<p>&amp;quot;selectin &amp;quot;ポリモリックな読み込みとquery-time：func： <cite>.orm.with_polymorphic`の使い方も可能です（これは非常に外側のものですが）。上記のマッピングに `</cite> polymorphic_load``が設定されていないと仮定すると、次のような結果が得られます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span><span class="p">,</span> <span class="n">selectin_polymorphic</span>

<span class="n">manager_poly</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Manager</span><span class="p">,</span> <span class="p">[</span><span class="n">VicePresident</span><span class="p">])</span>

<span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectin_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">manager_poly</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
</div>
</div>
<div class="section" id="referring-to-specific-subtypes-on-relationships">
<span id="inheritance-of-type"></span><h2>関係の特定のサブタイプを参照する<a class="headerlink" href="#referring-to-specific-subtypes-on-relationships" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>a：func： <cite>.relationship &amp;#39;に対応するマップされた属性は、2つのマッピング間のリンケージを参照するためにクエリで使用されます。これの一般的な使い方は、：meth： `.Query.join`と：func：</cite> .joinedload`のようなローダーオプションの中の：func： <cite>.relationship`を参照することです。ターゲットクラスが継承階層である場合、：func： `.relationship`を使用する場合、APIは、結合、eager load、または他のリンケージが特定のサブクラス、エイリアス、または：func：</cite> .orm.with_polymorphic`エイリアスをターゲットにすることを許可します：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`によって直接ターゲットとされるクラスではなく、そのクラス階層のクラスです。</p>
<p>：func： <cite>〜sqlalchemy.orm.interfaces.PropComparator.of_type`メソッドは：func：</cite>〜sqlalchemy.orm.relationship`のパスに沿ってジョインを構築し、特定の派生エイリアスやサブクラスに基準を絞り込みます。 `` employees``テーブルが `` Company``オブジェクトに関連付けられた従業員の集合を表すとします。 `` employees``テーブルに `` company_id``カラムと `` companies``という新しいテーブルを追加します：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Company</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;company&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span>
                    <span class="n">backref</span><span class="o">=</span><span class="s1">&#39;company&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
    <span class="n">company_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;company.id&#39;</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span><span class="p">,</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">engineer_info</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;manager&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span><span class="p">}</span></pre></div>
</div>
<p>`` Company``から `` Employee``関係に問い合わせるときは、：meth： <cite>.Query.join`メソッドと：meth：</cite> .PropComparator.any`と：meth： <cite>.PropComparatorのような演算子があります。 ``エンジニア ``や ``マネージャー `&amp;#39;を含めずに</cite> <cite>会社&amp;#39;</cite> <cite>従業員</cite> <cite>に参加することになる。具体的に `</cite> Engineer``クラスに対して基準を設定したい場合、それらのメソッドに：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.orm.interfaces.PropComparator.of_typeを使ってサブクラスを表す列の集合にサブクラス化するかサブクエリするように指示できます`演算子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">))</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;someinfo&#39;</span><span class="p">)</span></pre></div>
</div>
<p>同様に、 `` Company``から `` Engineer``と `` Manager``カラムの両方を含む多相エンティティに参加する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">manager_and_engineer</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
                            <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">])</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">))</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span>
        <span class="n">or_</span><span class="p">(</span>
            <span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span> <span class="o">==</span> <span class="s1">&#39;someinfo&#39;</span><span class="p">,</span>
            <span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span> <span class="o">==</span> <span class="s1">&#39;somedata&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.PropComparator.any`と：meth：</cite> .PropComparator.has`演算子は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.interfaces.PropComparator.of_type`で使用することもできます。組み込み基準がサブクラスの用語:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span>
            <span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">engineer_info</span><span class="o">==</span><span class="s1">&#39;someinfo&#39;</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<div class="section" id="eager-loading-of-specific-or-polymorphic-subtypes">
<span id="eagerloading-polymorphic-subtypes"></span><h3>特定または多型サブタイプのEager読み込み<a class="headerlink" href="#eager-loading-of-specific-or-polymorphic-subtypes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.joinedload</cite>、：func：` .subqueryload`、：func： <cite>.contains_eager`などのeagerloaderオプションは：func：</cite>〜.PropComparator.of_type`を利用するパスをサポートします。以下では、関連する `` Engineer``オブジェクトを熱心に読み込み、 `` employee``と `` engineer``テーブルを同時に照会しながら、 `` Company``行を読み込みます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Engineer</span><span class="p">))</span><span class="o">.</span>
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">machines</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.Query.join`の場合と同じように、：meth：</cite>〜.PropComparator.of_type`を使用してeager loadingと：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic`を組み合わせることができます。すべての参照されたサブタイプを読み込むことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">manager_and_engineer</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span>
                            <span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Manager</span><span class="p">,</span> <span class="n">Engineer</span><span class="p">],</span>
                            <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">joinedload</span><span class="p">(</span>
            <span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：func： <cite>.joinedload`と一緒に：func：</cite> .with_polymorphic`を使用する場合、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.with_polymorphic`オブジェクトは：class：<a href="#id3"><span class="problematic" id="id4">`</span></a>のインスタンスである&amp;quot;エイリアス化された&amp;quot;オブジェクトに対抗する必要があります。エイリアス（alias）」を使用して、多型選択可能なエイリアスがエイリアス化されるようにする（そうでなければ情報メッセージが発生する）。</p>
<p class="last">これを行う典型的な方法は：paramref： <cite>.with_polymorphic.aliased`または：paramref：</cite> .flat`フラグを含めることです。このフラグはこのエイリアシングを自動的に適用します。ただし、：paramref： <cite>.with_polymorphic.selectable`引数が既に：class：</cite> .Alias`オブジェクトのオブジェクトを渡すために使用されている場合、このフラグは設定されません**。 &amp;quot;flat &amp;quot;オプションは&amp;quot;エイリアス&amp;quot;オプションを意味し、より少ないサブクエリを生成する結合オブジェクトに対するエイリアシングの代替形式です。</p>
</div>
<p>いったん：meth： <cite>〜.PropComparator.of_type`が熱心なロードのターゲットであれば、元のクラスや派生クラスではなく、後続の連鎖に使用するエンティティです。 eager-loadedの `</cite> Engineer``クラスのコレクションをさらに熱心にロードしたい場合、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic`オブジェクトの名前空間からこのクラスにアクセスします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">joinedload</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">subqueryload</span><span class="p">(</span><span class="n">manager_and_engineer</span><span class="o">.</span><span class="n">Engineer</span><span class="o">.</span><span class="n">computers</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
</div>
</div>
<div class="section" id="loading-objects-with-joined-table-inheritance">
<span id="loading-joined-inheritance"></span><h2>テーブル継承を結合したオブジェクトのロード<a class="headerlink" href="#loading-objects-with-joined-table-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>結合テーブルの継承を使用する場合、継承セクションの &amp;quot;Engineer&amp;quot;のような2つのテーブルのJOINを表す特定のサブクラスをクエリすると、SQLはjoin</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上記のクエリは次のようにSQLを出力します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><div class='show_sql'>
SELECT employee.id AS employee_id,
    employee.name AS employee_name, employee.type AS employee_type,
    engineer.name AS engineer_name
FROM employee JOIN engineer
ON employee.id = engineer.id</div></pre></div>
</div>
<p>`` Engineer``オブジェクトのコレクションを取得します。これには、 `` employee``と `` engineer``のすべての列がロードされます。</p>
<p>しかし、基本クラスに対して：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を発行するとき、その動作は基本テーブル:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上の例では、デフォルトの動作は `` employee``テーブルのみからのSELECTであり、前の例では `` sub &amp;#39;&amp;quot;テーブル（` <cite>engineer``と</cite> <cite>manager`</cite>）からではありません。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><div class='show_sql'>
SELECT employee.id AS employee_id,
    employee.name AS employee_name, employee.type AS employee_type
FROM employee
[]</div></pre></div>
</div>
<p>クエリから `` Employee``オブジェクトのコレクションが返され、 `` engineer``または `` manager``の子テーブルで表される `` Employee``オブジェクトから属性が要求されると、データがまだロードされていなければ、関連する行の列に対する2番目のロードが発行されます。上のように、オブジェクトにアクセスした後、さらに次の行に沿って発行されたSQLが表示されます。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><div class='show_sql'>
SELECT manager.id AS manager_id,
    manager.manager_data AS manager_manager_data
FROM manager
WHERE ? = manager.id
[5]
SELECT engineer.id AS engineer_id,
    engineer.engineer_info AS engineer_engineer_info
FROM engineer
WHERE ? = engineer.id
[2]</div></pre></div>
</div>
<p>：func： <cite>.orm.with_polymorphic`関数とそれに関連する設定オプションは、条件付きで</cite> <cite>employee`</cite>、` <cite>engineer`</cite>、` <a href="#id1"><span class="problematic" id="id2">`</span></a>manager``に対して条件付きでロードするJOIN upフロントを放出することができますリレーションシップのための結合されたeagerローディングのように、エンティティごとの2番目のロードの必要性を取り除きます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">with_polymorphic</span>

<span class="n">eng_plus_manager</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="p">[</span><span class="n">Engineer</span><span class="p">,</span> <span class="n">Manager</span><span class="p">])</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">eng_plus_manager</span><span class="p">)</span></pre></div>
</div>
<p>上の例は、 `` employee``テーブルを `` engineer``と `` manager``テーブルの両方にジョインするクエリを生成します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT employee.id AS employee_id,
    engineer.id AS engineer_id,
    manager.id AS manager_id,
    employee.name AS employee_name,
    employee.type AS employee_type,
    engineer.engineer_info AS engineer_engineer_info,
    manager.manager_data AS manager_manager_data
FROM employee
    LEFT OUTER JOIN engineer
    ON employee.id = engineer.id
    LEFT OUTER JOIN manager
    ON employee.id = manager.id
[]</div></pre></div>
</div>
<p>セクション：ref： <cite>with_polymorphic`では：func：</cite> .orm.with_polymorphic`関数とその構成バリアントについて説明しています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>with_polymorphic</cite></p>
</div>
</div>
<div class="section" id="loading-objects-with-single-table-inheritance">
<span id="loading-single-inheritance"></span><h2>1つのテーブル継承を持つオブジェクトのロード<a class="headerlink" href="#loading-objects-with-single-table-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>現代の宣言型では、単一の継承マッピングが生成されます：class： <cite>.Column`オブジェクトは、サブクラスのみにマップされ、スーパークラスからは利用できません。例：ref： `single_inheritance`の例では、</cite> <cite>Manager``マッピングには：class：</cite> .Column`が指定されています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Manager</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">manager_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;manager&#39;</span>
    <span class="p">}</span></pre></div>
</div>
<p>上記の場合、 `` employee``テーブルに `` manager_data``カラムがあっても、 `` Employee.manager_data``属性はありません。 `` Manager``に対するクエリは、 `` Manager``オブジェクトだけに行を制限するIN句と同様に、このカラムをクエリに含めます：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Manager</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT
    employee.id AS employee_id,
    employee.name AS employee_name,
    employee.type AS employee_type,
    employee.manager_data AS employee_manager_data
FROM employee
WHERE employee.type IN (?)

(&#39;manager&#39;,)</div></pre></div>
</div>
<p>しかし、結合されたテーブルの継承と同様に、 `` Employee``に対するクエリは、 `` Employee``にマップされたカラムに対してのみクエリを実行します：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT employee.id AS employee_id,
    employee.name AS employee_name,
    employee.type AS employee_type
FROM employee</div></pre></div>
</div>
<p>私たちの結果から `` Manager``のインスタンスを取り戻せば、 `` Manager``にのみマップされた追加のカラムにアクセスすることは、継承継承と同様に、それらのカラムに遅延ロードを発生させます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT employee.manager_data AS employee_manager_data
FROM employee
WHERE employee.id = ? AND employee.type IN (?)</pre></div>
</div>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_polymorphic`関数は、単一継承の場合継承継承と同様の役割を果たします。 OUTER JOIN ::を使用するオーバーヘッドがなくても、サブクラス属性の読み込みとクエリ内のサブクラスの指定が可能です</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">employee_poly</span> <span class="o">=</span> <span class="n">with_polymorphic</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">employee_poly</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">or_</span><span class="p">(</span>
        <span class="n">employee_poly</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
        <span class="n">employee_poly</span><span class="o">.</span><span class="n">Manager</span><span class="o">.</span><span class="n">manager_data</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span>
    <span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記のクエリは1つのテーブルに対して残っていますが、 `` Manager``または `` Engineer``にあるカラムを&amp;quot;polymorphic &amp;quot;名前空間で参照できます。エンティティに対して `` &amp;quot;* &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>を指定しているので、 `` Engineer``と `` Manager``が一度に読み込まれます。 SQLは次のように出力されます。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT
    employee.id AS employee_id, employee.name AS employee_name,
    employee.type AS employee_type,
    employee.manager_data AS employee_manager_data,
    employee.engineer_info AS employee_engineer_info
FROM employee
WHERE employee.name = :name_1
OR employee.manager_data = :manager_data_1</div></pre></div>
</div>
</div>
<div class="section" id="inheritance-loading-api">
<h2>継承ロードAPI<a class="headerlink" href="#inheritance-loading-api" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="sqlalchemy.orm.with_polymorphic">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">with_polymorphic</code><span class="sig-paren">(</span><em>base</em>, <em>classes</em>, <em>selectable=False</em>, <em>flat=False</em>, <em>polymorphic_on=None</em>, <em>aliased=False</em>, <em>innerjoin=False</em>, <em>_use_mapper_path=False</em>, <em>_existing_alias=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.with_polymorphic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された基底の子孫マッパーの列を指定するclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedClass`構文を生成します。</p>
<p>このメソッドを使用すると、各子孫マッパーのテーブルがFROM句に含まれていることを確認し、それらのテーブルに対してfilter（）条件を使用できるようになります。結果のインスタンスには既にこれらの列がロードされているため、これらの列の&amp;quot;ポストフェッチ&amp;quot;は必要ありません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>with_polymorphic</cite>  -  func：` .orm.with_polymorphic`の完全な議論です。</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.base">¶</a> -- エイリアスするベースクラス。</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.classes"></span><strong>classes</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.classes">¶</a> -- 単一のクラスまたはマッパー、または基本クラスから継承したクラス/マッパーのリスト代わりに、文字列 `` &amp;#39;*&amp;#39; &amp;#39;`でもかまいません。この場合、降順にマップされたすべてのクラスがFROM句に追加されます。</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.aliased"></span><strong>aliased</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.aliased">¶</a> -- Trueの場合、選択可能なものは別名でラップされます。つまり、 <code class="docutils literal notranslate"><span class="pre">（*</span> <span class="pre">SELECT</span> <span class="pre">*</span> <span class="pre">FROM</span> <span class="pre">&lt;fromclauses&gt;</span> <span class="pre">）as</span> <span class="pre">anon_1</span></code>。これは、with_polymorphic（）を使用して、SQLiteや古いバージョンのMySQLなど、カッコで囲まれた結合をサポートしていないバックエンドでJOINのターゲットを作成するときに重要になります。ただし、：paramref： <cite>.with_polymorphic.selectable`パラメータが既存の：class：</cite> .Alias`構造で使用されている場合、このフラグは設定しないでください。</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.flat"></span><strong>flat</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.flat">¶</a> -- Boolean：は：meth： <cite>.FromClause.alias`呼び出しに渡され、class：</cite> .Join`オブジェクトのエイリアスには囲みSELECTが含まれません。これにより、多くの状況でより効率的なクエリにつながる可能性があります。ネストされたJOINに対するJOINは、この構文をサポートしていないバックエンド上のエイリアス化されたSELECTサブクエリに対するJOINとして書き換えられます。 `` flat``を `` True``に設定すると、 `` aliased``フラグも `` True``を意味します。 .. versionadded :: 0.9.0 .. seealso :: meth： <cite>.Join.alias</cite></li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.selectable"></span><strong>selectable</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.selectable">¶</a> -- 生成されたFROM句の代わりに使用されるtableまたはselect（）文。この引数は、SQLAlchemyが現在テーブル間でUNIONを自動的に生成できないため、目的のクラスのいずれかが具体的なテーブル継承を使用する場合に必要です。使用されている場合、 `` selectable``引数は、マップされたすべてのクラスによってマップされたテーブルとカラムのフルセットを表す必要があります。そうしないと、未対応のマップされた列は、結果として誤った結果につながるFROM句に直接表が追加されます。</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.polymorphic_on"></span><strong>polymorphic_on</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.polymorphic_on">¶</a> -- 指定された選択肢の&amp;quot;discriminator &amp;quot;列として使用される列。指定されていない場合、ベースクラスのマッパーのpolymorphic_on属性があればそれが使用されます。これは、デフォルトで多態的な読み込み動作を持たないマッピングに便利です。</li>
<li><span class="target" id="sqlalchemy.orm.with_polymorphic.params.innerjoin"></span><strong>innerjoin</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_polymorphic.params.innerjoin">¶</a> -- Trueの場合は、INNER JOINが使用されます。 1つの特定のサブタイプのみを照会する場合にのみ指定してください</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.selectin_polymorphic">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">selectin_polymorphic</code><span class="sig-paren">(</span><em>base_cls</em>, <em>classes</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.selectin_polymorphic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスに固有のすべての属性に対して熱心な負荷が発生することを示します。</p>
<p>これは、一致するすべてのプライマリキー値に対してINで追加のSELECTを使用し、：paramref： <cite>.mapper.polymorphic_load`パラメータの</cite> <cite>&amp;quot; selectin &amp;quot;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>設定に対するクエリごとの類似点です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>inheritance_polymorphic_load</cite></p>
</div>
</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="loading_relationships.html" title="previous chapter">関係の読み込み手法</a>
        Next:
        <a href="constructors.html" title="next chapter">コンストラクタとオブジェクトの初期化</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    SQLite
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="方言" href="index.html" />
        <link rel="next" title="Sybase" href="sybase.html" />
        <link rel="prev" title="PostgreSQL" href="postgresql.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="方言">方言</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="firebird.html">ファイアバード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mssql.html">Microsoft SQL Server</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mysql.html">MySQL</a></span></li>
<li><span class="link-container first"><a class="reference external" href="oracle.html">オラクル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="postgresql.html">PostgreSQL</a></span></li>
<li class="selected"><span class="link-container first"><strong>SQLite</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#dialect-sqlite">Support for the SQLite database.</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#date-and-time-types">日付と時刻の種類</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#ensuring-text-affinity">テキストの親和性の確保</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#sqlite-auto-incrementing-behavior">SQLite自動インクリメント動作</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-the-autoincrement-keyword">AUTOINCREMENTキーワードの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#allowing-autoincrement-behavior-sqlalchemy-types-other-than-integer-integer">自動インクリメントの動作を許可するInteger / INTEGER以外のSQLAlchemy型</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#database-locking-behavior-concurrency">データベースのロック動作/同時実行性</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#transaction-isolation-level">トランザクション分離レベル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#savepoint-support">SAVEPOINTのサポート</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#transactional-ddl">トランザクションDDL</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#foreign-key-support">外部キーのサポート</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#type-reflection">タイプリフレクション</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#partial-indexes">部分インデックス</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#dotted-column-names">点列名</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#sqlite-data-types">SQLiteデータ型</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#module-sqlalchemy.dialects.sqlite.pysqlite">Pysqlite</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#dialect-sqlite-pysqlite-url">DBAPI</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#dialect-sqlite-pysqlite-connect">Connecting</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#driver">ドライバ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#connect-strings">文字列を接続する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#compatibility-with-sqlite3-native-date-and-datetime-types">sqlite3 &amp;quot;native &amp;quot;の日付と日時の型との互換性</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#threading-pooling-behavior">スレッド/プーリングの動作</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-a-memory-database-in-multiple-threads">複数のスレッドでのメモリデータベースの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-temporary-tables-with-sqlite">SQLiteでのテンポラリテーブルの使用</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#unicode">Unicode</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#serializable-isolation-savepoints-transactional-ddl">シリアライズ可能な分離/セーブポイント/トランザクションDDL</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#module-sqlalchemy.dialects.sqlite.pysqlcipher">Pysqlcipher</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#dialect-sqlite-pysqlcipher-url">DBAPI</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#dialect-sqlite-pysqlcipher-connect">Connecting</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#id3">ドライバ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#id5">文字列を接続する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#pooling-behavior">プール動作</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="sybase.html">Sybase</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.dialects.sqlite.base">
<span id="sqlite"></span><span id="sqlite-toplevel"></span><h1>SQLite<a class="headerlink" href="#module-sqlalchemy.dialects.sqlite.base" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="dialect-sqlite">
<p>Support for the SQLite database.</p>
<h2>DBAPI Support<a class="headerlink" href="#dialect-sqlite" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The following dialect/DBAPI options are available.  Please refer to individual DBAPI sections for connect information.<ul class="simple">
<li><a class="reference external" href="#module-sqlalchemy.dialects.sqlite.pysqlite">pysqlite</a></li>
<li><a class="reference external" href="#module-sqlalchemy.dialects.sqlite.pysqlcipher">pysqlcipher</a></li>
</ul>
</p>
</div>
<div class="section" id="date-and-time-types">
<span id="sqlite-datetime"></span><h2>日付と時刻の種類<a class="headerlink" href="#date-and-time-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteにはDATE、TIME、またはDATETIME型が組み込まれておらず、Pythonの <cite>datetime`オブジェクトとSQLiteでサポートされている形式の間で値を変換する機能は用意されていません。 SQLAlchemy自身の：class： `〜sqlalchemy.types.DateTime`および関連する型は、SQliteが使用されているときに日付の書式設定と解析機能を提供します。実装クラスは、class： `〜.sqlite.DATETIME</cite>、：class：<cite>〜.sqlite.DATE</cite>、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.sqlite.TIME`です。これらのタイプは日付と時刻をISO形式の文字列として表し、順序付けもうまくサポートします。典型的な&amp;quot;libc &amp;quot;内部関数には依存していないので、歴史的日付が完全にサポートされています。</p>
<div class="section" id="ensuring-text-affinity">
<h3>テキストの親和性の確保<a class="headerlink" href="#ensuring-text-affinity" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの型に対してレンダリングされるDDLは、標準の `` DATE``、 `` TIME``、および <cite>DATETIME`のインジケータです。ただし、カスタム記憶域形式をこれらの種類に適用することもできます。格納形式がアルファベット文字を含まないものとして検出されると、これらの型のDDLは `</cite> DATE_CHAR``、 `` TIME_CHAR``、および `` DATETIME_CHAR``としてレンダリングされ、列は引き続きテキストの親和性を持ちます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>タイプアフィニティー&lt;<a class="reference external" href="http://www.sqlite.org/datatype3.html#affinity">http://www.sqlite.org/datatype3.html#affinity</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  -  SQLiteのドキュメント</p>
</div>
</div>
</div>
<div class="section" id="sqlite-auto-incrementing-behavior">
<span id="sqlite-autoincrement"></span><h2>SQLite自動インクリメント動作<a class="headerlink" href="#sqlite-auto-incrementing-behavior" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteの自動インクリメントの背景はhttp://sqlite.org/autoinc.htmlです。</p>
<p>主なコンセプト：</p>
<ul class="simple">
<li>SQLiteには、タイプ+プライマリキーに &amp;quot;INTEGER PRIMARY KEY&amp;quot;を使用して作成された非複合プライマリキーカラムに対して暗黙の&amp;quot;自動インクリメント&amp;quot;機能があります。</li>
<li>SQLiteには明示的な&amp;quot;AUTOINCREMENT &amp;quot;キーワードがあります。<strong>は暗黙の自動インクリメント機能と同等ではありません</strong>。このキーワードは一般的な使用には推奨されません。 SQLAlchemyは特別なSQLite特有の指令が使われていない限り、このキーワードを表示しません（下記参照）。ただし、列の型は&amp;quot;INTEGER &amp;quot;という名前でなければなりません。</li>
</ul>
<div class="section" id="using-the-autoincrement-keyword">
<h3>AUTOINCREMENTキーワードの使用<a class="headerlink" href="#using-the-autoincrement-keyword" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>DDLをレンダリングするときに主キー列のAUTOINCREMENTキーワードを特にレンダリングするには、フラグ `` sqlite_autoincrement = True``を表の構造体::に追加します</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;sometable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
        <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">sqlite_autoincrement</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="allowing-autoincrement-behavior-sqlalchemy-types-other-than-integer-integer">
<h3>自動インクリメントの動作を許可するInteger / INTEGER以外のSQLAlchemy型<a class="headerlink" href="#allowing-autoincrement-behavior-sqlalchemy-types-other-than-integer-integer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SQLiteの型定義モデルは命名規則に基づいています。とりわけ、これは部分文字列 `` &amp;quot;INT &amp;quot; <cite>&amp;quot;を含む型名は&amp;quot;整数類似性&amp;quot;であると判断されることを意味します。 &amp;quot;&amp;quot; BIGINT &amp;quot;</cite> <cite>、</cite> <cite>&amp;quot; SPECIAL_INT &amp;quot;</cite> <cite>または</cite> <cite>&amp;quot; XYZINTQPR &amp;quot;</cite> <cite>という名前の型は、SQLiteによって&amp;quot;整数&amp;quot;親和性であるとみなされます。ただし、**暗黙的または明示的に有効になっているSQLite自動インクリメント機能は、列の型名が文字列&amp;quot;INTEGER &amp;quot; **であることを必要とします。したがって、アプリケーションが主キーに：class： `.BigInteger`のような型を使用する場合、SQLiteではこの型は最初の</cite> <cite>CREATE TABLE &amp;#39;を発行するときに</cite> <cite>&amp;quot; INTEGER &amp;quot;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>という名前でレンダリングする必要があります``ステートメントを使用して、自動インクリメントの動作を利用できるようにします。</p>
<p>これを達成するための1つのアプローチは、：meth： <cite>.TypeEngine.with_variant</cite> ::を使用してSQLite上で：class：` .Integer`を使用することです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">BigInteger</span><span class="p">()</span><span class="o">.</span><span class="n">with_variant</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="s2">&quot;sqlite&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>もう1つは：class： <cite>.BigInteger`のサブクラスを使用して、DDL名をSQLiteに対してコンパイルするときに</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>INTEGER``にオーバーライドすることです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">BigInteger</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.compiler</span> <span class="k">import</span> <span class="n">compiles</span>

<span class="k">class</span> <span class="nc">SLBigInteger</span><span class="p">(</span><span class="n">BigInteger</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@compiles</span><span class="p">(</span><span class="n">SLBigInteger</span><span class="p">,</span> <span class="s1">&#39;sqlite&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bi_c</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;INTEGER&quot;</span>

<span class="nd">@compiles</span><span class="p">(</span><span class="n">SLBigInteger</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bi_c</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">compiler</span><span class="o">.</span><span class="n">visit_BIGINT</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>


<span class="n">table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;my_table&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">SLBigInteger</span><span class="p">(),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.TypeEngine.with_variant</cite></p>
<p>：ref： <cite>sqlalchemy.ext.compiler_toplevel</cite></p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>SQLiteバージョン3のデータ型&lt;<a class="reference external" href="http://sqlite.org/datatype3.html">http://sqlite.org/datatype3.html</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
</div>
</div>
</div>
<div class="section" id="database-locking-behavior-concurrency">
<span id="sqlite-concurrency"></span><h2>データベースのロック動作/同時実行性<a class="headerlink" href="#database-locking-behavior-concurrency" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteは、高いレベルの書き込み同時実行性のために設計されていません。データベースそのものはファイルであり、トランザクション内の書き込み操作中に完全にロックされます。つまり、正確に1つの &amp;quot;接続&amp;quot;（実際にはファイルハンドル）はこの期間中にデータベースへの排他的アクセス権を持ちます。この間にブロックされます。</p>
<p>Python DBAPI仕様では、常にトランザクション内にある接続モデルも必要です。 `` connection.begin（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドはなく、すぐに新しいトランザクションを開始する `` connection.commit（） <a href="#id3"><span class="problematic" id="id4">``</span></a>と `` connection.rollback（） <a href="#id5"><span class="problematic" id="id6">``</span></a>だけがあります。これは、SQLiteドライバが理論的にはいつでも特定のデータベースファイルに対して1つのファイルハンドルしか許可しないことを意味するように見えるかもしれません。しかし、SQlite自体とpysqliteドライバ内には、この制限を大幅に緩和するいくつかの要因があります。</p>
<p>しかし、ロックモードが使用されていても、トランザクションが開始され、DML（INSERT、UPDATE、DELETEなど）が少なくとも発行されると、SQLiteは常にデータベースファイルをロックし、少なくともその時点で他のトランザクションをブロックしますまた、DMLを発行しようとしています。デフォルトでは、このブロックの時間の長さは非常に短くなってからタイムアウトになり、エラーが発生します。</p>
<p>この動作は、SQLAlchemy ORMと組み合わせて使用​​するとより重要になります。 SQLAlchemyの：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`オブジェクトは、デフォルトでトランザクション内で実行され、その自動フラッシュモデルでは、SELECT文の前にDMLを発行することができます。これは、予想よりも早くロックするSQLiteデータベースにつながる可能性があります。 SQLiteとpysqliteドライバのロックモードはある程度操作できますが、SQLiteで高度な書き込み同時実行を実現することは失われた戦いであることに注意してください。</p>
<p>SQLiteの設計による書き込み同時実行性の欠如の詳細については、「別のRDBMSがうまくいく状況 - 高い並行性」を参照してください。 &lt;<a class="reference external" href="http://www.sqlite.org/whentouse.html">http://www.sqlite.org/whentouse.html</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_ページの一番下にあります。</p>
<p>以下のサブセクションでは、SQLiteのファイルベースアーキテクチャの影響を受ける領域について説明します。通常、pysqliteドライバを使用する場合は、回避策が必要です。</p>
</div>
<div class="section" id="transaction-isolation-level">
<span id="sqlite-isolation-level"></span><h2>トランザクション分離レベル<a class="headerlink" href="#transaction-isolation-level" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteは、2つの軸に沿って非標準的な方法で&amp;quot;トランザクション分離&amp;quot;をサポートしています。 1つは <cite>PRAGMA read_uncommitted &lt;http://www.sqlite.org/pragma.html#pragma_read_uncommitted&gt; `_命令。この設定は、基本的に `</cite> SERIALIZABLE``分離のデフォルトモードと通常 `` READ UNCOMMITTED``と呼ばれる&amp;quot;ダーティー読み込み&amp;quot;分離モードの間でSQLiteを切り替えることができます。</p>
<p>SQLAlchemyは、：func： <cite>.create_engine`の：paramref：</cite> .create_engine.isolation_level`パラメータを使用して、このPRAGMA文に結びつきます。このパラメータの有効な値は、SQLiteと一緒に使用するときは、それぞれ0と1の値に対応する `` &amp;quot;SERIALIZABLE &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>と `` &amp;quot;READ UNCOMMITTED &amp;quot; <cite>&amp;quot;です。 SQLiteのデフォルトは `</cite> SERIALIZABLE``ですが、動作はpysqliteドライバのデフォルト動作の影響を受けます。</p>
<p>SQLiteのトランザクションロックが影響を受けるもう1つの軸は、使用される `` BEGIN``ステートメントの性質によるものです。 <cite>BEGIN TRANSACTION &amp;#39;で説明されているように、3つの変種は&amp;quot;遅延&amp;quot;、&amp;quot;即時&amp;quot;、および&amp;quot;排他&amp;quot;です。 &lt;http://sqlite.org/lang_transaction.html&gt; `_。ストレート `</cite> BEGIN`ステートメントは、データベースファイルが最初の読み取りまたは書き込み操作までロックされておらず、読み取りアクセスが最初の書き込み操作まで他のトランザクションに対して開いたままである&amp;quot;遅延&amp;quot;モードを使用します。しかし、再び、pysqliteドライバは、最初の書き込み操作までBEGIN <a href="#id1"><span class="problematic" id="id2">*</span></a>を出さないことによってこの動作に干渉することに注意することが重要です。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SQLiteのトランザクションスコープは、pysqliteドライバの未解決の問題によって影響を受けます。この問題は、BEGIN文を実行する可能性があるよりもはるかに高いです。この動作を回避するテクニックについては、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>pysqlite_serializable`の節を参照してください。</p>
</div>
</div>
<div class="section" id="savepoint-support">
<h2>SAVEPOINTのサポート<a class="headerlink" href="#savepoint-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteはSAVEPOINTをサポートしています.SAVEPOINTは、トランザクションが開始されると機能します。 SQLAlchemyのSAVEPOINTサポートは、コアレベルで：meth： <cite>.Connection.begin_nested`メソッドを使用し、ORMレベルで：meth：</cite> .Session.begin_nested`を使用して使用できます。ただし、回避策が講じられない限り、SAVEPOINTはpysqliteではまったく動作しません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SQLiteのSAVEPOINT機能は、pysqliteドライバの未解決の問題によって影響を受けます。これは、BEGIN文をしばしば実現可能な程度よりも大きくします。この動作を回避するテクニックについては、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>pysqlite_serializable`の節を参照してください。</p>
</div>
</div>
<div class="section" id="transactional-ddl">
<h2>トランザクションDDL<a class="headerlink" href="#transactional-ddl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteデータベースはtransactional：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>DDL`もサポートしています。この場合、pysqliteドライバはトランザクションの開始に失敗するだけでなく、DDLが検出されたときに既存のトランザクションも終了するため、回避策も必要です。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SQLiteのトランザクションDDLは、BEGINを発行できず、さらにDDLに遭遇したときにCOMMITにトランザクションをキャンセルさせるpysqliteドライバの未解決の問題の影響を受けます。この動作を回避するテクニックについては、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>pysqlite_serializable`の節を参照してください。</p>
</div>
</div>
<div class="section" id="foreign-key-support">
<span id="sqlite-foreign-keys"></span><h2>外部キーのサポート<a class="headerlink" href="#foreign-key-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteは、テーブルのCREATE文を発行する際にFOREIGN KEY構文をサポートしていますが、デフォルトではこれらの制約はテーブルの操作には影響しません。</p>
<p>SQLiteの制約チェックには、次の3つの前提条件があります。</p>
<ul class="simple">
<li>SQLiteのバージョン3.6.19以上が使用されている必要があります</li>
<li>SQLiteライブラリは、SQLITE_OMIT_FOREIGN_KEYまたはSQLITE_OMIT_TRIGGERシンボルを有効にしないで*コンパイルする必要があります。</li>
<li>`` PRAGMA foreign_keys = ON``ステートメントは、使用する前にすべてのコネクションで発行する必要があります。</li>
</ul>
<p>SQLAlchemyはイベントの使用を通して新しい接続のために `` PRAGMA``文が自動的に出力されるようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="k">import</span> <span class="n">Engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Engine</span><span class="p">,</span> <span class="s2">&quot;connect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">set_sqlite_pragma</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbapi_connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;PRAGMA foreign_keys=ON&quot;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SQLiteの外部キーが有効な場合、相互に依存する外部キー制約を含むテーブルに対してCREATEまたはDROPステートメントを発行することはできません**。これらのテーブルに対してDDLを発行するには、ALTER TABLEを使用してこれらの制約を個別に作成または削除する必要があります。そのためにはSQLiteはサポートしていません。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>SQLite外部キーサポート&lt;<a class="reference external" href="http://www.sqlite.org/foreignkeys.html">http://www.sqlite.org/foreignkeys.html</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  -  SQLiteのWebサイトにあります。</p>
<p>：ref： <cite>event_toplevel</cite>  -  SQLAlchemyイベントAPI。</p>
<dl class="last docutils">
<dt>：ref： <cite>use_alter</cite>  - 処理のためのSQLAlchemyの機能の詳細</dt>
<dd>相互に依存する外部キー制約。</dd>
</dl>
</div>
</div>
<div class="section" id="type-reflection">
<span id="sqlite-type-reflection"></span><h2>タイプリフレクション<a class="headerlink" href="#type-reflection" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLite型は、他のほとんどのデータベースバックエンドとは異なります。通常、型の文字列名は1対1の方法で&amp;quot;型&amp;quot;に対応しません。その代わりに、SQLiteは、型ごとの文字列一致パターンに基づいて、列ごとの型付き動作を5つのいわゆる&amp;quot;型類似性&amp;quot;のいずれかにリンクします。</p>
<p>SQLAlchemyのリフレクションプロセスは、タイプを検査するときに、単純なルックアップテーブルを使用して、提供されたSQLAlchemyタイプに返されたキーワードをリンクします。このルックアップテーブルは、他のすべての方言の場合と同様に、SQLiteダイアレクト内に存在します。しかし、SQLiteの方言は、特定の型名がルックアップマップにないときには&amp;quot;フォールバック&amp;quot;ルーチンを持っています;代わりにhttp://www.sqlite.orgにあるSQLite &amp;quot;type affinity &amp;quot;スキームを実装します/datatype3.htmlセクション2.1。</p>
<p>指定されたタイプマップは、以下のタイプの文字列名との直接の関連付けを行います：</p>
<p>：class： <cite>〜.types.BIGLE</cite>、：class：<cite>〜.types.BLOB</cite>、：class： <cite>〜.types.BOOLEAN</cite>、：class：<cite>〜.types.BOOLEAN</cite>、：class： <cite>〜。 ：class： `〜.types.DATE &amp;#39;、：class：</cite>〜.types.FLOAT`、：class： <cite>〜.types.DECIMAL</cite>、：：クラス： <cite>〜.types.FLOAT</cite>、：class：<cite>〜.types.INTEGER</cite>、：class： <cite>〜.types.INTEGER</cite>、：class：<cite>〜.types.NUMERIC</cite>、：class： <cite>〜.typesクラス： `〜.types.SMALLINT</cite>、：class：<cite>〜.types.TEXT</cite>、：class： <cite>〜.types.TIME</cite>、：class：<cite>〜.types.TIMESTAMP</cite>、：class ： <cite>〜.types.VARCHAR</cite>、：class：<cite>〜.types.NVARCHAR</cite>、：クラス： <cite>〜.types.NCHAR</cite></p>
<p>型名が上記の型のいずれかと一致しない場合、代わりに&amp;quot;型類義語&amp;quot;の参照が使用されます：</p>
<ul class="simple">
<li>：型名に文字列 `` INT``が含まれている場合、クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.INTEGER`が返されます</li>
<li>：型名に文字列 `` CHAR``、 `` CLOB``または `` TEXT``が含まれている場合、クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.TEXT`が返されます</li>
<li>：型名に文字列 `` BLOB``が含まれている場合、クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.NullType`が返されます。</li>
<li>：class： `` REAL``、 `` FLOA``または `` DOUB``の文字列が型名に含まれている場合、 <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.REAL`が返されます。</li>
<li>それ以外の場合は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.types.NUMERIC`型が使用されます。</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.3 で追加: </span>列を反映させる際のSQLite型親和性ルールのサポート</p>
</div>
</div>
<div class="section" id="partial-indexes">
<span id="sqlite-partial-index"></span><h2>部分インデックス<a class="headerlink" href="#partial-indexes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>DDLシステムでは、 `` sqlite_where`` ::引数を使用して部分インデックス（例：WHERE句を使用するインデックス）を指定できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;testtbl&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="s1">&#39;test_idx1&#39;</span><span class="p">,</span> <span class="n">tbl</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">sqlite_where</span><span class="o">=</span><span class="n">and_</span><span class="p">(</span><span class="n">tbl</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tbl</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">))</span></pre></div>
</div>
<p>作成時にインデックスがレンダリングされます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">INDEX</span> <span class="n">test_idx1</span> <span class="n">ON</span> <span class="n">testtbl</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">WHERE</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">AND</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="mi">10</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.9 で追加.</span></p>
</div>
</div>
<div class="section" id="dotted-column-names">
<span id="sqlite-dotted-column-names"></span><h2>点列名<a class="headerlink" href="#dotted-column-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>明示的にピリオドを含む表名または列名を使用することは推奨されません**。これは一般的にリレーショナルデータベースでは一般的に悪い考えですが、ドットが構文的に重要な文字であるため、SQLiteのバージョン** 3.10.0 <a href="#id1"><span class="problematic" id="id2">**</span></a>までのSQLiteドライバにはバグがあり、SQLAlchemyはこれらの点を結果セット。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.1 で変更: </span>次のSQLiteの問題は、SQLiteのバージョン3.10.0で解決されています。 ** 1.1 <a href="#id1"><span class="problematic" id="id2">**</span></a>のSQLAlchemyは、このバージョンの検出に基づいて内部的な回避策を自動的に無効にします。</p>
</div>
<p>このバグは、SQLAlchemyの外部にあります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">assert</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">sqlite_version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;bug is fixed in this version&quot;</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table x (a integer, b integer)&quot;</span><span class="p">)</span>
<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (1, 1)&quot;</span><span class="p">)</span>
<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (2, 2)&quot;</span><span class="p">)</span>

<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select x.a, x.b from x&quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>

<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    select x.a, x.b from x where a=1</span>
<span class="s1">    union</span>
<span class="s1">    select x.a, x.b from x where a=2</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> \
    <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span></pre></div>
</div>
<p>2番目のアサーションは失敗します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;test.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">19</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x.a&#39;</span><span class="p">,</span> <span class="s1">&#39;x.b&#39;</span><span class="p">]</span></pre></div>
</div>
<p>上記の場合、ドライバはテーブルの名前を含む列の名前を間違って報告します。これは、UNIONが存在しない場合とまったく矛盾しています。</p>
<p>SQLAlchemyは、元の文とどのように一致するか予測可能なカラム名に依存しているため、SQLAlchemy方言はこれらをフィルタリングするだけではありません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table x (a integer, b integer)&quot;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (1, 1)&quot;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (2, 2)&quot;</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select x.a, x.b from x&quot;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    select x.a, x.b from x where a=1</span>
<span class="s1">    union</span>
<span class="s1">    select x.a, x.b from x where a=2</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span></pre></div>
</div>
<p>上記のように、SQLAlchemyがドットをフィルタリングしても、<em>両方の名前はまだアドレス可能です</em>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;x.a&quot;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;x.b&quot;</span><span class="p">]</span>
<span class="go">1</span></pre></div>
</div>
<p>したがって、SQLAlchemyによって適用される回避策は、パブリックAPIの：meth： <cite>.ResultProxy.keys`および：meth：</cite> .RowProxy.keys（） <cite>にのみ影響します。アプリケーションがドットを含む列名を使用するように強制され、これらのドット付きの名前を返すには：meth： `.ResultProxy.keys`と：meth：</cite> .RowProxy.keys（） <cite>の機能が必要な非常に特殊なケースでは、 `</cite> sqlite_raw_colnames``実行オプションは、per-：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`の基礎で提供されるかもしれません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">sqlite_raw_colnames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    select x.a, x.b from x where a=1</span>
<span class="s1">    union</span>
<span class="s1">    select x.a, x.b from x where a=2</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;x.a&quot;</span><span class="p">,</span> <span class="s2">&quot;x.b&quot;</span><span class="p">]</span></pre></div>
</div>
<p>またはper-：class： <cite>.Engine</cite> basis</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite://&quot;</span><span class="p">,</span> <span class="n">execution_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;sqlite_raw_colnames&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span></pre></div>
</div>
<p>per-：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`実行オプションを使用する場合、UNIONを使用する**コアクエリとORMクエリは正しく機能しない可能性があります**。</p>
</div>
<div class="section" id="sqlite-data-types">
<h2>SQLiteデータ型<a class="headerlink" href="#sqlite-data-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>すべてのSQLAlchemyの方言と同様に、SQLiteで有効であることが知られているすべてのUPPERCASE型は、from：mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.types`またはローカルの方言から上位の方言からインポートできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.sqlite</span> <span class="k">import</span> \
            <span class="n">BLOB</span><span class="p">,</span> <span class="n">BOOLEAN</span><span class="p">,</span> <span class="n">CHAR</span><span class="p">,</span> <span class="n">DATE</span><span class="p">,</span> <span class="n">DATETIME</span><span class="p">,</span> <span class="n">DECIMAL</span><span class="p">,</span> <span class="n">FLOAT</span><span class="p">,</span> \
            <span class="n">INTEGER</span><span class="p">,</span> <span class="n">NUMERIC</span><span class="p">,</span> <span class="n">JSON</span><span class="p">,</span> <span class="n">SMALLINT</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">,</span> <span class="n">TIME</span><span class="p">,</span> <span class="n">TIMESTAMP</span><span class="p">,</span> \
            <span class="n">VARCHAR</span></pre></div>
</div>
<span class="target" id="module-sqlalchemy.dialects.sqlite"></span><dl class="class">
<dt id="sqlalchemy.dialects.sqlite.DATETIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.sqlite.</code><code class="descname">DATETIME</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.sqlite.DATETIME" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.sqlite.base._DateTimeMixin</span></code>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.DateTime</span></code></a></p>
<p>文字列を使用してSQLiteでPython datetimeオブジェクトを表します。</p>
<p>デフォルトの文字列格納形式は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;</span><span class="si">%(year)04d</span><span class="s2">-</span><span class="si">%(month)02d</span><span class="s2">-</span><span class="si">%(day)02d</span><span class="s2"> </span><span class="si">%(hour)02d</span><span class="s2">:</span><span class="si">%(min)02d</span><span class="s2">:</span><span class="si">%(second)02d</span><span class="s2">.</span><span class="si">%(microsecond)06d</span><span class="s2">&quot;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2011</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">15</span> <span class="mi">12</span><span class="p">:</span><span class="mi">05</span><span class="p">:</span><span class="mf">57.10558</span></pre></div>
</div>
<p>ストレージフォーマットは、 `` storage_format``と `` regexp``パラメータを使ってある程度カスタマイズすることができます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.sqlite</span> <span class="k">import</span> <span class="n">DATETIME</span>

<span class="n">dt</span> <span class="o">=</span> <span class="n">DATETIME</span><span class="p">(</span><span class="n">storage_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(year)04d</span><span class="s2">/</span><span class="si">%(month)02d</span><span class="s2">/</span><span class="si">%(day)02d</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%(hour)02d</span><span class="s2">:</span><span class="si">%(min)02d</span><span class="s2">:</span><span class="si">%(second)02d</span><span class="s2">&quot;</span><span class="p">,</span>
              <span class="n">regexp</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;(\d+)/(\d+)/(\d+) (\d+)-(\d+)-(\d+)&quot;</span>
<span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.sqlite.DATETIME.params.storage_format"></span><strong>storage_format</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.DATETIME.params.storage_format">¶</a> -- 年、月、日、時、分、秒、マイクロ秒のキーで辞書に適用される書式文字列。</li>
<li><span class="target" id="sqlalchemy.dialects.sqlite.DATETIME.params.regexp"></span><strong>regexp</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.DATETIME.params.regexp">¶</a> -- 着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのdatetime（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、datetime（）コンストラクタは `` * map（int、match_obj.groups（0）） <a href="#id1"><span class="problematic" id="id2">`</span></a>&amp;#39;を介して位置引数で呼び出されます。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.sqlite.DATE">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.sqlite.</code><code class="descname">DATE</code><span class="sig-paren">(</span><em>storage_format=None</em>, <em>regexp=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.sqlite.DATE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.sqlite.base._DateTimeMixin</span></code>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Date" title="sqlalchemy.types.Date"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Date</span></code></a></p>
<p>文字列を使用してSQLiteでPythonの日付オブジェクトを表します。</p>
<p>デフォルトの文字列格納形式は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;</span><span class="si">%(year)04d</span><span class="s2">-</span><span class="si">%(month)02d</span><span class="s2">-</span><span class="si">%(day)02d</span><span class="s2">&quot;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2011</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">15</span></pre></div>
</div>
<p>ストレージフォーマットは、 `` storage_format``と `` regexp``パラメータを使ってある程度カスタマイズすることができます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.sqlite</span> <span class="k">import</span> <span class="n">DATE</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">DATE</span><span class="p">(</span>
        <span class="n">storage_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(month)02d</span><span class="s2">/</span><span class="si">%(day)02d</span><span class="s2">/</span><span class="si">%(year)04d</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">regexp</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(?P&lt;month&gt;\d+)/(?P&lt;day&gt;\d+)/(?P&lt;year&gt;\d+)&quot;</span><span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.sqlite.DATE.params.storage_format"></span><strong>storage_format</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.DATE.params.storage_format">¶</a> -- 年、月、日のキーを使って辞書に適用されるフォーマット文字列。</li>
<li><span class="target" id="sqlalchemy.dialects.sqlite.DATE.params.regexp"></span><strong>regexp</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.DATE.params.regexp">¶</a> -- 着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのdate（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、date（）コンストラクタは `` * map（int、match_obj.groups（0）） <a href="#id1"><span class="problematic" id="id2">`</span></a>&amp;#39;を介して位置引数で呼び出されます。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.sqlite.JSON">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.sqlite.</code><code class="descname">JSON</code><span class="sig-paren">(</span><em>none_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.sqlite.JSON" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.JSON</span></code></a></p>
<p>SQLite JSONタイプ。</p>
<p>SQLiteは、JSON1_拡張を介してバージョン3.9のJSONをサポートしています。 JSON1_はロード可能な拡張機能です&lt;<a class="reference external" href="https://www.sqlite.org/loadext.html">https://www.sqlite.org/loadext.html</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_そのようなものが利用できないか、実行時の読み込みが必要な場合があります。</p>
<p>：class： <cite>.sqlite.JSON`型はJSON値の永続性と、class：</cite> .types.JSON`データ型によって提供されるコアインデックス操作をサポートします。これは、 `` JSON_EXTRACT``関数をラップするデータベースレベルの `` JSON_QUOTE``関数の中で実行されます。結果が常にJSON文字列値であることを保証するために、抽出された値が引用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.3 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="https://www.sqlite.org/json1.html">JSON1</a></p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.dialects.sqlite.TIME">
<em class="property">class </em><code class="descclassname">sqlalchemy.dialects.sqlite.</code><code class="descname">TIME</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.dialects.sqlite.TIME" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.dialects.sqlite.base._DateTimeMixin</span></code>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Time" title="sqlalchemy.types.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.types.Time</span></code></a></p>
<p>文字列を使用してSQLiteでPythonの時間オブジェクトを表します。</p>
<p>デフォルトの文字列格納形式は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;</span><span class="si">%(hour)02d</span><span class="s2">:</span><span class="si">%(minute)02d</span><span class="s2">:</span><span class="si">%(second)02d</span><span class="s2">.</span><span class="si">%(microsecond)06d</span><span class="s2">&quot;</span></pre></div>
</div>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">12</span><span class="p">:</span><span class="mi">05</span><span class="p">:</span><span class="mf">57.10558</span></pre></div>
</div>
<p>ストレージフォーマットは、 `` storage_format``と `` regexp``パラメータを使ってある程度カスタマイズすることができます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.sqlite</span> <span class="k">import</span> <span class="n">TIME</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">TIME</span><span class="p">(</span><span class="n">storage_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(hour)02d</span><span class="s2">-</span><span class="si">%(minute)02d</span><span class="s2">-&quot;</span>
                        <span class="s2">&quot;</span><span class="si">%(second)02d</span><span class="s2">-</span><span class="si">%(microsecond)06d</span><span class="s2">&quot;</span><span class="p">,</span>
         <span class="n">regexp</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(\d+)-(\d+)-(\d+)-(?:-(\d+))?&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.dialects.sqlite.TIME.params.storage_format"></span><strong>storage_format</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.TIME.params.storage_format">¶</a> -- 日付、時間、分、秒、マイクロ秒のキーで適用されるフォーマット文字列。</li>
<li><span class="target" id="sqlalchemy.dialects.sqlite.TIME.params.regexp"></span><strong>regexp</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.dialects.sqlite.TIME.params.regexp">¶</a> -- 着信結果行に適用される正規表現。正規表現に名前付きグループが含まれている場合、結果の一致するdictはキーワード引数としてPythonのtime（）コンストラクタに適用されます。それ以外の場合は、位置グループを使用すると、time（）コンストラクタが `` * map（int、match_obj.groups（0）） <a href="#id1"><span class="problematic" id="id2">`</span></a>&amp;#39;を介して位置引数で呼び出されます。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-sqlalchemy.dialects.sqlite.pysqlite">
<span id="pysqlite"></span><h2>Pysqlite<a class="headerlink" href="#module-sqlalchemy.dialects.sqlite.pysqlite" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Support for the SQLite database via the pysqlite driver.<p>Note that <code class="docutils literal notranslate"><span class="pre">pysqlite</span></code> is the same driver as the <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code>
module included with the Python distribution.</p>
</p>
<div class="section" id="dialect-sqlite-pysqlite-url">
<h3>DBAPI<a class="headerlink" href="#dialect-sqlite-pysqlite-url" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Documentation and download information (if applicable) for pysqlite is available at:
<a class="reference external" href="http://docs.python.org/library/sqlite3.html">http://docs.python.org/library/sqlite3.html</a></p>
</div>
<div class="section" id="dialect-sqlite-pysqlite-connect">
<h3>Connecting<a class="headerlink" href="#dialect-sqlite-pysqlite-connect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Connect String:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlite</span><span class="o">+</span><span class="n">pysqlite</span><span class="p">:</span><span class="o">///</span><span class="n">file_path</span></pre></div>
</div>
</p>
</div>
<div class="section" id="driver">
<h3>ドライバ<a class="headerlink" href="#driver" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 2.5以上を使用する場合、組み込みの `` sqlite3``ドライバは既にインストールされており、追加のインストールは必要ありません。それ以外の場合は、 `` pysqlite2``ドライバが必要です。これは `` sqlite3``と同じドライバで、名前が違うだけです。</p>
<p>`` pysqlite2``ドライバが最初にロードされ、見つからなければ `` sqlite3``がロードされます。これにより、明示的にインストールされたpysqliteドライバが組み込みドライバよりも優先されます。すべての方言と同様に、特定のDBAPIモジュールを次のように提供することができます：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.create_engine（）`これを明示的に制御する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlite3</span> <span class="k">import</span> <span class="n">dbapi2</span> <span class="k">as</span> <span class="n">sqlite</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite+pysqlite:///file.db&#39;</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">sqlite</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="connect-strings">
<h3>文字列を接続する<a class="headerlink" href="#connect-strings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SQLiteデータベースのファイル指定は、URLの &amp;quot;データベース&amp;quot;部分とみなされます。 SQLAlchemyのURLのフォーマットは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">driver</span><span class="p">:</span><span class="o">//</span><span class="n">user</span><span class="p">:</span><span class="k">pass</span><span class="nd">@host</span><span class="o">/</span><span class="n">database</span></pre></div>
</div>
<p>つまり、実際に使用されるファイル名は、3番目のスラッシュの** right <a href="#id1"><span class="problematic" id="id2">**</span></a>の文字で始まります。相対ファイルパスに接続すると、次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># relative path</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///path/to/database.db&#39;</span><span class="p">)</span></pre></div>
</div>
<p>スラッシュで始まる絶対パスは、<a href="#id1"><span class="problematic" id="id2">**</span></a>四つのスラッシュが必要です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># absolute path</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:////path/to/database.db&#39;</span><span class="p">)</span></pre></div>
</div>
<p>Windowsパスを使用するには、通常のドライブ指定とバックスラッシュを使用できます。ダブルバックスラッシュはおそらく必要です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># absolute path on Windows</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///C:</span><span class="se">\\</span><span class="s1">path</span><span class="se">\\</span><span class="s1">to</span><span class="se">\\</span><span class="s1">database.db&#39;</span><span class="p">)</span></pre></div>
</div>
<p>ファイルパスが存在しない場合、sqlite <a href="#id1"><span class="problematic" id="id2">``</span></a>：memory： <a href="#id3"><span class="problematic" id="id4">``</span></a>識別子がデフォルトです。 `` sqlite：// <a href="#id5"><span class="problematic" id="id6">``</span></a>を指定し、他には何も指定しないでください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in-memory database</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite://&#39;</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="compatibility-with-sqlite3-native-date-and-datetime-types">
<h3>sqlite3 &amp;quot;native &amp;quot;の日付と日時の型との互換性<a class="headerlink" href="#compatibility-with-sqlite3-native-date-and-datetime-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>pysqliteドライバには、sqlite3.PARSE_DECLTYPESおよびsqlite3.PARSE_COLNAMESオプションが含まれています。これらのオプションは、&amp;quot;日付&amp;quot;または&amp;quot;タイムスタンプ&amp;quot;として明示的にキャストされる列または式の影響をPythonの日付または日時オブジェクトに変換します。 pysqliteの方言で提供されているdate型とdatetime型は、pysqliteのドライバではないマイクロ秒を含むISOの日付/時刻をレンダリングするため、これらのオプションと現在互換性がありません。さらに、SQLAlchemyは現在、フリースタンディング関数&amp;quot;current_timestamp &amp;quot;と&amp;quot;current_date &amp;quot;に必要な&amp;quot;キャスト&amp;quot;構文をネイティブにdatetime / date型を返すように自動的にレンダリングしません。残念ながら、pysqliteは標準のDBAPI型を `` cursor.description``に提供していないため、SQLAlchemyに高価な行単位のチェックを行わずにこれらの型を即座に検出することはできません。</p>
<p>SQLAlchemyで使用するには、pysqliteの解析オプションは推奨されておらず、また必要であることに留意してください。create_engine（）で&amp;quot;native_datetime = True &amp;quot;を設定すると、PARSE_DECLTYPESの使用を強制できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite://&#39;</span><span class="p">,</span>
    <span class="n">connect_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;detect_types&#39;</span><span class="p">:</span>
        <span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_DECLTYPES</span><span class="o">|</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_COLNAMES</span><span class="p">},</span>
    <span class="n">native_datetime</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span></pre></div>
</div>
<p>このフラグを有効にすると、DATETIME型やTIMESTAMP型（ただし、DATETIME型やTIME型ではありませんが、まだ混乱していません）は、バインドパラメータや結果処理を実行しません。 &amp;quot;func.current_date（）&amp;quot;の実行は文字列を返します。 &amp;quot;func.current_timestamp（）&amp;quot;はSQLAlchemyにDATETIME型を返すように登録されているので、この関数はSQLAlchemyレベルの結果処理を受け取ります。</p>
</div>
<div class="section" id="threading-pooling-behavior">
<span id="pysqlite-threading-pooling"></span><h3>スレッド/プーリングの動作<a class="headerlink" href="#threading-pooling-behavior" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pysqliteのデフォルトの動作は、複数のスレッドで単一の接続の使用を禁止することです。これはもともと、さまざまな状況下でマルチスレッド処理をサポートしていなかった古いバージョンのSQLiteで動作するように意図されています。特に、以前のSQLiteのバージョンでは、どんな状況下でも `` memory： <a href="#id1"><span class="problematic" id="id2">``</span></a>データベースを複数のスレッドで使用することができませんでした。</p>
<p>Pysqliteには、このチェックを無効にする `` check_same_thread``というフラグがありますが、pysqliteの接続は複数のスレッドで同時に使用することは安全ではありません。特に、Pysqliteはスレッドセーフなエラーメッセージの伝播を提供しないため、ステートメント実行呼び出しは外部的に相互排除する必要があります。そのため、現代のSQLiteではスレッド間で <a href="#id1"><span class="problematic" id="id2">``</span></a>：memory： <a href="#id3"><span class="problematic" id="id4">``</span></a>のデータベースを共有することができますが、Pysqliteはスレッドセーフではありません。</p>
<p>SQLAlchemyは、Pysqliteのデフォルト動作で動作するようにプーリングを設定します。</p>
<ul>
<li><p class="first">`` memory： `` SQLiteデータベースが指定されている場合、デフォルトでは：class： <cite>.SingletonThreadPool`が使用されます。このプールはスレッドごとに1つの接続を維持するので、現在のスレッド内のエンジンへのすべてのアクセスは同じ `</cite> memory： <a href="#id1"><span class="problematic" id="id2">``</span></a>データベースを使用し、他のスレッドは別の `` memory： <a href="#id3"><span class="problematic" id="id4">``</span></a>データベースにアクセスします。</p>
</li>
<li><p class="first">ファイルベースのデータベースが指定されると、方言は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.NullPool`を接続のソースとして使用します。このプールは、すぐにプールに返される接続を閉じて破棄します。 SQLiteのファイルベースの接続は非常にオーバーヘッドが少ないため、プールする必要はありません。このスキームはまた、接続が別のスレッドで再び使用されることを防ぎ、SQLiteの粗いファイルロックで最も効果的です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>デフォルト選択：class：SQLiteファイルベースのデータベースの <cite>.NullPool</cite>。以前のバージョンでは、すべてのSQLiteデータベースに対して、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SingletonThreadPool`がデフォルトで選択されていました。</p>
</div>
</li>
</ul>
<div class="section" id="using-a-memory-database-in-multiple-threads">
<h4>複数のスレッドでのメモリデータベースの使用<a class="headerlink" href="#using-a-memory-database-in-multiple-threads" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>マルチスレッドのシナリオで `` memory： <code class="docutils literal notranslate"><span class="pre">データベースを使用するには、データベースがその接続のスコープ内にしか存在しないため、同じ接続オブジェクトをスレッド間で共有する必要があります。</span> <span class="pre">：class：</span> <span class="pre">`.StaticPool`実装はグローバルに単一の接続を維持し、`</span> <span class="pre">`check_same_thread``フラグをPysqliteに`</span> <span class="pre">`False</span></code> ::として渡すことができます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">StaticPool</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite://&#39;</span><span class="p">,</span>
                    <span class="n">connect_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;check_same_thread&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span>
                    <span class="n">poolclass</span><span class="o">=</span><span class="n">StaticPool</span><span class="p">)</span></pre></div>
</div>
<p>複数のスレッドで `` memory： <a href="#id1"><span class="problematic" id="id2">``</span></a>データベースを使用するには、最近のバージョンのSQLiteが必要です。</p>
</div>
<div class="section" id="using-temporary-tables-with-sqlite">
<h4>SQLiteでのテンポラリテーブルの使用<a class="headerlink" href="#using-temporary-tables-with-sqlite" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>SQLiteが一時テーブルを処理する方法のため、ORM：class： <cite>.Session`を使用する場合など、接続プールからの複数のチェックアウトにわたってファイルベースのSQLiteデータベースで一時テーブルを使用する場合は、一時テーブル：meth： `.Session.commit`または：meth：</cite> .Session.rollback`が呼び出された後も引き続き残る必要があります.1つの接続を維持するプールを使用する必要があります。スコープが現在のスレッド内でのみ必要な場合は、class： <cite>.SingletonThreadPool`を使用するか、または：class：</cite> .StaticPool` isスコープがこの場合複数のスレッド内で必要です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># maintain the same connection per thread</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">SingletonThreadPool</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///mydb.db&#39;</span><span class="p">,</span>
                    <span class="n">poolclass</span><span class="o">=</span><span class="n">SingletonThreadPool</span><span class="p">)</span>


<span class="c1"># maintain the same connection across all threads</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">StaticPool</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///mydb.db&#39;</span><span class="p">,</span>
                    <span class="n">poolclass</span><span class="o">=</span><span class="n">StaticPool</span><span class="p">)</span></pre></div>
</div>
<p>注意：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SingletonThreadPool`は、使用されるスレッドの数を設定する必要があります。その数を超えると、接続は非決定論的な方法でクローズされます。</p>
</div>
</div>
<div class="section" id="unicode">
<h3>Unicode<a class="headerlink" href="#unicode" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>pysqliteドライバは、結果セット内のPythonの `` unicode``オブジェクトだけを返すだけで、決してプレーンな文字列ではなく、すべての場合にバインドされたパラメータ値内の `` unicode``オブジェクトに対応します。使用されているSQLAlchemy文字列型にかかわらず、文字列ベースの結果値はPython 2のPythonの `` unicode``になります。：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Unicode`型は、Unicodeを必要とする列を示すために使用されます。誤って渡された <a href="#id3"><span class="problematic" id="id4">``</span></a>unicode``以外の値は警告を発します。 ASCII以外の文字を含む <a href="#id5"><span class="problematic" id="id6">``</span></a>unicode``以外の文字列が渡された場合、Pysqliteはエラーを出力します。</p>
</div>
<div class="section" id="serializable-isolation-savepoints-transactional-ddl">
<span id="pysqlite-serializable"></span><h3>シリアライズ可能な分離/セーブポイント/トランザクションDDL<a class="headerlink" href="#serializable-isolation-savepoints-transactional-ddl" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>セクション：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlite_concurrency`では、SQLiteのいくつかの機能が正しく動作しないようにするpysqliteドライバのさまざまな問題を取り上げます。 pysqlite DBAPIドライバには、トランザクショナル動作の正確性に影響するいくつかの長年にわたるバグがあります。デフォルトの動作モードでは、SERIALIZABLE分離、トランザクションDDL、SAVEPOINTサポートなどのSQLite機能は機能しません。これらの機能を使用するには、回避策を講じる必要があります。</p>
<p>問題は基本的に、ドライバがSQLiteデータベースのファイルロック動作を最小限に抑えるために、SQLite自体が&amp;quot;共有&amp;quot;ロックを使用しているにもかかわらず、ユーザーの意図を第二に推測し、トランザクションを開始せず、読み取り専用アクティビティ</p>
<p>SQLAlchemyは、この動作をデフォルトで変更しないことを選択します。これは、pysqliteドライバの長い動作が期待される動作であるためです。 pysqliteドライバがこれらの問題を修復しようとすると、SQLAlchemyのデフォルトに近づくでしょう。</p>
<p>良いニュースは、いくつかのイベントでは、pysqliteの機能を完全に無効にして自分自身を始動させることによって、トランザクションサポートを完全に実装できることです。これは、2つのイベントリスナーを使用して実現されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">event</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///myfile.db&quot;</span><span class="p">)</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;connect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_connect</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">):</span>
    <span class="c1"># disable pysqlite&#39;s emitting of the BEGIN statement entirely.</span>
    <span class="c1"># also stops it from emitting COMMIT before any DDL.</span>
    <span class="n">dbapi_connection</span><span class="o">.</span><span class="n">isolation_level</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;begin&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_begin</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="c1"># emit our own BEGIN</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;BEGIN&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上では、新しいpysqlite接続を傍受し、トランザクション統合を無効にします。次に、SQLAlchemyがトランザクションスコープを開始することを知っている時点で、私たちは `` &amp;quot;BEGIN &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>を自分自身で発行します。</p>
<p>`` &amp;quot;BEGIN &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>を制御すると、 <cite>BEGIN TRANSACTION &amp;#39;で導入されたSQLiteのロックモードを直接制御することもできます&lt;http://sqlite.org/lang_transaction.html&gt; `_ &amp;#39;に、希望するロックモードを</cite> <cite>&amp;quot; BEGIN &amp;quot;</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>::に追加する</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;begin&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_begin</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;BEGIN EXCLUSIVE&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>BEGIN TRANSACTION &lt;<a class="reference external" href="http://sqlite.org/lang_transaction.html">http://sqlite.org/lang_transaction.html</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  -  SQLiteサイトで</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>sqlite3 SELECTはトランザクションを開始しません&lt;<a class="reference external" href="http://bugs.python.org/issue9924">http://bugs.python.org/issue9924</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  -  Pythonバグトラッカーで</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>sqlite3モジュールがトランザクションを中断し、データを破壊する可能性がある&lt;<a class="reference external" href="http://bugs.python.org/issue10740">http://bugs.python.org/issue10740</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  -  Pythonバグトラッカーで</p>
</div>
</div>
</div>
<div class="section" id="module-sqlalchemy.dialects.sqlite.pysqlcipher">
<span id="pysqlcipher"></span><h2>Pysqlcipher<a class="headerlink" href="#module-sqlalchemy.dialects.sqlite.pysqlcipher" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Support for the SQLite database via the pysqlcipher driver.<p><code class="docutils literal notranslate"><span class="pre">pysqlcipher</span></code> is a fork of the standard <code class="docutils literal notranslate"><span class="pre">pysqlite</span></code> driver to make
use of the <a class="reference external" href="https://www.zetetic.net/sqlcipher">SQLCipher</a> backend.</p>
<p><code class="docutils literal notranslate"><span class="pre">pysqlcipher3</span></code> is a fork of <code class="docutils literal notranslate"><span class="pre">pysqlcipher</span></code> for Python 3. This dialect
will attempt to import it if <code class="docutils literal notranslate"><span class="pre">pysqlcipher</span></code> is non-present.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1.4 で追加: </span>- added fallback import for pysqlcipher3</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.9 で追加: </span>- added pysqlcipher dialect</p>
</div>
</p>
<div class="section" id="dialect-sqlite-pysqlcipher-url">
<h3>DBAPI<a class="headerlink" href="#dialect-sqlite-pysqlcipher-url" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Documentation and download information (if applicable) for pysqlcipher is available at:
<a class="reference external" href="https://pypi.python.org/pypi/pysqlcipher">https://pypi.python.org/pypi/pysqlcipher</a></p>
</div>
<div class="section" id="dialect-sqlite-pysqlcipher-connect">
<h3>Connecting<a class="headerlink" href="#dialect-sqlite-pysqlcipher-connect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Connect String:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sqlite+pysqlcipher://:passphrase/file_path[?kdf_iter=&lt;iter&gt;]</pre></div>
</div>
</p>
</div>
<div class="section" id="id3">
<h3>ドライバ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ここのドライバは <a href="#id1"><span class="problematic" id="id2">`</span></a>pysqlcipher &lt;<a class="reference external" href="https://pypi.python.org/pypi/pysqlcipher">https://pypi.python.org/pypi/pysqlcipher</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_ドライバ、SQLCipherエンジンを利用します。このシステムは基本的に新しいPRAGMAコマンドをSQLiteに導入し、パスフレーズや他の暗号化パラメータの設定を可能にし、データベースファイルを暗号化できるようにします。</p>
<p><cite>pysqlcipher3`はPython 3をサポートする</cite> pysqlcipher`のforkです。ドライバは同じです。</p>
</div>
<div class="section" id="id5">
<h3>文字列を接続する<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>接続文字列の形式は、mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.dialects.sqlite.pysqlite`ドライバと同じように、パスフレーズを含む&amp;quot;パスワード&amp;quot;フィールドが現在受け入れられています。 ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite+pysqlcipher://:testing@/foo.db&#39;</span><span class="p">)</span></pre></div>
</div>
<p>絶対ファイルパスの場合は、データベース名に2つの先頭スラッシュを使用する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite+pysqlcipher://:testing@//path/to/foo.db&#39;</span><span class="p">)</span></pre></div>
</div>
<p><a class="reference external" href="https://www.zetetic.net/sqlcipher/sqlcipher-api">https://www.zetetic.net/sqlcipher/sqlcipher-api</a>/で文書化されているようにSQLCipherでサポートされている追加の暗号化関連プラグマをクエリ文字列に渡すと、新しい接続ごとにPRAGMAが呼び出されます。現在、 `` cipher``、 `` kdf_iter``、 `` cipher_page_size``、 `` cipher_use_hmac``がサポートされています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite+pysqlcipher://:testing@/foo.db?cipher=aes-256-cfb&amp;kdf_iter=64000&#39;</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="pooling-behavior">
<h3>プール動作<a class="headerlink" href="#pooling-behavior" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ドライバは、：ref： <cite>pysqlite_threading_pooling`で説明されているように、pysqliteのデフォルトのプール動作を変更します。 pysqlcipherドライバはpysqliteドライバよりも接続がかなり遅いことが観測されています。おそらく暗号化のオーバーヘッドが原因です。したがって、ここでの方言は：class： `.SingletonThreadPool`実装の代わりに：class：`の代わりに使用されます。 pysqliteによって使用されるNullPoolプール。いつものように、プールの実装は：paramref： `.create_engine.poolclass`パラメータを使って完全に設定可能です。 ：class： `.StaticPool`は、シングルスレッドの場合にはより適しています：class：</cite> .NullPool`は、暗号化されていない接続が長時間オープンされないようにするために使用されます。新しい接続のために。</p>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="postgresql.html" title="previous chapter">PostgreSQL</a>
        Next:
        <a href="sybase.html" title="next chapter">Sybase</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



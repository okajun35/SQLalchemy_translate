<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    用語集
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
        <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="contents.html">Contents</a> |
                <a href="genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy 1.3 Documentation">SQLAlchemy 1.3 Documentation</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="intro.html">概要</a></span></li>
<li><span class="link-container first"><a class="reference external" href="orm/index.html">SQLAlchemy ORM</a></span></li>
<li><span class="link-container first"><a class="reference external" href="core/index.html">SQLAlchemyコア</a></span></li>
<li><span class="link-container first"><a class="reference external" href="dialects/index.html">方言</a></span></li>
<li><span class="link-container first"><a class="reference external" href="faq/index.html">よくある質問</a></span></li>
<li><span class="link-container first"><a class="reference external" href="errors.html">エラーメッセージ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="changelog/index.html">Changes and Migration</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="glossary">
<span id="id1"></span><h1>用語集<a class="headerlink" href="#glossary" title="このヘッドラインへのパーマリンク">¶</a></h1>
<dl class="glossary docutils">
<dt id="term-acid">酸<dt id="term-acid-model">ACIDモデル</dt>
<dd><p class="first">&amp;quot;原子性、一貫性、分離、耐久性&amp;quot;の頭字語。そのデータベーストランザクションが確実に処理されることを保証する一連のプロパティ（ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語：「原子性」</p>
<p>：用語：「整合性」</p>
<p>：用語： <cite>分離</cite></p>
<p>：用語： <cite>耐久性</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/ACID_Model">http://en.wikipedia.org/wiki/ACID_Model</a></p>
</div>
</dd>
<dt id="term-annotations">アノテーション</dt>
<dd><p class="first">アノテーションは、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ClauseElement`オブジェクトとともに追加情報を格納するために、SQLAlchemyによって内部的に使用される概念です。 Python辞書はオブジェクトのコピーに関連付けられています。この中には、主にORM ::内のさまざまな内部システムにとって重要なキーと値のペアが含まれています</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_column</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;some_column&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>
<span class="n">some_column_annotated</span> <span class="o">=</span> <span class="n">some_column</span><span class="o">.</span><span class="n">_annotate</span><span class="p">({</span><span class="s2">&quot;entity&quot;</span><span class="p">:</span> <span class="n">User</span><span class="p">})</span></pre></div>
</div>
<p class="last">アノテーションシステムはパブリックディクショナリ：attr： <cite>.Column.info`とは異なります。上記のアノテーション操作では、すべてのアノテーション値がaの一部とみなされるのではなく、新しい：class：</cite> .Column`の* copy <a href="#id1"><span class="problematic" id="id2">*</span></a>単一ユニット。 ORMは、継承継承エンティティに対して相対的なものとしてレンダリングすべき列と、直接の親表のみに対して相対的にレンダリングすべき列を区別するなど、コンテキストに固有の注釈を適用するために式オブジェクトのコピーを作成します。いくつかのケースでは、ある特定のテーブルエイリアスまたは別のテーブルエイリアスの観点から表現される必要がある関係の「結合条件」内の列を区別するために使用されます。</p>
</dd>
<dt id="term-association-relationship">関連関係</dt>
<dd><p class="first">真ん中の関連テーブルを使って2つのテーブルをつなぎ合わせる2段階：term： <cite>relationship</cite>。関連関係は、：func： <cite>sqlalchemy.orm.relationship`構造体によって目に見えない形で処理されるのではなく、多対多表が完全なクラスによってマップされるという点で、：term：</cite> many to many`関係と異なります。追加の属性が明示的に利用できるように、多対多の場合</p>
<p>たとえば、従業員をプロジェクトに関連させ、その従業員の特定のロールをプロジェクトに保存する場合、リレーショナルスキーマは次のようになります。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">project</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee_project</span> <span class="p">(</span>
    <span class="n">employee_id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">project_id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">role_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="n">employee_id</span> <span class="k">REFERENCES</span> <span class="n">employee</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="n">project_id</span> <span class="k">REFERENCES</span> <span class="n">project</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記のSQLAlchemyの宣言的なマッピングは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Project</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;project&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">EmployeeProject</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee_project&#39;</span>

    <span class="n">employee_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">project_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;project.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">role_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">project</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Project&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;project_employees&quot;</span><span class="p">)</span>
    <span class="n">employee</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;employee_projects&quot;</span><span class="p">)</span></pre></div>
</div>
<p>ロール名を指定して従業員をプロジェクトに追加することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Client A&quot;</span><span class="p">)</span>

<span class="n">emp1</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp1&quot;</span><span class="p">)</span>
<span class="n">emp2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp2&quot;</span><span class="p">)</span>

<span class="n">proj</span><span class="o">.</span><span class="n">project_employees</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
    <span class="n">EmployeeProject</span><span class="p">(</span><span class="n">employee</span><span class="o">=</span><span class="n">emp1</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="s2">&quot;tech lead&quot;</span><span class="p">),</span>
    <span class="n">EmployeeProject</span><span class="p">(</span><span class="n">employee</span><span class="o">=</span><span class="n">emp2</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="s2">&quot;account executive&quot;</span><span class="p">)</span>
<span class="p">])</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：用語：「多対多」</p>
</div>
</dd>
<dt id="term-atomicity">原子性</dt>
<dd><p class="first">Atomicityは：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>ACID`モデルのコンポーネントの1つであり、各トランザクションは&amp;quot;すべてかどうか&amp;quot;である必要があります：トランザクションの一部が失敗し、トランザクション全体が失敗し、データベースの状態は変更されません。原子システムは、停電、エラー、クラッシュなど、すべての状況で原子性を保証する必要があります。 （ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語： <cite>ACID</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Atomicity_(database_systems">http://en.wikipedia.org/wiki/Atomicity_(database_systems</a>）</p>
</div>
</dd>
<dt id="term-backref">バックリファレンス<dt id="term-bidirectional-relationship">双方向関係</dt>
<dd><p class="first">2つの異なる：func： <cite>〜sqlalchemy.orm.relationship`オブジェクトを相互に関連付けることができる：term：</cite> relationship`システムへの拡張です。これらの2つの関係が構築される最も一般的な方法は、一方の側に対して明示的に：func： <cite>〜sqlalchemy.orm.relationship`関数を使用し、他方に</cite> backref``キーワードを指定することです：func： <cite>〜sqlalchemy .orm.relationship`が自動的に作成されます。これを例に挙げてみましょう：term： `one to many`</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;department&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;department&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;department.id&#39;</span><span class="p">))</span></pre></div>
</div>
<p>バックレファレンスは、1対多、多対1、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>many to many &amp;#39;など、あらゆる関係に適用できます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：term： <cite>relationship</cite></p>
<p>：用語：「1対多数」</p>
<p>：用語：「多対1」</p>
<p class="last">：用語：「多対多」</p>
</div>
</dd>
<dt id="term-candidate-key">候補キー</dt>
<dd><p class="first">A：term：行の一意の識別キーを形成する属性または属性セットを参照する「関係代数」用語。 1つの行に複数の候補キーがあり、それぞれがその行の主キーとして使用するのに適しています。テーブルの主キーは常に候補キーです。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：term： <cite>主キー</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Candidate_key">http://en.wikipedia.org/wiki/Candidate_key</a></p>
</div>
</dd>
<dt id="term-check-constraint">チェック制約</dt>
<dd><p class="first">検査制約は、リレーショナル・データベースの表の項目を追加または更新するときに有効なデータを定義する条件です。検査制約が表の各行に適用されます。</p>
<p>（ウィキペディア経由で）</p>
<p>チェック制約は、次のように：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>DDL`を使用して標準SQLのテーブルに追加できます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">distributors</span> <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">zipchk</span> <span class="k">CHECK</span> <span class="p">(</span><span class="k">char_length</span><span class="p">(</span><span class="n">zipcode</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Check_constraint">http://en.wikipedia.org/wiki/Check_constraint</a></p>
</div>
</dd>
<dt id="term-columns-clause">columns句</dt>
<dd><p class="first">結果セットに返されるSQL式を列挙する `` SELECT``ステートメントの部分。式は `` SELECT``キーワードの直後にあり、カンマで区切られた個々の式のリストです。</p>
<p>例えば：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_account</span><span class="p">.</span><span class="n">email</span>
<span class="k">FROM</span> <span class="n">user_account</span> <span class="k">WHERE</span> <span class="n">user_account</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;fred&#39;</span></pre></div>
</div>
<p class="last">上のカラムのリスト `` user_acount.name``、 `` user_account.email``は `` SELECT``のカラム節です。</p>
</dd>
<dt id="term-consistency">一貫性</dt>
<dd><p class="first">整合性は：term： <cite>ACID`モデルのコンポーネントの1つであり、トランザクションによって確実に1つの有効な状態から別の状態にデータベースが移行されます。データベースに書き込まれるデータは、term： `constraints</cite>、カスケード、トリガー、およびそれらの任意の組み合わせなど、すべての定義された規則に従って有効でなければなりません。 （ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語： <cite>ACID</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Consistency_(database_systems">http://en.wikipedia.org/wiki/Consistency_(database_systems</a>）</p>
</div>
</dd>
<dt id="term-constraint">制約<dt id="term-constraints">制約<dt id="term-constrained">拘束された</dt>
<dd>リレーショナルデータベース内に確立され、データの妥当性と整合性を保証するルール。一般的な制約には、term： <cite>primary key constraint</cite>、：term：` foreign key constraint`、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>check constraint`があります。</dd>
<dt id="term-correlates">相関する<dt id="term-correlated-subquery">相関サブクエリ<dt id="term-correlated-subqueries">相関サブクエリ</dt>
<dd><p class="first">A：term： <cite>subquery`は、囲む</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>SELECT``のデータに依存する場合には相関します。</p>
<p>以下では、サブクエリは、 `` user_account.id`の値ごとに呼び出されるように、 `` MIN（a.id） <a href="#id1"><span class="problematic" id="id2">``</span></a>を `` email_address``テーブルから選択し、列を `` email_address.user_account_id``列に置き換えます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">email_address</span><span class="p">.</span><span class="n">email</span>
 <span class="k">FROM</span> <span class="n">user_account</span>
 <span class="k">JOIN</span> <span class="n">email_address</span> <span class="k">ON</span> <span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">email_address</span><span class="p">.</span><span class="n">user_account_id</span>
 <span class="k">WHERE</span> <span class="n">email_address</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">email_address</span> <span class="k">AS</span> <span class="n">a</span>
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">user_account_id</span><span class="o">=</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
 <span class="p">)</span></pre></div>
</div>
<p>上記のサブクエリは、 `` user_account``テーブルを参照します。このテーブルは、このネストされたクエリの `` FROM``節にはありません。代わりに、 `` user_account``テーブルは囲むクエリから受け取られます。ここで `` user_account``から選択された各行はサブクエリの別個の実行をもたらします。</p>
<p>相関サブクエリは、ほとんどの場合、ORDER BY節またはHAVING節だけでなく、すぐに囲まれた `` SELECT``文の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>WHERE節`または：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>columns節`に存在します。</p>
<p>あまり一般的でない場合には、相関サブクエリは、囲む `` SELECT``の：term： <cite>FROM clause`に存在することがあります。これらの場合、相関は、典型的には、次のような別の `</cite> SELECT``のWHERE、ORDER BY、columnsまたはHAVING節に囲まれた囲み `` SELECT``自体に起因します。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">parent</span><span class="p">.</span><span class="n">id</span> <span class="k">FROM</span> <span class="n">parent</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">child</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">parent_id</span> <span class="k">AS</span> <span class="n">parent_id</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">pos</span> <span class="k">AS</span> <span class="n">pos</span>
        <span class="k">FROM</span> <span class="n">child</span>
        <span class="k">WHERE</span> <span class="n">child</span><span class="p">.</span><span class="n">parent_id</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">id</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">child</span><span class="p">.</span><span class="n">pos</span>
    <span class="k">LIMIT</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">)</span></pre></div>
</div>
<p class="last">1つの `` SELECT``から `` FROM``節を介して相関クエリを囲むものへの直接的な相関は不可能です。囲み文のFROM句の元のソース行が利用可能になると相関が進行するだけです。</p>
</dd>
<dt id="term-crud">酷いです</dt>
<dd>&amp;quot;作成、更新、削除&amp;quot;を意味する頭字語。 SQLにおける用語は、用語：DMLとも呼ばれ、データベースからデータを作成、変更、および削除する操作の集合を指し、通常は「INSERT」、「UPDATE」、 <a href="#id1"><span class="problematic" id="id2">`</span></a>DELETE`ステートメント。</dd>
<dt id="term-dbapi">DBAPI</dt>
<dd><p class="first">DBAPIは、&amp;quot;Python Database API Specification &amp;quot;というフレーズの省略形です。これは、すべてのデータベース接続パッケージの共通の使用パターンを定義するPython内で広く使用されている仕様です。 DBAPIは&amp;quot;低レベル&amp;quot; APIで、通常はPythonアプリケーションでデータベースと話すために使用される最低レベルのシステムです。 SQLAlchemyの：term： <cite>dialect`システムは、特定のデータベースエンジンの上に特定のDBAPIを提供する個々のダイアレクトクラスを提供する、DBAPIの操作の周りに構築されます。 ：func： `.create_engine</cite> URL` <cite>postgresql + psycopg2：// &#64; localhost / test``は：mod：</cite> psycopg2 &amp;lt;.​​postgresql.psycopg2&amp;gt; <cite>DBAPI / dialectの組み合わせを指しますが、 `mysql + mysqldb：// &#64; localhost / test``は、：mod：</cite> MySQL for Python &amp;lt;.mysql.mysqldb&amp;gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>DBAPI DBAPI / dialectの組み合わせを指します。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>PEP 249  -  PythonデータベースAPI仕様v2.0 &lt;<a class="reference external" href="http://www.python.org/dev/peps/pep-0249/">http://www.python.org/dev/peps/pep-0249/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
</div>
</dd>
<dt id="term-ddl">DDL</dt>
<dd><p class="first"><a href="#id1"><span class="problematic" id="id2">*</span></a>データ定義言語*の頭字語。 DDLは、データベース・スキーマ内の表、制約およびその他の永続オブジェクトを構成するためにリレーショナル・データベースが使用するSQLのサブセットです。 SQLAlchemyは、DDL式を構築および出力するための豊富なAPIを提供します。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>metadata_toplevel</cite></p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>DDL（ウィキペディア経由） &lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Data_definition_language">http://en.wikipedia.org/wiki/Data_definition_language</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
</div>
</dd>
<dt id="term-deleted">削除された</dt>
<dd><p class="first">これは、オブジェクトがa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`内に持つことができる主要なオブジェクト状態の1つを記述します。削除されたオブジェクトは、以前は永続的であったオブジェクトであり、その行を削除するためにフラッシュ内でデータベースにDELETE文が発行されました。セッションのトランザクションがコミットされると、オブジェクトは：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>detached`状態に移ります。あるいは、セッションのトランザクションがロールバックされると、DELETEは元に戻され、オブジェクトは：term： <a href="#id5"><span class="problematic" id="id6">`</span></a>persistent`状態に戻ります。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_object_states</cite></p>
</div>
</dd>
<dt id="term-descriptor">記述子<dt id="term-descriptors">記述子</dt>
<dd><p class="first">Pythonでは、ディスクリプタは「バインディング動作」を持つオブジェクト属性です。その属性アクセスは、ディスクリプタプロトコルのメソッドによってオーバーライドされています&lt;<a class="reference external" href="http://docs.python.org/howto/descriptor.html">http://docs.python.org/howto/descriptor.html</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_。これらのメソッドは、__get __（）、__set __（）、および__delete __（）です。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、それは記述子であると言われます。</p>
<p>SQLAlchemyでは、記述子は、マップされたクラスで属性の動作を提供するために頻繁に使用されます。クラスがそのようにマップされているとき:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span></pre></div>
</div>
<p>`` MyClass``クラスは、その定義が完了したときにterm： <cite>mapped`となります。その時点で、class：</cite> .Column`オブジェクトとして始まる `` id``と `` data``属性が、上記の `` __get __（） <a href="#id1"><span class="problematic" id="id2">``</span></a>、 `` __set __（） <a href="#id3"><span class="problematic" id="id4">``</span></a>および `` __delete__（）を提供する記述子であるclass： <cite>.InstrumentedAttribute`のインスタンスを持つ：term：</cite> instrumentation`システムで置き換えられます。 （） <a href="#id5"><span class="problematic" id="id6">``</span></a>メソッドを呼び出します。 ：class： <a href="#id7"><span class="problematic" id="id8">`</span></a>.InstrumentedAttribute`は、クラスレベルで使用するとSQL式を生成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">data = :data_1</span></pre></div>
</div>
<p>インスタンスレベルでは、値の変更を追跡します。また、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>lazy loads`データベースからアンロードされた属性:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;some data&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">added</span>
<span class="go">&quot;some data&quot;</span></pre></div>
</div>
</dd>
<dt id="term-detached">分離された</dt>
<dd><p class="first">これは、オブジェクトがa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`内に持つことができる主要なオブジェクト状態の1つを記述します。デタッチされたオブジェクトは、データベースアイデンティティ（すなわち、主キー）を有するが、どのセッションにも関連付けられていないオブジェクトである。以前は：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>persistent`だったオブジェクトが、それが消去されたか、所有しているセッションが閉じられたためにそのセッションから削除されたオブジェクトは、分離状態に移行します。切り離された状態は、オブジェクトがセッション間で移動されるとき、または外部オブジェクトキャッシュとの間で移動されるときに一般に使用されます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_object_states</cite></p>
</div>
</dd>
<dt id="term-discriminator">弁別器</dt>
<dd><p class="first">特定の着信結果行にどのような種類のマップクラスを適用するかを決定するための：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>polymorphic`ローディング中に使用される結果セット列。 SQLAlchemyでは、クラスは常に継承マッピングを使用した階層マッピングの一部です。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>継承_レベル</cite></p>
</div>
</dd>
<dt id="term-domain-model">ドメインモデル</dt>
<dd><p class="first">問題解決とソフトウェア工学におけるドメインモデルは、特定の問題に関連するすべてのトピックの概念モデルです。さまざまなエンティティ、その属性、役割、および関係、および問題のドメインを管理する制約について説明します。</p>
<p>（ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>ドメインモデル（wikipedia） &lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Domain_model">http://en.wikipedia.org/wiki/Domain_model</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
</div>
</dd>
<dt id="term-durability">耐久性</dt>
<dd><p class="first">耐久性は：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>ACID`モデルの特性です。トランザクションがコミットされると、停電、クラッシュ、またはエラーが発生した場合でもその状態が維持されます。たとえば、リレーショナルデータベースでは、一度SQL文のグループが実行されると、結果は永続的に保存される必要があります（データベースがすぐにクラッシュした場合でも）。 （ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語： <cite>ACID</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Durability_(database_systems">http://en.wikipedia.org/wiki/Durability_(database_systems</a>）</p>
</div>
</dd>
<dt id="term-expire">失効する<dt id="term-expires">失効する<dt id="term-expiring">失効する</dt>
<dd><p class="first">SQLAlchemy ORMでは、：term： <cite>persistent`または時には：term：</cite> detached`オブジェクトのデータがいつ消去されるかを参照します。オブジェクトの属性が次にアクセスされるとき、a：term： <cite>lazy load</cite> SQLクエリ現在の進行中のトランザクションに格納されているこのオブジェクトのデータをリフレッシュするために発行されます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_expire</cite></p>
</div>
</dd>
<dt id="term-foreign-key-constraint">外部キー制約</dt>
<dd><p class="first">2つの表間の参照制約。外部キーは、別のテーブルのa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>候補キー（candidate key） &amp;#39;と一致するリレーショナルテーブル内のフィールドまたはフィールドのセットです。外部キーは、テーブルの相互参照に使用できます。 （ウィキペディア経由で）</p>
<p>次のように、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>DDL`を使用して、標準SQLのテーブルに外部キー制約を追加できます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">dep_id_fk</span>
<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">employee</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">department</span> <span class="p">(</span><span class="n">dep_id</span><span class="p">)</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Foreign_key_constraint">http://en.wikipedia.org/wiki/Foreign_key_constraint</a></p>
</div>
</dd>
<dt id="term-from-clause">FROM句</dt>
<dd><p class="first">`` SELECT``文の最初の行のソースを示す部分です。</p>
<p>単純な `` SELECT``はFROM句に1つ以上のテーブル名を持ちます。複数のソースはコンマで区切られます：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span> <span class="k">user</span><span class="p">,</span> <span class="n">address</span>
<span class="k">WHERE</span> <span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
<p>FROM句は、明示的な結合が指定されている場所でもあります。上記の `` SELECT``は、2つのテーブルの `` JOIN``からなる単一の `` FROM``要素を使って書き換えることができます：</p>
<div class="last highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span> <span class="k">user</span> <span class="k">JOIN</span> <span class="n">address</span> <span class="k">ON</span> <span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
</dd>
<dt id="term-generative">生成的</dt>
<dd>SQLAlchemyが、通常は「term： <cite>method chaining</cite>」と呼ばれるものを参照するために使用する用語。詳細については、その用語を参照してください。</dd>
<dt id="term-identity-map">アイデンティティマップ</dt>
<dd><p class="first">PythonオブジェクトとそのデータベースID間のマッピング。アイデンティティマップは、ORM：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`オブジェクトに関連付けられたコレクションであり、そのIDにキーインされたすべてのデータベースオブジェクトの単一インスタンスを保持します。このパターンの利点は、特定のデータベースIDに対して発生するすべての操作が、単一のオブジェクトインスタンスに透過的に調整されることです。 ：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>isolated`トランザクションと一緒にアイデンティティマップを使用する場合、特定の主キーを持つことがわかっているオブジェクトへの参照は、実際のデータベース行へのプロキシであると考えることができます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Martin Fowler  - アイデンティティマップ -  <a class="reference external" href="http://martinfowler.com/eaaCatalog/identityMap.html">http://martinfowler.com/eaaCatalog/identityMap.html</a></p>
</div>
</dd>
<dt id="term-instrumentation">計装<dt id="term-instrumented">計装された<dt id="term-instrumenting">装備</dt>
<dd>計装とは、特定のクラスの機能と属性セットを増強するプロセスを指します。理想的には、クラスの動作は、追加の動作や機能が利用可能になることを除いて、通常のクラスに近いままにする必要があります。とりわけ、SQLAlchemy：term： <cite>mapping`プロセスは、関連するクラスに対する特定のデータベース列または関係を表すマップされたクラスにdatabase-enabled：term：</cite> descriptors &amp;#39;を追加します。</dd>
<dt id="term-isolation">隔離<dt id="term-isolated">分離された</dt>
<dd><p class="first">：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>ACID`モデルのisolationプロパティは、トランザクションの並行実行により、トランザクションが連続して実行された場合、つまり順番に実行される場合に得られるシステム状態になります。各トランザクションは完全に分離して実行する必要があります。つまり、T1とT2が同時に実行される場合は、それぞれが別のトランザクションと独立していなければなりません。 （ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語： <cite>ACID</cite></p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Isolation_(database_systems">http://en.wikipedia.org/wiki/Isolation_(database_systems</a>）</p>
</div>
</dd>
<dt id="term-lazy-load">遅延ロード<dt id="term-lazy-loads">怠惰な負荷<dt id="term-lazy-loaded">怠惰に読み込まれた<dt id="term-lazy-loading">遅延読み込み</dt>
<dd><p class="first">オブジェクトリレーショナルマッピングでは、&amp;quot;レイジーロード&amp;quot;とは、通常、オブジェクトが最初にロードされたときに、データベース側の値が含まれない属性を指します。代わりに、属性はデータベースに送られて最初に使用されたときにそのデータをロードする* memoization <a href="#id1"><span class="problematic" id="id2">*</span></a>を受け取ります。このパターンを使用すると、関連する表の属性をすぐに処理する必要がないため、オブジェクト・フェッチ内で費やされる複雑さと時間を時々削減できます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>レイジーロード（Martin Fowler） &lt;<a class="reference external" href="http://martinfowler.com/eaaCatalog/lazyLoad.html">http://martinfowler.com/eaaCatalog/lazyLoad.html</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
<p>：用語：「Nプラス1つの問題」</p>
<p class="last">：doc： <cite>orm / loading_relationships</cite></p>
</div>
</dd>
<dt id="term-many-to-many">数多く</dt>
<dd><p class="first">中間形式の中間テーブルを介して2つのテーブルをリンクする：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.orm.relationship`のスタイルです。この構成を使用すると、左側の任意の数の行が右側の任意の数の行を参照することができ、その逆もあります。</p>
<p>従業員をプロジェクトに関連付けることができるスキーマ：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">project</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee_project</span> <span class="p">(</span>
    <span class="n">employee_id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">project_id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="n">employee_id</span> <span class="k">REFERENCES</span> <span class="n">employee</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="n">project_id</span> <span class="k">REFERENCES</span> <span class="n">project</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記の `` employee_project``テーブルは多対多のテーブルで、自然に関連する各テーブルの主キーからなる複合主キーを形成します。</p>
<p>SQLAlchemyでは、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.orm.relationship`関数は、多対多の表がプレーン・テーブル・メタデータを使用して指定されるほとんど透過的な方法で、このスタイルの関係を表すことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

    <span class="n">projects</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Project&quot;</span><span class="p">,</span>
        <span class="n">secondary</span><span class="o">=</span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;employee_project&#39;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;employee_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span>
                                <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;project_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;project.id&#39;</span><span class="p">),</span>
                                <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">),</span>
        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;employees&quot;</span>
        <span class="p">)</span>

<span class="k">class</span> <span class="nc">Project</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;project&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span></pre></div>
</div>
<p>上記では、 `` Employee.projects``と `` Project.employees``のコレクションを逆参照しています：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Client A&quot;</span><span class="p">)</span>

<span class="n">emp1</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp1&quot;</span><span class="p">)</span>
<span class="n">emp2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;emp2&quot;</span><span class="p">)</span>

<span class="n">proj</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">emp1</span><span class="p">,</span> <span class="n">emp2</span><span class="p">])</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：用語： <cite>関係関係</cite></p>
<p>：term： <cite>relationship</cite></p>
<p>：用語：「1対多数」</p>
<p class="last">：用語：「多対1」</p>
</div>
</dd>
<dt id="term-many-to-one">多対1</dt>
<dd><p class="first">親マッパーのテーブルの外部キーを関連するテーブルの主キーにリンクする：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.relationship`のスタイル。各親オブジェクトは、正確にゼロまたは1つの関連オブジェクトを参照することができます。</p>
<p>関連するオブジェクトは、それらを参照する任意の数の親オブジェクトに対して、暗黙的または明示的に：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>one to many`関係を持ちます。</p>
<p>1対多のスキーマの例（これは、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>one to many`スキーマと同じです）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">department</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
    <span class="n">dep_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">department</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>1つの部門に多くの従業員レコードを関連付けることができるので、「従業員」から「部署」までの関係は多岐にわたります。 SQLAlchemyマッピングは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;department&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;department.id&#39;</span><span class="p">))</span>
    <span class="n">department</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Department&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：term： <cite>relationship</cite></p>
<p>：用語：「1対多数」</p>
<p class="last">：term： <cite>backref</cite></p>
</div>
</dd>
<dt id="term-mapping">マッピング<dt id="term-mapped">マップされた</dt>
<dd>：func： <cite>.orm.mapper`関数を使って渡されたクラスは、&amp;quot;マップされています&amp;quot;と言います。このプロセスは、クラスをデータベーステーブルまたは他の：term： `selectable`構造に関連付けます。そのため、インスタンスは：class：</cite> .Session`を使用して永続化することができ、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を使用してロードできます。</dd>
<dt id="term-method-chaining">メソッド連鎖</dt>
<dd><p class="first">オブジェクト上のメソッドを呼び出すことによってオブジェクトの状態が構築されるオブジェクト指向技術。オブジェクトには任意の数のメソッドがあり、それぞれがオブジェクトに追加された状態で新しいオブジェクト（場合によっては同じオブジェクト）を返します。</p>
<p>メソッド連鎖を最大限に活用する2つのSQLAlchemyオブジェクトは：class： <cite>〜.expression.Select`オブジェクトと：class：</cite>〜.orm.query.Query`オブジェクトです。たとえば：class： <cite>〜.expression.Select`オブジェクトには、：meth：</cite>〜.Select.where`と：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>を呼び出すことによって、WHERE句とORDER BY句に2つの式を割り当てることができます。 〜.Select.order_by`メソッド:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span>\
            <span class="n">where</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">where</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">order_by</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></pre></div>
</div>
<p>上記の各メソッド呼び出しは、元の：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.Select`オブジェクトのコピーを返します。追加の修飾子が追加されています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：用語：「生成的」</p>
</div>
</dd>
<dt id="term-n-plus-one-problem">Nプラス1つの問題</dt>
<dd><p class="first">Nプラス1つの問題は、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>lazy load`パターンの共通の副作用であり、アプリケーションは、その属性またはコレクションが設定されているオブジェクトの結果セットの各メンバー上の関連する属性またはコレクションを反復したい遅延ロードパターンを介してロードされます。結果として、親オブジェクトの初期結果セットをロードするSELECT文が発行されます。アプリケーションが各メンバーを反復すると、そのメンバーの関連属性またはコレクションをロードするために、各メンバーに対して追加のSELECTステートメントが発行されます。最終的には、N個の親オブジェクトの結果セットに対して、N + 1個のSELECTステートメントが発行されます。</p>
<p>Nプラス1つの問題は、term： <a href="#id1"><span class="problematic" id="id2">`</span></a>eager loading`を使用して緩和されます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：doc： <cite>orm / loading_relationships</cite></p>
</div>
</dd>
<dt id="term-one-to-many">1対多数</dt>
<dd><p class="first">親マッパーのテーブルの主キーを関連するテーブルの外部キーにリンクする：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.relationship`のスタイル。その後、各固有の親オブジェクトは、0以上の固有の関連オブジェクトを参照することができる。</p>
<p>関連するオブジェクトは、親オブジェクトに対して暗黙的または明示的：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>many to one`の関係を持ちます。</p>
<p>1対多のスキーマの例（これは、：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>many to one`スキーマと同じです）：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">department</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
    <span class="n">dep_id</span> <span class="nb">INTEGER</span> <span class="k">REFERENCES</span> <span class="n">department</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>「部署」から「従業員」までの関係は、多くの従業員レコードが1つの部門に関連付けることができるため、1対多です。 SQLAlchemyマッピングは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Department</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;department&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">employees</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Employee&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">dep_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;department.id&#39;</span><span class="p">))</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>：term： <cite>relationship</cite></p>
<p>：用語：「多対1」</p>
<p class="last">：term： <cite>backref</cite></p>
</div>
</dd>
<dt id="term-pending">保留中</dt>
<dd><p class="first">これは、オブジェクトがa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`内に持つことができる主要なオブジェクト状態の1つを記述します。保留中のオブジェクトは、データベースアイデンティティを持たないが、最近セッションに関連付けられた新しいオブジェクトです。セッションがフラッシュされ、行が挿入されると、オブジェクトは：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>persistent`ステートに移動します。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_object_states</cite></p>
</div>
</dd>
<dt id="term-persistent">永続的な</dt>
<dd><p class="first">これは、オブジェクトがa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`内に持つことができる主要なオブジェクト状態の1つを記述します。永続オブジェクトは、データベースID（すなわち主キー）を持ち、現在セッションに関連付けられているオブジェクトです。以前は：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>pending`で挿入されたオブジェクトは、セッションからデータベースからロードされたオブジェクトと同様に永続状態になります。永続オブジェクトがセッションから削除されると、term： <a href="#id5"><span class="problematic" id="id6">`</span></a>detached`と呼ばれます。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_object_states</cite></p>
</div>
</dd>
<dt id="term-polymorphic">多型<dt id="term-polymorphically">多形的に</dt>
<dd><p class="first">一度にいくつかの型を扱う関数を指す。 SQLAlchemyでは、ORMマッピングされたクラスのコンセプトにこの用語が通常適用され、結果セット内の情報に基づいて異なるサブクラスが返されます。通常は、結果として特定の列の値を確認します：term： 「弁別者」。</p>
<p class="last">SQLAlchemyの多態的なロードは、3つの異なるスキームの1つまたは組み合わせを使用してクラスの階層をマップすることを意味します。 &amp;quot;joined &amp;quot;、&amp;quot;single &amp;quot;、&amp;quot;concrete &amp;quot;のいずれかです。セクション：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>inheritance_toplevel`は継承マッピングを完全に記述します。</p>
</dd>
<dt id="term-primary-key">主キー<dt id="term-primary-key-constraint">主キー制約</dt>
<dd><p class="first">A：term： <cite>constraint`は、それぞれ：term：</cite> row`の特性を一意的に定義します。主キーは、他の行で複製できない特性で構成する必要があります。主キーは、単一の属性または複数の属性を組み合わせて構成できます。 （ウィキペディア経由で）</p>
<p>テーブルの主キーは、通常は「CREATE TABLE」内に定義されていますが、term： <cite>DDL</cite>：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">employee</span> <span class="p">(</span>
     <span class="n">emp_id</span> <span class="nb">INTEGER</span><span class="p">,</span>
     <span class="n">emp_name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
     <span class="n">dep_id</span> <span class="nb">INTEGER</span><span class="p">,</span>
     <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">emp_id</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Primary_Key">http://en.wikipedia.org/wiki/Primary_Key</a></p>
</div>
</dd>
<dt id="term-relationship">関係<dt id="term-relationships">関係</dt>
<dd><p class="first">2つのマップされたクラス間の接続ユニット。データベース内の2つのテーブル間の関係に対応します。</p>
<p>この関係は、SQLAlchemy関数func： <cite>〜sqlalchemy.orm.relationship`を使用して定義されます。 SQLAlchemyは、作成された引数と基本的なマッピングを調べて、その関係を：term： `one to many</cite>、：term：` many to one`、または：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>many to many`の3つの型の1つとして分類します。 。この分類では、関係構成は、メモリ内のオブジェクトの関連付けに応答してデータベース内の適切なリンケージを保持するタスクと、データベース内の現在のリンケージに基づいてオブジェクト参照およびコレクションをメモリにロードするジョブを処理します。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>relationship_config_toplevel</cite></p>
</div>
</dd>
<dt id="term-release">解放<dt id="term-releases">リリース<dt id="term-released">解放された</dt>
<dd><p class="first">SQLAlchemyの文脈では、&amp;quot;リリース&amp;quot;という用語は、特定のデータベース接続の使用を終了するプロセスを指します。 SQLAlchemyは接続プールの使用を特徴としており、これによりデータベース接続の寿命についての設定が可能です。プールされた接続を使用する場合、&amp;quot;closing &amp;quot;のプロセス、つまり `` connection.close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>のようなステートメントを呼び出すと、接続が既存のプールに返されるか、その接続によって参照される基礎となるTCP / IP接続を実際にシャットダウンする効果（設定は、プールの現在の状態と同様に）によって異なります。そこで、代わりに* released <a href="#id3"><span class="problematic" id="id4">*</span></a>という言葉を使用しました。&amp;quot;それらを使って終了したら接続を使って何をしていても何でもします&amp;quot;という意味です。</p>
<p>この用語は、「解放トランザクション資源」という句で使用されることがあり、実際に「解放」しているのは、接続時に蓄積されたトランザクション状態です。ほとんどの状況で、テーブルから選択するプロセス、更新を発行するプロセスなどは、その接続と潜在的な行ロックまたはテーブルロックに対して：term： <cite>isolated &amp;#39;状態を取得します。この状態は、接続上の特定のトランザクションに対してすべてローカルであり、ロールバックを発行すると解放されます。接続プールの重要な機能は、プールへの接続を返すときに、DBAPIの `</cite> connection.rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドも呼び出されるため、接続が再び使用されるように設定されるので、以前の一連の操作に参照が保持されていない状態で「クリーン」状態になっています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pooling_toplevel</cite></p>
</div>
</dd>
<dt id="term-returning">戻り値</dt>
<dd><p class="first">これは、特定のバックエンドによってさまざまな形式で提供される非SQL標準句で、INSERT文、UPDATE文またはDELETE文の実行時に結果セットを返すサービスを提供します。一致した行の列の集合は、SELECT文から生成されたかのように戻すことができます。</p>
<p>RETURNING節は、インラインまたはデフォルトで生成されたプライマリ・キー値の取得や作成時のデフォルト値の取得など、共通の更新/選択シナリオに対する劇的なパフォーマンスの向上と、サーバー生成のデフォルト値を取得する方法原子的な方法で</p>
<p>PostgreSQLに慣用されているRETURNINGの例は次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INSERT</span> <span class="n">INTO</span> <span class="n">user_account</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="n">VALUES</span> <span class="p">(</span><span class="s1">&#39;new name&#39;</span><span class="p">)</span> <span class="n">RETURNING</span> <span class="nb">id</span><span class="p">,</span> <span class="n">timestamp</span></pre></div>
</div>
<p>上記のINSERT文は、実行時に、 `` user_account.id``と `` user_account.timestamp``の値を含む結果セットを提供します。これは、上記には含まれていないのでデフォルト値として生成されるべきです（ただし、一連の列またはSQL式は、デフォルト値の列だけでなく、RETURNINGに配置できます）。</p>
<p>現在、RETURNINGなどの構文をサポートするバックエンドは、PostgreSQL、SQL Server、Oracle、およびFirebirdです。 PostgreSQLとFirebirdの実装は一般的にフル機能ですが、SQL ServerとOracleの実装には注意が必要です。 SQL Serverでは、この節はINSERTおよびUPDATE文では &amp;quot;OUTPUT INSERTED&amp;quot;、DELETE文では &amp;quot;OUTPUT DELETED&amp;quot;と呼ばれます。重要な注意点は、このキーワードと組み合わせてトリガーはサポートされないということです。 Oracleでは、 &amp;quot;RETURNING ... INTO &amp;quot;と呼ばれており、値をOUTパラメータに入れる必要があります。これは、構文が厄介なだけでなく、一度に1つの行にしか使用できないことを意味します。</p>
<p class="last">SQLAlchemyの：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.UpdateBase.returning`システムは、これらのバックエンドのRETURNINGシステムの上に抽象レイヤーを提供して、返すカラムに対して一貫したインターフェースを提供します。 ORMには、利用可能な場合にRETURNINGを使用する多くの最適化も含まれています。</p>
</dd>
<dt id="term-session">セッション</dt>
<dd><p class="first">ORMデータベース操作のコンテナまたはスコープ。セッションは、データベースからインスタンスをロードし、マップされたインスタンスへの変更を追跡し、フラッシュされると単一の作業単位で変更を保持します。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：doc： <cite>orm / session</cite></p>
</div>
</dd>
<dt id="term-subquery">サブクエリ</dt>
<dd><p class="first">囲む `` SELECT``の中に埋め込まれた `` SELECT``ステートメントを参照します。</p>
<p>サブクエリには2つの一般的なフレーバがあります。スカラー選択とは、特に1つの行と1つの列を正確に返さなければならないものと、&amp;quot;派生テーブル&amp;quot;として機能し、スカラー選択は、囲み選択の：term： <cite>WHERE句</cite>、：term： <cite>columns節</cite>、ORDER BY句、またはHAVING節に配置することができますが、派生テーブル形式は同封の `` SELECT``のFROM句に入れることができます。</p>
<p>例：</p>
<ol class="last arabic">
<li><p class="first">囲む &amp;quot;SELECT&amp;quot;の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>columns節に置かれたスカラー副問い合わせ。この例のサブクエリは、：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>correlated subquery`です。なぜなら、それが選択する行の一部が囲む文を介して与えられるからです。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">address</span> <span class="k">WHERE</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="o">=</span><span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">FROM</span> <span class="k">user</span></pre></div>
</div>
</li>
<li><p class="first">囲む &amp;quot;SELECT&amp;quot;の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>WHERE句`に置かれたスカラー副問い合わせ。この例のこのサブクエリは、固定結果を選択するときには関連付けられていません。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">name</span> <span class="k">FROM</span> <span class="k">user</span>
<span class="k">WHERE</span> <span class="n">status</span><span class="o">=</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">status_id</span> <span class="k">FROM</span> <span class="n">status_code</span> <span class="k">WHERE</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p class="first">包含する `` SELECT``の：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>FROM clause`に配置された派生テーブル副問い合わせです。このようなサブクエリには、ほとんどの場合、エイリアス名が付けられます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">user</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="k">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ad_subq</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span>
    <span class="k">user</span> <span class="k">JOIN</span>
    <span class="p">(</span><span class="k">select</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">email_address</span> <span class="k">FROM</span> <span class="n">address</span> <span class="k">WHERE</span> <span class="n">address_type</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">)</span> <span class="k">AS</span> <span class="n">ad_subq</span>
    <span class="k">ON</span> <span class="k">user</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">ad_subq</span><span class="p">.</span><span class="n">user_id</span></pre></div>
</div>
</li>
</ol>
</dd>
<dt id="term-transient">一時的な</dt>
<dd><p class="first">これは、オブジェクトがa：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>session`内に持つことができる主要なオブジェクト状態の1つを記述します。一時オブジェクトはデータベースアイデンティティを持たず、まだセッションに関連付けられていない新しいオブジェクトです。オブジェクトがセッションに追加されると、それは：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>pending`の状態に移ります。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>session_object_states</cite></p>
</div>
</dd>
<dt id="term-unique-constraint">ユニーク制約<dt id="term-unique-key-index">一意のキーインデックス</dt>
<dd><p class="first">一意のキー索引は、データベース表のデータ値の各行を一意に識別できます。一意のキー索引は、単一のデータベース表内の単一の列または一連の列で構成されます。 NULL値が使用されない場合、データベース表の2つの異なる行またはデータ・レコードは、これらの一意のキー索引列に同じデータ値（またはデータ値の組み合わせ）を持つことはできません。その設計に応じて、データベーステーブルは多数のユニークキーインデックスを持つことができますが、多くても1つのプライマリキーインデックスを持ちます。</p>
<p>（ウィキペディア経由で）</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Unique_key#Defining_unique_keys">http://en.wikipedia.org/wiki/Unique_key#Defining_unique_keys</a></p>
</div>
</dd>
<dt id="term-unit-of-work">作業単位</dt>
<dd><p class="first">このパターンは、システムがオブジェクトの変更を透過的に追跡し、保留中のすべての変更を定期的にデータベースにフラッシュします。 SQLAlchemyのSessionは、Hibernateのような方法でこのパターンを完全に実装しています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p>マーティン・ファウラーによる「作業単位」 &lt;<a class="reference external" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">http://martinfowler.com/eaaCatalog/unitOfWork.html</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_</p>
<p class="last">：doc： <cite>orm / session</cite></p>
</div>
</dd>
<dt id="term-where-clause">WHERE句</dt>
<dd><p class="first">行をフィルタリングする基準を示す `` SELECT``文の部分。これは、キーワード &amp;quot;WHERE&amp;quot;に続く単一のSQL式です。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_account</span><span class="p">.</span><span class="n">email</span>
<span class="k">FROM</span> <span class="n">user_account</span>
<span class="k">WHERE</span> <span class="n">user_account</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;fred&#39;</span> <span class="k">AND</span> <span class="n">user_account</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span></pre></div>
</div>
<p class="last">上記の文節 `` WHERE user_account.name = &amp;#39;fred&amp;#39; AND user_account.status = &amp;#39;E&amp;#39;``は、 `` SELECT``のWHERE句で構成されています。</p>
</dd>
</dl>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">

    <div id="docs-copyright">
        &copy; <a href="copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    './',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="_static/detectmobile.js"></script>
    <script type="text/javascript" src="_static/init.js"></script>


    </body>
</html>



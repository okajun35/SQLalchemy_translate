<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    SQL式言語チュートリアル
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="SQLAlchemyコア" href="index.html" />
        <link rel="next" title="SQL Statements and Expressions API(SQL文とAPI式)" href="expression_api.html" />
        <link rel="prev" title="SQLAlchemyコア" href="index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemyコア">SQLAlchemyコア</a>
        </h3>

        <ul>
<li class="selected"><span class="link-container first"><strong>SQL式言語チュートリアル</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#version-check">バージョンチェック</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#connecting">接続する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#define-and-create-tables">表の定義と作成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#insert-expressions">式の挿入</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#executing">実行中</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#executing-multiple-statements">複数のステートメントの実行</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#selecting">選択</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#operators">演算子</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#operator-customization">オペレータのカスタマイズ</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#conjunctions">結合詞</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-textual-sql">テキストSQLの使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#specifying-bound-parameter-behaviors">バウンドパラメータビヘイビアの指定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#specifying-result-column-behaviors">結果列ビヘイビアの指定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-text-fragments-inside-bigger-statements">より大きな文の中でのtext（）フラグメントの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-more-specific-text-with-table-literal-column-and-column">：func： <cite>.table</cite></a></span></li>
<li><span class="link-container first"><a class="reference external" href="#ordering-or-grouping-by-a-label">ラベルによる注文またはグループ化</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#using-aliases">エイリアスの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-joins">結合の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#everything-else">ほかのすべて</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#bind-parameter-objects">パラメータオブジェクトのバインド</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#functions">関数</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#window-functions">ウィンドウ関数</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#unions-and-other-set-operations">組合とその他の集合演算</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#scalar-selects">スカラ選択</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#correlated-subqueries">相関サブクエリ</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#lateral-correlation">LATERAL相関</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#ordering-grouping-limiting-offset-ing">オーダー、グルーピング、制限、オフセット... ing ...</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#inserts-updates-and-deletes">挿入、更新、および削除</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#correlated-updates">相関関係の更新</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#multiple-table-updates">複数のテーブルの更新</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#parameter-ordered-updates">パラメータオーダーの更新</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#deletes">削除</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#multiple-table-deletes">複数のテーブルの削除</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#matched-row-counts">一致した行数</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#further-reference">さらなる参照</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="expression_api.html">SQL Statements and Expressions API(SQL文とAPI式)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="schema.html">スキーマ定義言語</a></span></li>
<li><span class="link-container first"><a class="reference external" href="types.html">列とデータ型</a></span></li>
<li><span class="link-container first"><a class="reference external" href="engines_connections.html">エンジンと接続の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="api_basics.html">コアAPIの基礎</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="sql-expression-language-tutorial">
<span id="sqlexpression-toplevel"></span><h1>SQL式言語チュートリアル<a class="headerlink" href="#sql-expression-language-tutorial" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>SQLAlchemy Expression Languageは、Pythonの構造を使ってリレーショナルデータベースの構造と表現を表現するシステムを提供します。これらの構成は、データベースのバックエンド間のさまざまな実装の違いを抽象化しながら、できるだけ密接に基盤データベースのものに似せるようにモデル化されています。構築物は、一貫した構造を持つバックエンド間で同等の概念を表現しようとしますが、バックエンドの特定のサブセットに固有の有用な概念を隠すわけではありません。したがって、Expression Languageは、バックエンドに中立なSQL式を記述する方法を提供しますが、式がバックエンドに中立であることを強制しようとしません。</p>
<p>Expression Languageは、Object Relational Mapperと対照的です。これは、Expression Languageの上に構築される個別のAPIです。 ：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>ormtutorial_toplevel`で導入されたORMは、高いレベルで抽象化された使用パターンを提示しますが、それ自体が表現言語の適用された使い方の例です。表現言語は、リレーショナルのプリミティブ構造を表すシステムを提示します意見なしで直接データベース。</p>
<p>ORMと表現言語の使用パターンには重複がありますが、類似点は最初に現れるよりも表面的です。ユーザ定義のドメインモデルの観点から、データの構造と内容にアプローチする&lt;<a class="reference external" href="http://en.wikipedia.org/wiki/Domain_model">http://en.wikipedia.org/wiki/Domain_model</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_は透過的に永続化され、その基礎となるストレージモデルからリフレッシュされます。もう1つは、データベースによって個別に消費されるメッセージに明示的に構成されたリテラルスキーマとSQL式表現の観点からアプローチする方法です。</p>
<p>アプリケーションの概念を個々のデータベースメッセージと個々のデータベース結果セットに変換する独自のシステムを定義する必要がありますが、エクスプレッション言語のみを使用してアプリケーションを構築することができます。あるいは、ORMで構築されたアプリケーションは、高度なシナリオでは、特定のデータベースのやりとりが必要な特定の領域で直接Expression Languageを使用することがあります。</p>
<p>次のチュートリアルはdoctest形式です。つまり、 `` &amp;gt;&amp;gt;&amp;gt; <a href="#id1"><span class="problematic" id="id2">``</span></a>の行はPythonコマンドプロンプトで入力できるものを表し、次のテキストは期待される戻り値を表します。チュートリアルには前提条件はありません。</p>
<div class="section" id="version-check">
<h2>バージョンチェック<a class="headerlink" href="#version-check" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyのバージョン1.3 <a href="#id1"><span class="problematic" id="id2">**</span></a>以上であることを確認するためのクイックチェック：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sqlalchemy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">__version__</span>  
<span class="go">1.3.0</span></pre></div>
</div>
</div>
<div class="section" id="connecting">
<h2>接続する<a class="headerlink" href="#connecting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このチュートリアルでは、メモリ内のSQLiteデータベースを使用します。これは、実際のデータベースをどこにでも定義する必要なく、物をテストする簡単な方法です。接続するには：func： <cite>〜sqlalchemy.create_engine</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre></div>
</div>
<p>`` echo``フラグは、SQLAlchemyのロギングを設定するためのショートカットです。これは、Pythonの標準の `` logging``モジュールによって実現されます。これを有効にすると、生成されたすべての生成SQLが表示されます。このチュートリアルで作業しており、生成される出力が少なくてすむようなら、 `` False``に設定してください。このチュートリアルでは、SQLをポップアップウィンドウの後ろに書式設定して、私たちのやり方では得られないようにします。 &amp;quot;SQL &amp;quot;リンクをクリックして、何が生成されているかを確認してください。</p>
<p>：func： <cite>.create_engine`の戻り値は：class：</cite> .Engine`のインスタンスであり、データベースのコアインタフェースを表し、：term： <cite>dialect`によって適合され、データベースの詳細を処理します。 ：term： `DBAPI`が使用中です。この場合、SQLiteダイアレクトはPythonの組み込み `</cite> sqlite3``モジュールへの命令を解釈します。</p>
<div class="sidebar">
<p class="first sidebar-title">Lazy Connecting</p>
<p class="last">：class： <cite>.Engine`は：func：</cite> .create_engine`によって最初に返されたときに、まだデータベースに接続しようとしていません。これは、初めてデータベースに対してタスクを実行するように要求されたときにのみ発生します。</p>
</div>
<p>初めて：meth： <cite>.Engine.execute`や：meth：</cite> .Engine.connect`のようなメソッドが呼び出されると、class： <cite>.Engine`はデータベースへのreal：term：</cite> DBAPI`接続を確立します。これを使用してSQLを発行します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>database_urls</cite>  - いくつかの種類のデータベースに接続する：func：` .create_engine`の例を含んでいます。</p>
</div>
</div>
<div class="section" id="define-and-create-tables">
<h2>表の定義と作成<a class="headerlink" href="#define-and-create-tables" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQL式言語は、ほとんどの場合、表の列に対して式を構成します。 SQLAlchemyでは、カラムはclass： <cite>〜sqlalchemy.schema.Column`というオブジェクトで表現されることが最も多く、すべての場合にclass：</cite>〜sqlalchemy.schema.Column`は：class： <cite>〜 sqlalchemy.schema.Table</cite>。 ：class： <cite>〜sqlalchemy.schema.Table`オブジェクトとそれに関連する子オブジェクトのコレクションは、**データベースメタデータ**と呼ばれます。このチュートリアルでは、class： `〜sqlalchemy.schema.Table`オブジェクトを明示的にレイアウトしますが、SAは：class：</cite>〜sqlalchemy.schema.Table`オブジェクトのセット全体を自動的に&amp;quot;インポート&amp;quot;することもできます既存のデータベース（このプロセスを**表反映**と呼びます）。</p>
<p>通常のSQL CREATE TABLE文に似ている：class： <cite>〜sqlalchemy.schema.Table`構文を使用して、class：</cite>〜sqlalchemy.schema.MetaData`というカタログ内にテーブルを定義します。 2つのテーブルを作成します。そのうちの1つはアプリケーション内の&amp;quot;users &amp;quot;を表し、もう1つは&amp;quot;users &amp;quot;テーブルの各行の0以上の&amp;quot;電子メールアドレス&amp;quot;を表します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">addresses</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;email_address&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span></pre></div>
</div>
<p>：class： <cite>〜sqlalchemy.schema.Table`オブジェクトの定義方法と既存のデータベースから自動的に作成する方法については、ref：</cite> metadata_toplevel`を参照してください。</p>
<p>次に、：class： <cite>〜sqlalchemy.schema.MetaData`を伝えるために、私たちは実際にSQLiteデータベース内のテーブルの選択を作成したいと考えています：func：</cite>〜sqlalchemy.schema.MetaData.create_all`、私たちのデータベースを指す `` engine``インスタンスを渡します。これは、作成する前に各テーブルの存在を最初にチェックするので、複数回呼び出しても安全です。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<span class="go">SE...</span>
<div class='popup_sql'>CREATE TABLE users (
    id INTEGER NOT NULL,
    name VARCHAR,
    fullname VARCHAR,
    PRIMARY KEY (id)
)
()
COMMIT
CREATE TABLE addresses (
    id INTEGER NOT NULL,
    user_id INTEGER,
    email_address VARCHAR NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY(user_id) REFERENCES users (id)
)
()
COMMIT</div></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>CREATE TABLEの構文に精通しているユーザーは、VARCHAR列が長さなしで生成されたことに気付くことがあります。 SQLiteとPostgreSQLでは、これは有効なデータ型ですが、他のものでは許可されていません。したがって、これらのデータベースの1つでこのチュートリアルを実行し、SQLAlchemyを使用してCREATE TABLEを発行する場合は、以下のようにclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.types.String`型に&amp;quot; length &amp;quot;を指定することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span></pre></div>
</div>
<p>長さフィールドは：class： <cite>〜sqlalchemy.types.String`と同様の精度/スケールフィールドで利用できます：class：</cite>〜sqlalchemy.types.Integer`、：class： <cite>〜sqlalchemy.types.Numeric</cite>、テーブルの作成時以外はSQLAlchemyによって参照されません。</p>
<p>さらに、FirebirdとOracleは新しい主キー識別子を生成するためにシーケンスを必要とし、SQLAlchemyは指示されずにこれらを生成したり仮定したりしません。そのためには、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.schema.Sequence`コンストラクトを使用します：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Sequence</span>
<span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.schema.Table`は次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">(</span><span class="s1">&#39;user_id_seq&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
   <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p class="last">主にin-Pythonの使用法のみを対象とした最小コンストラクトと、特定のセットのCREATE TABLE文を発行するために使用されるものとの違いを強調するために、このより詳細な：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.schema.Table`構造を個別に組み込みます。より厳しい要件のバックエンド。</p>
</div>
</div>
<div class="section" id="insert-expressions">
<span id="coretutorial-insert-expressions"></span><h2>式の挿入<a class="headerlink" href="#insert-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最初に作成するSQL式は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.Insert`です。これはINSERT文を表します。これは、通常、ターゲットテーブルに対して作成されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span></pre></div>
</div>
<p>この構文が生成するSQLのサンプルを見るには、 `` str（） <a href="#id1"><span class="problematic" id="id2">``</span></a>関数を使います:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (id, name, fullname) VALUES (:id, :name, :fullname)&#39;</span></pre></div>
</div>
<p>上記のINSERTステートメントは、 `` users``テーブルのすべてのカラムに名前を付けています。これは、INSERTのVALUES句を明示的に確立する `` values（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドを使うことで制限できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Jack Jones&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (name, fullname) VALUES (:name, :fullname)&#39;</span></pre></div>
</div>
<p>上記の `` values``メソッドはVALUES句を2つのカラムに限定していましたが、 `` values``に置かれた実際のデータは文字列にレンダリングされませんでした。代わりに、名前付きのバインドパラメータが取得されます。実際には、私たちのデータ*は*：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.Insert`構造体に格納されていますが、通常はその文が実際に実行されたときにのみ出力されます。データはリテラル値で構成されているため、SQLAlchemyは自動的にバインドパラメータを生成します。このデータは、コンパイルされた次のような文を見ればわかります。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span>  
<span class="go">{&#39;fullname&#39;: &#39;Jack Jones&#39;, &#39;name&#39;: &#39;jack&#39;}</span></pre></div>
</div>
</div>
<div class="section" id="executing">
<h2>実行中<a class="headerlink" href="#executing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>興味深い：class： <cite>〜sqlalchemy.sql.expression.Insert`がそれを実行しています。このチュートリアルでは、一般に、SQL構造を実行する最も明白な方法に焦点を当て、後でそれを行うためのいくつかの &amp;quot;ショートカット&amp;quot;方法に触れます。作成した `</cite> engine``オブジェクトは、SQLをデータベースに発行できるデータベース接続のリポジトリです。接続を取得するには、 `` connect（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドを使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span>
<span class="go">&lt;sqlalchemy.engine.base.Connection object at 0x...&gt;</span></pre></div>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.engine.Connection`オブジェクトは、アクティブにチェックアウトされたDBAPI接続リソースを表します。 class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.sql.expression.Insert`オブジェクトをフィードし、何が起こるかを見てみましょう：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<div class='show_sql'>INSERT INTO users (name, fullname) VALUES (?, ?)
(&#39;jack&#39;, &#39;Jack Jones&#39;)
COMMIT</div></pre></div>
</div>
<p>そのため、INSERT文がデータベースに発行されました。出力の&amp;quot;named &amp;quot;バインドパラメータの代わりに位置&amp;quot;qmark &amp;quot;バインドパラメータを取得しましたが、どうして ？実行されると、：class： <cite>〜sqlalchemy.engine.Connection`はSQLite **方言**を使ってステートメントを生成します。 `</cite> str（） <a href="#id1"><span class="problematic" id="id2">``</span></a>関数を使うと、このステートメントはこの方言を認識せず、名前付きパラメータを使うデフォルトに戻ります。これを手動で次のように表示できます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">engine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
<span class="go">&#39;INSERT INTO users (name, fullname) VALUES (?, ?)&#39;</span></pre></div>
</div>
<p>`` execute（） <a href="#id1"><span class="problematic" id="id2">``</span></a>と呼んだときに得た `` result``変数はどうでしょうか？ SQLAlchemy：class： <cite>〜sqlalchemy.engine.Connection`オブジェクトはDBAPI接続を参照するため、a：class：</cite>〜sqlalchemy.engine.ResultProxy`オブジェクトと呼ばれる結果はDBAPIカーソルオブジェクトに似ています。 INSERTの場合、ステートメントから生成された主キーの値（attr： <cite>.ResultProxy.inserted_primary_key</cite>）など、重要な情報を取得できます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">inserted_primary_key</span>
<span class="go">[1]</span></pre></div>
</div>
<p>`` 1``の値はSQLiteによって自動的に生成されましたが、class： <cite>〜sqlalchemy.sql.expression.Insert`ステートメントで</cite> <cite>id``カラムを指定しなかったためです。それ以外の場合は、明示的な値が使用されます。どちらの場合でも、SQLAlchemyは、新しく生成された主キー値を取得する方法を常に知っています。各データベースのclass： `〜sqlalchemy.engine.interfaces.Dialect`は、正しい値（または値; attr：</cite> .ResultProxy.inserted_primary_key`）が複合主キーをサポートするようにリストを返します）。ここでのメソッドには、 `` cursor.lastrowid``からデータベース固有の関数から `` INSERT..RETURNING``構文の使用までの範囲があります。これはすべて透過的に行われます。</p>
</div>
<div class="section" id="executing-multiple-statements">
<span id="execute-multiple"></span><h2>複数のステートメントの実行<a class="headerlink" href="#executing-multiple-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上記の挿入例は、意図的に表現言語構造の様々な振る舞いを示すために描かれたものです。普通の場合、class： <cite>〜sqlalchemy.sql.expression.Insert`文は通常、class：</cite>〜sqlalchemy.engine.Connection`の `` execute（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドに送られるパラメータに対してコンパイルされます。 class： <cite>〜sqlalchemy.sql.expression.Insert`で</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>values``キーワードを使う必要はありません。 <a href="#id5"><span class="problematic" id="id6">`</span></a>〜sqlalchemy.sql.expression.Insert`ステートメントを再度作成し、それを&amp;quot;通常の&amp;quot;という形で使用します：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">)</span>
<div class='show_sql'>INSERT INTO users (id, name, fullname) VALUES (?, ?, ?)
(2, &#39;wendy&#39;, &#39;Wendy Williams&#39;)
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
<p>上記では、 `` execute（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドで3つのカラムをすべて指定したため、コンパイルされた：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.expression.Insert`には3つのカラムがすべて含まれていました。 ：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>〜.expression.Insert`文は、指定されたパラメータに基づいて実行時にコンパイルされます。より少ないパラメータを指定すると、：class： <a href="#id7"><span class="problematic" id="id8">`</span></a>〜.expression.Insert`はそのVALUES句に含まれるエントリが少なくなります。</p>
<p>DBAPIの `` executemany（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドを使って多くのインサートを発行するには、いくつかの電子メールアドレスを追加するために、挿入する個別のパラメータセットを含むディクショナリのリストを送ることができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">[</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;www@www.org&#39;</span><span class="p">},</span>
<span class="gp">... </span>   <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span> <span class="p">:</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">},</span>
<span class="gp">... </span><span class="p">])</span>
<div class='show_sql'>INSERT INTO addresses (user_id, email_address) VALUES (?, ?)
((1, &#39;jack@yahoo.com&#39;), (1, &#39;jack@msn.com&#39;), (2, &#39;www@www.org&#39;), (2, &#39;wendy@aol.com&#39;))
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
<p>上記では、各「アドレス」行のSQLiteの主キー識別子の自動生成に再び依存しました。</p>
<p>複数のパラメータセットを実行する場合、各辞書に**同じ**キーセットが必要です。つまり、ある辞書では他の辞書より少ないキーしか持っていません。これは、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.Insert`ステートメントがリストの**最初の**ディクショナリに対してコンパイルされているためで、後続のすべての引数ディクショナリがそのステートメントと互換性があると仮定しています。</p>
<p>&amp;quot;executemany &amp;quot;スタイルの呼び出しは：func： <cite>.insert</cite>、：func：` .update`と：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.delete`の各構文で利用できます。</p>
</div>
<div class="section" id="selecting">
<span id="coretutorial-selecting"></span><h2>選択<a class="headerlink" href="#selecting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>私たちは、テストデータベースにデータが入っているように、挿入を開始しました。より興味深いのは、データを選択することです！後でUPDATEとDELETE文について説明します。 SELECT文を生成するために使用される主な構文は、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`関数です：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<div class='show_sql'>SELECT users.id, users.name, users.fullname
FROM users
()</div></pre></div>
</div>
<p>上では、basic：func： <cite>.select`コールを発行し、selectのCOLUMNS句に</cite> <cite>users``テーブルを置き、実行しました。 SQLAlchemyは、 `</cite> users``テーブルを各カラムのセットに展開し、FROM句を生成しました。返される結果は、再び：class： <cite>〜sqlalchemy.engine.ResultProxy`オブジェクトです。このオブジェクトは、func：</cite>〜sqlalchemy.engine.ResultProxy.fetchone`や：func： <cite>〜などのメソッドを含むDBAPIカーソルとよく似た働きをします。 sqlalchemy.engine.ResultProxy.fetchall</cite>。行を取得する最も簡単な方法は、反復処理だけです。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)</span></pre></div>
</div>
<p>上記のように、各行を印刷すると単純なタプルのような結果が得られることがわかります。各行のデータにアクセスする際の選択肢が増えました。非常に一般的な方法の1つは、列の文字列名を使用した辞書アクセスによるものです。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname
FROM users
()

</div><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;fullname&#39;</span><span class="p">])</span>
<span class="go">name: jack ; fullname: Jack Jones</span></pre></div>
</div>
<p>整数インデックスも同様に動作します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">name: wendy ; fullname: Wendy Williams</span></pre></div>
</div>
<p>しかし、後で明白になる別の方法は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.schema.Column`オブジェクトをキーとして直接使うことです：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="s2">&quot;; fullname:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname
FROM users
()
</div><span class="go">name: jack ; fullname: Jack Jones</span>
<span class="go">name: wendy ; fullname: Wendy Williams</span></pre></div>
</div>
<p>保留中の行が残っている結果セットは、破棄する前に明示的に閉じておく必要があります。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.engine.ResultProxy`で参照されるカーソルと接続リソースは、オブジェクトがガベージコレクトされたときに閉じられ、接続プールに返されますが、一部のデータベースAPIは非常に厄介なので、そのようなことについて：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>selectのCOLUMNS節に置かれているカラムをもっと慎重に制御したい場合は、class： <cite>〜sqlalchemy.schema.Column`オブジェクトをindividual：class：</cite>〜sqlalchemy.schema.Table`から参照します。 。これらは、class： <cite>〜sqlalchemy.schema.Table`オブジェクトの</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>c``属性から名前付き属性として利用できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<div class='popup_sql'>SELECT users.name, users.fullname
FROM users
()
</div><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">(u&#39;jack&#39;, u&#39;Jack Jones&#39;)</span>
<span class="go">(u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)</span></pre></div>
</div>
<p>FROM句に関する興味深いことを観察できます。生成されたステートメントは2つの異なるセクション、すなわち &amp;quot;SELECT columns&amp;quot;部分と &amp;quot;FROM table&amp;quot;部分を含んでいますが、私たちの：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`構造は列を含むリストしか持っていません。これはどのように作動しますか ？ func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.select`ステートメントに* 2つのテーブルを入れてみましょう：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname, addresses.id, addresses.user_id, addresses.email_address
FROM users, addresses
()
</div><span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span></pre></div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>両方の**テーブルをFROM句に入れました。しかしまた、それは本当の混乱を作りました。 SQLに慣れている人は、これが**デカルト製品**であることを知っています。 `` users``テーブルの各行は `` addresses``テーブルの各行に対して生成されます。したがって、この文にいくつかの正気を置くためには、WHERE句が必要です。これを行うには：meth： <cite>.Select.where</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname, addresses.id,
   addresses.user_id, addresses.email_address
FROM users, addresses
WHERE users.id = addresses.user_id
()
</div><span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;)</span>
<span class="go">(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 3, 2, u&#39;www@www.org&#39;)</span>
<span class="go">(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 4, 2, u&#39;wendy@aol.com&#39;)</span></pre></div>
</div>
<p>だからもっと良く見えるように、私たちはfunc： <cite>.select`に式を追加しました。これは</cite> <cite>WHERE users.id = addresses.user_id``を文に追加する効果があり、結果は`</cite> users``と `` addresses``行の結合が意味を成していました。しかし、その表現を見てみましょうか？ 2つの異なるクラス： <cite>〜sqlalchemy.schema.Column`オブジェクトの間でPythonの等価演算子を使用しています。何かが起こっていることは明らかです。 `</cite> 1 == 1``は `` True``を出力し、 `` 1 == 2``はWHERE句ではなく `` False``を出力します。その表現が何をしているのかを正確に見ることができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span>
<span class="go">&lt;sqlalchemy.sql.elements.BinaryExpression object at 0x...&gt;</span></pre></div>
</div>
<p>うわー、驚き！これは「真」でも「偽」でもない。まあそれは何ですか？</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">&#39;users.id = addresses.user_id&#39;</span></pre></div>
</div>
<p>ご覧のとおり、 `` == <a href="#id1"><span class="problematic" id="id2">``</span></a>演算子は、これまでのところ、class： <cite>〜.expression.Insert`と：func：</cite> .select`オブジェクトに非常によく似たオブジェクトを生成しています。ありがとうPythonの `` __eq __（） <a href="#id3"><span class="problematic" id="id4">``</span></a>に組み込みます。あなたは `` str（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を呼び出してSQLを生成します。ここまでで、作業しているものはすべて最終的に同じタイプのオブジェクトであることがわかります。 SQLAlchemyは、これらすべての式の基本クラスをclass： <a href="#id7"><span class="problematic" id="id8">`</span></a>〜.expression.ColumnElement`と呼びます。</p>
</div>
<div class="section" id="operators">
<h2>演算子<a class="headerlink" href="#operators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyの演算子パラダイムを見つけたので、いくつかの機能を試してみましょう。 2つの列を相互に等しくする方法を見てきました。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">users.id = addresses.user_id</span></pre></div>
</div>
<p>リテラル値（SQLAlchemy句オブジェクトではなく文字通りの意味）を使用すると、バインドパラメータが取得されます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">users.id = :id_1</span></pre></div>
</div>
<p>`` 7``リテラルは次のように埋め込まれます：class： <cite>〜.expression.ColumnElement</cite>; ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.Insert`オブジェクトを使って同じトリックを使用することができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span>
<span class="go">{u&#39;id_1&#39;: 7}</span></pre></div>
</div>
<p>ほとんどのPython演算子は、equals、equalsなどのように、ここにSQL式を生成します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">users.id != :id_1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># None converts to IS NULL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">users.name IS NULL</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># reverse works too</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;fred&#39;</span> <span class="o">&gt;</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">users.name &lt; :name_1</span></pre></div>
</div>
<p>2つの整数列を加算すると、加算式が得られます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">users.id + addresses.id</span></pre></div>
</div>
<p>興味深いことに、：class： <cite>〜sqlalchemy.schema.Column`の型は重要です！ 2つの文字列ベースの列を持つ `</cite> + <a href="#id1"><span class="problematic" id="id2">``</span></a>を使用する場合（class： <cite>〜sqlalchemy.types.Integer`と：class：</cite>〜sqlalchemy.types.String`のような型をクラス： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy最初に.schema.Column`オブジェクト）、私たちは何か違うものを得ます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span>
<span class="go">users.name || users.fullname</span></pre></div>
</div>
<p>`` || <a href="#id1"><span class="problematic" id="id2">``</span></a>はほとんどのデータベースで使用される文字列連結演算子です。しかし、それらのすべてではありません。 MySQLのユーザーは、恐れていない：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">((</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>     <span class="nb">compile</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mysql://&#39;</span><span class="p">)))</span> 
<span class="go">concat(users.name, users.fullname)</span></pre></div>
</div>
<p>上の例は、MySQLデータベースに接続されている：class： <cite>〜sqlalchemy.engine.Engine`に対して生成されたSQLを示しています。 `</cite> || <a href="#id1"><span class="problematic" id="id2">``</span></a>演算子はMySQLの `` concat（） <a href="#id3"><span class="problematic" id="id4">``</span></a>関数としてコンパイルされるようになりました。</p>
<p>実際に利用できない演算子を見つけた場合は、常に：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Operators.op`メソッドを使用できます。必要な演算子を生成します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;tiddlywinks&#39;</span><span class="p">)(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span>
<span class="go">users.name tiddlywinks :name_1</span></pre></div>
</div>
<p>この関数は、ビット演算子を明示的にするためにも使用できます。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)(</span><span class="mh">0xff</span><span class="p">)</span></pre></div>
</div>
<p>`` somecolumn``の値のビット単位のANDです。</p>
<p>：meth： <cite>.Operators.op`を使用する場合、演算子が結果列として送られる式で使用されるときは、式の戻り値の型が重要になります。この場合、通常どおりでない場合は、型を明示的に明示してください：func： `.type_coerce</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">type_coerce</span>
<span class="n">expr</span> <span class="o">=</span> <span class="n">type_coerce</span><span class="p">(</span><span class="n">somecolumn</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s1">&#39;-%&gt;&#39;</span><span class="p">)(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="n">MySpecialType</span><span class="p">())</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span></pre></div>
</div>
<p>ブール演算子の場合は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Operators.bool_op`メソッドを使用します。これにより、式の戻り値の型がboolean ::として扱われます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">somecolumn</span><span class="o">.</span><span class="n">bool_op</span><span class="p">(</span><span class="s1">&#39;--&gt;&#39;</span><span class="p">)(</span><span class="s1">&#39;some value&#39;</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2.0b3 で追加: </span>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Operators.bool_op`メソッドを追加しました。</p>
</div>
<div class="section" id="operator-customization">
<h3>オペレータのカスタマイズ<a class="headerlink" href="#operator-customization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>急いでカスタムオペレータを得るには：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Operators.op`が便利ですが、コアはタイプレベルでのオペレータシステムの基本的なカスタマイズと拡張をサポートします。既存の演算子の動作は、型ごとに変更することができ、新しい演算を定義して、その特定の型の一部であるすべての列式で使用できるようにすることができます。説明については：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>types_operators`を参照してください。</p>
</div>
</div>
<div class="section" id="conjunctions">
<h2>結合詞<a class="headerlink" href="#conjunctions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>我々は、func： <cite>.select`構造体の中にいくつかの演算子を披露したいと思います。しかし、もう少しまとめる必要があるので、最初に接続詞を紹介しましょう。結合詞は、物事をまとめるANDやORのような小さな言葉です。我々はまた、NOTに当てるでしょう。 ：func： `.and_</cite>、：func：` .or_`、そして：func： <cite>.not_`は、SQLAlchemyが提供する対応する関数から動作することができます（：meth：</cite>〜.ColumnOperators.like`） ：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;j%&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>             <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span>
<span class="gp">... </span>        <span class="p">),</span>
<span class="gp">... </span>        <span class="n">not_</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>      <span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
<span class="go">users.name LIKE :name_1 AND users.id = addresses.user_id AND</span>
<span class="go">(addresses.email_address = :email_address_1</span>
<span class="go">   OR addresses.email_address = :email_address_2)</span>
<span class="go">AND users.id &lt;= :id_1</span></pre></div>
</div>
<p>また、リジグされたビット単位のAND、OR、およびNOT演算子を使用することもできます。ただし、演​​算子の優先順位がPythonのため、カッコを見る必要があります。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;j%&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span> <span class="o">&amp;</span>
<span class="gp">... </span>    <span class="p">(</span>
<span class="gp">... </span>      <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">)</span> <span class="o">|</span> \
<span class="gp">... </span>      <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span> \
<span class="gp">... </span>    <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">users.name LIKE :name_1 AND users.id = addresses.user_id AND</span>
<span class="go">(addresses.email_address = :email_address_1</span>
<span class="go">    OR addresses.email_address = :email_address_2)</span>
<span class="go">AND users.id &lt;= :id_1</span></pre></div>
</div>
<p>したがって、このすべての語彙では、AOLまたはMSNのメールアドレスを持つすべてのユーザーを選択しましょう。名前は&amp;quot;m &amp;quot;と&amp;quot;z &amp;quot;の間の文字で始まり、フルネームとメールアドレスを組み合わせたものです。この文には、meth： <cite>〜.ColumnOperators.between`と：meth：</cite>〜.ColumnElement.label`の2つの新しい構造体を追加します。 ：meth： <cite>〜.ColumnOperators.between`はBETWEEN句を生成し、</cite> <cite>AS``キーワードを使ってラベルを生成するために：meth：</cite>〜.ColumnElement.label`を列式で使用します。それ以外の場合は名前を持たない式から選択することをお勧めします：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
<span class="gp">... </span>              <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>          <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>              <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>              <span class="p">)</span>
<span class="gp">... </span>          <span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">SELECT users.fullname || ? || addresses.email_address AS title</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND</span>
<span class="go">(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class="go">(&#39;, &#39;, &#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span></pre></div>
</div>
<p>もう一度、SQLAlchemyは私たちのステートメントのFROM句を見つけました。実際には、他のすべてのビットに基づいてFROM句を決定します。 columns句、where句、およびORDER BY、GROUP BY、およびHAVINGを含むまだ扱っていない他の要素が含まれています。</p>
<p>：func： <cite>.and_`を使うショートカットは、複数の：meth：</cite>〜.Select.where`節を連鎖することです。上記は次のように書くこともできます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
<span class="gp">... </span>              <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>              <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
<span class="gp">... </span>              <span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<span class="go">SELECT users.fullname || ? || addresses.email_address AS title</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND</span>
<span class="go">(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)</span>
<span class="go">(&#39;, &#39;, &#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)</span>
<span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span></pre></div>
</div>
<p>連続するメソッド呼び出しを通じてa：func： <cite>.select`構造を構築する方法は、term：</cite> method chaining`と呼ばれます。</p>
</div>
<div class="section" id="using-textual-sql">
<span id="sqlexpression-text"></span><h2>テキストSQLの使用<a class="headerlink" href="#using-textual-sql" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>私たちの最後の例は実際には少数になりました。理解しているものをテキストのSQL式にすることから、プログラマチックなスタイルでコンポーネントをグループ化するPythonの構造に移行するのは難しいでしょう。そのため、SQLAlchemyでは、SQLがすでにわかっており、ステートメントが動的機能をサポートする必要がない場合に、文字列を使用できます。 ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.text`構文は、ほとんど変更されていないデータベースに渡されるテキスト文を作成するために使用されます。以下に、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.expression.text`オブジェクトを作成して実行します：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;FROM users, addresses &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;WHERE users.id = addresses.user_id &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;AND users.name BETWEEN :x AND :y &quot;</span>
<span class="gp">... </span>        <span class="s2">&quot;AND (addresses.email_address LIKE :e1 &quot;</span>
<span class="gp">... </span>            <span class="s2">&quot;OR addresses.email_address LIKE :e2)&quot;</span><span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title
FROM users, addresses
WHERE users.id = addresses.user_id AND users.name BETWEEN ? AND ? AND
(addresses.email_address LIKE ? OR addresses.email_address LIKE ?)
(&#39;m&#39;, &#39;z&#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)
</div><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span></pre></div>
</div>
<p>上記では、バインドされたパラメータが、指定されたコロン形式を使用して：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.text`で指定されていることがわかります。この形式は、データベースのバックエンドに関係なく一貫しています。パラメータの値を送るために、それらを追加の引数として：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Connection.execute`メソッドに渡しました。</p>
<div class="section" id="specifying-bound-parameter-behaviors">
<h3>バウンドパラメータビヘイビアの指定<a class="headerlink" href="#specifying-bound-parameter-behaviors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>〜.expression.text`構造体は、：meth：</cite> .TextClause.bindparams`メソッドを使って事前に設定されたバウンド値をサポートします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users WHERE users.name BETWEEN :x AND :y&quot;</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;z&quot;</span><span class="p">)</span></pre></div>
</div>
<p>パラメータは明示的にタイプすることもできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">),</span> <span class="n">bindparam</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span></pre></div>
</div>
<p>型がデータ型によって提供されるPython側または特別なSQL側の処理を必要とする場合、バインドされたパラメータの型指定が必要です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.TextClause.bindparams</cite>  - 完全なメソッドの説明</p>
</div>
</div>
<div class="section" id="specifying-result-column-behaviors">
<span id="sqlexpression-text-columns"></span><h3>結果列ビヘイビアの指定<a class="headerlink" href="#specifying-result-column-behaviors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>結果の列に関する情報は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TextClause.columns`メソッドを使って指定することもできます。このメソッドは、名前に基づいて戻り値の型を指定するために使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">Integer</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">String</span><span class="p">)</span></pre></div>
</div>
<p>または、型指定されたものと型なしのもののいずれかを、位置的に完全な列式に渡すことができます。この場合、私たちの列式のSQLへの相関関係は位置的に行われるので、テキスト形式のSQL内で明示的に列を列挙することをお勧めします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT id, name FROM users&quot;</span><span class="p">)</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.TextClause.columns`メソッドを呼び出すと、attr：</cite> .TextAsFrom.c`と他の&amp;quot;selectable &amp;quot;オペレーションをサポートする：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TextAsFrom`オブジェクトが返されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>

<span class="n">new_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
    <span class="n">select_from</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span></pre></div>
</div>
<p>位置形式の：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TextClause.columns`は、テキストのSQLを既存のCoreまたはORMモデルに関連付けるときに特に便利です。これは、名前の競合やテキストの結果列名に関するその他の問題を気にせずに列式を直接使用できるためですSQL：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT users.id, addresses.id, users.id, &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;users.name, addresses.email_address AS email &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;FROM users JOIN addresses ON users.id=addresses.user_id &quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;WHERE users.id = 1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span>
<span class="gp">... </span>    <span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='popup_sql'>SELECT users.id, addresses.id, users.id, users.name,
    addresses.email_address AS email
FROM users JOIN addresses ON users.id=addresses.user_id WHERE users.id = 1
()
</div></pre></div>
</div>
<p>上の例では、&amp;quot;id &amp;quot;という名前の3つの列がありますが、これらを列式と位置的に関連付けているので、実際の列オブジェクトを使用して結果列を取得したときの名前は問題になりませんキー。 `` email_address``カラムを取得することは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">]</span>
<span class="go">&#39;jack@yahoo.com&#39;</span></pre></div>
</div>
<p>一方、文字列の列キーを使用した場合、名前ベースの照合の通常の規則が適用され、 `` id``値に対してあいまいな列エラーが発生します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">InvalidRequestError</span>: <span class="n">Ambiguous column name &#39;id&#39; in result set column descriptions</span></pre></div>
</div>
<p>：class： <cite>.Column`オブジェクトを使った結果セットからのカラムへのアクセスは珍しいように見えるかもしれませんが、ORMによって使用される唯一のシステムで、class：</cite>〜 .orm.query.Query`オブジェクト;このように、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TextClause.columns`メソッドは、通常、ORMコンテキストで使用されるテキスト文に非常に適用されます。 ：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>orm_tutorial_literal_sql`の例は簡単な使い方を示しています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.TextClause.columns`メソッドは、テーブルのメタデータまたはORMを一致させるときに、SQL文で列名が一致する必要がなくなるか、またはSQL文中で一意でなくても、プレーンテキストのSQL結果セットと位置的に一致する列式を受け入れるようになりましたモデルをテキストSQLに変換します。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.TextClause.columns</cite>  - 完全なメソッドの説明</p>
<p class="last">：ref： <cite>orm_tutorial_literal_sql</cite>  -  ORMレベルのクエリを：func：` .text`と統合する</p>
</div>
</div>
<div class="section" id="using-text-fragments-inside-bigger-statements">
<h3>より大きな文の中でのtext（）フラグメントの使用<a class="headerlink" href="#using-text-fragments-inside-bigger-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>〜.expression.text`は、：func：</cite>〜.expression.select`オブジェクト内で自由に使用できるSQLのフラグメントを生成するためにも使用できます。これは：func： <cite>〜.expression.text`オブジェクトを受け入れますそのビルダー関数のほとんどの引数として使用します。以下は、：func： `〜.expression.text`の使用法をa：func：</cite> .select`オブジェクト内で組み合わせたものです。 ：func： <cite>〜.expression.select`構造は文の&amp;quot; geometry &amp;quot;を提供し、：func：</cite>〜.expression.text`構造はこの形式のテキストコンテンツを提供します。あらかじめ設定されたクラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Table`メタデータを参照せずにステートメントを作成することができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>       <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.fullname || &#39;, &#39; || addresses.email_address AS title&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.id = addresses.user_id&quot;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.name BETWEEN &#39;m&#39; AND &#39;z&#39;&quot;</span><span class="p">),</span>
<span class="gp">... </span>                <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>                    <span class="s2">&quot;(addresses.email_address LIKE :x &quot;</span>
<span class="gp">... </span>                    <span class="s2">&quot;OR addresses.email_address LIKE :y)&quot;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">... </span>        <span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;users, addresses&#39;</span><span class="p">))</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.fullname || &#39;, &#39; || addresses.email_address AS title
FROM users, addresses
WHERE users.id = addresses.user_id AND users.name BETWEEN &#39;m&#39; AND &#39;z&#39;
AND (addresses.email_address LIKE ? OR addresses.email_address LIKE ?)
(&#39;%@aol.com&#39;, &#39;%@msn.com&#39;)
</div><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>：func： <cite>.select`構文は、文字列SQLフラグメントが強制的に：func：</cite> .text`に、そして：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.text`が明示的に使用されるべきときに、警告を出します。背景については：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>migration_2992`を参照してください。</p>
</div>
</div>
<div class="section" id="using-more-specific-text-with-table-literal-column-and-column">
<span id="sqlexpression-literal-column"></span><h3>：func： <cite>.table</cite>、：func：` .literal_column`、および：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.column`でより特定のテキストを使用する<a class="headerlink" href="#using-more-specific-text-with-table-literal-column-and-column" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>〜.expression.column</cite>、：func：<cite>〜.expression.literal_column</cite>、および：func： <cite>〜.expression.table`のために、私たちは構造のレベルを反対方向に戻すこともできます私たちの声明の重要な要素のいくつか。これらの構造体を使用すると、func： `〜.expression.text`を直接使用する場合よりも、より多くの表現能力を得ることができます。これらの構造体は、格納する文字列の使用方法class： `.Table`ベースのメタデータです。以下では、key：func： `〜.expression.literal_column`オブジェクトの2つについて：class：</cite> .String`データ型を指定して、文字列固有の連結演算子を利用できるようにします。また、 `` users.fullname``のようにテーブル修飾された式を使うために：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.literal_column`を使います。 ：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.expression.column`は、引用符で囲むことができる個々の列名を意味します：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">and_</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">literal_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>   <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;users.fullname&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span>   <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
<span class="gp">... </span>   <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;addresses.email_address&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>   <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>           <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;users.id&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;addresses.user_id&quot;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">text</span><span class="p">(</span><span class="s2">&quot;users.name BETWEEN &#39;m&#39; AND &#39;z&#39;&quot;</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">text</span><span class="p">(</span>
<span class="gp">... </span>               <span class="s2">&quot;(addresses.email_address LIKE :x OR &quot;</span>
<span class="gp">... </span>               <span class="s2">&quot;addresses.email_address LIKE :y)&quot;</span><span class="p">)</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">... </span>   <span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">table</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">))</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.fullname || ? || addresses.email_address AS anon_1
FROM users, addresses
WHERE users.id = addresses.user_id
AND users.name BETWEEN &#39;m&#39; AND &#39;z&#39;
AND (addresses.email_address LIKE ? OR addresses.email_address LIKE ?)
(&#39;, &#39;, &#39;%@aol.com&#39;, &#39;%@msn.com&#39;)
</div><span class="go">[(u&#39;Wendy Williams, wendy@aol.com&#39;,)]</span></pre></div>
</div>
</div>
<div class="section" id="ordering-or-grouping-by-a-label">
<h3>ラベルによる注文またはグループ化<a class="headerlink" href="#ordering-or-grouping-by-a-label" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>文字列をショートカットとして使用したい場合がある場所の1つは、&amp;quot;ORDER BY &amp;quot;または&amp;quot;GROUP BY &amp;quot;節などの場所で参照したいラベル付きの列要素がいくつかある場合です。他の候補には、&amp;quot;OVER &amp;quot;または&amp;quot;DISTINCT &amp;quot;節内のフィールドが含まれます。 ：func： <cite>.select`構造体にこのようなラベルがある場合は、文字列を：meth：</cite> .select.order_by`または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select.group_by`に直接渡すことで直接参照することができます。その他。これは名前付きラベルを参照し、式が2回表示されないようにします。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;num_addresses&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;num_addresses&quot;</span><span class="p">)</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT addresses.user_id, count(addresses.id) AS num_addresses
FROM addresses ORDER BY num_addresses
()
</div><span class="go">[(2, 4)]</span></pre></div>
</div>
<p>文字列名を渡すことによって：func： <cite>.asc`や：func：</cite> .desc`のような修飾子を使うことができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">desc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;num_addresses&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">order_by</span><span class="p">(</span><span class="n">desc</span><span class="p">(</span><span class="s2">&quot;num_addresses&quot;</span><span class="p">))</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT addresses.user_id, count(addresses.id) AS num_addresses
FROM addresses ORDER BY num_addresses DESC
()
</div><span class="go">[(2, 4)]</span></pre></div>
</div>
<p>ここでの文字列のフィーチャは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.ColumnElement.label`メソッドを使用して特別な名前のラベルを作成したときに非常に調整されていることに注意してください。他の場合では、表現システムがレンダリングのための最も効果的な選択肢を作ることができるように、常に：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.ColumnElement`オブジェクトを直接参照したいと思っています。以下では、：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.ColumnElement`を使用すると、複数回出現する列名で並べ替えるときのあいまいさがなくなります。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1a</span><span class="p">,</span> <span class="n">u1b</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">alias</span><span class="p">(),</span> <span class="n">users</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">u1a</span><span class="p">,</span> <span class="n">u1b</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">u1a</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="n">u1b</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">order_by</span><span class="p">(</span><span class="n">u1a</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># using &quot;name&quot; here would be ambiguous</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users_1.id, users_1.name, users_1.fullname, users_2.id,
users_2.name, users_2.fullname
FROM users AS users_1, users AS users_2
WHERE users_1.name &gt; users_2.name ORDER BY users_1.name
()
</div><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;, 1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)]</span></pre></div>
</div>
</div>
</div>
<div class="section" id="using-aliases">
<h2>エイリアスの使用<a class="headerlink" href="#using-aliases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLのエイリアスは、テーブルまたはSELECTステートメントの&amp;quot;リネームされた&amp;quot;バージョンに対応します。これは&amp;quot;SELECT。FROM sometable AS someothername &amp;quot;といつでも言います。 `` AS``はテーブルの新しい名前を作成します。エイリアスは、テーブルやサブクエリを一意の名前で参照できるため、主要な構成要素です。テーブルの場合、FROM句に複数の同じテーブルの名前を付けることができます。 SELECTステートメントの場合は、ステートメントによって表される列の親名を提供します。この名前を基準にして参照できるようにします。</p>
<p>SQLAlchemyでは、：class： <cite>.Table</cite>、：func：` .select`構造体、またはその他の選択可能なものは、：meth： <cite>.FromClause.alias`メソッドを使用して別名に変換できます。 。アリアの構造。例として、ユーザーの `</cite> jack``に2つの特定の電子メールアドレスがあることを知っているとします。これらの2つのアドレスの組み合わせに基づいて、どのようにジャックを見つけることができますか？これを達成するために、アドレスごとに `` addresses``テーブルへの結合を1回使います。 `` addresses``に対してclass： <cite>.Alias`構造を作り、それをa：func：</cite> .select`構造体の中で使う：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">where</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
<span class="gp">... </span>           <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">a2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span>
<span class="gp">... </span>       <span class="p">))</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname
FROM users, addresses AS addresses_1, addresses AS addresses_2
WHERE users.id = addresses_1.user_id
    AND users.id = addresses_2.user_id
    AND addresses_1.email_address = ?
    AND addresses_2.email_address = ?
(&#39;jack@msn.com&#39;, &#39;jack@yahoo.com&#39;)
</div><span class="go">[(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;)]</span></pre></div>
</div>
<p>：class： <cite>.Alias`構文は、最終的なSQL結果に</cite> <cite>addresses_1``と</cite> <cite>addresses_2``という名前を生成したことに注意してください。これらの名前の生成は、ステートメント内の構造の位置によって決まります。 2番目の `</cite> a2``エイリアスだけを使ってクエリを作成した場合、その名前は `` addresses_1``として出てきます。名前の生成も*確定的です。つまり、特定の方言に対してレンダリングされるたびに、同じSQLAlchemyステートメント構成で同じSQL文字列が生成されます。</p>
<p>外部では：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Alias`構造体を使用してエイリアスを参照するので、生成された名前について心配する必要はありません。しかし、デバッグの目的では、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.FromClause.alias`メソッドに文字列名を渡すことで指定することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">)</span></pre></div>
</div>
<p>エイリアスは、もちろんSELECT文を含め、SELECTから選択できるものに使用できます。文全体のエイリアスを作成して作成した：func： <cite>.select`に</cite> <cite>users``テーブルを自己結合することができます。 `</cite> correlate（None） <a href="#id1"><span class="problematic" id="id2">``</span></a>ディレクティブは、内側の `` users``テーブルを外側のテーブルと &amp;quot;相関&amp;quot;させるSQLAlchemyの試みを避けることです：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">a1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.name
FROM users,
    (SELECT users.id AS id, users.name AS name, users.fullname AS fullname
        FROM users, addresses AS addresses_1, addresses AS addresses_2
        WHERE users.id = addresses_1.user_id AND users.id = addresses_2.user_id
        AND addresses_1.email_address = ?
        AND addresses_2.email_address = ?) AS anon_1
WHERE users.id = anon_1.id
(&#39;jack@msn.com&#39;, &#39;jack@yahoo.com&#39;)
</div><span class="go">[(u&#39;jack&#39;,)]</span></pre></div>
</div>
</div>
<div class="section" id="using-joins">
<h2>結合の使用<a class="headerlink" href="#using-joins" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>途中でSELECT式を構築できるようになりました。 SELECTの次の基盤はJOIN式です。私たちはすでに、例の中でjoin節を行っています：columns節または：func： <cite>.select`構造のwhere節に2つのテーブルを置くだけです。しかし、実際の&amp;quot;JOIN &amp;quot;または&amp;quot;OUTERJOIN &amp;quot;構造を作成したい場合は、：meth： `〜.FromClause.join`メソッドと：meth：</cite>〜.FromClause.outerjoin`メソッドを使用します。結合の左の表から：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span>
<span class="go">users JOIN addresses ON users.id = addresses.user_id</span></pre></div>
</div>
<p>アラートリーダーはもっと驚きを見るでしょう。 SQLAlchemyは、2つのテーブルを結合する方法を考え出しました！結合のON条件は、このチュートリアルの冒頭にある `` addresses``テーブルの方法で設定した：class： <cite>〜sqlalchemy.schema.ForeignKey`オブジェクトに基づいて自動的に生成されました。既に `</cite> join（） <a href="#id1"><span class="problematic" id="id2">``</span></a>構造はテーブルを結合するもっと良い方法のように見えます。</p>
<p>もちろん、自分のユーザー名と同じ名前の電子メールアドレスに参加するすべてのユーザーに参加したい場合など、必要な表現に参加できます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">... </span> <span class="p">)</span>
<span class="go">users JOIN addresses ON addresses.email_address LIKE users.name || :name_1</span></pre></div>
</div>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`構文を作成すると、SQLAlchemyは前述のテーブルを調べて、それらをステートメントのFROM句に配置します。しかし、JOINを使うときは、私たちが望むFROM句を知っているので、ここで：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Select.select_from`メソッドを使います：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">))</span>
<span class="gp">... </span>   <span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.fullname
FROM users JOIN addresses ON addresses.email_address LIKE users.name || ?
(&#39;%&#39;,)
</div><span class="go">[(u&#39;Jack Jones&#39;,), (u&#39;Jack Jones&#39;,), (u&#39;Wendy Williams&#39;,)]</span></pre></div>
</div>
<p>：meth： <cite>〜.FromClause.outerjoin`メソッドは、</cite> LEFT OUTER JOIN`コンストラクトを作成し、以下のように使用されます：meth： <cite>〜.FromClause.join</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.fullname</span>
<span class="go">    FROM users</span>
<span class="go">    LEFT OUTER JOIN addresses ON users.id = addresses.user_id</span></pre></div>
</div>
<p>これはもちろん、バージョン9より前のOracleを使ってギグに陥っていて、エンジンをセットアップしていない限り（ `` OracleDialect``を使っている）、 `` outerjoin（） <a href="#id1"><span class="problematic" id="id2">``</span></a>という出力が生成されます。 Oracle固有のSQLを使用するには：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.oracle</span> <span class="kn">import</span> <span class="n">dialect</span> <span class="k">as</span> <span class="n">OracleDialect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">OracleDialect</span><span class="p">(</span><span class="n">use_ansi</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
<span class="go">SELECT users.fullname</span>
<span class="go">FROM users, addresses</span>
<span class="go">WHERE users.id = addresses.user_id(+)</span></pre></div>
</div>
<p>SQLが何を意味するのかわからない場合は、心配しないでください！ Oracle DBAの秘密の部族は、彼らの黒い魔法を発見したくはありません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：func： <cite>.expression.join</cite></p>
<p>：func： <cite>.expression.outerjoin</cite></p>
<p class="last">：クラス： <cite>.Join</cite></p>
</div>
</div>
<div class="section" id="everything-else">
<h2>ほかのすべて<a class="headerlink" href="#everything-else" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQL式の作成の概念が導入されました。残っているのは、同じテーマのより多くの変種です。だから今私たちが知る必要がある残りの重要なものをカタログ化します。</p>
<div class="section" id="bind-parameter-objects">
<span id="coretutorial-bind-param"></span><h3>パラメータオブジェクトのバインド<a class="headerlink" href="#bind-parameter-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらすべての例を通して、SQLAlchemyはリテラル式が出現するたびにバインドパラメータを作成しています。独自の名前で独自のバインド・パラメーターを指定し、同じステートメントを繰り返し使用することもできます。 ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.bindparam`構文は、指定された名前を持つバインドされたパラメータを生成するために使用されます。 SQLAlchemyは常にAPI側で名前でバインドされたパラメータを参照しますが、実行時にデータベースの方言は適切な名前付きまたは位置指定のスタイルに変換されます。ここではSQLiteの定位置に変換されます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">bindparam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">))</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname
FROM users
WHERE users.name = ?
(&#39;wendy&#39;,)
</div><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)]</span></pre></div>
</div>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.bindparam`のもう一つの重要な側面は、型に割り当てられるということです。バインド・パラメータのタイプによって、式内での動作と、バインドされたデータが処理されてデータベースに送信される仕組みが決まります。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;%&#39;&quot;</span><span class="p">)))</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname
FROM users
WHERE users.name LIKE ? || &#39;%&#39;
(&#39;wendy&#39;,)
</div><span class="go">[(2, u&#39;wendy&#39;, u&#39;Wendy Williams&#39;)]</span></pre></div>
</div>
<p>同じ名前のfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.bindparam`構造体も複数回使用できます。ここでは、実行パラメータには単一の名前付き値しか必要ありません。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">,</span> <span class="n">addresses</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span>
<span class="gp">... </span>       <span class="n">or_</span><span class="p">(</span>
<span class="gp">... </span>         <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;%&#39;&quot;</span><span class="p">)),</span>
<span class="gp">... </span>         <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span> <span class="o">+</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;@%&#39;&quot;</span><span class="p">))</span>
<span class="gp">... </span>       <span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">order_by</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT users.id, users.name, users.fullname, addresses.id,
    addresses.user_id, addresses.email_address
FROM users LEFT OUTER JOIN addresses ON users.id = addresses.user_id
WHERE users.name LIKE ? || &#39;%&#39; OR addresses.email_address LIKE ? || &#39;@%&#39;
ORDER BY addresses.id
(&#39;jack&#39;, &#39;jack&#39;)
</div><span class="go">[(1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 1, 1, u&#39;jack@yahoo.com&#39;), (1, u&#39;jack&#39;, u&#39;Jack Jones&#39;, 2, 1, u&#39;jack@msn.com&#39;)]</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：機能： <cite>.bindparam</cite></p>
</div>
</div>
<div class="section" id="functions">
<h3>関数<a class="headerlink" href="#functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SQL関数は：data： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.func`キーワードを使用して作成され、属性アクセスを使用して関数を生成します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="go">now()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">concat(:concat_1, :concat_2)</span></pre></div>
</div>
<p>&amp;quot;generate &amp;quot;とは、<strong>任意の</strong> SQL関数は、選択した単語に基づいて作成されたことを意味します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">xyz_my_goofy_function</span><span class="p">())</span>
<span class="go">xyz_my_goofy_function()</span></pre></div>
</div>
<p>特定の関数名はSQLAlchemyによって認識され、特別な動作規則が適用されます。たとえば、&amp;quot;ANSI &amp;quot;関数があります。つまり、CURRENT_TIMESTAMPのように後に括弧が追加されないという意味です。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">current_timestamp</span><span class="p">())</span>
<span class="go">CURRENT_TIMESTAMP</span></pre></div>
</div>
<p>関数は、通常、select文のcolumns句で使用されます。また、型を指定するだけでなく、ラベル付けすることもできます。文字列名に基づいて結果の行を対象にし、結果セット処理（Unicode変換や日付変換など）が必要な場合は、型を割り当てるために、関数にラベルを付けることをお勧めします。以下では、結果関数 `` scalar（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を使用して、最初の行の最初の列を読み込み、結果を閉じます。ラベルは存在していてもこの場合重要ではありません。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>           <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">String</span><span class="p">)</span><span class="o">.</span>
<span class="gp">... </span>               <span class="n">label</span><span class="p">(</span><span class="s1">&#39;maxemail&#39;</span><span class="p">)</span>
<span class="gp">... </span>          <span class="p">])</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<div class='show_sql'>SELECT max(addresses.email_address) AS maxemail
FROM addresses
()
</div><span class="go">u&#39;www@www.org&#39;</span></pre></div>
</div>
<p>結果セット全体を返す関数をサポートするPostgreSQLやOracleなどのデータベースは、ステートメントで使用できる選択可能なユニットにアセンブルできます。パラメータ `` x``と `` y``をとり、 `` q``、 `` z``という3つのカラムを返すデータベース関数 `` calculate（） `` <cite>と</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>r``を使うと、&amp;quot;字句&amp;quot;列オブジェクトとバインドパラメータを使って構築できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calculate</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">column</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>       <span class="n">select_from</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">func</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span>
<span class="gp">... </span>                   <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">... </span>               <span class="p">)</span>
<span class="gp">... </span>            <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">calc</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
<span class="go">SELECT users.id, users.name, users.fullname</span>
<span class="go">FROM users, (SELECT q, z, r</span>
<span class="go">FROM calculate(:x, :y)) AS anon_1</span>
<span class="go">WHERE users.id &gt; anon_1.z</span></pre></div>
</div>
<p>異なったバインドパラメータで `` calculate``ステートメントを2回使いたいなら、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.ClauseElement.unique_params`関数は私たちのためにコピーを作成し、バインドパラメータを&amp;quot; unique &amp;quot;を使用して、競合する名前が分離されるようにします。選択可能なものの2つの別々のエイリアスも作成しています。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calc1</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;c1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique_params</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc2</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;c2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique_params</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">calc1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">calc2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, users.name, users.fullname</span>
<span class="go">FROM users,</span>
<span class="go">    (SELECT q, z, r FROM calculate(:x_1, :y_1)) AS c1,</span>
<span class="go">    (SELECT q, z, r FROM calculate(:x_2, :y_2)) AS c2</span>
<span class="go">WHERE users.id BETWEEN c1.z AND c2.z</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span><span class="o">.</span><span class="n">params</span> 
<span class="go">{u&#39;x_2&#39;: 5, u&#39;y_2&#39;: 12, u&#39;y_1&#39;: 45, u&#39;x_1&#39;: 17}</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：データ： <cite>.func</cite></p>
</div>
</div>
<div class="section" id="window-functions">
<span id="id1"></span><h3>ウィンドウ関数<a class="headerlink" href="#window-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Any：class： <cite>.FunctionElement`は：data：</cite>〜.expression.func`で生成された関数も含めて、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.FunctionElementを使ってOVER句である&amp;quot;ウィンドウ関数 &amp;quot;に変換できます.over`メソッド:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">order_by</span><span class="o">=</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, row_number() OVER (ORDER BY users.name) AS anon_1</span>
<span class="go">FROM users</span></pre></div>
</div>
<p>：meth： <cite>.FunctionElement.over`は：paramref：</cite> .expression.over.rows`または：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.expression.over.range`のいずれかのパラメータを使って範囲指定をサポートしています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
<span class="gp">... </span>        <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">func</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">order_by</span><span class="o">=</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">rows</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gp">... </span>    <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">SELECT users.id, row_number() OVER</span>
<span class="go">(ORDER BY users.name ROWS BETWEEN :param_1 PRECEDING AND UNBOUNDED FOLLOWING) AS anon_1</span>
<span class="go">FROM users</span></pre></div>
</div>
<p>：paramref： <cite>.expression.over.rows`と：paramref：</cite> .expression.over.range`はそれぞれ、範囲のための負の整数と正の整数の組み合わせを含む2つのタプルを受け入れ、&amp;quot;CURRENT ROW &amp;quot; &amp;quot;UNBOUNDED &amp;quot;を示す &amp;quot;None&amp;quot;を指定します。詳細については、例：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.over`を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>ウィンドウ関数の&amp;quot;行&amp;quot;と&amp;quot;範囲&amp;quot;指定のサポート</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：func： <cite>.over</cite></p>
<p class="last">：meth： <cite>.FunctionElement.over</cite></p>
</div>
</div>
<div class="section" id="unions-and-other-set-operations">
<h3>組合とその他の集合演算<a class="headerlink" href="#unions-and-other-set-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>共用体には、モジュールレベルの関数func： <cite>〜.expression.union`と：func：</cite>〜.expression.union_all`の2つのフレーバーUNIONとUNION ALLがあります。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">union</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;foo@bar.com&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@yahoo.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT addresses.id, addresses.user_id, addresses.email_address
FROM addresses
WHERE addresses.email_address = ?
UNION
SELECT addresses.id, addresses.user_id, addresses.email_address
FROM addresses
WHERE addresses.email_address LIKE ? ORDER BY addresses.email_address
(&#39;foo@bar.com&#39;, &#39;%@yahoo.com&#39;)
</div><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;)]</span></pre></div>
</div>
<p>func： <cite>〜.expression.intersect</cite>、：func：<cite>〜.expression.intersect_all</cite>、：func： <cite>〜.expression.except_</cite>、および：func：<cite>〜は、すべてのデータベースでサポートされていますが、 .expression.except_all</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">except_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">except_</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@%.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>

<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT addresses.id, addresses.user_id, addresses.email_address
FROM addresses
WHERE addresses.email_address LIKE ?
EXCEPT
SELECT addresses.id, addresses.user_id, addresses.email_address
FROM addresses
WHERE addresses.email_address LIKE ?
(&#39;%@%.com&#39;, &#39;%@msn.com&#39;)
</div><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;), (4, 2, u&#39;wendy@aol.com&#39;)]</span></pre></div>
</div>
<p>いわゆる「化合物」選択肢の一般的な問題は、かっこでネスティングするという事実のために発生します。特にSQLiteでは、かっこで始まる文が好きではありません。したがって、 &amp;quot;compound&amp;quot;内に&amp;quot;compound &amp;quot;を入れ子にするときは、最も外側の化合物の最初の要素に `` .alias（）。select（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を適用する必要があります。たとえば、&amp;quot;union &amp;quot;と&amp;quot;select &amp;quot;を&amp;quot;except _ &amp;quot;の中にネストする場合、SQLiteは&amp;quot;union &amp;quot;をサブクエリとして記述します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">except_</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">union</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@yahoo.com&#39;</span><span class="p">)),</span>
<span class="gp">... </span>        <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span>
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(),</span>   <span class="c1"># apply subquery here</span>
<span class="gp">... </span>   <span class="n">addresses</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>
<a href='#' class='sql_link'>sql</a><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='popup_sql'>SELECT anon_1.id, anon_1.user_id, anon_1.email_address
FROM (SELECT addresses.id AS id, addresses.user_id AS user_id,
    addresses.email_address AS email_address
    FROM addresses
    WHERE addresses.email_address LIKE ?
    UNION
    SELECT addresses.id AS id,
        addresses.user_id AS user_id,
        addresses.email_address AS email_address
    FROM addresses
    WHERE addresses.email_address LIKE ?) AS anon_1
EXCEPT
SELECT addresses.id, addresses.user_id, addresses.email_address
FROM addresses
WHERE addresses.email_address LIKE ?
(&#39;%@yahoo.com&#39;, &#39;%@msn.com&#39;, &#39;%@msn.com&#39;)
</div><span class="go">[(1, 1, u&#39;jack@yahoo.com&#39;)]</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：func： <cite>.union</cite></p>
<p>：func： <cite>.union_all</cite></p>
<p>：func： <cite>.intersect</cite></p>
<p>：func： <cite>.intersect_all</cite></p>
<p>：func： <cite>.except_</cite></p>
<p class="last">：func： <cite>.except_all</cite></p>
</div>
</div>
<div class="section" id="scalar-selects">
<span id="id2"></span><h3>スカラ選択<a class="headerlink" href="#scalar-selects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スカラー選択は、正確に1つの行と1つの列を返すSELECTです。これを列式として使用できます。スカラー選択は、しばしば：関連するサブクエリであり、FROM句の少なくとも1つを取得するために囲むSELECTステートメントに依存します。</p>
<p>：func： <cite>.select`構造体は、：meth：</cite>〜.SelectBase.as_scalar`または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.SelectBase.label`メソッドのいずれかを呼び出して、列式として動作するように変更できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">as_scalar</span><span class="p">()</span></pre></div>
</div>
<p>上記の構造体はa：class： <cite>〜.expression.ScalarSelect`オブジェクトになり、もはやclass：</cite>〜.expression.FromClause`階層の一部ではなくなりました。その代わりに：class： <cite>〜.expression.ColumnElement`の式構造体の中にあります。この構造体を他の列と同じように配置することができます：func： `.select</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">]))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, (SELECT count(addresses.id) AS count_1
FROM addresses
WHERE users.id = addresses.user_id) AS anon_1
FROM users
()
</div><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span></pre></div>
</div>
<p>非匿名の列名をスカラー選択に適用するには、代わりに：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SelectBase.label`を使用して作成します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">label</span><span class="p">(</span><span class="s2">&quot;address_count&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stmt</span><span class="p">]))</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, (SELECT count(addresses.id) AS count_1
FROM addresses
WHERE users.id = addresses.user_id) AS address_count
FROM users
()
</div><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Select.as_scalar</cite></p>
<p class="last">：meth： <cite>.Select.label</cite></p>
</div>
</div>
<div class="section" id="correlated-subqueries">
<span id="id3"></span><h3>相関サブクエリ<a class="headerlink" href="#correlated-subqueries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：ref： <cite>scalar_selects`の例では、各組み込みselectのFROM句にFROM句に</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>users``テーブルが含まれていませんでした。これは、SQLAlchemyが自動的に：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>correlates`をFROMオブジェクトに埋め込みクエリが存在する場合、内部SELECTステートメントがそれ自身のFROM句を少なくとも1つも持っているためです。例えば：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name
FROM users
WHERE users.id = (SELECT addresses.user_id
    FROM addresses
    WHERE addresses.user_id = users.id
    AND addresses.email_address = ?)
(&#39;jack@yahoo.com&#39;,)
</div><span class="go">[(u&#39;jack&#39;,)]</span></pre></div>
</div>
<p>自己相関は通常予想されることを行いますが、制御することもできます。例えば、ステートメントが `` addresses``テーブルにのみ関連づけられ、 `` users``テーブルには関連しないようにするには、両者が囲まれたSELECTに存在していても、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Select。 correlate`メソッドを使用して、相関する可能性のあるFROM句を指定します。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, addresses.email_address
 FROM users JOIN addresses ON users.id = addresses.user_id
 WHERE users.id = (SELECT users.id
 FROM users
 WHERE users.id = addresses.user_id AND users.name = ?)
 (&#39;jack&#39;,)
 </div><span class="go">[(u&#39;jack&#39;, u&#39;jack@yahoo.com&#39;), (u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span></pre></div>
</div>
<p>ステートメントの相関を完全に無効にするには、引数として `` None``を渡すことができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name
 FROM users
 WHERE users.id = (SELECT users.id
  FROM users
  WHERE users.name = ?)
(&#39;wendy&#39;,)
</div><span class="go">[(u&#39;wendy&#39;,)]</span></pre></div>
</div>
<p>：meth： <cite>.Select.correlate_except`メソッドを使用して、除外による相関を制御することもできます。例えば、 `</cite> users``を除くすべてのFROM句を関連付けるように指示することで、 `` users``テーブルのSELECTを書くことができます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">correlate_except</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enclosing_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="gp">... </span>        <span class="p">[</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>    <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">stmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">enclosing_stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, addresses.email_address
 FROM users JOIN addresses ON users.id = addresses.user_id
 WHERE users.id = (SELECT users.id
 FROM users
 WHERE users.id = addresses.user_id AND users.name = ?)
 (&#39;jack&#39;,)
 </div><span class="go">[(u&#39;jack&#39;, u&#39;jack@yahoo.com&#39;), (u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span></pre></div>
</div>
<div class="section" id="lateral-correlation">
<span id="lateral-selects"></span><h4>LATERAL相関<a class="headerlink" href="#lateral-correlation" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>LATERAL相関は、選択可能なユニットが単一のFROM句内の別の選択可能なユニットを参照できるようにする、SQL相関の特別なサブカテゴリです。これは、SQL標準の一部ではあるが、最近のバージョンのPostgreSQLでサポートされることが知られている非常に特殊な使用例である。</p>
<p>通常、SELECT文がFROM句で `` table1 JOIN（some SELECT）AS subquery``を参照する場合、右側のサブクエリは左側の&amp;quot;table1 &amp;quot;式を参照しないことがあります。相関は、このSELECTを完全に囲む別のSELECTの一部である表のみを参照することがあります。 LATERALキーワードは、このような振る舞いを可能にし、次のような表現を可能にします：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">age</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> <span class="n">people</span> <span class="k">JOIN</span> <span class="k">LATERAL</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">book_id</span> <span class="k">AS</span> <span class="n">book_id</span>
<span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">owner_id</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">people_id</span><span class="p">)</span>
<span class="k">AS</span> <span class="n">book_subq</span> <span class="k">ON</span> <span class="k">true</span></pre></div>
</div>
<p>上記のところでは、JOINの右側には、&amp;quot;books &amp;quot;テーブルだけでなく&amp;quot;people &amp;quot;テーブルも参照するサブクエリがあり、JOINの左側に関連付けられています。 SQLAlchemy Coreは、上記のような文を以下のように：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Select.lateral`メソッドを使用してサポートします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">people</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s1">&#39;people&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;people_id&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">books</span> <span class="o">=</span> <span class="n">table</span><span class="p">(</span><span class="s1">&#39;books&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;book_id&#39;</span><span class="p">),</span> <span class="n">column</span><span class="p">(</span><span class="s1">&#39;owner_id&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">books</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">book_id</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>     <span class="n">where</span><span class="p">(</span><span class="n">books</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">owner_id</span> <span class="o">==</span> <span class="n">people</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">people_id</span><span class="p">)</span><span class="o">.</span><span class="n">lateral</span><span class="p">(</span><span class="s2">&quot;book_subq&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="n">people</span><span class="p">])</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subq</span><span class="p">,</span> <span class="n">true</span><span class="p">())))</span>
<span class="go">SELECT people.people_id, people.age, people.name</span>
<span class="go">FROM people JOIN LATERAL (SELECT books.book_id AS book_id</span>
<span class="go">FROM books WHERE books.owner_id = people.people_id)</span>
<span class="go">AS book_subq ON true</span></pre></div>
</div>
<p>上記のように、：meth： <cite>.Select.lateral`メソッドは：meth：</cite> .Select.alias`メソッドのように動作します。これには、オプションの名前を指定することもできます。しかし、構造体は：class： <cite>.Lateral`構造体である：class：</cite> .Alias`は、LATERALキーワードと、囲むステートメントのFROM句の内部からの相関を可能にする特別な命令を提供します。</p>
<p>：meth： <cite>.Select.lateral`メソッドは：meth：</cite> .Select.correlate`と：meth： <cite>.Select.correlate_except`メソッドと正常にやり取りします。ただし、相関ルールは、他のテーブルにも適用されます。囲む文のFROM句。相関はデフォルトでこれらのテーブルに対して&amp;quot;自動&amp;quot;であり、テーブルが：meth： `.Select.correlate`に指定されている場合は明示的であり、：meth：</cite> .Select.correlate_except` 。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>LATERALキーワードと横方向相関のサポート。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：クラス： <cite>.Lateral</cite></p>
<p class="last">：meth： <cite>.Select.lateral</cite></p>
</div>
</div>
</div>
<div class="section" id="ordering-grouping-limiting-offset-ing">
<h3>オーダー、グルーピング、制限、オフセット... ing ...<a class="headerlink" href="#ordering-grouping-limiting-offset-ing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>順序付けは、列式を：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.SelectBase.order_by`メソッドに渡すことによって行われます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name
FROM users ORDER BY users.name
()
</div><span class="go">[(u&#39;jack&#39;,), (u&#39;wendy&#39;,)]</span></pre></div>
</div>
<p>昇順または降順は：meth： <cite>〜.ColumnElement.asc`と：meth：</cite>〜.ColumnElement.desc`修飾子を使って制御できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name
FROM users ORDER BY users.name DESC
()
</div><span class="go">[(u&#39;wendy&#39;,), (u&#39;jack&#39;,)]</span></pre></div>
</div>
<p>グループ化はGROUP BY句を参照し、集約する行のグループを確立するために集計関数と一緒に使用されます。これは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.SelectBase.group_by`メソッドによって提供されます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">group_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, count(addresses.id) AS count_1
FROM users JOIN addresses
    ON users.id = addresses.user_id
GROUP BY users.name
()
</div><span class="go">[(u&#39;jack&#39;, 2), (u&#39;wendy&#39;, 2)]</span></pre></div>
</div>
<p>GROUP BYが適用された後、HAVINGを使用して集計値の結果をフィルタリングできます。これは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Select.having`メソッドで利用できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">group_by</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">having</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, count(addresses.id) AS count_1
FROM users JOIN addresses
    ON users.id = addresses.user_id
GROUP BY users.name
HAVING length(users.name) &gt; ?
(4,)
</div><span class="go">[(u&#39;wendy&#39;, 2)]</span></pre></div>
</div>
<p>合成されたSELECT文で重複を処理する一般的なシステムは、DISTINCT修飾子です。単純なDISTINCT節は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Select.distinct`メソッドを使って追加できます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span>
<span class="gp">... </span>                   <span class="n">contains</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">distinct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT DISTINCT users.name
FROM users, addresses
WHERE (addresses.email_address LIKE &#39;%&#39; || users.name || &#39;%&#39;)
()
</div><span class="go">[(u&#39;jack&#39;,), (u&#39;wendy&#39;,)]</span></pre></div>
</div>
<p>ほとんどのデータベースバックエンドは、返される行の数を制限するシステムをサポートしています。大半は、指定された&amp;quot;オフセット&amp;quot;の後に行を返す方法もあります。 PostgreSQL、MySQL、SQLiteなどの一般的なバックエンドはLIMITとOFFSETのキーワードをサポートしていますが、他のバックエンドは同じ効果を得るために&amp;quot;ウィンドウ関数&amp;quot;や行IDのようなより秘密の機能を参照する必要があります。 ：meth： <cite>〜.Select.limit`メソッドと：meth：</cite>〜.Select.offset`メソッドは、現在のバックエンドの方法論を簡単に抽象化します：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">select_from</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
<div class='show_sql'>SELECT users.name, addresses.email_address
FROM users JOIN addresses ON users.id = addresses.user_id
 LIMIT ? OFFSET ?
(1, 1)
</div><span class="go">[(u&#39;jack&#39;, u&#39;jack@msn.com&#39;)]</span></pre></div>
</div>
</div>
</div>
<div class="section" id="inserts-updates-and-deletes">
<span id="inserts-and-updates"></span><h2>挿入、更新、および削除<a class="headerlink" href="#inserts-updates-and-deletes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>我々は見た：meth： <cite>〜.TableClause.insert`はこのチュートリアルの前半で説明しました。 ：meth： `〜.TableClause.insert`はINSERTを生成し、：meth：</cite>〜.TableClause.update`メソッドはUPDATEを生成します。どちらの構文も、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.ValuesBase.values`というメソッドで、ステートメントのVALUES節またはSET節を指定します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.ValuesBase.values`メソッドは、任意の列式を値として扱います：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Fullname: &quot;</span> <span class="o">+</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql'>UPDATE users SET fullname=(? || users.name)
(&#39;Fullname: &#39;,)
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
<p>&amp;quot;execute many &amp;quot;コンテキストで：meth： <cite>〜.TableClause.insert`または：meth：</cite>〜.TableClause.update`を使用する場合、引数で参照できる名前付きバインドパラメータを指定することもできますリスト。 2つの構文は、実行時に：meth： <cite>〜.Connection.execute`に送られた辞書に渡された任意の列名のためのバインドされたプレースホルダを自動的に生成します。しかし、明示的にターゲットとした名前付きパラメータを合成式で使用する場合は、：func： `〜.expression.bindparam`構文を使用する必要があります。 ：meth： `〜.TableClause.insert`または：meth：</cite>〜.TableClause.update`を使用して：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expression.bindparam`を使用すると、テーブルのカラム自体の名前は&amp;quot; automatic &amp;quot;バインド名の生成。以下の例のように、暗黙的に使用可能なバインド名と明示的に名前が付けられたパラメータの使用法を組み合わせることができます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>        <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; .. name&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name1&#39;</span><span class="p">},</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name2&#39;</span><span class="p">},</span>
<span class="gp">... </span>       <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name3&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">])</span>
<div class='show_sql'>INSERT INTO users (id, name) VALUES (?, (? || ?))
((4, &#39;name1&#39;, &#39; .. name&#39;), (5, &#39;name2&#39;, &#39; .. name&#39;), (6, &#39;name3&#39;, &#39; .. name&#39;))
COMMIT
&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</div></pre></div>
</div>
<p>UPDATE文は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.TableClause.update`構文を使用して生成されます。これは、指定できる追加のWHERE句があることを除いて、INSERTとよく似ています。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql'>UPDATE users SET name=? WHERE users.name = ?
(&#39;ed&#39;, &#39;jack&#39;)
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
<p>&amp;quot;executemany &amp;quot;コンテキストで：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.TableClause.update`を使用する場合、WHERE句で明示的に名前付きのバインドされたパラメータを使用することもできます。ここでも、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.expression.bindparam`はこれを達成するために使用される構造体です：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;oldname&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;newname&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;ed&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;mary&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;jake&#39;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">])</span>
<div class='show_sql'>UPDATE users SET name=? WHERE users.name = ?
((&#39;ed&#39;, &#39;jack&#39;), (&#39;mary&#39;, &#39;wendy&#39;), (&#39;jake&#39;, &#39;jim&#39;))
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
<div class="section" id="correlated-updates">
<h3>相関関係の更新<a class="headerlink" href="#correlated-updates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>相関更新では、別の表または同じ表からの選択を使用して表を更新できます。</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">])</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
<span class="gp">... </span>            <span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">fullname</span><span class="o">=</span><span class="n">stmt</span><span class="p">))</span>
<div class='show_sql'>UPDATE users SET fullname=(SELECT addresses.email_address
    FROM addresses
    WHERE addresses.user_id = users.id
    LIMIT ? OFFSET ?)
(1, 0)
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
</div>
<div class="section" id="multiple-table-updates">
<span id="multi-table-updates"></span><h3>複数のテーブルの更新<a class="headerlink" href="#multiple-table-updates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.4 で追加.</span></p>
</div>
<p>PostgreSQL、Microsoft SQL Server、およびMySQLバックエンドは、すべて複数のテーブルを参照するUPDATE文をサポートしています。 PGとMSSQLの場合、これは&amp;quot;UPDATE FROM &amp;quot;構文で、一度に1つのテーブルを更新しますが、WHERE句で直接参照できる追加の&amp;quot;FROM &amp;quot;節で追加のテーブルを参照できます。 MySQLでは、カンマで区切られた単一のUPDATE文に複数のテーブルを埋め込むことができます。 SQLAlchemy：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.update`構文は、WHERE句で複数のテーブルを指定することによって、これらのモードを暗黙的にサポートします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed wood&#39;</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>上記の文から得られるSQLは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">users</span> <span class="n">SET</span> <span class="n">name</span><span class="o">=</span><span class="p">:</span><span class="n">name</span> <span class="n">FROM</span> <span class="n">addresses</span>
<span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span> <span class="n">AND</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="p">:</span><span class="n">email_address_1</span> <span class="o">||</span> <span class="s1">&#39;%&#39;</span></pre></div>
</div>
<p>MySQLを使用する場合、各テーブルのカラムは、SET句の中で、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Update.values`に渡されるディクショナリフォームを使用して直接割り当てることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">values</span><span class="p">({</span>
            <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="s1">&#39;ed wood&#39;</span><span class="p">,</span>
            <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">:</span><span class="s1">&#39;ed.wood@foo.com&#39;</span>
        <span class="p">})</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span></pre></div>
</div>
<p>テーブルはSET節で明示的に参照されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">users</span><span class="p">,</span> <span class="n">addresses</span> <span class="n">SET</span> <span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span><span class="o">=%</span><span class="n">s</span><span class="p">,</span>
        <span class="n">users</span><span class="o">.</span><span class="n">name</span><span class="o">=%</span><span class="n">s</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span>
        <span class="n">AND</span> <span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="n">concat</span><span class="p">(</span><span class="o">%</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span></pre></div>
</div>
<p>この構造体がサポートされていないデータベースで使用されると、コンパイラは `` NotImplementedError``を発生させます。便宜上、ステートメントが方言が指定されていない文字列として出力された場合、&amp;quot;文字列SQL &amp;quot;コンパイラが呼び出され、構文の非動作SQL表現が提供されます。</p>
</div>
<div class="section" id="parameter-ordered-updates">
<span id="updates-order-parameters"></span><h3>パラメータオーダーの更新<a class="headerlink" href="#parameter-ordered-updates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SET句をレンダリングするときの：func： <cite>.update`のデフォルトの動作は、originating：class：</cite> .Table`オブジェクトで与えられた列の順序付けを使ってレンダリングすることです。これは、特定の列を持つ特定のUPDATE文のレンダリングが毎回同じようにレンダリングされることを意味するため、重要な動作です。これは、クライアント側またはサーバー側の文の形式に依存する問合せキャッシュ・システムに影響します側。パラメータ自体は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Update.values`メソッドにPythonのディクショナリキーとして渡されるため、利用可能な他の固定順序はありません。</p>
<p>しかし、場合によっては、UPDATEステートメントのSET節に表示されるパラメーターの順序が重要になることがあります。この主な例は、MySQLを使用し、他の列の値に基づいて列の値を更新するときです。次のステートメントの最終結果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">some_table</span> <span class="n">SET</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span></pre></div>
</div>
<p>::とは異なる結果をもたらすでしょう。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UPDATE</span> <span class="n">some_table</span> <span class="n">SET</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">10</span></pre></div>
</div>
<p>これは、MySQLでは個々のSET句が行単位ではなく、値ごとに完全に評価され、各SET句が評価されるときに行に埋め込まれた値が変化しているためです。</p>
<p>この特定のユースケースに合わせて、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.update.preserve_parameter_order`フラグを使用することができます。このフラグを使用するときは、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Update.values`メソッドの引数として**の2つのタプル**のPythonリストを提供します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">some_table</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">preserve_parameter_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">values</span><span class="p">([(</span><span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">some_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)])</span></pre></div>
</div>
<p>2タプルのリストは、基本的にPython辞書と同じ構造ですが、順序は異なります。上記の形式を使用すると、&amp;quot;y &amp;quot;列のSET句が最初にレンダリングされ、次に&amp;quot;x &amp;quot;列のSET句がレンダリングされることが保証されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.10 で追加: </span>：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.update.preserve_parameter_order`フラグを使用して、UPDATEパラメータの明示的な順序付けをサポートしました。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>mysql_insert_on_duplicate_key_update</cite>  -  MySQLの` <a href="#id1"><span class="problematic" id="id2">`</span></a>ON DUPLICATE KEY UPDATE``節の背景と、パラメータの順序付けをサポートする方法。</p>
</div>
</div>
<div class="section" id="deletes">
<span id="id4"></span><h3>削除<a class="headerlink" href="#deletes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最後に、削除。これは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.TableClause.delete`構文を使って簡単に行えます：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">delete</span><span class="p">())</span>
<div class='show_sql'>DELETE FROM addresses
()
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="s1">&#39;m&#39;</span><span class="p">))</span>
<div class='show_sql'>DELETE FROM users WHERE users.name &gt; ?
(&#39;m&#39;,)
COMMIT
</div><span class="go">&lt;sqlalchemy.engine.result.ResultProxy object at 0x...&gt;</span></pre></div>
</div>
</div>
<div class="section" id="multiple-table-deletes">
<span id="multi-table-deletes"></span><h3>複数のテーブルの削除<a class="headerlink" href="#multiple-table-deletes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<p>PostgreSQL、Microsoft SQL Server、およびMySQLのバックエンドはすべて、WHERE条件内の複数のテーブルを参照するDELETE文をサポートしています。 PGとMySQLの場合、これは&amp;quot;DELETE USING &amp;quot;構文であり、SQL Serverの場合は複数のテーブルを参照する&amp;quot;DELETE FROM &amp;quot;です。 SQLAlchemy：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.delete`構文は、WHERE句で複数のテーブルを指定することによって、これらのモードを暗黙的にサポートします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ed%&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>Postgresqlのバックエンドでは、上記の文から得られるSQLは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DELETE</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">USING</span> <span class="n">addresses</span>
<span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">id</span>
<span class="n">AND</span> <span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">email_address</span> <span class="n">LIKE</span> <span class="o">%</span><span class="p">(</span><span class="n">email_address_1</span><span class="p">)</span><span class="n">s</span> <span class="o">||</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">&#39;</span><span class="p">)</span></pre></div>
</div>
<p>この構造体がサポートされていないデータベースで使用されると、コンパイラは `` NotImplementedError``を発生させます。便宜上、ステートメントが方言が指定されていない文字列として出力された場合、&amp;quot;文字列SQL &amp;quot;コンパイラが呼び出され、構文の非動作SQL表現が提供されます。</p>
</div>
<div class="section" id="matched-row-counts">
<h3>一致した行数<a class="headerlink" href="#matched-row-counts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜.TableClause.update`と：meth：</cite>〜.TableClause.delete`は*一致する行数*に関連付けられます。これは、WHERE句で一致した行の数を示す数値です。 &amp;quot;matched &amp;quot;によって、UPDATEが実際に行なわれなかった行が含まれていることに注意してください。値は次のように使用できます：attr： <cite>〜.ResultProxy.rowcount</cite>：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">delete</span><span class="p">())</span>
<div class='show_sql'>DELETE FROM users
()
COMMIT
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>
<span class="go">1</span></pre></div>
</div>
</div>
</div>
<div class="section" id="further-reference">
<h2>さらなる参照<a class="headerlink" href="#further-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>表現言語リファレンス：：ref： <cite>expression_api_toplevel</cite></p>
<p>データベースメタデータリファレンス：：ref： <cite>metadata_toplevel</cite></p>
<p>エンジンリファレンス：：doc： <cite>/ core / engines</cite></p>
<p>接続リファレンス：：ref： <cite>connections_toplevel</cite></p>
<p>型リファレンス：：ref： <cite>types_toplevel</cite></p>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="index.html" title="previous chapter">SQLAlchemyコア</a>
        Next:
        <a href="expression_api.html" title="next chapter">SQL Statements and Expressions API(SQL文とAPI式)</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



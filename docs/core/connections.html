<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    エンジンと接続の操作
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="エンジンと接続の使用" href="engines_connections.html" />
        <link rel="next" title="接続プーリング" href="pooling.html" />
        <link rel="prev" title="エンジン構成" href="engines.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemyコア">SQLAlchemyコア</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">SQL式言語チュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="expression_api.html">SQL Statements and Expressions API(SQL文とAPI式)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="schema.html">スキーマ定義言語</a></span></li>
<li><span class="link-container first"><a class="reference external" href="types.html">列とデータ型</a></span></li>
<li><span class="link-container first"><a class="reference external" href="engines_connections.html">エンジンと接続の使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="engines.html">エンジン構成</a></span></li>
<li class="selected"><span class="link-container first"><strong>エンジンと接続の操作</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#basic-usage">基本的な使用法</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-transactions">トランザクションの使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#nesting-of-transaction-blocks">トランザクションブロックのネスト</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#understanding-autocommit">オートコミットについて</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#connectionless-execution-implicit-execution">コネクションレス型の実行、暗黙の実行</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#translation-of-schema-names">スキーマ名の変換</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#engine-disposal">エンジンの廃棄</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-the-threadlocal-execution-strategy">スレッドローカル実行戦略の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#working-with-raw-dbapi-connections">Raw DBAPI接続の操作</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#calling-stored-procedures">ストアドプロシージャの呼び出し</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#multiple-result-sets">複数の結果セット</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#registering-new-dialects">新しい方言の登録</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#registering-dialects-in-process">インプロセスのダイアレクトの登録</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#connection-engine-api">接続/エンジンAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="pooling.html">接続プーリング</a></span></li>
<li><span class="link-container first"><a class="reference external" href="events.html">コアイベント</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="api_basics.html">コアAPIの基礎</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.engine">
<span id="working-with-engines-and-connections"></span><span id="connections-toplevel"></span><h1>エンジンと接続の操作<a class="headerlink" href="#module-sqlalchemy.engine" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このセクションでは、：class： <cite>.Engine</cite>、：class：` .Connection`、および関連するオブジェクトを直接使用する方法について詳しく説明します。 SQLAlchemy ORMを使用する場合、これらのオブジェクトは一般にアクセスされないことに注意することが重要です。代わりに：class： <cite>.Session`オブジェクトがデータベースへのインタフェースとして使用されます。しかし、ORMの上位レベルの管理サービスが関与していないテキストSQLステートメントやSQL式構造を直接使用するアプリケーションの場合、：class： `.Engine`と：class：</cite> .Connection`はキングです女王？） - 読んでください。</p>
<div class="section" id="basic-usage">
<h2>基本的な使用法<a class="headerlink" href="#basic-usage" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>.create_engine`コールでクラス：</cite> .Engine`が作成されたことを思い出してください：:: / core / engines`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mysql://scott:tiger@localhost/test&#39;</span><span class="p">)</span></pre></div>
</div>
<p>：func： <cite>.create_engine（）`の典型的な使い方は、特定のデータベースURLごとに一度であり、単一のアプリケーションプロセスの存続期間にわたってグローバルに保持されます。単一の：class： `.Engine`は、プロセスに代わって多くの個々のDBAPI接続を管理し、並行して呼び出されることを意図しています。 ：class： `.Engine`はDBAPIの</cite> <cite>connect``関数と同義ではありません**：**：</cite> .Engine`はモジュールで一度だけ作成されたときに最も効率的ですオブジェクト単位または関数単位の呼び出しではなく、アプリケーションのレベル。</p>
<p>`` os.fork``システムコールや、例えばPythonの `` multiprocessing``モジュールを使用するマルチプロセスアプリケーションでは、通常、各子プロセスに別々の：class： <cite>.Engine`を使用する必要があります。これは、：class： `.Engine`が最終的にDBAPI接続を参照する接続プールへの参照を保持しているためです。これらはプロセスの境界を越えて移植できない傾向があります。プーリングを使用しないように設定されたclass： `.Engine`（これは：class：</cite> .NullPool`の使用によって実現されます）にはこの要件はありません。</p>
<p>エンジンを直接使用してデータベースにSQLを発行することができます。最も一般的な方法は、まず：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.connect`メソッドで取得する接続リソースを取得することです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select username from users&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;username:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
<span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>接続は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`のインスタンスです。これは実際のDBAPI接続の**プロキシ**オブジェクトです。 DBAPI接続は、class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Connection`が作成された時点で接続プールから取得されます。</p>
<p>返される結果は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`のインスタンスで、DBAPIカーソルを参照し、DBAPIカーソルのインタフェースとほぼ互換性のあるインタフェースを提供します。 DBAPIカーソルは、すべての結果行（存在する場合）が使い果たされたときに：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.ResultProxy`によって閉じられます。 A：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.ResultProxy`は、UPDATE文のような行を返しません（返された行はありません）。</p>
<p>：meth： <cite>〜.Connection.close`メソッドが呼び出されると、参照されるDBAPI接続は：term：`解放されて接続プールに接続されます。プーリングが使用されていると仮定すると、データベース自体の観点からは、実際には &amp;quot;クローズド&amp;quot;はありません。プーリングメカニズムはDBAPI接続で `</cite> rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>呼び出しを発行し、トランザクション状態やロックが削除され、次回の使用の準備ができます。</p>
<p>上記の手順は：meth： <cite>〜.Engine.execute`メソッドを使って簡単に実行できます：class：</cite> .Engine`自体:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select username from users&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;username:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span></pre></div>
</div>
<p>上記の場合、：meth： <cite>〜.Engine.execute`メソッドは、それ自身で新しい：class：</cite> .Connection`を取得し、そのオブジェクトでステートメントを実行し、：class： <cite>.ResultProxy`を返します。この場合、：class： `.ResultProxy`は</cite> <cite>close_with_result``と呼ばれる特別なフラグを含みます。これは、その基になるDBAPIカーソルが閉じられると、：class：</cite> .Connection`オブジェクト自体も閉じられます。 DBAPI接続を接続プールに戻し、トランザクション・リソースを解放します。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`に潜在的に行が残っている場合、そのリソースを明示的に閉じるように指示することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>：class： <cite>.ResultProxy`に残っている行が残っていて、アプリケーションが閉じずに参照解除されると、Pythonのガベージコレクションは最終的にカーソルを閉じて、プールされたDBAPI接続リソースをプールに戻します（SQLAlchemyはこれはweakrefコールバックの使用によるものです。*決して* `</cite> __del__``メソッド） - しかし、リソースを管理するためにPythonのガベージコレクションに依存することは決して良い考えではありません。</p>
<p>上記の例では、テキストのSQL文字列の実行を示しています。 ：meth： <cite>〜.Connection.execute`メソッドはもちろん、ref：</cite> sqlexpression_toplevel`に記述されているさまざまなSQL式の構文を含めて、それ以上のものに対応できます。</p>
</div>
<div class="section" id="using-transactions">
<h2>トランザクションの使用<a class="headerlink" href="#using-transactions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このセクションでは、class： <cite>.Engine`と：class：</cite> .Connection`オブジェクトを直接扱うときのトランザクションの使い方について説明します。 SQLAlchemy ORMを使用する場合、トランザクション制御用のパブリックAPIは、：class： <cite>.Session`オブジェクトを介して行われます。このオブジェクトは：class：</cite> .Transaction`オブジェクトを内部的に使用します。詳細は：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>unitofwork_transaction`を参照してください。</p>
</div>
<p>：class： <cite>〜sqlalchemy.engine.Connection`オブジェクトは：class：</cite> .Transaction`オブジェクトを返す：meth： <cite>〜.Connection.begin`メソッドを提供します。このオブジェクトは通常、try / except句内で使用されるため、meth： `.Transaction.rollback`または：meth：</cite> .Transaction.commit` ::を呼び出すことが保証されています</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">col1</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">col2</span><span class="o">=</span><span class="s1">&#39;this is some data&#39;</span><span class="p">)</span>
    <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
    <span class="k">raise</span></pre></div>
</div>
<p>上記のブロックはコンテキストマネージャを使ってより簡潔に作成することができます：class： <cite>.Engine</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># runs a transaction</span>
<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">col1</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">col2</span><span class="o">=</span><span class="s1">&#39;this is some data&#39;</span><span class="p">)</span></pre></div>
</div>
<p>または、：class： <cite>.Connection`から：class：</cite> .Transaction`オブジェクトも利用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">trans</span><span class="p">:</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table1</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">col1</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">col2</span><span class="o">=</span><span class="s1">&#39;this is some data&#39;</span><span class="p">)</span></pre></div>
</div>
<div class="section" id="nesting-of-transaction-blocks">
<span id="connections-nested-transactions"></span><h3>トランザクションブロックのネスト<a class="headerlink" href="#nesting-of-transaction-blocks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <cite>.Transaction`オブジェクトは、一番外側の開始/コミットのペアを追跡することによって、&amp;quot;入れ子&amp;quot;の振る舞いも処理します。この例では、2つの関数の両方が：class： `.Connection`でトランザクションを発行しますが、最も外側の：class：</cite> .Transaction`オブジェクトだけが実際にコミットされたときに有効になります。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="c1"># method_a starts a transaction and calls method_b</span>
<span class="k">def</span> <span class="nf">method_a</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="c1"># open a transaction</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">method_b</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># transaction is committed here</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span> <span class="c1"># this rolls back the transaction unconditionally</span>
        <span class="k">raise</span>

<span class="c1"># method_b also starts a transaction</span>
<span class="k">def</span> <span class="nf">method_b</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="c1"># open a transaction - this runs in the context of method_a&#39;s transaction</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into mytable values (&#39;bat&#39;, &#39;lala&#39;)&quot;</span><span class="p">)</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">mytable</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">col1</span><span class="o">=</span><span class="s1">&#39;bat&#39;</span><span class="p">,</span> <span class="n">col2</span><span class="o">=</span><span class="s1">&#39;lala&#39;</span><span class="p">)</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># transaction is not committed yet</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span> <span class="c1"># this rolls back the transaction unconditionally</span>
        <span class="k">raise</span>

<span class="c1"># open a Connection and call method_a</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">method_a</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>上では、 `` connection_begin（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を呼び出す `` method_a``が最初に呼び出されます。次に、 `` method_b``を呼び出します。 `` method_b``が `` connection.begin（） <a href="#id3"><span class="problematic" id="id4">``</span></a>を呼び出すとき、単に `` commit（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を呼び出すとデクリメントされるカウンタをインクリメントします。 `` method_a``または `` method_b``のどちらかが `` rollback（） <a href="#id7"><span class="problematic" id="id8">``</span></a>を呼び出すと、トランザクション全体がロールバックされます。 `` method_a``が `` commit（） <a href="#id9"><span class="problematic" id="id10">``</span></a>メソッドを呼び出すまで、トランザクションはコミットされません。この &amp;quot;ネスティング（nesting）&amp;quot;動作は、トランザクションがまだ利用可能でない場合にトランザクションが使用されることを保証する機能の作成を可能にするが、トランザクションが存在する場合にはそれを自動的に囲むトランザクションに参加する。</p>
</div>
</div>
<div class="section" id="understanding-autocommit">
<span id="autocommit"></span><span id="index-0"></span><h2>オートコミットについて<a class="headerlink" href="#understanding-autocommit" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前のトランザクションの例は：class： <cite>.Transaction`を使っていくつかの実行が同じトランザクションに参加できるようにする方法を示しています。 ：class： `.Transaction`を使わずにINSERT、UPDATE、またはDELETE呼び出しを発行するとどうなりますか？一部のDBAPI実装では、さまざまな特別な &amp;quot;非トランザクション&amp;quot;モードを提供していますが、PEP-0249のDBAPIのコア動作は、トランザクションが常に進行中*で、 `</cite> rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>と `` commit ） <a href="#id3"><span class="problematic" id="id4">``</span></a>メソッドではなく `` begin（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を呼び出すことができます。 SQLAlchemyは、これが与えられたDBAPIの場合であると仮定します。</p>
<p>この要件が与えられると、SQLAlchemyはすべてのバックエンドで完全に一貫して機能する独自の&amp;quot;自動コミット&amp;quot;機能を実装します。これは、データ変更操作、つまりINSERT、UPDATE、DELETE、およびCREATE TABLE、ALTER TABLEなどのデータ定義言語（DDL）文を表す文を検出し、トランザクションが進行中でない場合にCOMMITを自動的に発行することによって実現されます。検出は、文の `` autocommit = True``実行オプションの有無に基づいて行われます。文がテキストのみの文であり、フラグが設定されていない場合は、正規表現を使用して特定のバックエンドに対してさまざまな他のコマンドと同様にINSERT、UPDATE、DELETEを検出します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO users VALUES (1, &#39;john&#39;)&quot;</span><span class="p">)</span>  <span class="c1"># autocommits</span></pre></div>
</div>
<p>&amp;quot;autocommit &amp;quot;機能は、class： <cite>.Transaction`が宣言されていない場合にのみ有効です。つまり、：class： `.Session`オブジェクトは、デフォルトで常に進行中の：class：</cite> .Transaction`を維持しているため、この機能はORMで一般的には使用されません。</p>
<p>&amp;quot;autocommit &amp;quot;の動作を完全に制御するには、class： <cite>.Connection</cite>、：class：` .Engine`、：class： <cite>.Executable`で提供されるgenerative：meth：</cite> .Connection.execution_options`メソッドを使用できます。選択されたスコープの自動コミットをオンまたはオフにする&amp;quot;自動コミット&amp;quot;フラグを使用します。たとえば、ストアド・プロシージャを表すa：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.text`構造体は、コミットするストアド・プロシージャを使用して、SELECT文がCOMMIT</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT my_mutating_procedure()&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></pre></div>
</div>
</div>
<div class="section" id="connectionless-execution-implicit-execution">
<span id="dbengine-implicit"></span><h2>コネクションレス型の実行、暗黙の実行<a class="headerlink" href="#connectionless-execution-implicit-execution" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最初のセクションから：class： <cite>.Connection`の明示的な使用の有無にかかわらず実行することを思い出してください。 &amp;quot;Connectionless &amp;quot;の実行とは：class： `.Connection`ではないオブジェクトに対して</cite> <cite>execute（）</cite> <cite>メソッドを使用することを指します。これは：meth： `〜.Engine.execute`メソッドを使って説明しました：class：</cite> .Engine`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select username from users&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;username:&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span></pre></div>
</div>
<p>&amp;quot;コネクションレス&amp;quot;の実行に加えて、実行をサポートするSQL式オブジェクトのマーカーである：class： <cite>.Executable`構文の：meth：</cite>〜.Executable.execute`メソッドを使用することもできます。 SQL式オブジェクト自体は：class： <cite>.Engine`または**：bind：**と呼ばれる：class：</cite> .Connection`を参照します。これはいわゆる暗黙的な実行サービスを提供するために使用されます。</p>
<p>与えられたテーブルは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>

<span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>
<span class="n">users_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>明示的に実行すると、SQLテキストまたは構築されたSQL式が：meth： <cite>〜.Connection.execute`メソッドに渡されます。class：</cite>〜sqlalchemy.engine.Connection`：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///file.db&#39;</span><span class="p">)</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users_table</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="c1"># ....</span>
<span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>明示的でコネクションレスな実行は、式を：meth： <cite>〜.Engine.execute`メソッドに渡します：class：</cite>〜sqlalchemy.engine.Engine`：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///file.db&#39;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users_table</span><span class="o">.</span><span class="n">select</span><span class="p">())</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="c1"># ....</span>
<span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>暗黙の実行もコネクションレスであり、式自体に：meth： <cite>〜.Executable.execute`メソッドを使用します。このメソッドは：class： `.Executable`クラスの一部として提供されます。このクラスは、データベースに対して呼び出されるのに十分なSQLステートメントを参照します。このメソッドは、：class： `〜sqlalchemy.engine.Engine`または：class：</cite>〜sqlalchemy.engine.Connection`のいずれかが式オブジェクトに**バインド**されているという前提を使用します。 &amp;quot;bound &amp;quot;という特別な属性：attr： <cite>.MetaData.bind`は一連の：class：</cite> .Table`オブジェクトと、それらから派生したすべてのSQL構造体を特定のエンジンに関連付けるために使用されています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///file.db&#39;</span><span class="p">)</span>
<span class="n">meta</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">engine</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">users_table</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="c1"># ....</span>
<span class="n">result</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>上記では、特別な属性：attr： <cite>.MetaData.bind`を使用して：class：</cite> .Engine`をa：class： <cite>.MetaData`オブジェクトに関連付けます。 ：class： `.Table`オブジェクトから生成された：func：</cite> .select`構造体はメソッド：meth： <cite>〜.Executable.execute`を持っています。これは：class：</cite> .Engine`を探します。 &amp;quot;を：class：` .Table`に追加します。</p>
<p>全体として、&amp;quot;バインドされたメタデータ&amp;quot;の使用には、3つの一般的な効果があります。</p>
<ul class="simple">
<li>SQL文オブジェクトは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Executable.execute`メソッドを取得します。これは自動的に&amp;quot;バインド&amp;quot;を検索して実行します。</li>
<li>ORM：class： <cite>.Session`オブジェクトは、特定のマップされたクラスに代わってSQL文を呼び出すためにclass：</cite> .Engine`が使われるべきであることを確立するために、&amp;quot;bound metadata <cite>.Session`は、complex：class：</cite> .Engine` / mappedのクラス設定を確立する独自の明示的なシステムも備えています。</li>
<li>：meth： <cite>.MetaData.create_all</cite>、：meth：` .MetaData.drop_all`、：meth： <cite>.Table.create</cite>、：meth：` .Table.drop`、および&amp;quot;autoload &amp;quot;フィーチャーはすべてmake bound：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`を明示的に渡す必要なしに自動的に使用します。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>最近のSQLAlchemyでは、&amp;quot;バウンドメタデータ&amp;quot;と&amp;quot;暗黙の実行&amp;quot;という概念は強調されていません。彼らはいくつかの便利さを提供しますが、それらはもはやAPIによって必要とされず、決して必要ではありません。</p>
<p>複数の：class： <cite>.Engine`オブジェクトが存在し、それぞれが特定のテーブルセット（すなわち* vertical sharding *）に論理的に関連付けられているアプリケーションでは、&amp;quot;バインドされたメタデータ&amp;quot;テクニックを使用して、individual：class： `.Table`は適切な：class：</cite> .Engine`を自動的に参照できます。特にこれはORM内で：class： <cite>.Session`オブジェクトを使って：class：</cite> .Table`オブジェクトを適切な：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`に関連付ける手段としてサポートされています。 ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`によって直接受け入れられます。</p>
<p>しかし、&amp;quot;暗黙の実行&amp;quot;技法は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`によって維持されるトランザクションコンテキストをバイパスするので、ORMでの使用にはまったく適していません。</p>
<p>全体的に、<em>大多数のケースでは、&amp;quot;バインドされたメタデータ&amp;quot;と&amp;quot;暗黙の実行&amp;quot;は有用ではありません*</em>。 &amp;quot;バインドされたメタデータ&amp;quot;はORMの設定に関して有益な限界レベルを持っていますが、&amp;quot;暗黙の実行&amp;quot;は非常に古い使用パターンであり、ほとんどの場合、参考になるよりも混乱しやすく、どちらのパターンも、後で問題を引き起こすアプリケーション設計における短期間の「短期間」の過度使用を促進するように見える。</p>
<p class="last">最新のSQLAlchemyの使用、特にORMは、トランザクションのコンテキスト内で常に作業することに重いストレスを与えます。 &amp;quot;暗黙の実行&amp;quot;という概念は、文の実行と特定のトランザクションとの関連付けをはるかに困難にします。特定のSQL文に対する：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Executable.execute`メソッドは、通常、実行が特定のトランザクションの一部ではないことを意味します。通常、これは望ましい効果ではありません。</p>
</div>
<p>両方の&amp;quot;connectionless &amp;quot;の例では、：class： <cite>〜sqlalchemy.engine.Connection`がバックグラウンドで作成されています。 ：class： `〜sqlalchemy.engine.ResultProxy`は、SQL文を発行するために使用される：class：</cite>〜sqlalchemy.engine.Connection`を参照します。 ：class： <cite>.ResultProxy`が閉じられると、基底の：class：</cite> .Connection`が閉じられ、トランザクションリソースが削除されたDBAPI接続がプールに返されます。</p>
</div>
<div class="section" id="translation-of-schema-names">
<span id="schema-translating"></span><h2>スキーマ名の変換<a class="headerlink" href="#translation-of-schema-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>共通のテーブルセットを複数のスキーマに配布するマルチテナントアプリケーションをサポートするには、：paramref： <cite>.Connection.execution_options.schema_translate_map`実行オプションを使用して、class：</cite> .Table`オブジェクトのセットを再利用して、スキーマ名は変更されません。</p>
<p>与えられたテーブル:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>：paramref： <cite>.Table.schema`属性で定義されているthis：class：</cite> .Table`のスキーマは `` None``です。 ：paramref： <cite>.Connection.execution_options.schema_translate_map`はスキーマが</cite> <cite>None``のall：class：</cite> .Table`オブジェクトがスキーマを `` user_schema_one``としてレンダリングすることを指定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span>
    <span class="n">schema_translate_map</span><span class="o">=</span><span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="s2">&quot;user_schema_one&quot;</span><span class="p">})</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">select</span><span class="p">())</span></pre></div>
</div>
<p>上記のコードは、フォームのデータベース上でSQLを呼び出します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">user_schema_one</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user_schema_one</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="n">FROM</span>
<span class="n">user_schema</span><span class="o">.</span><span class="n">user</span></pre></div>
</div>
<p>つまり、スキーマ名は翻訳された名前に置き換えられます。マップは、任意の数のtarget-&amp;gt; destinationスキーマを指定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span>
    <span class="n">schema_translate_map</span><span class="o">=</span><span class="p">{</span>
        <span class="kc">None</span><span class="p">:</span> <span class="s2">&quot;user_schema_one&quot;</span><span class="p">,</span>     <span class="c1"># no schema name -&gt; &quot;user_schema_one&quot;</span>
        <span class="s2">&quot;special&quot;</span><span class="p">:</span> <span class="s2">&quot;special_schema&quot;</span><span class="p">,</span> <span class="c1"># schema=&quot;special&quot; becomes &quot;special_schema&quot;</span>
        <span class="s2">&quot;public&quot;</span><span class="p">:</span> <span class="kc">None</span>               <span class="c1"># Table objects with schema=&quot;public&quot; will render with no schema</span>
    <span class="p">})</span></pre></div>
</div>
<p>：paramref： <cite>.Connection.execution_options.schema_translate_map`パラメータは：class：</cite> .Table`または：class： <cite>.Sequence`オブジェクトから派生した、SQL式言語から生成されたすべてのDDLとSQL構造に影響します。これは、：func： `.expression.text`コンストラクトや、：meth：</cite> .Connection.execute`に渡されるプレーンな文字列を介して使用されるリテラル文字列SQLには影響しません。</p>
<p>この機能は、スキーマの名前が：class： <cite>.Table`または：class：</cite> .Sequence`;のものから直接派生した場合に** <strong>のみ有効です。文字列スキーマ名が直接渡されるメソッドには影響しません。このパターンでは、：meth： `.MetaData.create_all`や：meth：` .MetaData.drop_all`などのメソッドによって実行されるチェックは、 &amp;quot;作成できます&amp;quot; / &amp;quot; class： `.Table`オブジェクトを指定してテーブルリフレクションを使用すると有効になります。ただし、：class： `.Inspector`オブジェクトに存在する操作には影響しません</strong>。スキーマ名はこれらのメソッドに明示的に渡されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</div>
<div class="section" id="engine-disposal">
<span id="id1"></span><h2>エンジンの廃棄<a class="headerlink" href="#engine-disposal" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <cite>.Engine`は接続プールを指します。これは通常の状況下では：class：</cite> .Engine`オブジェクトがまだメモリに常駐している間に開いているデータベース接続が存在することを意味します。 ：class： <cite>.Engine`がガベージコレクトされると、その接続プールはもはやその：class：</cite> .Engine`によって参照されなくなり、接続がまだチェックアウトされていないと仮定すると、プールとその接続もガーベッジ・コレクションは、実際のデータベース接続もクローズするという効果があります。しかし、それ以外の場合、：class： <cite>.Engine`は、オープンされたデータベース接続を保持します：class：</cite> .QueuePool`の通常のデフォルトのプール実装を使用すると仮定します。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`は、通常、アプリケーションの寿命を通して維持され、維持されている永続的なフィクスチャであることを意図しています。接続ごとに作成および廃棄することを意図したものではありません**。代わりに、接続プールと使用中のデータベースとDBAPIに関する構成情報とデータベース単位の内部キャッシュのある程度のキャッシュを維持するレジストリです。</p>
<p>しかし、class： <cite>.Engine`で参照されるすべての接続リソースを完全にクローズすることが望ましい場合が多いです。これらの場合には、Pythonガベージコレクションを使用するのが一般的には良い考えではありません。代わりに：class： `.Engine`は：meth：</cite> .Engine.dispose`メソッドを使って明示的に処理することができます。これにより、エンジンの基礎となる接続プールが破棄され、空の新しい接続プールに置き換えられます。ただし：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`がこの時点で破棄され、使用されなくなった場合、参照されている**チェックインされた**接続も完全に閉じられます。</p>
<p>呼び出しの有効な使用例：meth： <cite>.Engine.dispose</cite> include：</p>
<ul class="simple">
<li>プログラムが接続プールによって保持されている残りのチェックインされた接続を解放したい場合、将来の操作のためにそのデータベースに接続できなくなることが予想されます。</li>
<li>プログラムがマルチプロセッシングや `` fork（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を使用し、：class： <cite>.Engine`オブジェクトが子プロセスにコピーされた場合、エンジンが新しいものを作成するように：meth：</cite> .Engine.dispose`を呼び出す必要がありますそのフォークにローカルなデータベース接続。データベース接続は通常、プロセスの境界を越えて移動しません**。</li>
<li>多くの特別な、短命の：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトが作成され、処理されるテストスイートまたはマルチテナントシナリオでは、</li>
</ul>
<p><strong>チェックアウトされた接続**は、エンジンが廃棄されたりガベージコレクトされたときに破棄されません</strong>。これらの接続は依然としてアプリケーションの他の場所でも強く参照されています。しかし、：meth： <cite>.Engine.dispose`が呼び出された後、それらの接続はもはやそれに関連付けられません：class：</cite> .Engine`;それらが閉じられると、それらは孤立した接続プールに戻され、最終的にガベージコレクションされます。一度それを参照するすべての接続もどこでも参照されなくなります。このプロセスは制御するのが容易ではないので、meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.dispose`は、チェックアウトされたすべての接続がチェックインされた後に呼び出されるか、そうでなければプールからデア結合された後にのみ呼び出されます。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトの接続プーリングの使用によって悪影響を受けるアプリケーションの代替方法は、プーリングを完全に無効にすることです。これは、通常、新しい接続の使用時にわずかなパフォーマンスの影響しか受けません。つまり、接続がチェックインされると、完全にクローズされ、メモリに保持されません。プーリングを無効にする方法のガイドラインについては、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>pool_switching`を参照してください。</p>
</div>
<div class="section" id="using-the-threadlocal-execution-strategy">
<span id="threadlocal-strategy"></span><h2>スレッドローカル実行戦略の使用<a class="headerlink" href="#using-the-threadlocal-execution-strategy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>&amp;quot;threadlocal &amp;quot;エンジン戦略は、ORM以外のアプリケーションがトランザクションを現在のスレッドに関連付けるために使用できるオプションの機能です。アプリケーションのすべての部分が明示的に次のものを参照する必要はなく暗黙的にそのトランザクションに参加できます。クラス： <cite>.Connection</cite>。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">&amp;quot;threadlocal &amp;quot;機能は一般的には推奨されません。これは、一般にレガシーパターンと見なされる特定の使用パターン用に設計されています。 SQLAlchemyコンポーネントやアプリケーションの&amp;quot;スレッドセーフティ&amp;quot;に**影響はありません**。また、ORM：class： <cite>〜sqlalchemy.orm.session.Session`オブジェクトを使用するときは使用しないでください。class：</cite>〜sqlalchemy.orm.session.Session`自体は進行中のトランザクションを表し、それ自体はジョブを処理します接続リソースとトランザクションリソースを維持します。</p>
</div>
<p>`` threadlocal``を有効にするには、次のようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mysql://localhost/test&#39;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;threadlocal&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記の：class： <cite>.Engine`は：meth：</cite> .Engine.execute`または：meth： <cite>.Engine.contextual_connect`の時にスレッドローカル変数から派生した接続リソースを使用して：class：</cite> .Connection`を取得するようになりました。が呼び出されます。この接続リソースは参照されている限り維持され、アプリケーションの複数のポイントがコネクションレス実行を使用してトランザクションを共有できるようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">call_operation1</span><span class="p">():</span>
    <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into users values (?, ?)&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;john&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">call_operation2</span><span class="p">():</span>
    <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span>

<span class="n">db</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">call_operation1</span><span class="p">()</span>
    <span class="n">call_operation2</span><span class="p">()</span>
    <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">db</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span></pre></div>
</div>
<p>明示的な実行は、：meth： <cite>.Engine.connect`メソッドを使用して、threadlocalスコープの一部ではない：class：</cite> .Connection`を取得することによって、コネクションレス実行と混合することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">db</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">log_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Operation started&quot;</span><span class="p">)</span>
    <span class="n">call_operation1</span><span class="p">()</span>
    <span class="n">call_operation2</span><span class="p">()</span>
    <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">log_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Operation succeeded&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">db</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">log_table</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Operation failed&quot;</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>スレッドローカルスコープにバインドされている：class： <cite>.Connection`にアクセスするには、：meth：</cite> .Engine.contextual_connect`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span>
<span class="n">call_operation3</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>&amp;quot;contextual &amp;quot;接続でmeth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Connection.close`を実行しても、そのリソースの他のすべての用途が閉じられるまで、リソースは解放されません。コミット。</p>
</div>
<div class="section" id="working-with-raw-dbapi-connections">
<span id="dbapi-connections"></span><h2>Raw DBAPI接続の操作<a class="headerlink" href="#working-with-raw-dbapi-connections" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyが、ストアドプロシージャの呼び出しや複数の結果セットの処理など、いくつかの：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>DBAPI`関数にアクセスする際に汎用化された方法を提供しないケースがいくつかあります。このような場合は、生のDBAPI接続を直接処理するほうが便利です。</p>
<p>生のDBAPI接続にアクセスする最も一般的な方法は、既に存在する：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトから直接取得することです。これは：attr： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Connection.connection`属性を使って存在します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">dbapi_conn</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">connection</span></pre></div>
</div>
<p>ここのDBAPI接続は、元の接続プールに関しては実際には「プロキシード」ですが、これはほとんどの場合無視できる実装の詳細です。このDBAPI接続は依然としてowning：class： <cite>.Connection`オブジェクトのスコープ内に含まれているので、トランザクション制御などのほとんどの機能には：class：</cite> .Connection`オブジェクトを使用することが最善です。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.close`メソッド;これらの操作がDBAPI接続で直接実行される場合、所有：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Connection`は状態のこれらの変更を認識しません。</p>
<p>所有：class： <cite>.Connection`によって維持されるDBAPI接続によって課される制限を克服するために、：meth：`を使用して：class： `.Connection`を最初に取得する必要なしにDBAPI接続も利用できます： .Engine.raw_connection`のメソッド：class： `.Engine</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbapi_conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">()</span></pre></div>
</div>
<p>このDBAPI接続は、前と同様にプロキシされた形式です。この接続の <a href="#id1"><span class="problematic" id="id2">``</span></a>close（）` <a href="#id3"><span class="problematic" id="id4">`</span></a>メソッドを呼び出すと、DBAPI接続は通常は実際には閉じられず、term：<a href="#id5"><span class="problematic" id="id6">`</span></a>解放されてエンジンの接続プールに戻されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbapi_conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>SQLAlchemyでは将来DBAPIユースケースの組み込みパターンを追加することがありますが、これらのケースはめったに必要ではなく、使用されているDBAPIのタイプによって大きく異なるため、リターンは減少します。したがって、直接DBAPI呼び出しパターンは、必要な場合に常に存在します。</p>
<p>DBAPI接続の使用に関するいくつかのレシピが続きます。</p>
<div class="section" id="calling-stored-procedures">
<span id="stored-procedures"></span><h3>ストアドプロシージャの呼び出し<a class="headerlink" href="#calling-stored-procedures" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>特殊な構文またはパラメータの問題を伴うストアドプロシージャの場合、DBAPIレベルの `` callproc &lt;<a class="reference external" href="http://legacy.python.org/dev/peps/pep-0249/#callproc">http://legacy.python.org/dev/peps/pep-0249/#callproc</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_を使うことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">callproc</span><span class="p">(</span><span class="s2">&quot;my_procedure&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">])</span>
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
</div>
<div class="section" id="multiple-result-sets">
<h3>複数の結果セット<a class="headerlink" href="#multiple-result-sets" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数の結果セットのサポートは、未処理のDBAPIカーソルから <a href="#id1"><span class="problematic" id="id2">`</span></a>nextset &lt;<a class="reference external" href="http://legacy.python.org/dev/peps/pep-0249/#nextset">http://legacy.python.org/dev/peps/pep-0249/#nextset</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_メソッド:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select * from table1; select * from table2&quot;</span><span class="p">)</span>
    <span class="n">results_one</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">nextset</span><span class="p">()</span>
    <span class="n">results_two</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
</div>
</div>
<div class="section" id="registering-new-dialects">
<h2>新しい方言の登録<a class="headerlink" href="#registering-new-dialects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine`関数呼び出しは、setuptoolsのエントリポイントを使って指定された方言を探します。これらのエントリポイントは、setup.pyスクリプト内のサードパーティの方言用に設定できます。たとえば、新しいダイアレクト「foodialect：// 」を作成するには、次の手順を実行します。</p>
<ol class="arabic">
<li><p class="first">`` foodialect``というパッケージを作ります。</p>
</li>
<li><p class="first">パッケージにはdialectクラスを含むモジュールが必要です。これは、通常、class： <cite>sqlalchemy.engine.default.DefaultDialect`のサブクラスです。この例では、 `</cite> FooDialect``と呼ばれ、モジュールは `` foodialect.dialect``でアクセスされます。</p>
</li>
<li><p class="first">エントリポイントは、次のようにsetup.pyで設定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry_points</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">[sqlalchemy.dialects]</span>
<span class="s2">foodialect = foodialect.dialect:FooDialect</span>
<span class="s2">&quot;&quot;&quot;</span></pre></div>
</div>
</li>
</ol>
<p>ダイアレクトが既存のSQLAlchemy対応データベースの上に特定のDBAPIをサポートしている場合は、そのデータベース名を含めて名前を付けることができます。たとえば、 `` FooDialect``が実際にMySQLの方言だった場合、エントリポイントは次のように設定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry_points</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">[sqlalchemy.dialects]</span>
<span class="s2">mysql.foodialect = foodialect.dialect:FooDialect</span>
<span class="s2">&quot;&quot;&quot;</span></pre></div>
</div>
<p>上記のエントリポイントは `` create_engine（&amp;quot;mysql + foodialect：// &amp;quot;） <a href="#id1"><span class="problematic" id="id2">``</span></a>としてアクセスされます。</p>
<div class="section" id="registering-dialects-in-process">
<h3>インプロセスのダイアレクトの登録<a class="headerlink" href="#registering-dialects-in-process" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SQLAlchemyでは、別のインストールの必要性を回避して、現在のプロセス内にダイアレクトを登録することもできます。次のように `` register（） <a href="#id1"><span class="problematic" id="id2">``</span></a>関数を使用してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">registry</span>
<span class="n">registry</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;mysql.foodialect&quot;</span><span class="p">,</span> <span class="s2">&quot;myapp.dialect&quot;</span><span class="p">,</span> <span class="s2">&quot;MyMySQLDialect&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記は `` create_engine（&amp;quot;mysql + foodialect：// &amp;quot;） <a href="#id1"><span class="problematic" id="id2">``</span></a>に応答し、 `` myapp.dialect``モジュールから `` MyMySQLDialect``クラスをロードします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
</div>
</div>
<div class="section" id="connection-engine-api">
<h2>接続/エンジンAPI<a class="headerlink" href="#connection-engine-api" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.engine.Connection">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">Connection</code><span class="sig-paren">(</span><em>engine</em>, <em>connection=None</em>, <em>close_with_result=False</em>, <em>_branch_from=None</em>, <em>_execution_options=None</em>, <em>_dispatch=None</em>, <em>_has_events=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.engine.Connectable" title="sqlalchemy.engine.Connectable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.engine.Connectable</span></code></a></p>
<p>ラップされたDB-API接続の高レベル機能を提供します。</p>
<p>文字列ベースのSQL文だけでなく、：class： <cite>.ClauseElement</cite>、：class：` .Compiled`、：class： <cite>.DefaultGenerator`オブジェクトの実行をサポートします。 ：meth： `begin`メソッドを提供して：class：</cite> .Transaction`オブジェクトを返します。</p>
<p>Connectionオブジェクトは**スレッドセーフではありません**。 Connectionは、適切に同期化されたアクセスを使用してスレッド間で共有できますが、基礎となるDBAPI接続がスレッド間の共有アクセスをサポートしていない可能性もあります。詳細については、DBAPIのマニュアルを参照してください。</p>
<p>Connectionオブジェクトは、接続プールからチェックアウトされた単一のdbapi接続を表します。この状態では、接続プールは、有効期限またはタイムアウト状態を含む接続に影響を与えません。接続プールが適切に接続を管理するためには、接続が使用されていないときはいつでも、接続プール（つまり `` connection.close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>）に返す必要があります。</p>
<span class="target" id="index-1"></span><dl class="method">
<dt id="sqlalchemy.engine.Connection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>engine</em>, <em>connection=None</em>, <em>close_with_result=False</em>, <em>_branch_from=None</em>, <em>_execution_options=None</em>, <em>_dispatch=None</em>, <em>_has_events=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a new Connection.</p>
<p>The constructor here is not public and is only called only by an
<a class="reference internal" href="#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>. See <a class="reference internal" href="#sqlalchemy.engine.Engine.connect" title="sqlalchemy.engine.Engine.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.connect()</span></code></a> and
<a class="reference internal" href="#sqlalchemy.engine.Engine.contextual_connect" title="sqlalchemy.engine.Engine.contextual_connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Engine.contextual_connect()</span></code></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.begin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>トランザクションを開始し、トランザクションハンドルを返します。</p>
<p>返されるオブジェクトは：class： <cite>.Transaction`のインスタンスです。このオブジェクトは：meth： `.Transaction.rollback`または：meth：</cite> .Transaction.commit`メソッドが呼び出されたときに完了する、トランザクションの&amp;quot;スコープ&amp;quot;を表します。</p>
<p>クラス： <cite>.Connection`は、囲んでいるトランザクションのスコープ内でエミュレートされたトランザクションを表すnew：class：</cite> .Transaction`オブジェクトを返します。つまり、:: meth： <cite>.begin</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trans</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>   <span class="c1"># outermost transaction</span>
<span class="n">trans2</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># &quot;nested&quot;</span>
<span class="n">trans2</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>        <span class="c1"># does nothing</span>
<span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>         <span class="c1"># actually commits</span></pre></div>
</div>
<p>：meth： <cite>.Transaction.commit`は、：class：</cite> .Transaction`オブジェクトから呼び出されたときにのみ効果がありますが、：class： <cite>の：meth：</cite> .Transaction.rollback`メソッドです。トランザクションオブジェクトはトランザクションをロールバックします。</p>
<p>参照：</p>
<p>：meth： <cite>.Connection.begin_nested</cite>  -  SAVEPOINTを使用します。</p>
<p>：meth： <cite>.Connection.begin_twophase</cite>  - 二相/ XIDトランザクションを使用する</p>
<p>：meth： <cite>.Engine.begin</cite>  - コンテキストマネージャはclass：` .Engine`から利用できます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.begin_nested">
<code class="descname">begin_nested</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.begin_nested" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ネストされたトランザクションを開始し、トランザクションハンドルを返します。</p>
<p>返されるオブジェクトは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.NestedTransaction`のインスタンスです。</p>
<p>ネストされたトランザクションでは、基礎となるデータベースにSAVEPOINTサポートが必要です。階層内のどのトランザクションも「コミット」と「ロールバック」することができますが、もっとも外側のトランザクションは全体のトランザクションの全体的な「コミット」または「ロールバック」を制御します。</p>
<p>参照：meth： <cite>.Connection.begin</cite>、：meth：` .Connection.begin_twophase`。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.begin_twophase">
<code class="descname">begin_twophase</code><span class="sig-paren">(</span><em>xid=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.begin_twophase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2フェーズまたはXAトランザクションを開始し、トランザクションハンドルを返します。</p>
<p>返されるオブジェクトは：class： <cite>.TwoPhaseTransaction`のインスタンスです：class：</cite> .Transaction`によって提供されるメソッドに加えて：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.TwoPhaseTransaction.prepare`メソッドも提供されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.engine.Connection.begin_twophase.params.xid"></span><strong>xid</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.begin_twophase.params.xid">¶</a> -- 2フェーズのトランザクションID指定しない場合は、ランダムなIDが生成されます。</td>
</tr>
</tbody>
</table>
<p>参照：meth： <cite>.Connection.begin</cite>、：meth：` .Connection.begin_twophase`。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これを閉じます：class： <cite>.Connection</cite>。</p>
<p>これにより、基盤となるデータベース・リソース、つまり内部的に参照されるDBAPI接続が解放されます。 DBAPI接続は、通常、class： <cite>.Connection`を生成した：class：</cite> .Engine`によって参照される：class： <cite>.Pool`を保持している接続に復元されます。 DBAPI接続に存在するトランザクション状態は、DBAPI接続の `</cite> rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドを介して無条件に解放されます。これはclass： <cite>.Transaction`オブジェクトに関係なく未処理です。class：</cite> .Connection <a href="#id3"><span class="problematic" id="id4">`</span></a>。</p>
<p>：meth： <cite>〜.Connection.close`が呼び出された後、：class：</cite> .Connection`は永続的に閉じた状態にあり、これ以上の操作はできません。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.closed">
<code class="descname">closed</code><a class="headerlink" href="#sqlalchemy.engine.Connection.closed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この接続が閉じている場合はTrueを返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これの分岐バージョンを返します：class： <cite>.Connection</cite>。</p>
<p>返される：meth： <cite>.Connection.close`メソッドは、：class：</cite> .Connection`を呼び出すことができ、これは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`はオープンのままです。</p>
<p>このメソッドは、コンテキストマネージャでの使用を含め、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.connect`で使用対称性を提供します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.connection">
<code class="descname">connection</code><a class="headerlink" href="#sqlalchemy.engine.Connection.connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このConnectionによって管理される基本となるDB-API接続。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>dbapi_connections</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.contextual_connect">
<code class="descname">contextual_connect</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.contextual_connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これの分岐バージョンを返します：class： <cite>.Connection</cite>。</p>
<p>返される：meth： <cite>.Connection.close`メソッドは、：class：</cite> .Connection`を呼び出すことができ、これは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`はオープンのままです。</p>
<p>このメソッドは、コンテキストマネージャでの使用を含め、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.contextual_connect`で使用対称性を提供します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.default_isolation_level">
<code class="descname">default_isolation_level</code><a class="headerlink" href="#sqlalchemy.engine.Connection.default_isolation_level" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これに割り当てられたデフォルトの分離レベル：class： <cite>.Connection</cite>。</p>
<p>これは：class： <cite>.Connection`が：meth：</cite> .Engine.connect`メソッドで最初に調達したときの分離レベルの設定です。このレベルは、：paramref： <cite>.Connection.execution_options.isolation_level`がper：：class：</cite> .Connection`ベースで設定を変更するために使用されるまでそのまま残ります。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.get_isolation_level`とは異なり、この属性は、方言で最初に取得された接続から事前に設定されているため、このアクセサが呼び出されたときにSQLクエリは呼び出されません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.9 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Connection.get_isolation_level</cite>  - 現在のレベルを表示する</p>
<p>：paramref： <cite>.create_engine.isolation_level</cite>  -  per：class：` .Engine`分離レベル</p>
<p class="last">：paramref： <cite>.Connection.execution_options.isolation_level</cite>  -  per：class：` .Connection`の分離レベル</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.detach">
<code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.detach" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基礎となるDB-API接続を接続プールから切り離します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SET search_path TO schema1, schema2&quot;</span><span class="p">)</span>

    <span class="c1"># work with connection</span>

<span class="c1"># connection is fully closed (since we used &quot;with:&quot;, can</span>
<span class="c1"># also call .close())</span></pre></div>
</div>
<p>これは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`インスタンスは使用可能なままです。閉じられると（上記のようなコンテキスト・マネージャ・コンテキストから抜け出すと）、DB-API接続は文字どおり閉じられ、元のプールに戻されません。</p>
<p>このメソッドを使用して、接続の変更された状態（トランザクション分離レベルなど）からアプリケーションの残りの部分を保護することができます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>object</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.execute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SQL文を実行し、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`を返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.engine.Connection.execute.params.object"></span><strong>object</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execute.params.object">¶</a> -- 実行されるステートメント。 <em>：単純な文字列</em> any：class： <cite>.ClauseElement`構造体：class：</cite> .Executable`のサブクラスでもあります：a：func： <cite>〜.expression.select`構造体* a：クラス： `.FunctionElement`は、：data：</cite> .func`によって生成されたものなど、自動的にSELECTステートメントにラップされ、それが実行されます。 * a：class： <cite>.DDLElement`オブジェクト* a：class：</cite> .DefaultGenerator`オブジェクト* a：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Compiled`オブジェクト</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execute.params.*multiparams/**params"></span><strong>*multiparams/**params</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execute.params.*multiparams/**params">¶</a> -- 実行に使用されるバインドされたパラメータ値を表します。通常、* multiparams :: conn.execute（table.insert（）、{&amp;quot;id &amp;quot;：1、&amp;quot;value &amp;quot;：&amp;quot;v1 &amp;quot;}、{&amp;quot; id &amp;quot;：2、&amp;quot; value &amp;quot;：&amp;quot; v2 &amp;quot;}）... ** params :: conn.execute（table.insert（ ）、id = 1、value = &amp;quot;v1 &amp;quot;）プレーンSQL文字列が渡され、基礎となるDBAPIが位置バインドパラメータを受け入れる場合、* multiparamsのタプルまたは個々の値の集合が渡されます。 （1、&amp;quot;v1 &amp;quot;）、（2、&amp;quot;v2 &amp;quot;））conn.execute（&amp;quot;INSERT INTOテーブル（ID、値）VALUE（？、？） （？、？）&amp;quot;、1、&amp;quot; v1 &amp;quot;）上記のように、&amp;quot;？&amp;quot;または他のシンボルの使用は&amp;quot; paramstyle &amp;quot;qmark &amp;quot;、&amp;quot;named &amp;quot;、&amp;quot;pyformat &amp;quot;、&amp;quot;format &amp;quot;、&amp;quot;numeric &amp;quot;のいずれかであるDBAPIで受け入れられます。 <a href="#id1"><span class="problematic" id="id2">`</span></a>pep-249 &lt;<a class="reference external" href="http://www.python.org/dev/peps/pep-0249/">http://www.python.org/dev/peps/pep-0249/</a>&gt;パラームスタイルの詳細については、_を参照してください。 DBAPIに依存しない方法でバインドされたパラメータを使用するテキストSQL文を実行するには、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.expression.text`構文を使用します。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.execution_options">
<code class="descname">execution_options</code><span class="sig-paren">(</span><em>**opt</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.execution_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行中に有効になる接続の非SQLオプションを設定します。</p>
<p>このメソッドは、同じ基底のDBAPI接続を参照するthis：class： <cite>.Connection`のコピーを返しますが、：meth：</cite> execute`の呼び出しに有効な、指定された実行オプションも定義します。 new：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`は同じ基礎となるリソースを参照するので、通常はコピーがすぐに破棄されるようにすることをお勧めします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">stream_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
                    <span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span></pre></div>
</div>
<p>どのキー/値も：meth： <cite>.Connection.execution_options`に渡すことができ、：class：</cite> .Connection`の `` _execution_options``ディクショナリに格納されます。例えば、エンドユーザスキームがイベントリスナと通信するのに適しています。</p>
<p>現在SQLAlchemyで認識されているキーワードには、meth： <cite>.Executable.execution_options`の他に、class：</cite> .Connection`に固有のものも含まれます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.autocommit"></span><strong>autocommit</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.autocommit">¶</a> -- 利用可能：接続、ステートメント。 Trueの場合、COMMITは &amp;#39;自動コミット&amp;#39;モードで実行されたとき、つまり明示的なトランザクションが接続で開始されていないときに実行されます。デフォルトでは、DBAPI接続は常にトランザクション内にあることに注意してください.SQLAlchemyは、さまざまな種類のステートメントに適用されるルールを使用して、COMMITが呼び出されて自動コミット機能を提供するかどうかを判断します。通常、すべてのINSERT / UPDATE / DELETEステートメントとCREATE / DROPステートメントは、自動コミット動作を有効にします。 SELECT構文はしません。 COMMITが必要なSELECTや他の特定のSQL構文（通常はストアド・プロシージャを呼び出すときなど）を呼び出し、明示的なトランザクションが進行中でないときに、このオプションを使用します。</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.compiled_cache"></span><strong>compiled_cache</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.compiled_cache">¶</a> -- 使用可能な場所：Connection。辞書：where：class： <cite>.Compiled`オブジェクトは：class：</cite> .Connection`が節式を：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Compiled`オブジェクトにコンパイルするときにキャッシュされます。このディクショナリのサイズを管理するのは、ディクテーション、節の要素、INSERTまたはUPDATEのVALUESまたはSET句内の列名、および「バッチ」モードに対応するキーを持つユーザーの責任です。 INSERTまたはUPDATEステートメントの場合この辞書の形式は、将来のリリースでも同じであるとは限りません。 ORMは、フラッシュ操作を含むいくつかの操作に、独自の&amp;quot;コンパイル済み&amp;quot;キャッシュを使用することに注意してください。 ORMによって使用されるキャッシングは、ここで指定されたキャッシュディクショナリに優先して内部的に使用されます。</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.isolation_level"></span><strong>isolation_level</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.isolation_level">¶</a> -- 利用可能なのは：class： <cite>.Connection`です。 class： `.Connection`オブジェクトのライフタイムに対するトランザクション分離レベルを設定します（class：</cite> .Connection`オブジェクトの終了時にレベルが元の設定にリセットされる、基底のDBAPI接続ではありません） 。有効な値には：paramref： <cite>.create_engine.isolation_level`パラメータで受け入れられた文字列値が含まれます：func：</cite> .create_engine`。これらのレベルはセミデータベース固有のものです。有効なレベルについては個々の方言文書を参照してください。このオプションは、元の：class： <cite>.Connection`の存続期間の基礎となるDBAPI接続に必ず影響し、実行ごとではないことに注意してください。この設定は、基礎となるDBAPI接続が接続プールに返されるまでは削除されません。つまり、：meth： `.Connection.close`メソッドが呼び出されます。 .. warning :: `</cite> isolation_level``実行オプションは、トランザクションがすでに確立されている場合、つまり：meth： <cite>.Connection.begin`メソッドなどが呼び出されたときには使用しないでください。データベースは進行中のトランザクションの分離レベルを変更することができず、異なるDBAPIやSQLAlchemyの方言はトランザクションを暗黙的にロールバックまたはコミットしたり、接続にまったく影響を与えません。 .. versionchanged :: 0.9.9トランザクションが：meth： `.Connection.begin`またはそれに類するもので開始された後、</cite> <cite>isolation_level``実行オプションが使用されたときに、警告が発行されます。 ..注意:: `</cite> isolation_level``実行オプションは、：class： <cite>.Connection`が無効にされている場合、例えば：meth：</cite> .Connection.invalidate`メソッドによって、または切断エラーが発生した場合、暗黙的にリセットされます。無効化後に生成された新しい接続には、分離レベルが自動的に再適用されることはありません。 .. seealso :: paramref :: <cite>.create_engine.isolation_level</cite>  -  per：class：` .Engine`分離レベル：meth： <cite>.Connection.get_isolation_level</cite>  - 現在のレベルを表示：ref：` SQLite Transaction Isolation &lt;sqlite_isolation_level&gt; <cite>：ref：</cite> PostgreSQLトランザクションの分離&lt;postgresql_isolation_level&gt; <cite>：ref：</cite> MySQLトランザクションの分離&lt;mysql_isolation_level&gt; <cite>：ref：</cite> SQL Serverトランザクションの分離&lt;mssql_isolation_level&gt; <cite>：ref：</cite> session_transaction_isolation`  -  ORMのために</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.no_parameters"></span><strong>no_parameters</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.no_parameters">¶</a> -- `` True``のとき、最後のパラメータリストまたは辞書が完全に空であれば、パラメータコレクションをまったく渡さずに、カーソル上の文を `` cursor.execute（statement） <a href="#id1"><span class="problematic" id="id2">``</span></a>として呼び出します。 psycopg2やmysql-pythonなどの一部のDBAPIでは、パラメータが存在する場合にのみパーセント記号が重要とみなされます。このオプションを使用すると、DBAPIによって実行されるか、後でコマンドラインツールで呼び出されるスクリプトにパイプされているかに関して、パーセント記号（場合によってはその他の文字）を含むSQLをコードで生成できます。 .. versionadded :: 0.7.6</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.stream_results"></span><strong>stream_results</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.stream_results">¶</a> -- 利用可能：接続、ステートメント。可能であれば、結果は &amp;quot;ストリーミング&amp;quot;され、事前にバッファリングされてはならないという方言を示します。これは多くのDBAPIの制限です。フラグは現在、psycopg2、mysqldb、およびpymysqlの方言でのみ理解されています。</li>
<li><span class="target" id="sqlalchemy.engine.Connection.execution_options.params.schema_translate_map"></span><strong>schema_translate_map</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map">¶</a> -- 利用可能：接続、エンジン。 SQLまたはDDL式の要素が文字列にコンパイルされたときに、それぞれ：class： <cite>.Table`が検出され、：paramref：</cite> .Table.schema`要素に適用される、スキーマ名をスキーマ名にマッピングする辞書です。結果のスキーマ名は、元の名前のマップ内の存在に基づいて変換されます。 .. versionadded :: 1.1 .. seealso ::：ref： <cite>schema_translating</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.get_isolation_level">
<code class="descname">get_isolation_level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.get_isolation_level" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`に割り当てられた現在の隔離レベルを返します。</p>
<p>：paramref： <cite>.Connection.execution_options.isolation_level`機能を使用してper：：class：</cite> .Connection`ベースで隔離レベルを変更していない限り、これは通常、方言によって決定されるデフォルトの隔離レベルになります。</p>
<p>この属性は、現在の分離レベルを取得するために通常はライブSQL操作を実行するため、返される値は、この状態がどのように設定されたかにかかわらず、基礎となるDBAPI接続の実際のレベルです。 ：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.default_isolation_level`アクセサと比較して、SQLクエリを実行せずにダイアレクトレベルの設定を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.9 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：attr： <cite>.Connection.default_isolation_level</cite>  - デフォルトのレベルを表示する</p>
<p>：paramref： <cite>.create_engine.isolation_level</cite>  -  per：class：` .Engine`分離レベル</p>
<p class="last">：paramref： <cite>.Connection.execution_options.isolation_level</cite>  -  per：class：` .Connection`の分離レベル</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.in_transaction">
<code class="descname">in_transaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.in_transaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>トランザクションが進行中の場合はTrueを返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.info">
<code class="descname">info</code><a class="headerlink" href="#sqlalchemy.engine.Connection.info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`で参照される基になるDBAPI接続に関連付けられた情報辞書。ユーザー定義のデータを接続に関連付けることができます。</p>
<p>ここでのデータは、接続プールに戻された後のものも含めて、DBAPI接続の後に続き、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`の後続のインスタンスで再び使用されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><em>exception=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.invalidate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これに関連する基礎となるDBAPI接続を無効にします：class： <cite>.Connection</cite>。</p>
<p>基本となるDBAPI接続は、可能な場合は文字通り閉じられ、破棄されます。そのソース接続プールは、通常、新しい接続を作成して置き換えます。</p>
<p>次の使用時に（use &amp;quot;は通常：meth：` .Connection.execute`メソッドなどを使用することを意味します）、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`は、次のサービスを使用して新しいDBAPI接続を獲得しようとします。 ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Pool`を接続元（例えば&amp;quot;再接続 &amp;quot;）にします。</p>
<p>：meth： <cite>.Connection.invalidate`メソッドが呼び出されたときに、トランザクションが進行中（例えば、：meth：</cite> .Connection.begin`メソッドが呼び出された場合）、DBAPIレベルでこのトランザクションに関連するすべての状態が失われ、 DBAPI接続が閉じられているためです。 ：class： <cite>.Connection`は：class：</cite> .Transaction`オブジェクトが終了するまで、：meth： <cite>.Transaction.rollback`メソッドを呼び出すことによって、再接続を続行することはできません。その時点まで：class： `.Connection`を使い続けると、class：</cite>〜sqlalchemy.exc.InvalidRequestError`が発生します。これは、無効化によってトランザクションが失われたにもかかわらず、アプリケーションが誤って進行中のトランザクション操作を続行しないようにするためです。</p>
<p>：meth： <cite>.Connection.invalidate`メソッドは、自動無効化と同様に、接続プールレベルで、：meth：</cite> .PoolEvents.invalidate`イベントを呼び出します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pool_connection_invalidation</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.invalidated">
<code class="descname">invalidated</code><a class="headerlink" href="#sqlalchemy.engine.Connection.invalidated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この接続が無効にされた場合はTrueを返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.run_callable">
<code class="descname">run_callable</code><span class="sig-paren">(</span><em>callable_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.run_callable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能なオブジェクトまたは関数があれば、それを実行して：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`を最初の引数として渡します。</p>
<p>与えられた* argsと** kwargsは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`引数の後に渡されます。</p>
<p>この関数は：meth： <cite>.Engine.run_callable`と一緒に、：class：</cite> .Connection`または：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトを使って関数を実行することを可能にします。 。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.scalar">
<code class="descname">scalar</code><span class="sig-paren">(</span><em>object</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の行の最初の列を実行して返します。</p>
<p>基礎となる結果/カーソルは実行後に閉じられます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Connection.schema_for_object">
<code class="descname">schema_for_object</code><em class="property"> = &lt;sqlalchemy.sql.schema._SchemaTranslateMap object&gt;</em><a class="headerlink" href="#sqlalchemy.engine.Connection.schema_for_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの&amp;quot;スキーマ&amp;quot;属性を返します。</p>
<p>：class： <cite>.Table</cite>、：class：` .Sequence`などのオブジェクトで使用され、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.execution_options.schema_translate_map`パラメータを考慮します。</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>schema_translating</cite></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connection.transaction">
<code class="descname">transaction</code><span class="sig-paren">(</span><em>callable_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connection.transaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された関数をトランザクション境界内で実行します。</p>
<p>この関数は次のように渡されます：クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`を最初の引数に指定し、その後に与えられた* argsと** kwargsを続けます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some statement&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>

<span class="n">conn</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="n">do_something</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></pre></div>
</div>
<p>関数内の操作はすべて、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction`という単一のコンテキスト内で呼び出されます。成功すると、トランザクションはコミットされます。例外が発生した場合、トランザクションは例外を伝播する前にロールバックされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：meth： <cite>.transaction`メソッドは、Pythonの</cite> <cite>with：</cite> <cite>ステートメントの代わりに使われます。これは：meth：</cite> .Connection.begin`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some statement&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span></pre></div>
</div>
<p>同様に：meth： <cite>.Engine.begin</cite></p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some statement&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span></pre></div>
</div>
</div>
<p>参照：</p>
<blockquote>
<div><p>：meth： <cite>.Engine.begin</cite>  - エンジンレベルのトランザクションコンテキスト</p>
<p>：meth： <cite>.Engine.transaction</cite>  - エンジンレベルのバージョン：meth：` .Connection.transaction`</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.Connectable">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">Connectable</code><a class="headerlink" href="#sqlalchemy.engine.Connectable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SQL構文の実行をサポートするオブジェクトのインタフェース。</p>
<p>class： <cite>.Connectable`の2つの実装は：class：</cite> .Connection`と：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`です。</p>
<p>Connectableは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Dialect`インスタンスを参照する &amp;#39;dialect&amp;#39;メンバも実装しなければなりません。</p>
<dl class="method">
<dt id="sqlalchemy.engine.Connectable.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>a：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトを返します。</p>
<p>文脈によっては、このオブジェクトが既に：class： <cite>.Connection`のインスタンスである場合は</cite> <cite>self`</cite>、またはこのオブジェクトがインスタンスである場合は`：Connection :: `` Connection``：class： <cite>： .Engine</cite>。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connectable.contextual_connect">
<code class="descname">contextual_connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.contextual_connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>進行中のコンテキストの一部であるかもしれないa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトを返します。</p>
<p>文脈によっては、このオブジェクトが既に：class： <cite>.Connection`のインスタンスである場合は</cite> <cite>self`</cite>、またはこのオブジェクトがインスタンスである場合は`：Connection :: `` Connection``：class： <cite>： .Engine</cite>。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connectable.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>entity</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.create" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたスキーマエンティティのCREATE文を発行します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.7 で撤廃: </span>指定されたスキーマオブジェクトに対して直接create（）メソッドを使用してください：meth： <cite>.Table.create</cite>、：meth：` .Index.create`、：meth： <cite>.MetaData.create_all</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connectable.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>entity</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.drop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたスキーマエンティティのDROP文を発行します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.7 で撤廃: </span>指定されたスキーマオブジェクトに対してdrop（）メソッドを直接使用してください：meth： <cite>.Table.drop</cite>、：meth：` .Index.drop`、：meth： <cite>.MetaData.drop_all</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connectable.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>object</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.execute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた構文を実行し、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`を返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Connectable.scalar">
<code class="descname">scalar</code><span class="sig-paren">(</span><em>object</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Connectable.scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の行の最初の列を実行して返します。</p>
<p>基本カーソルは実行後に閉じられます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.CreateEnginePlugin">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">CreateEnginePlugin</code><span class="sig-paren">(</span><em>url</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.CreateEnginePlugin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URLのエントリポイント名に基づいて：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトの構築を補強するためのフックのセットです。</p>
<p>：class： <cite>.CreateEnginePlugin`の目的は、ターゲットアプリケーションを変更することなく、サードパーティシステムがエンジン、プール、および方言レベルのイベントリスナーを適用できるようにすることです。代わりに、プラグイン名をデータベースURLに追加することができます。ターゲットアプリケーション：class： `.CreateEnginePlugin</cite> include：</p>
<ul class="simple">
<li>例えば、イベントを使用してチェックアウトの回数および/またはステートメントで費やされた時間を追跡する接続およびSQLパフォーマンスツール</li>
<li>プロキシなどの接続プラグイン</li>
</ul>
<p>プラグインは、方言と同様にエントリポイントを使って登録されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry_points</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;sqlalchemy.plugins&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;myplugin = myapp.plugins:MyPlugin&#39;</span>
    <span class="p">]</span></pre></div>
</div>
<p>上記の名前を使用するプラグインは、次のようにデータベースURLから呼び出されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
  <span class="s2">&quot;mysql+pymysql://scott:tiger@localhost/test?plugin=myplugin&quot;</span><span class="p">)</span></pre></div>
</div>
<p>代わりに、：paramref： <cite>.create_engine.plugins &amp;quot;引数をリストとして渡すこともできます：func： `.create_engine</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
  <span class="s2">&quot;mysql+pymysql://scott:tiger@localhost/test&quot;</span><span class="p">,</span>
  <span class="n">plugins</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;myplugin&quot;</span><span class="p">])</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2.3 で追加: </span>プラグイン名も指定することができます：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine`をリストとして</p>
</div>
<p>`` plugin``引数は複数のインスタンスをサポートしているので、URLは複数のプラグインを指定することができます。 URLに記載された順序でロードされます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
  <span class="s2">&quot;mysql+pymysql://scott:tiger@localhost/&quot;</span>
  <span class="s2">&quot;test?plugin=plugin_one&amp;plugin=plugin_twp&amp;plugin=plugin_three&quot;</span><span class="p">)</span></pre></div>
</div>
<p>プラグインは、URL文字列とfunc： <cite>.create_engine`に渡されるキーワード引数から追加の引数を受け取ることができます。 ：class： `.URL`オブジェクトとキーワード辞書はコンストラクタに渡され、これらの引数はurlの：attr：</cite> .URL.query`コレクションから、また辞書:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyPlugin</span><span class="p">(</span><span class="n">CreateEnginePlugin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_one</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_one&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_two</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_two&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_argument_three</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;my_argument_three&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></pre></div>
</div>
<p>上記のような議論は、次のものから消費されるでしょう：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
  <span class="s2">&quot;mysql+pymysql://scott:tiger@localhost/&quot;</span>
  <span class="s2">&quot;test?plugin=myplugin&amp;my_argument_one=foo&amp;my_argument_two=bar&quot;</span><span class="p">,</span>
  <span class="n">my_argument_three</span><span class="o">=</span><span class="s1">&#39;bat&#39;</span><span class="p">)</span></pre></div>
</div>
<p>URLと辞書は、それ以降のエンジンの設定にそのまま使用されるため、プラグインはその場で引数を変更できます。プラグインだけが理解できる引数はポップされるか、そうでなければ削除されて、後で誤った引数として解釈されないようにする必要があります。</p>
<p>エンジンの作成プロセスが完了し、：class： <cite>.Engine`オブジェクトを生成すると、再び：meth：</cite> .CreateEnginePlugin.engine_created`フックを介してプラグインに渡されます。このフックでは、エンジンに追加の変更を加えることができ、最も一般的にはイベントの設定が必要です（例：：ref： <cite>core_event_toplevel</cite>）。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<dl class="method">
<dt id="sqlalchemy.engine.CreateEnginePlugin.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>url</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.CreateEnginePlugin.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Contruct a new <a class="reference internal" href="#sqlalchemy.engine.CreateEnginePlugin" title="sqlalchemy.engine.CreateEnginePlugin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateEnginePlugin</span></code></a>.</p>
<p>The plugin object is instantiated individually for each call
to <a class="reference internal" href="engines.html#sqlalchemy.create_engine" title="sqlalchemy.create_engine"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code></a>.  A single <a class="reference internal" href="#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> will be
passed to the <a class="reference internal" href="#sqlalchemy.engine.CreateEnginePlugin.engine_created" title="sqlalchemy.engine.CreateEnginePlugin.engine_created"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CreateEnginePlugin.engine_created()</span></code></a> method
corresponding to this URL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.engine.CreateEnginePlugin.params.url"></span><strong>url</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.CreateEnginePlugin.params.url">¶</a> -- the <a class="reference internal" href="engines.html#sqlalchemy.engine.url.URL" title="sqlalchemy.engine.url.URL"><code class="xref py py-class docutils literal notranslate"><span class="pre">URL</span></code></a> object.  The plugin should inspect
what it needs here as well as remove its custom arguments from the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">URL.query</span></code> collection.  The URL can be modified in-place
in any other way as well.</li>
<li><span class="target" id="sqlalchemy.engine.CreateEnginePlugin.params.kwargs"></span><strong>kwargs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.CreateEnginePlugin.params.kwargs">¶</a> -- The keyword arguments passed to :func`.create_engine`.
The plugin can read and modify this dictionary in-place, to affect
the ultimate arguments used to create the engine.  It should
remove its custom arguments from the dictionary as well.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.CreateEnginePlugin.engine_created">
<code class="descname">engine_created</code><span class="sig-paren">(</span><em>engine</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.CreateEnginePlugin.engine_created" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それが完全に構築されたら：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトを受け取ります。</p>
<p>プラグインは、エンジンまたは接続プールイベントの登録など、エンジンに追加の変更を加えることがあります。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.CreateEnginePlugin.handle_dialect_kwargs">
<code class="descname">handle_dialect_kwargs</code><span class="sig-paren">(</span><em>dialect_cls</em>, <em>dialect_args</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.CreateEnginePlugin.handle_dialect_kwargs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>方言kwargsを解析して修正する</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.CreateEnginePlugin.handle_pool_kwargs">
<code class="descname">handle_pool_kwargs</code><span class="sig-paren">(</span><em>pool_cls</em>, <em>pool_args</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.CreateEnginePlugin.handle_pool_kwargs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プールkwargsを解析して変更する</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.Engine">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">Engine</code><span class="sig-paren">(</span><em>pool</em>, <em>dialect</em>, <em>url</em>, <em>logging_name=None</em>, <em>echo=None</em>, <em>proxy=None</em>, <em>execution_options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.engine.Connectable" title="sqlalchemy.engine.Connectable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.engine.Connectable</span></code></a>, <a class="reference internal" href="internals.html#sqlalchemy.log.Identified" title="sqlalchemy.log.Identified"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.log.Identified</span></code></a></p>
<p>a：class： <cite>〜sqlalchemy.pool.Pool`と：class：</cite>〜sqlalchemy.engine.interfaces.Dialect`を一緒に接続して、データベース接続と動作のソースを提供します。</p>
<p>An：class： <cite>.Engine`オブジェクトは：func：</cite>〜sqlalchemy.create_engine`関数を使って公開されています。</p>
<p>参照：</p>
<p>：doc： <cite>/ core / engines</cite></p>
<p>：ref： <cite>connections_toplevel</cite></p>
<dl class="method">
<dt id="sqlalchemy.engine.Engine.begin">
<code class="descname">begin</code><span class="sig-paren">(</span><em>close_with_result=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.begin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャーを返します：class： <cite>.Connection`を：class：</cite> .Transaction`が設定された状態で返します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into table (x, y, z) values (1, 2, 3)&quot;</span><span class="p">)</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;my_special_procedure(5)&quot;</span><span class="p">)</span></pre></div>
</div>
<p>操作が成功すると、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction`がコミットされます。エラーが発生すると、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Transaction`がロールバックされます。</p>
<p>`` close_with_result``フラグは通常 `` False``で、操作が完了すると：class： <cite>.Connection`が閉じられることを示します。 `</cite> True``に設定すると、：class： <cite>.Connection`が&amp;quot;一回使用&amp;quot;モードにあります。ここで、：class：</cite> .ResultProxy`は最初の呼び出しで返されます：meth： <cite>.Connection .execute`は：class： `.Connection`を閉じます：class：</cite> .ResultProxy`がすべての結果行を使い果たしたとき。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.6 で追加.</span></p>
</div>
<p>参照：</p>
<p>：meth： <cite>.Engine.connect</cite>  - ：class：` .Engine`からa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`を取得します。</p>
<p>：meth： <cite>.Connection.begin</cite>  - 特定の：class：` .Connection`に対してa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction`を開始します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトを返します。</p>
<p>：class： <cite>.Connection`オブジェクトは、データベースと通信するためにDBAPI接続を内部的に使用するファサードです。この接続は、class： `.Engine`によって参照されるconnection-holding：class：</cite> .Pool`から取得されます。 ：class： <cite>.Connection`オブジェクトの：meth：</cite>〜.Connection.close`メソッドが呼び出されると、基礎となるDBAPI接続が接続プールに返されます。この接続プールは、次に続く呼び出しで再び使用されます。 meth： <cite>〜.Engine.connect</cite>。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.contextual_connect">
<code class="descname">contextual_connect</code><span class="sig-paren">(</span><em>close_with_result=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.contextual_connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>進行中のコンテキストの一部であるかもしれないa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトを返します。</p>
<p>デフォルトでは、このメソッドは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.connect`と同じことを行います。 ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Engine`のサブクラスは、このメソッドをオーバーライドしてコンテキスト動作を提供します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.engine.Engine.contextual_connect.params.close_with_result"></span><strong>close_with_result</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Engine.contextual_connect.params.close_with_result">¶</a> -- Trueの場合、：class： <cite>.Connection`で作成された最初の：class：</cite> .ResultProxy`は、保留中の結果行が使い尽くされるとすぐにその接続の：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.close`メソッドを呼び出します。これは、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Engine.execute`メソッドによって提供される&amp;quot;コネクションレス実行&amp;quot;の動作を提供するために使用されます。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.dispose">
<code class="descname">dispose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.dispose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`によって使用された接続プールを破棄します。</p>
<p>これは**現在チェックされているすべての**データベース接続を完全に閉じるという効果があります。まだチェックアウトされているコネクションは**閉鎖されませんが、class： <cite>.Engine`にはもはや関連付けられません。したがって、それらが個別に閉じられると、結局：class：</cite> .Pool`ガベージコレクションに関連付けられており、チェックイン時にまだ閉じていない場合は、完全にクローズされます。</p>
<p>新しい接続プールは、古い接続プールが破棄された直後に作成されます。この新しいプールは、すべてのSQLAlchemy接続プールと同様に、データベースへの実際の接続が最初に要求されるまで行われないため、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`が再び使用されない限り、新しい接続は行われません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>engine_disposal</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Engine.driver">
<code class="descname">driver</code><a class="headerlink" href="#sqlalchemy.engine.Engine.driver" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <cite>Engine`によって使用されている：class：</cite>〜sqlalchemy.engine.interfaces.Dialect`のドライバ名です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>statement</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.execute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた構文を実行し、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`を返します。</p>
<p>引数は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.execute`で使用される引数と同じです。</p>
<p>ここで、a：class： <cite>.Connection`は、：meth：</cite>〜.Engine.contextual_connect`メソッドとその接続で実行されたステートメントを使用して取得されます。返される：class： <cite>.ResultProxy`は、：class：</cite> .ResultProxy`が使い果たされ、その下にあるカーソルが閉じられると、ここで作成される：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`も閉じられ、接続プールに返されるDBAPI接続リソース。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.execution_options">
<code class="descname">execution_options</code><span class="sig-paren">(</span><em>**opt</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.execution_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された実行オプションで：class： <cite>.Connection`オブジェクトを提供する新しい：class：</cite> .Engine`を返します。</p>
<p>返される：class： <cite>.Engine`は、元の：class：</cite> .Engine`に関連していて、同じ接続プールと他の状態を共有しています：</p>
<ul class="simple">
<li>新しい：class： <cite>.Engine`で使われる：class：</cite> .Pool`は同じインスタンスです。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine.dispose`メソッドは、親エンジンとこれと同じ接続プールインスタンスを置き換えます。</li>
<li>イベントリスナーは&amp;quot;カスケード&amp;quot;です。新しい：class： <cite>.Engine`は親のイベントを継承し、新しいイベントはnew：class：</cite> .Engine`に個別に関連付けることができます。</li>
<li>ロギング設定とlogging_nameは、親：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`からコピーされます。</li>
</ul>
<p>：meth： <cite>.Engine.execution_options`メソッドの目的は、multiple：class：</cite> .Engine`オブジェクトが同じ接続プールを参照していて、消費するオプションによって区別されるsharding スキームを実装することですカスタムイベント:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">primary_engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql://&quot;</span><span class="p">)</span>
<span class="n">shard1</span> <span class="o">=</span> <span class="n">primary_engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">shard_id</span><span class="o">=</span><span class="s2">&quot;shard1&quot;</span><span class="p">)</span>
<span class="n">shard2</span> <span class="o">=</span> <span class="n">primary_engine</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">shard_id</span><span class="o">=</span><span class="s2">&quot;shard2&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記の `` shard1``エンジンは、実行オプション `` shard_id = shard1``と `` shard2``を含むclass： <cite>.Connection`オブジェクトのファクトリとして機能します：class：</cite> .Connection <cite>実行オプション</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>shard_id = shard2``を含むオブジェクトです。</p>
<p>イベントハンドラは、上記の実行オプションを消費して、接続が与えられたときにスキーマスイッチやその他の操作を実行できます。以下では、MySQLの `` use``文を発行してデータベースを切り替えると同時に、：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.info`ディクショナリを使用してどのデータベースを構築したかを追跡します。 DBAPI接続:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="k">import</span> <span class="n">Engine</span>

<span class="n">shards</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="n">shard_1</span><span class="p">:</span> <span class="s2">&quot;db1&quot;</span><span class="p">,</span> <span class="s2">&quot;shard_2&quot;</span><span class="p">:</span> <span class="s2">&quot;db2&quot;</span><span class="p">}</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Engine</span><span class="p">,</span> <span class="s2">&quot;before_cursor_execute&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_switch_shard</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">executemany</span><span class="p">):</span>
    <span class="n">shard_id</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shard_id&#39;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">)</span>
    <span class="n">current_shard</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;current_shard&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">current_shard</span> <span class="o">!=</span> <span class="n">shard_id</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;use </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">shards</span><span class="p">[</span><span class="n">shard_id</span><span class="p">])</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;current_shard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shard_id</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Connection.execution_options</cite>  -  class：` .Connection`オブジェクトの実行オプションを更新します。</p>
<p class="last">：meth： <cite>.Engine.update_execution_options</cite>  - 与えられた：class：` .Engine`の実行オプションを更新します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.has_table">
<code class="descname">has_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>schema=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.has_table" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたバックエンドに指定された名前のテーブルがある場合はTrueを返します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>metadata_reflection_inspector</cite>  - ：class：` .Inspector`インターフェースを使った詳細なスキーマ検査。</p>
<p class="last">：class： <cite>.quoted_name</cite>  - 引用情報とスキーマ識別子を渡すために使われます。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Engine.name">
<code class="descname">name</code><a class="headerlink" href="#sqlalchemy.engine.Engine.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <cite>Engine`によって使用されている：class：</cite>〜sqlalchemy.engine.interfaces.Dialect`の文字列名です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.raw_connection">
<code class="descname">raw_connection</code><span class="sig-paren">(</span><em>_connection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.raw_connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続プールから&amp;quot;未処理&amp;quot; DBAPI接続を返します。</p>
<p>返されるオブジェクトは、使用中の基礎となるドライバによって使用されるDBAPI接続オブジェクトのプロキシバージョンです。オブジェクトは実際のDBAPI接続と全く同じ動作をしますが、 `` close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドでは、接続が実際には閉じられずにプールに返される点が異なります。</p>
<p>このメソッドは、class： <cite>.Connection`によって提供されるAPIが不要な特殊な状況に対して直接DBAPI接続アクセスを提供します。 a：class： `.Connection`オブジェクトが既に存在する場合、DBAPI接続は：attr：</cite> .Connection.connection`アクセサを使用して利用できます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>dbapi_connections</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.run_callable">
<code class="descname">run_callable</code><span class="sig-paren">(</span><em>callable_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.run_callable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能なオブジェクトまたは関数があれば、それを実行して：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`を最初の引数として渡します。</p>
<p>与えられた* argsと** kwargsは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`引数の後に渡されます。</p>
<p>この関数は：meth： <cite>.Connection.run_callable`と一緒に、：class：</cite> .Connection`または：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトを使って関数を実行することを許可します。 。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.scalar">
<code class="descname">scalar</code><span class="sig-paren">(</span><em>statement</em>, <em>*multiparams</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の行の最初の列を実行して返します。</p>
<p>基本カーソルは実行後に閉じられます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.Engine.schema_for_object">
<code class="descname">schema_for_object</code><em class="property"> = &lt;sqlalchemy.sql.schema._SchemaTranslateMap object&gt;</em><a class="headerlink" href="#sqlalchemy.engine.Engine.schema_for_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの&amp;quot;スキーマ&amp;quot;属性を返します。</p>
<p>：class： <cite>.Table</cite>、：class：` .Sequence`などのオブジェクトで使用され、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.execution_options.schema_translate_map`パラメータを考慮します。</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>schema_translating</cite></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.table_names">
<code class="descname">table_names</code><span class="sig-paren">(</span><em>schema=None</em>, <em>connection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.table_names" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>データベースで使用可能なすべてのテーブル名のリストを返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.engine.Engine.table_names.params.schema"></span><strong>schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Engine.table_names.params.schema">¶</a> -- オプションで、デフォルト以外のスキーマから名前を取得します。</li>
<li><span class="target" id="sqlalchemy.engine.Engine.table_names.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.engine.Engine.table_names.params.connection">¶</a> -- オプションで、指定された接続を使用します。デフォルトはこの `` Engine``の `` contextual_connect``です。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.transaction">
<code class="descname">transaction</code><span class="sig-paren">(</span><em>callable_</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.transaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された関数をトランザクション境界内で実行します。</p>
<p>この関数は：class： <cite>.Connection`を新たに：meth：</cite> .Engine.contextual_connect`から最初の引数として渡し、その後に与えられた* argsと** kwargsを渡します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some statement&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>

<span class="n">engine</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="n">do_something</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></pre></div>
</div>
<p>関数内の操作はすべて、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction`という単一のコンテキスト内で呼び出されます。成功すると、トランザクションはコミットされます。例外が発生した場合、トランザクションは例外を伝播する前にロールバックされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：meth： <cite>.transaction`メソッドは、Pythonの</cite> <cite>with：</cite> <cite>ステートメントの代わりに使われます。これは：meth：</cite> .Engine.begin`</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some statement&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">})</span></pre></div>
</div>
</div>
<p>参照：</p>
<blockquote>
<div><p>：meth： <cite>.Engine.begin</cite>  - エンジンレベルのトランザクションコンテキスト</p>
<p>：meth： <cite>.Connection.transaction</cite>  - 接続レベルのバージョン：meth：` .Engine.transaction`</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Engine.update_execution_options">
<code class="descname">update_execution_options</code><span class="sig-paren">(</span><em>**opt</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Engine.update_execution_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これのデフォルトのexecution_options辞書を更新してください：class： <cite>.Engine</cite>。</p>
<p>** optの指定されたキー/値は、すべての接続で使用されるデフォルトの実行オプションに追加されます。この辞書の初期の内容は、 `` execution_options``パラメータを介して：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine`に送ることができます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Connection.execution_options</cite></p>
<p class="last">：meth： <cite>.Engine.execution_options</cite></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.ExceptionContext">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">ExceptionContext</code><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>進行中のエラー状態に関する情報をカプセル化します。</p>
<p>このオブジェクトは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ConnectionEvents.handle_error`イベントに渡すためにのみ存在し、後方互換性を持たない拡張が可能なインターフェースをサポートしています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.7 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.chained_exception">
<code class="descname">chained_exception</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.chained_exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>例外チェーン内の前のハンドラによって返された例外（存在する場合）。</p>
<p>存在する場合、この例外は、後続のハンドラがそれを置き換えない限り、最終的にSQLAlchemyによって生成される例外になります。</p>
<p>なしかもしれません。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.connection">
<code class="descname">connection</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class：例外の間に使用されている <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`です。</p>
<p>このメンバーは、最初に接続するときの障害を除いて存在します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：attr： <cite>.ExceptionContext.engine</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.cursor">
<code class="descname">cursor</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.cursor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPIカーソルオブジェクト。</p>
<p>なしかもしれません。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.engine">
<code class="descname">engine</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.engine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class：例外の間に使用されている <cite>.Engine</cite>。</p>
<p>最初に接続したときに障害が発生した場合でも、このメンバーは常に存在する必要があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.execution_context">
<code class="descname">execution_context</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.execution_context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>進行中の実行操作に対応する：class： <cite>.ExecutionContext</cite>。</p>
<p>これは、文の実行操作には存在しますが、トランザクションの開始/終了などの操作には現れません。これは、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ExecutionContext`が構築される前に例外が発生したときにも存在しません。</p>
<p>：attr： <cite>.ExceptionContext.statement`と：attr：</cite> .ExceptionContext.parameters`のメンバーは、：class： <cite>.ExecutionContext`とは異なる値を表すかもしれないことに注意してください。a：meth：</cite> .ConnectionEvents.before_cursor_execute`イベントまたは同様のものが送信されるステートメント/パラメータを変更しました。</p>
<p>なしかもしれません。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect">
<code class="descname">invalidate_pool_on_disconnect</code><em class="property"> = True</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&amp;quot;disconnect &amp;quot;条件が有効なときに、プール内のすべての接続を無効にする必要があるかどうかを表します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ConnectionEvents.handle_error`イベントのスコープ内でこのフラグをFalseに設定すると、切断中にプール内の接続の完全集合が無効にならないような効果があります。エラーの対象となる現在の接続のみが実際に無効になります。</p>
<p>このフラグの目的は、プール内の他の接続の無効化が他の条件に基づいて、または接続ごとに実行されるカスタム切断処理スキームのためです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.is_disconnect">
<code class="descname">is_disconnect</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.is_disconnect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>発生した例外が&amp;quot;disconnect &amp;quot;状態を表すかどうかを表します。</p>
<p>このフラグは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ConnectionEvents.handle_error`ハンドラーのスコープ内で常にTrueまたはFalseになります。</p>
<p>SQLAlchemyはこのフラグを延期して、その後に接続を無効にする必要があるかどうかを判断します。つまり、このフラグを代入することによって、このフラグを変更することによって接続およびプールの無効化をもたらす「切断」イベントを呼び出すことができます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.original_exception">
<code class="descname">original_exception</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.original_exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>捕捉された例外オブジェクト。</p>
<p>このメンバーは常に存在します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.parameters">
<code class="descname">parameters</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.parameters" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPIに直接発行されたパラメータコレクション。</p>
<p>なしかもしれません。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.sqlalchemy_exception">
<code class="descname">sqlalchemy_exception</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.sqlalchemy_exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <cite>sqlalchemy.exc.StatementError</cite>：元の文字をラップし、例外処理がイベントによって回避されない場合に発生します。</p>
<p>すべての例外タイプがSQLAlchemyでラップされているわけではないため、Noneである可能性があります。 dbapiのErrorクラスをサブクラス化するDBAPIレベルの例外の場合、このフィールドは常に存在します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ExceptionContext.statement">
<code class="descname">statement</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.engine.ExceptionContext.statement" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>String直接DBAPIに発行されたSQLステートメント。</p>
<p>なしかもしれません。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.NestedTransaction">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">NestedTransaction</code><span class="sig-paren">(</span><em>connection</em>, <em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.NestedTransaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.engine.Transaction</span></code></a></p>
<p>&amp;#39;ネストされた&amp;#39;トランザクション、またはSAVEPOINTトランザクションを表します。</p>
<p>新しい：class： <cite>.NestedTransaction`オブジェクトは、：meth：</cite> .Connection.begin_nested`メソッドを使用して調達することができます。</p>
<p>インタフェースは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Transaction`と同じです。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.ResultProxy">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">ResultProxy</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>行の列へのアクセスを容易にするためにDB-APIカーソルオブジェクトをラップします。</p>
<p>個々の列は、整数位置、大文字小文字を区別しない列名、または `` schema.Column``オブジェクトによってアクセスできます。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="n">fetchone</span><span class="p">()</span>

<span class="n">col1</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># access via integer position</span>

<span class="n">col2</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;col2&#39;</span><span class="p">]</span>   <span class="c1"># access via name</span>

<span class="n">col3</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">mycol</span><span class="p">]</span> <span class="c1"># access via Column object.</span></pre></div>
</div>
<p>`` ResultProxy``は、この結果セットを生成した元のSQL文から参照される `` TypeEngine``オブジェクトを使用して結果カラムデータの後処理も処理します。</p>
<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy._cursor_description">
<code class="descname">_cursor_description</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy._cursor_description" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスによってオーバーライドされることがあります。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy._process_row">
<code class="descname">_process_row</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy._process_row" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlalchemy.engine.RowProxy" title="sqlalchemy.engine.RowProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowProxy</span></code></a> のエイリアス</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy._soft_close">
<code class="descname">_soft_close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy._soft_close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソフトを閉じるには：class： <cite>.ResultProxy</cite>。</p>
<p>これにより、すべてのDBAPIカーソルリソースが解放されますが、意味的な観点からResultProxy &amp;quot;open &amp;quot;が残されます。つまり、fetchXXX（）メソッドは空の結果を引き続き返します。</p>
<p>このメソッドは、次の場合に自動的に呼び出されます。</p>
<ul class="simple">
<li>fetchXXX（）メソッドを使用してすべての結果行が使い果たされます。</li>
<li>cursor.descriptionはNoneです。</li>
</ul>
<p>このメソッドはpublic <a href="#id1"><span class="problematic" id="id2">**</span></a>ではありませんが、使用された&amp;quot;autoclose &amp;quot;プロセスを明確にするために文書化されています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.ResultProxy.close</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このResultProxyを閉じます。</p>
<p>これにより、文の実行に対応する基礎となるDBAPIカーソルが存在する場合は、それがクローズされます。 ：class： <cite>.ResultProxy`が利用可能なすべての行を使い果たすと、DBAPIカーソルが自動的に解放されることに注意してください。 ：meth： `.ResultProxy.close`は、fetchのために保留中の行がまだ残っている：class：</cite> .ResultProxy`を破棄する場合を除いて、一般的にオプションです。</p>
<p>結果の場合：ref： <cite>コネクションレス型の実行&lt;dbengine_implicit&gt; `、underlying：class：</cite> .Connection`オブジェクトも閉じます。term：DBAPI接続リソースを解放します。</p>
<p>このメソッドが呼び出された後は、フェッチメソッドを呼び出すことはもはや有効ではなく、後で使用するときには：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResourceClosedError`が発生します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>- the <a class="reference internal" href="#sqlalchemy.engine.ResultProxy.close" title="sqlalchemy.engine.ResultProxy.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultProxy.close()</span></code></a> method
has been separated out from the process that releases the underlying
DBAPI cursor resource.   The &quot;auto close&quot; feature of the
<a class="reference internal" href="#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> now performs a so-called &quot;soft close&quot;, which
releases the underlying DBAPI cursor, but allows the
<a class="reference internal" href="#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a> to still behave as an open-but-exhausted
result set; the actual <a class="reference internal" href="#sqlalchemy.engine.ResultProxy.close" title="sqlalchemy.engine.ResultProxy.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultProxy.close()</span></code></a> method is never
called.    It is still safe to discard a <a class="reference internal" href="#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResultProxy</span></code></a>
that has been fully exhausted without calling this method.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>connections_toplevel</cite></p>
<p class="last">：meth： <cite>.ResultProxy._soft_close</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.fetchall">
<code class="descname">fetchall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.fetchall" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DB-APIの `` cursor.fetchall（） <a href="#id1"><span class="problematic" id="id2">``</span></a>のように、すべての行を取得します。</p>
<p>すべての行が使い果たされた後、基礎となるDBAPIカーソルリソースが解放され、オブジェクトは安全に破棄される可能性があります。</p>
<p>続いて：meth： <cite>.ResultProxy.fetchall`を呼び出すと、空のリストが返されます。 ：meth： `.ResultProxy.close`メソッドが呼び出されると、このメソッドはraise：class：</cite> .ResourceClosedError`メソッドを呼び出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>- Added &quot;soft close&quot; behavior which
allows the result to be used in an &quot;exhausted&quot; state prior to
calling the <a class="reference internal" href="#sqlalchemy.engine.ResultProxy.close" title="sqlalchemy.engine.ResultProxy.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultProxy.close()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.fetchmany">
<code class="descname">fetchmany</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.fetchmany" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DB-APIの `` cursor.fetchmany（size = cursor.arraysize） <a href="#id1"><span class="problematic" id="id2">``</span></a>と同じように、多くの行を取得します。</p>
<p>すべての行が使い果たされた後、基礎となるDBAPIカーソルリソースが解放され、オブジェクトは安全に破棄される可能性があります。</p>
<p>すべての行が使い果たされた後：meth： <cite>.ResultProxy.fetchmany`を呼び出すと、空のリストが返されます。 ：meth： `.ResultProxy.close`メソッドが呼び出されると、このメソッドはraise：class：</cite> .ResourceClosedError`メソッドを呼び出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>- Added &quot;soft close&quot; behavior which
allows the result to be used in an &quot;exhausted&quot; state prior to
calling the <a class="reference internal" href="#sqlalchemy.engine.ResultProxy.close" title="sqlalchemy.engine.ResultProxy.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultProxy.close()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.fetchone">
<code class="descname">fetchone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.fetchone" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DB-APIの `` cursor.fetchone（） <a href="#id1"><span class="problematic" id="id2">``</span></a>と同じように、1つの行を取得します。</p>
<p>すべての行が使い果たされた後、基礎となるDBAPIカーソルリソースが解放され、オブジェクトは安全に破棄される可能性があります。</p>
<p>：meth： <cite>.ResultProxy.fetchone`を呼び出すと、すべての行がなくなり、</cite> <cite>None``が返されます。 ：meth： `.ResultProxy.close`メソッドが呼び出されると、このメソッドはraise：class：</cite> .ResourceClosedError`メソッドを呼び出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>- Added &quot;soft close&quot; behavior which
allows the result to be used in an &quot;exhausted&quot; state prior to
calling the <a class="reference internal" href="#sqlalchemy.engine.ResultProxy.close" title="sqlalchemy.engine.ResultProxy.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResultProxy.close()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.first">
<code class="descname">first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.first" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の行をフェッチし、無条件に結果セットを閉じます。</p>
<p>行が存在しない場合はNoneを返します。</p>
<p>このメソッドを呼び出した後、オブジェクトは完全に閉じられます。例えば、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy.close`メソッドが呼び出されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.inserted_primary_key">
<code class="descname">inserted_primary_key</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.inserted_primary_key" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>挿入された行の主キーを返します。</p>
<p>戻り値は、ターゲット表の主キー列のリストに対応するスカラー値のリストです。</p>
<p>これは明示的に：meth： <cite>.Insert.returning`を指定しなかった単一行：func：</cite> .insert`構造にのみ適用されます。</p>
<p>server_default句を指定するか、または &amp;quot;autoincrement &amp;quot;カラム（class： <cite>.Column`の注釈を参照）として修飾されず、データベース側のデフォルトを使用して生成された主キー列は、バックエンドが&amp;quot;戻る&amp;quot;をサポートしていなくて、&amp;quot;暗黙の復帰&amp;quot;を有効にして実行された挿入文がない限り、このリストは `</cite> None``となります。</p>
<p>実行された文がコンパイルされた式構造でないか、またはinsert（）構文でない場合、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.exc.InvalidRequestError`を送出します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.is_insert">
<code class="descname">is_insert</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.is_insert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Trueの場合：class： <cite>.ResultProxy`はコンパイルされた式言語を実行した結果です：func：</cite> .expression.insert` construct。</p>
<p>Trueの場合、これは：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>inserted_primary_key`属性がアクセス可能であることを意味し、ステートメントにユーザー定義の&amp;quot;返す &amp;quot;構成が含まれていないと仮定します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>行の文字列キーの現在のセットを返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.last_inserted_params">
<code class="descname">last_inserted_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.last_inserted_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この実行から挿入されたパラメータのコレクションを返します。</p>
<p>実行された文がコンパイルされた式構造でないか、またはinsert（）構文でない場合、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.exc.InvalidRequestError`を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.last_updated_params">
<code class="descname">last_updated_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.last_updated_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この実行から更新されたパラメータのコレクションを返します。</p>
<p>実行された文がコンパイルされた式の構文でないか、またはupdate（）構文でない場合、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.exc.InvalidRequestError`を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.lastrow_has_defaults">
<code class="descname">lastrow_has_defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.lastrow_has_defaults" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基底：class： <cite>.ExecutionContext`から</cite> <cite>lastrow_has_defaults（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を返します。</p>
<p>詳細は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ExecutionContext`を参照してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.lastrowid">
<code class="descname">lastrowid</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.lastrowid" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPIカーソルの &amp;#39;lastrowid&amp;#39;アクセサを返します。</p>
<p>これはDBAPI固有のメソッドであり、それをサポートするバックエンド、適切なステートメントに対してのみ機能します。バックエンド間で一貫していない動作です。</p>
<p>このメソッドの使用法は、通常、insert（）式の構文を使用する場合は不要です。 ：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜ResultProxy.inserted_primary_key`属性は、データベースのバックエンドに関係なく、新しく挿入された行の主キー値のタプルを提供します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>next（）プロトコルを実装します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.postfetch_cols">
<code class="descname">postfetch_cols</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.postfetch_cols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基礎となる：class： <cite>.ExecutionContext`から</cite> <cite>postfetch_cols（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を返します。</p>
<p>詳細は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ExecutionContext`を参照してください。</p>
<p>実行された文がコンパイルされた式構造でないか、またはinsert（）またはupdate（）構文でない場合、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.exc.InvalidRequestError`を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.prefetch_cols">
<code class="descname">prefetch_cols</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.prefetch_cols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基礎となる：class： <cite>.ExecutionContext`から</cite> prefetch_cols（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を返します。</p>
<p>詳細は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ExecutionContext`を参照してください。</p>
<p>実行された文がコンパイルされた式構造でないか、またはinsert（）またはupdate（）構文でない場合、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.exc.InvalidRequestError`を送出します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.returned_defaults">
<code class="descname">returned_defaults</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.returned_defaults" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ValuesBase.return_defaults`機能を使用してフェッチされたデフォルト列の値を返します。</p>
<p>値は：class： <cite>.RowProxy`のインスタンス、または：meth：</cite> .ValuesBase.return_defaults`が使用されなかった場合、またはバックエンドがRETURNINGをサポートしない場合は `` None``です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.ValuesBase.return_defaults</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.returns_rows">
<code class="descname">returns_rows</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.returns_rows" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>trueの場合：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy`は行を返します。</p>
<p>つまり、meth： <cite>〜.ResultProxy.fetchone</cite>、：meth：<cite>〜.ResultProxy.fetchmany</cite>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.ResultProxy.fetchall`メソッドを呼び出すことが合法であるかどうか。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.engine.ResultProxy.rowcount">
<code class="descname">rowcount</code><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.rowcount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この結果の「行数」を返します。</p>
<p>&amp;#39;rowcount&amp;#39;は、UPDATEまたはDELETEステートメントのWHERE条件に一致する行数を報告します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>注意事項：attr： <cite>.ResultProxy.rowcount</cite>：</p>
<ul class="last simple">
<li>この属性は、実際に*変更された行の数と必ずしも同じではない*一致した行の数を返します。* UPDATE文は、指定されたSET値が与えられた場合、すでに行にあるものと同じです。このような行は一致しますが、変更されません。 MySQLなどの両方のスタイルを持つバックエンドでは、rowcountはデフォルトですべてのケースで一致カウントを返すように設定されています。</li>
<li>：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy.rowcount`は、UPDATEまたはDELETEステートメントと組み合わせてのみ有効です。 Python DBAPIとは異なり、行がバッファリングされていない場合、DBAPIはこの機能をサポートできないため、SELECT文の結果から使用可能な行数を返しません。</li>
<li>：attr： <cite>.ResultProxy.rowcount`はすべての方言によって完全に実装されていないかもしれません。特に、ほとんどのDBAPIはexecutemanyコールからの集計行カウントをサポートしていません。 ：meth： `.ResultProxy.supports_sane_rowcount`と：meth：</cite> .ResultProxy.supports_sane_multi_rowcount`メソッドは、各使用法がサポートされていることがわかっている場合、方言から報告します。</li>
<li>RETURNINGを使用するステートメントは、正しい行数を返しません。</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.scalar">
<code class="descname">scalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の行の最初の列をフェッチし、結果セットを閉じます。</p>
<p>行が存在しない場合はNoneを返します。</p>
<p>このメソッドを呼び出した後、オブジェクトは完全に閉じられます。例えば、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ResultProxy.close`メソッドが呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.supports_sane_multi_rowcount">
<code class="descname">supports_sane_multi_rowcount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.supports_sane_multi_rowcount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>方言から `` supports_sane_multi_rowcount``を返します。</p>
<p>参照：背景：attr： <cite>.ResultProxy.rowcount</cite></p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.ResultProxy.supports_sane_rowcount">
<code class="descname">supports_sane_rowcount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.ResultProxy.supports_sane_rowcount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>方言から `` supports_sane_rowcount``を返します。</p>
<p>参照：背景：attr： <cite>.ResultProxy.rowcount</cite></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.RowProxy">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">RowProxy</code><span class="sig-paren">(</span><em>parent</em>, <em>row</em>, <em>processors</em>, <em>keymap</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.RowProxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.engine.BaseRowProxy</span></code></p>
<p>単一のカーソル行からのプロキシ値。</p>
<p>ほとんどの場合、結果セットの値を文字列ベースの列名、行内の結果の整数位置、およびこの結果セットを生成した元の列にマップできるColumnインスタンスにマップする、&amp;quot;順序付けられた辞書&amp;quot;の動作に従います構築されたSQL式に対応する結果の場合）。</p>
<dl class="method">
<dt id="sqlalchemy.engine.RowProxy.has_key">
<code class="descname">has_key</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.RowProxy.has_key" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このRowProxyに指定されたキーが含まれている場合はTrueを返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.RowProxy.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.RowProxy.items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キー/値のペアを含むタプルのリストを返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.RowProxy.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.RowProxy.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このRowProxyが表す文字列としてキーのリストを返します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.Transaction">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">Transaction</code><span class="sig-paren">(</span><em>connection</em>, <em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Transaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>進行中のデータベーストランザクションを表します。</p>
<p>：class： <cite>.Transaction`オブジェクトは、：meth：</cite>〜.Connection.begin`メソッドを呼び出すことによって調達されます：class： <cite>.Connection</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;postgresql://scott:tiger@localhost/test&quot;</span><span class="p">)</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (1, 2)&quot;</span><span class="p">)</span>
<span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>オブジェクトは、トランザクションの境界を制御するために：meth： <cite>.rollback`メソッドと：meth：</cite> .commit`メソッドを提供します。また、Pythonの `` with``文が：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.begin`メソッドで使用できるように、コンテキストマネージャインタフェースを実装しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into x (a, b) values (1, 2)&quot;</span><span class="p">)</span></pre></div>
</div>
<p>Transactionオブジェクトは**スレッドセーフではありません。</p>
<p>：meth： <cite>.Connection.begin</cite>、：meth：` .Connection.begin_twophase`、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.begin_nested`も参照してください。</p>
<span class="target" id="index-2"></span><dl class="method">
<dt id="sqlalchemy.engine.Transaction.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Transaction.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これを閉じます：class： <cite>.Transaction</cite>。</p>
<p>このトランザクションがbegin / commitネストの基本トランザクションである場合、トランザクションはロールバック（）されます。それ以外の場合は、メソッドが戻ります。</p>
<p>これは、囲みトランザクションのスコープに影響を与えずにトランザクションを取り消すために使用されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Transaction.commit">
<code class="descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Transaction.commit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これをコミットします：class： <cite>.Transaction</cite>。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.engine.Transaction.rollback">
<code class="descname">rollback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.Transaction.rollback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これをロールバックする：class： <cite>.Transaction</cite>。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.engine.TwoPhaseTransaction">
<em class="property">class </em><code class="descclassname">sqlalchemy.engine.</code><code class="descname">TwoPhaseTransaction</code><span class="sig-paren">(</span><em>connection</em>, <em>xid</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.TwoPhaseTransaction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.engine.Transaction" title="sqlalchemy.engine.Transaction"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.engine.Transaction</span></code></a></p>
<p>2フェーズトランザクションを表します。</p>
<p>新しい：class： <cite>.TwoPhaseTransaction`オブジェクトは：meth：</cite> .Connection.begin_twophase`メソッドを使って調達することができます。</p>
<p>インタフェースは：class： <cite>.Transaction`のインタフェースと同じで、：meth：</cite> prepare`メソッドが追加されています。</p>
<dl class="method">
<dt id="sqlalchemy.engine.TwoPhaseTransaction.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.engine.TwoPhaseTransaction.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これを準備します：class： <cite>.TwoPhaseTransaction</cite>。</p>
<p>PREPAREの後に、トランザクションをコミットすることができます。</p>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="engines.html" title="previous chapter">エンジン構成</a>
        Next:
        <a href="pooling.html" title="next chapter">接続プーリング</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



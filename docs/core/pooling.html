<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    接続プーリング
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="エンジンと接続の使用" href="engines_connections.html" />
        <link rel="next" title="コアイベント" href="events.html" />
        <link rel="prev" title="エンジンと接続の操作" href="connections.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemyコア">SQLAlchemyコア</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">SQL式言語チュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="expression_api.html">SQL Statements and Expressions API(SQL文とAPI式)</a></span></li>
<li><span class="link-container first"><a class="reference external" href="schema.html">スキーマ定義言語</a></span></li>
<li><span class="link-container first"><a class="reference external" href="types.html">列とデータ型</a></span></li>
<li><span class="link-container first"><a class="reference external" href="engines_connections.html">エンジンと接続の使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="engines.html">エンジン構成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="connections.html">エンジンと接続の操作</a></span></li>
<li class="selected"><span class="link-container first"><strong>接続プーリング</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#connection-pool-configuration">接続プールの構成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#switching-pool-implementations">スイッチングプールの実装</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-a-custom-connection-function">カスタム接続関数の使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#constructing-a-pool">プールの作成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#pool-events">プールイベント</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#dealing-with-disconnects">切断を扱う</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#disconnect-handling-pessimistic">切断処理 - 悲観的</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#custom-legacy-pessimistic-ping">カスタム/レガシーペシミスティックPing</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#disconnect-handling-optimistic">ディスコネクト処理 - 楽観的</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#setting-pool-recycle">プールリサイクルの設定</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#more-on-invalidation">失効の詳細</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#using-fifo-vs-lifo">FIFOとLIFOの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-connection-pools-with-multiprocessing">マルチプロセッシングでの接続プールの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#api-documentation-available-pool-implementations">APIドキュメント - 使用可能なプールの実装</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="events.html">コアイベント</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="api_basics.html">コアAPIの基礎</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.pool">
<span id="connection-pooling"></span><span id="pooling-toplevel"></span><h1>接続プーリング<a class="headerlink" href="#module-sqlalchemy.pool" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>接続プールは、効率的な再利用のためにメモリ内の長時間実行される接続を維持するとともに、アプリケーションが同時に使用できる接続の総数を管理するために使用される標準的な手法です。</p>
<p>特にサーバー側のWebアプリケーションの場合、接続プールは、メモリ内のアクティブなデータベース接続のプールを維持し、要求全体で再利用するための標準的な方法です。</p>
<p>SQLAlchemyには：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`と統合するいくつかの接続プール実装が含まれています。また、通常のDBAPIアプローチにプーリングを追加するアプリケーションに直接使用することもできます。</p>
<div class="section" id="connection-pool-configuration">
<h2>接続プールの構成<a class="headerlink" href="#connection-pool-configuration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>〜sqlalchemy.create_engine`関数によって返される：class：</cite>〜.engine.Engine`は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.QueuePool`が組み込まれていて、合理的なプーリングのデフォルトで事前設定されています。プーリングを有効にする方法を学ぶためにのみ、このセクションを読んでいるなら、おめでとうございます！あなたはすでに完了しています。</p>
<p>最も一般的な：class： <cite>.QueuePool`チューニングパラメータはキーワード引数として：func：</cite>〜sqlalchemy.create_engine`に直接渡すことができます： `` pool_size``、 `` max_overflow``、 `` pool_recycle``、 `` pool_timeout``を実行します。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://me@localhost/mydb&#39;</span><span class="p">,</span>
                       <span class="n">pool_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">max_overflow</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></pre></div>
</div>
<p>SQLiteの場合、：class： <cite>.SingletonThreadPool`または：class：</cite> .NullPool`が方言によって選択され、SQLiteのスレッドとロックモデルとの互換性が向上し、SQLite 単一の接続の範囲内でデータセット全体を維持する「メモリ」データベース。</p>
<p>すべてのSQLAlchemyプールの実装は、接続のどれもが &amp;quot;作成前に作成されません&amp;quot;という共通点を持っています - すべての実装は、接続を作成する前に初めて使用するまで待機します。この時点で、さらに多くの接続に対する追加の並行チェックアウト要求が行われない場合、追加の接続は作成されません。これは、func： <cite>.create_engine`が、アプリケーションが実際に5つの接続が待ち行列に入っているかどうかにかかわらず、size：5のclass：</cite> .QueuePool`を使用することをデフォルトにしている理由です。アプリケーションが実際に5つの接続を同時に使用した場合はそのサイズになります。この場合、小さなプールの使用は完全に適切なデフォルト動作です。</p>
</div>
<div class="section" id="switching-pool-implementations">
<span id="pool-switching"></span><h2>スイッチングプールの実装<a class="headerlink" href="#switching-pool-implementations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>.create_engine`を使って別の種類のプールを使用する通常の方法は、</cite> <cite>poolclass``引数を使うことです。この引数は、 `</cite> sqlalchemy.pool``モジュールからインポートされたクラスを受け取り、プールの構築の詳細を処理します。一般的なオプションには、class： <cite>.QueuePool</cite> with SQLite</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">QueuePool</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///file.db&#39;</span><span class="p">,</span> <span class="n">poolclass</span><span class="o">=</span><span class="n">QueuePool</span><span class="p">)</span></pre></div>
</div>
<p>クラスを使用してプールを無効にする：class： <cite>.NullPool</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">NullPool</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
          <span class="s1">&#39;postgresql+psycopg2://scott:tiger@localhost/test&#39;</span><span class="p">,</span>
          <span class="n">poolclass</span><span class="o">=</span><span class="n">NullPool</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="using-a-custom-connection-function">
<h2>カスタム接続関数の使用<a class="headerlink" href="#using-a-custom-connection-function" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>All：class： <cite>.Pool`クラスは、新しい接続を作成する呼び出し可能な引数</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>creator``を受け入れます。 ：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.create_engine`は、この関数が同じ名前の引数を使ってプールに渡すことを許可します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy.pool</span> <span class="k">as</span> <span class="nn">pool</span>
<span class="kn">import</span> <span class="nn">psycopg2</span>

<span class="k">def</span> <span class="nf">getconn</span><span class="p">():</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">dbname</span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
    <span class="c1"># do things with &#39;c&#39; to set up</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql+psycopg2://&#39;</span><span class="p">,</span> <span class="n">creator</span><span class="o">=</span><span class="n">getconn</span><span class="p">)</span></pre></div>
</div>
<p>ほとんどの&amp;quot;初期化時の接続&amp;quot;ルーチンでは、：class： <cite>.PoolEvents`イベントフックを使うほうが便利です。つまり、：func：</cite> .create_engine`の通常のURL引数が引き続き使用できるようになります。 `` creator``は、DBAPIがSQLAlchemyでサポートされていない何らかの形式の `` connect``を持っているときの最後の手段です。</p>
</div>
<div class="section" id="constructing-a-pool">
<h2>プールの作成<a class="headerlink" href="#constructing-a-pool" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <cite>.Pool`を単独で使うには、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>creator``関数が唯一の引数であり、最初に渡され、その後に追加のオプションが続きます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlalchemy.pool</span> <span class="k">as</span> <span class="nn">pool</span>
<span class="kn">import</span> <span class="nn">psycopg2</span>

<span class="k">def</span> <span class="nf">getconn</span><span class="p">():</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="n">dbname</span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="n">mypool</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">QueuePool</span><span class="p">(</span><span class="n">getconn</span><span class="p">,</span> <span class="n">max_overflow</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>次に、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool.connect`関数を使用してプールからDBAPI接続を調達することができます。このメソッドの戻り値は、透過プロキシに含まれるDBAPI接続です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># get a connection</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">mypool</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

<span class="c1"># use it</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select foo&quot;</span><span class="p">)</span></pre></div>
</div>
<p>透過プロキシの目的は、DBAPI接続が閉じられる代わりにプールに返されるように、 `` close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>の呼び出しを傍受することです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># &quot;close&quot; the connection.  Returns</span>
<span class="c1"># it to the pool.</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre></div>
</div>
<p>プロキシは、プールにガベージコレクションされたときにそのプールに含まれるDBAPI接続も返しますが、Pythonではこれが即座に発生することは確定的ではありません（cPythonでは典型的ですが）。</p>
<p>`` close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>ステップは、DBAPI接続の `` rollback（） <a href="#id3"><span class="problematic" id="id4">``</span></a>メソッドを呼び出す重要なステップも実行します。これは、接続上の既存のトランザクションが削除されるため、次の使用時に既存の状態が残っていないことを保証するだけでなく、表と行のロックが解除され、隔離されたデータスナップショットが削除されます。この動作は、class： <cite>.Pool`の</cite> <a href="#id5"><span class="problematic" id="id6">`</span></a>reset_on_return``オプションを使って無効にすることができます。</p>
<p>特定のpre-created：class： <cite>.Pool`は、func：</cite> .create_engine` ::の `` pool``引数に渡すことで、1つ以上のエンジンと共有することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql://&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">mypool</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="pool-events">
<h2>プールイベント<a class="headerlink" href="#pool-events" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>接続プールは、最初の接続時、新規接続時、および接続のチェックアウト時およびチェックイン時にフックを実行できるイベント・インターフェースをサポートします。詳しくは、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.PoolEvents`を参照してください。</p>
</div>
<div class="section" id="dealing-with-disconnects">
<span id="pool-disconnects"></span><h2>切断を扱う<a class="headerlink" href="#dealing-with-disconnects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>接続プールには、以前にプールされた接続を「無効」と設定して、個々の接続およびその接続セット全体をリフレッシュする機能があります。一般的な使用例として、データベースサーバーの再起動時に接続プールを正常に回復させることができ、以前に確立された接続は機能しなくなります。これには2つのアプローチがあります。</p>
<div class="section" id="disconnect-handling-pessimistic">
<span id="pool-disconnects-pessimistic"></span><h3>切断処理 - 悲観的<a class="headerlink" href="#disconnect-handling-pessimistic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>悲観的なアプローチでは、各接続プールのチェックアウトの開始時にSQL接続でテストステートメントを発行し、データベース接続が実行可能であることをテストします。通常、これは&amp;quot;SELECT 1 &amp;quot;のような単純な文ですが、DBAPI固有のメソッドを使用して、接続の有効性をテストすることもできます。</p>
<p>このアプローチでは、接続チェックアウトプロセスにわずかなオーバーヘッドが追加されますが、プールされていない接続によるデータベースエラーを完全に排除する最も単純で信頼できるアプローチです。呼び出し元のアプリケーションは、プールからチェックアウトされた古い接続から回復できるように操作を整理することを心配する必要はありません。</p>
<p>事前pingのアプローチ**は、トランザクションや他のSQL操作の途中で削除された接続**に対応していないことに注意することが重要です。トランザクションが進行中にデータベースが使用できなくなると、トランザクションは失われ、データベースのエラーが発生します。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection`オブジェクトは&amp;quot; disconnect &amp;quot;状況を検出し、接続をリサイクルするだけでなく、この条件が発生したときに残りの接続プールを無効にしますが、例外が発生した個々の操作は失われます。操作を中止するか、トランザクション全体をやり直すかはアプリケーションによって異なります。</p>
<p>チェックアウト時の接続の悲観的なテストは、：paramref： <cite>.Pool.pre_ping`引数を使用することで実現できます。：paramref：</cite> .create_engine.pool_pre_ping`引数を介して：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine`から取得できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql+pymysql://user:pw@host/db&quot;</span><span class="p">,</span> <span class="n">pool_pre_ping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>&amp;quot;プレping &amp;quot;機能は通常、接続がプールからチェックアウトされるたびに&amp;quot;SELECT 1 &amp;quot;と同等のSQLを出力します。 &amp;quot;disconnect &amp;quot;状態として検出されたエラーが発生した場合、接続は直ちにリサイクルされ、現在時刻より古いプールされた接続はすべて無効になり、次回チェックアウトされると、使用前にリサイクルしてください。</p>
<p>&amp;quot;pre ping &amp;quot;が実行されてもデータベースが使用できない場合、初期接続は失敗し、接続失敗のエラーは正常に伝播されます。データベースが接続で利用可能であるが、&amp;quot;ping &amp;quot;に応答できない珍しい状況では、&amp;quot;pre_ping &amp;quot;は3回まで試行し、最後に受信したデータベースエラーを伝播します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">&amp;quot;pre-ping &amp;quot;によって生成された&amp;quot;SELECT 1 &amp;quot;はPythonの待ち時間を最小限に抑えるために非常に短いコードパスを使用して接続プール/方言の範囲内で呼び出されます。そのため、この文は** SQLエコー出力**には記録されず、SQLAlchemyのエンジンログには表示されません。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加: </span>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`クラスに&amp;quot; pre-ping &amp;quot;機能を追加しました。</p>
</div>
<div class="section" id="custom-legacy-pessimistic-ping">
<h4>カスタム/レガシーペシミスティックPing<a class="headerlink" href="#custom-legacy-pessimistic-ping" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>：paramref： <cite>.create_engine.pool_pre_ping`が追加される前に、&amp;quot; pre-ping &amp;quot;アプローチは歴史的に：meth：</cite> .ConnectionEvents.engine_connect`エンジンイベントを使用して手動で実行されました。アプリケーションがすでにそのようなレシピを使用している場合や、特別な動作が必要な場合の参考のため、これに関する最も一般的なレシピは次のとおりです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">select</span>

<span class="n">some_engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">some_engine</span><span class="p">,</span> <span class="s2">&quot;engine_connect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ping_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">branch</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">branch</span><span class="p">:</span>
        <span class="c1"># &quot;branch&quot; refers to a sub-connection of a connection,</span>
        <span class="c1"># we don&#39;t want to bother pinging on these.</span>
        <span class="k">return</span>

    <span class="c1"># turn off &quot;close with result&quot;.  This flag is only used with</span>
    <span class="c1"># &quot;connectionless&quot; execution, otherwise will be False in any case</span>
    <span class="n">save_should_close_with_result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">should_close_with_result</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">should_close_with_result</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># run a SELECT 1.   use a core select() so that</span>
        <span class="c1"># the SELECT of a scalar value without a table is</span>
        <span class="c1"># appropriately formatted for the backend</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">DBAPIError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># catch SQLAlchemy&#39;s DBAPIError, which is a wrapper</span>
        <span class="c1"># for the DBAPI&#39;s exception.  It includes a .connection_invalidated</span>
        <span class="c1"># attribute which specifies if this connection is a &quot;disconnect&quot;</span>
        <span class="c1"># condition, which is based on inspection of the original exception</span>
        <span class="c1"># by the dialect in use.</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">connection_invalidated</span><span class="p">:</span>
            <span class="c1"># run the same SELECT again - the connection will re-validate</span>
            <span class="c1"># itself and establish a new connection.  The disconnect detection</span>
            <span class="c1"># here also causes the whole connection pool to be invalidated</span>
            <span class="c1"># so that all stale connections are discarded.</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">select</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># restore &quot;close with result&quot;</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">should_close_with_result</span> <span class="o">=</span> <span class="n">save_should_close_with_result</span></pre></div>
</div>
<p>上記のレシピは、SQLAlchemyの機能を利用して、&amp;quot;disconnect &amp;quot;状況を示す既知のDBAPI例外を検出し、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトの現在の値を正しく無効にする機能を利用するという利点があります現在の：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Connection`が新しいDBAPI接続に再検証できるようにします。</p>
</div>
</div>
<div class="section" id="disconnect-handling-optimistic">
<h3>ディスコネクト処理 - 楽観的<a class="headerlink" href="#disconnect-handling-optimistic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>悲観的な取り扱いが採用されていない場合、およびデータベースがトランザクション内で接続の使用期間の途中でシャットダウンおよび/または再開される場合と同様に、古い/閉じた接続を処理するもう1つの方法は、SQLAlchemyがその時点で、プール内のすべての接続が無効になります。つまり、古いものとみなされ、次のチェックアウト時に更新されます。この動作は、：class： <cite>.Pool`が：class：</cite> .Engine`と一緒に使用されることを前提としています。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`は、切断イベントを検出して自動的にプールをリフレッシュするロジックを持っています。</p>
<p>：class： <cite>.Connection`がDBAPI接続を使用しようとし、&amp;quot; disconnect &amp;quot;イベントに対応する例外が発生すると、接続は無効になります。 ：class： `.Connection`は：meth：</cite> .Pool.recreate`メソッドを呼び出し、現在チェックアウトされていないすべてのコネクションを効果的に無効にして、次のチェックアウト時に新しいコネクションに置き換えます。このフローは、次のコード例で説明されています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">exc</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># suppose the database has been restarted.</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM table&quot;</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">DBAPIError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="c1"># an exception is raised, Connection is invalidated.</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">connection_invalidated</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection was invalidated!&quot;</span><span class="p">)</span>

<span class="c1"># after the invalidate event, a new connection</span>
<span class="c1"># starts with a new Pool</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM table&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記の例は、切断イベントが検出された後も正常に続行する、プールをリフレッシュするための特別な介入は必要ないことを示しています。ただし、データベース使用不能イベントが発生している間に使用されている各接続ごとに1つのデータベース例外が発生します。 ORMセッションを使用する一般的なWebアプリケーションでは、上記の条件は1つのリクエストが500エラーで失敗した場合に対応し、Webアプリケーションはそれを超えて通常通り続きます。したがって、頻繁なデータベースの再起動が予期されない点で、アプローチは「楽観的」である。</p>
<div class="section" id="setting-pool-recycle">
<span id="pool-setting-recycle"></span><h4>プールリサイクルの設定<a class="headerlink" href="#setting-pool-recycle" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>&amp;quot;楽観的な&amp;quot;アプローチを補うことができる追加の設定は、プールリサイクルパラメータを設定することです。このパラメータは、プールが特定の経過時間を経過した特定の接続を使用できないようにします。MySQLなどのデータベースバックエンドに適しており、特定の期間の経過後に自動的に接続を切断します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql://scott:tiger@localhost/test&quot;</span><span class="p">,</span> <span class="n">pool_recycle</span><span class="o">=</span><span class="mi">3600</span><span class="p">)</span></pre></div>
</div>
<p>上記の場合、1時間以上開いているDBAPI接続は、次のチェックアウト時に無効になり、置き換えられます。無効化**のみがチェックアウト中に発生することに注意してください。チェックアウト状態に保持されている接続ではありません。 `` pool_recycle``は：class： <cite>.Engine`が使用されているかどうかに関係なく、：class：</cite> .Pool`自体の関数です。</p>
</div>
</div>
<div class="section" id="more-on-invalidation">
<span id="pool-connection-invalidation"></span><h3>失効の詳細<a class="headerlink" href="#more-on-invalidation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`は、接続の明示的な無効化と、接続を使用不可能にすると判断される条件に応じた自動無効化の両方を可能にする&amp;quot;接続無効化&amp;quot;サービスを提供します。</p>
<p>&amp;quot;無効化&amp;quot;は、特定のDBAPI接続がプールから削除され、破棄されることを意味します。 `` .close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドは、接続自体が閉じられないことが明らかでない場合にこの接続で呼び出されますが、このメソッドが失敗すると、例外はログに記録されますが、操作は引き続き進行します。</p>
<p>：class： <cite>.Engine`を使用する場合、：meth：</cite> .Connection.invalidate`メソッドは、明示的な無効化の通常のエントリポイントです。 DBAPI接続が無効になるその他の条件は次のとおりです。</p>
<ul class="simple">
<li>`` connection.execute（） <a href="#id1"><span class="problematic" id="id2">``</span></a>のようなメソッドが呼び出されたときに発生するclass： <cite>.OperationalError`のようなDBAPI例外は、いわゆる&amp;quot;切断 &amp;quot;状態を示すものとして検出されます。 Python DBAPIは例外の性質を判断するための標準システムを提供していないので、すべてのSQLAlchemy方言には、文字列メッセージと潜在的なエラーコードを含む例外オブジェクトの内容を調べる `</cite> is_disconnect（） <a href="#id3"><span class="problematic" id="id4">``</span></a>システムが含まれていますこの例外が接続がもはや使用不能であることを示すかどうかを判断するために使用します。この場合、：meth： <a href="#id5"><span class="problematic" id="id6">`</span></a>._ConnectionFairy.invalidate`メソッドが呼び出され、DBAPI接続が破棄されます。</li>
<li>接続がプールに返され、プールの&amp;quot;reset on return &amp;quot;の動作によって指定された `` connection.rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>または `` connection.commit（） <a href="#id3"><span class="problematic" id="id4">``</span></a>メソッドを呼び出すと、例外がスローされます。接続時に `` .close（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を呼び出す最後の試みが行われ、それが破棄されます。</li>
<li>：meth： <cite>.PoolEvents.checkout`を実装しているリスナーが：class：</cite>〜sqlalchemy.exc.DisconnectionError`例外を送出すると、接続が使用できなくなり、新しい接続を試みる必要があることを示します。</li>
</ul>
<p>発生するすべての無効化は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.PoolEvents.invalidate`イベントを呼び出します。</p>
</div>
</div>
<div class="section" id="using-fifo-vs-lifo">
<span id="pool-use-lifo"></span><h2>FIFOとLIFOの使用<a class="headerlink" href="#using-fifo-vs-lifo" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <cite>.QueuePool`クラスには、paramref：</cite> .QueuePool.use_lifo`というフラグがあります。これは、：paramref： <cite>.create_engine.pool_use_lifo`を介して：func：</cite> .create_engine`からアクセスすることもできます。このフラグを `` True``に設定すると、プールの&amp;quot;queue &amp;quot;振る舞いは&amp;quot;stack &amp;quot;の振る舞いになります。例えば、プールに返される最後の接続は、要求。プール内の各接続を直列に使用するラウンドロビン効果を生み出す先入れ先出し方式のプールの長年の動作とは対照的に、ライフモードでは余分な接続がプール内でアイドル状態を維持できるため、これらの接続を閉じるために、サイドタイムアウトスキームを使用します。 FIFOとLIFOの違いは、基本的に、プールがアイドル期間中でも実行できるようにフルセットの接続を維持することが望ましいかどうかです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span>
    <span class="s2">&quot;postgreql://&quot;</span><span class="p">,</span> <span class="n">pool_use_lifo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pool_pre_ping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>上記では、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine.pool_pre_ping`フラグを使用して、サーバー側からクローズされた接続が接続プールによって正常に処理され、新しい接続で置き換えられるようにします。</p>
<p>このフラグはclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.QueuePool`のみに適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.3 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pool_disconnects</cite></p>
</div>
</div>
<div class="section" id="using-connection-pools-with-multiprocessing">
<h2>マルチプロセッシングでの接続プールの使用<a class="headerlink" href="#using-connection-pools-with-multiprocessing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>接続プールを使用し、拡張子で：：class： <cite>.Engine`を使用して：func：</cite> .create_engine`を使用して作成した場合、プールされた接続**はフォークされたプロセス**と共有されません。 TCP接続は、通常はプロセスの境界を越えて動作するファイルディスクリプタとして表されます。これは、2つ以上の完全に独立したPythonインタープリタの状態のためにファイルディスクリプタに同時にアクセスすることを意味します。</p>
<p>これに対処するには2つの方法があります。</p>
<p>最初は、子プロセス内で新しい：class： <cite>.Engine`を作成するか、既存の：class：</cite> .Engine`の上で子プロセスが接続を使用する前に：meth： <cite>.Engine.dispose`を呼び出します。これにより、既存の接続がプールからすべて削除され、新しい接続がすべて作成されます。以下は `</cite> multiprocessing.Process``を使った単純なバージョンですが、このアイデアは使用中のフォークのスタイルに適合させるべきです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run_in_process</span><span class="p">():</span>
  <span class="n">eng</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>

  <span class="k">with</span> <span class="n">eng</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
      <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_in_process</span><span class="p">)</span></pre></div>
</div>
<p>次のアプローチは、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`自体にイベントを設定して、接続がサブプロセスで自動的に無効になるようにすることです。これはもう少し魔法ですが、恐らくもっと簡単です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">exc</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">eng</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;connect&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">):</span>
    <span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;checkout&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">checkout</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">,</span> <span class="n">connection_proxy</span><span class="p">):</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">:</span>
        <span class="n">connection_record</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection_proxy</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">DisconnectionError</span><span class="p">(</span>
                <span class="s2">&quot;Connection record belongs to pid </span><span class="si">%s</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;attempting to check out in pid </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">],</span> <span class="n">pid</span><span class="p">)</span>
        <span class="p">)</span></pre></div>
</div>
<p>上記では、異なる親プロセスで発生したDBAPI接続を&amp;quot;無効な&amp;quot;接続として扱うために、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>pool_disconnects_pessimistic`に記述されているのと同様の方法を使用して、プールを強制して接続レコードをリサイクルして、接続。</p>
</div>
<div class="section" id="api-documentation-available-pool-implementations">
<h2>APIドキュメント - 使用可能なプールの実装<a class="headerlink" href="#api-documentation-available-pool-implementations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.pool.Pool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">Pool</code><span class="sig-paren">(</span><em>creator</em>, <em>recycle=-1</em>, <em>echo=None</em>, <em>use_threadlocal=False</em>, <em>logging_name=None</em>, <em>reset_on_return=True</em>, <em>listeners=None</em>, <em>events=None</em>, <em>dialect=None</em>, <em>pre_ping=False</em>, <em>_dispatch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="internals.html#sqlalchemy.log.Identified" title="sqlalchemy.log.Identified"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.log.Identified</span></code></a></p>
<p>接続プールの抽象基本クラス。</p>
<dl class="method">
<dt id="sqlalchemy.pool.Pool.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>creator</em>, <em>recycle=-1</em>, <em>echo=None</em>, <em>use_threadlocal=False</em>, <em>logging_name=None</em>, <em>reset_on_return=True</em>, <em>listeners=None</em>, <em>events=None</em>, <em>dialect=None</em>, <em>pre_ping=False</em>, <em>_dispatch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プールを構築する。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.pool.Pool.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.creator">¶</a> -- DB-API接続オブジェクトを返す呼び出し可能な関数。関数はパラメータとともに呼び出されます。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.recycle"></span><strong>recycle</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.recycle">¶</a> -- 非-1に設定すると、接続リサイクルの間の秒数、チェックアウト時に、このタイムアウトを超えると接続が閉じられ、新しく開かれた接続に置き換えられます。デフォルトは-1です。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.logging_name"></span><strong>logging_name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.logging_name">¶</a> -- &amp;quot;sqlalchemy.pool &amp;quot;ロガー内で生成されたロギングレコードの&amp;quot;name &amp;quot;フィールド内で使用される文字列識別子。デフォルトではオブジェクトのIDの16進文字列になります。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.echo"></span><strong>echo</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.echo">¶</a> -- Trueの場合、プールから引き出され、プールから取得された接続は、プールサイズ情報と同様に標準出力に記録されます。エコー処理は、&amp;quot;sqlalchemy.pool &amp;quot;名前空間のロギングを有効にすることでも実現できます。デフォルトはFalseです。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.use_threadlocal"></span><strong>use_threadlocal</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.use_threadlocal">¶</a> -- Trueに設定されている場合、同じアプリケーションスレッド内で：meth： <cite>connect`を繰り返し呼び出すと、同じ接続オブジェクトがプールからすでに取得され、まだ返されていない場合に返されます。デフォルトで個々のトランザクションを犠牲にしてわずかなパフォーマンス上の利点を提供します。 ：meth： `.Pool.unique_connection`メソッドは、フラグが設定されているときに、この動作を回避するための一貫性のある一意の接続を返すために提供されています。 ..警告::：paramref： `.Pool.use_threadlocal`フラグ**は、：meth：</cite> .Engine.connect`の動作**に影響しません。 ：meth： <cite>.Engine.connect`はスレッドローカルコンテキスト**を使わない：meth：</cite> .Pool.unique_connection`メソッドを使います。 ：meth： <cite>.Pool.connect`メソッドを参照する：class：</cite> .Connection`を生成するには、：meth： <cite>.Engine.contextual_connect`を使います。 ：meth： `.Engine.execute`やorm：class：</cite> .Session`などの他のSQLAlchemy接続システムは：meth： <cite>.Engine.contextual_connect`を内部的に使用しているので、これらの関数は：paramref： `.Pool.use_threadlocal`の設定です。 .. seealso :: ref： `threadlocal_strategy</cite>  -  &amp;quot; threadlocal &amp;quot;エンジン戦略の詳細を含んでいます：class：` .Engine <cite>：and：class：</cite> .Connection`オブジェクトを直接呼び出します。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.reset_on_return"></span><strong>reset_on_return</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.reset_on_return">¶</a> -- 接続がプールに返されるときに、接続にかかる手順を決定します。 reset_on_returnには、次のいずれかの値を指定できます。* `` &amp;quot;rollback &amp;quot; ``  - 接続上でrollback（）を呼び出し、ロックとトランザクションリソースを解放します。これがデフォルト値です。大部分のユースケースでは、この値を設定したままにする必要があります。 * `` True``  -  &amp;#39;rollback&amp;#39;と同じですが、下位互換性のためにここにあります。 * `` &amp;quot;commit &amp;quot; ``  - 接続上でcommit（）を呼び出し、ロックとトランザクションリソースを解放します。ここでのコミットは、Microsoft SQL Serverなど、コミットが発行された場合にクエリプランをキャッシュするデータベースにとって望ましい場合があります。ただし、トランザクションに存在するデータ変更が無条件にコミットされるため、この値は「ロールバック」よりも危険です。 * `` None``  - 接続時に何もしません。この設定は、通常、トランザクションのサポートがまったくないデータベース、つまりMySQL MyISAMでのみ行われます。このバックエンドで使用すると、&amp;quot;ロールバック&amp;quot;呼び出しがMySQLでまだ高価であるため、パフォーマンスを向上させることができます。 <a href="#id1"><span class="problematic" id="id2">**</span></a>強くお勧めします**この設定は、class： <cite>.QueuePool`のような永続的なプールと一緒にトランザクションをサポートしているデータベースには使用しないでください。プール。この設定は、class： `.NullPool`の場合、または使用中の接続プールが接続ライフサイクルを維持するために使用されていない特別な状況の場合に適切です。 * `</cite> False``  -  Noneと同じですが、下位互換性のためにここにあります。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.events"></span><strong>events</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.events">¶</a> -- 構築時に：func： <cite>.event.listen`に渡される</cite> <cite>（callable、target）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>の2つのタプルのリストです。ダイアグラムレベルのリスナーが適用される前に：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.create_engine`によってイベントリスナーを割り当てることができるように、ここで提供されています。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.listeners"></span><strong>listeners</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.listeners">¶</a> -- 推奨されていません。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.interfaces.PoolListener`のようなオブジェクトや、DB-API接続が作成されたときにイベントを受け取り、プールにチェックインしてチェックインしたコールバックの辞書。これは、func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.event.listen`に取って代わられています。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.dialect">¶</a> -- DBAPI接続でrollback（）、close（）、またはcommit（）を呼び出す作業を処理する <cite>：class：</cite> .Dialect`を使用します。省略すると、組み込みの&amp;quot;スタブ&amp;quot;の方言が使われます。 ：func： <cite>〜.create_engine`を使用するアプリケーションは、エンジン作成戦略によって処理されるので、このパラメータを使用しないでください。 .. versionadded :: 1.1  -  `</cite> dialect``は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`のパブリックパラメータになりました。</li>
<li><span class="target" id="sqlalchemy.pool.Pool.params.pre_ping"></span><strong>pre_ping</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.Pool.params.pre_ping">¶</a> -- Trueの場合、プールはチェックアウト時に接続上に&amp;quot;ping &amp;quot;（通常は&amp;quot;SELECT 1 &amp;quot;、dialect特有です）を出して、接続が生きているかどうかをテストします。そうでない場合、接続は透過的に再接続され、成功すると、そのタイムスタンプより前に確立された他のすべてのプールされた接続は無効になります。切断エラーを解釈するためにダイアレクトも渡される必要があります。 .. versionadded :: 1.2</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.Pool.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プールからDBAPI接続を返します。</p>
<p>接続は、 `` close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドが呼び出されたときに接続がプールに返されるようにインストルメントされています。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.Pool.dispose">
<code class="descname">dispose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool.dispose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このプールを廃棄してください。</p>
<p>この方法では、プール内でアイドル状態の接続にのみ影響するため、チェックアウトされた接続が開いたままになる可能性があります。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>Pool.recreate`メソッドも参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.Pool.recreate">
<code class="descname">recreate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool.recreate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスと同じクラスの新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`を返し、同じ作成引数で設定します。</p>
<p>このメソッドは、：meth： <cite>dispose`と一緒に使用されて：class：</cite> .Pool`全体を閉じ、その場所に新しいものを作成します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.Pool.unique_connection">
<code class="descname">unique_connection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.Pool.unique_connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意のスレッドローカルコンテキストによって参照されないDBAPI接続を生成します。</p>
<p>このメソッドは、：paramref： <cite>.Pool.use_threadlocal`フラグがTrueに設定されていない場合、：meth：</cite> .Pool.connect`と同じです。 ：paramref： <cite>.Pool.use_threadlocal`がTrueの場合、：meth：</cite> .Pool.unique_connection`メソッドはスレッドローカルコンテキストをバイパスする手段を提供します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool.QueuePool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">QueuePool</code><span class="sig-paren">(</span><em>creator</em>, <em>pool_size=5</em>, <em>max_overflow=10</em>, <em>timeout=30</em>, <em>use_lifo=False</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.QueuePool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.pool.base.Pool</span></code></p>
<p>A：class：開いている接続の数に制限を課す <cite>.Pool</cite>。</p>
<p>：class： <cite>.QueuePool`は、SQLiteの方言が使われていない限り、all：class：</cite> .Engine`オブジェクトに使われるデフォルトのプール実装です。</p>
<dl class="method">
<dt id="sqlalchemy.pool.QueuePool.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>creator</em>, <em>pool_size=5</em>, <em>max_overflow=10</em>, <em>timeout=30</em>, <em>use_lifo=False</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.QueuePool.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>QueuePoolを構築します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.creator">¶</a> -- ：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool.creator`と同じDB-API接続オブジェクトを返す呼び出し可能な関数です。</li>
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.pool_size"></span><strong>pool_size</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.pool_size">¶</a> -- 保持するプールのサイズ（デフォルトは5）。これは、プール内で永続的に保持される接続の最大数です。プールは接続なしで開始されます。この数の接続が要求されると、その数の接続が残ります。 `` pool_size``はサイズ制限がないことを示すために0に設定できます。プーリングを無効にするには、代わりに：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.pool.NullPool`を使用してください。</li>
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.max_overflow"></span><strong>max_overflow</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.max_overflow">¶</a> -- プールの最大オーバーフローサイズ。チェックアウトされた接続の数がpool_sizeに設定されたサイズに達すると、追加の接続がこの制限まで返されます。これらの追加の接続がプールに戻されると、接続が切断されて破棄されます。プールが許可する同時接続の総数はpool_size + <a href="#id1"><span class="problematic" id="id2">`</span></a>max_overflow`であり、プールが許可するスリープ接続の総数はpool_sizeであり、max_overflow`は-1を指定してnoオーバーフロー制限であり、同時接続の合計数に制限はありません。デフォルトは10です。</li>
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.timeout"></span><strong>timeout</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.timeout">¶</a> -- 接続を返すときに諦めるまで待機する秒数。デフォルトは30です。</li>
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.use_lifo"></span><strong>use_lifo</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.use_lifo">¶</a> -- FIFO（先入れ先出し）の代わりに接続を取り出すときは、LIFO（ラスト・イン・ファースト・アウト）を使用します。 LIFOを使用すると、サーバー側のタイムアウトスキームは、ピーク時以外に使用される接続の数を減らすことができます。サーバー側のタイムアウトを計画するときは、古くなった接続を正常に処理するためにリサイクルまたはプレping戦略が使用されていることを確認してください。 .. versionadded :: 1.3 .. seealso :: ref： <cite>pool_use_lifo</cite>：ref：` pool_disconnects`</li>
<li><span class="target" id="sqlalchemy.pool.QueuePool.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.QueuePool.params.**kw">¶</a> -- 他のキーワード引数：paramref： <cite>.Pool.recycle</cite>、：paramref：` .Pool.echo`、：paramref： <cite>.Pool.reset_on_return`などは、：class：</cite> .Pool`コンストラクタに渡されます。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.QueuePool.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.QueuePool.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> <em>method of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></div>
<p>プールからDBAPI接続を返します。</p>
<p>接続は、 `` close（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドが呼び出されたときに接続がプールに返されるようにインストルメントされています。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool.QueuePool.unique_connection">
<code class="descname">unique_connection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.QueuePool.unique_connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-meth docutils literal notranslate"><span class="pre">unique_connection()</span></code> <em>method of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></div>
<p>任意のスレッドローカルコンテキストによって参照されないDBAPI接続を生成します。</p>
<p>このメソッドは、：paramref： <cite>.Pool.use_threadlocal`フラグがTrueに設定されていない場合、：meth：</cite> .Pool.connect`と同じです。 ：paramref： <cite>.Pool.use_threadlocal`がTrueの場合、：meth：</cite> .Pool.unique_connection`メソッドはスレッドローカルコンテキストをバイパスする手段を提供します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool.SingletonThreadPool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">SingletonThreadPool</code><span class="sig-paren">(</span><em>creator</em>, <em>pool_size=5</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.SingletonThreadPool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.pool.base.Pool</span></code></p>
<p>スレッドごとに1つの接続を維持するプール。</p>
<p>各スレッドごとに1つの接続を維持し、作成されたスレッド以外のスレッドへの接続を決して移動しません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>：class： <cite>.SingletonThreadPool`は、</cite> <cite>pool_size`のサイズ設定を超えて存在する任意の接続で</cite> <cite>.close（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>を呼び出します。 <a href="#id3"><span class="problematic" id="id4">`</span></a>状態が使用されます。このクリーンアップは非決定的であり、それらのスレッドIDにリンクされている接続が現在使用されているかどうかには影響を受けません。</p>
<p class="last">：class： <cite>.SingletonThreadPool`は将来のリリースで改善されるかもしれませんが、現在のところ、SQLiteの</cite>：memory： <a href="#id1"><span class="problematic" id="id2">``</span></a>データベースを使ったテストシナリオでのみ使用され、プロダクションでの使用はお勧めしません。</p>
</div>
<p>オプションは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`のオプションと同じです：</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.pool_size"></span><strong>pool_size</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.pool_size">¶</a> -- 一度に接続を維持するスレッドの数。デフォルトは5です。</td>
</tr>
</tbody>
</table>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SingletonThreadPool`は、メモリベースのデータベースが使用されているときに自動的にSQLiteの方言によって使用されます。参照：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>sqlite_toplevel`を参照してください。</p>
<dl class="method">
<dt id="sqlalchemy.pool.SingletonThreadPool.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>creator</em>, <em>pool_size=5</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.SingletonThreadPool.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プールを構築する。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.creator">¶</a> -- DB-API接続オブジェクトを返す呼び出し可能な関数。関数はパラメータとともに呼び出されます。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.recycle"></span><strong>recycle</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.recycle">¶</a> -- 非-1に設定すると、接続リサイクルの間の秒数、チェックアウト時に、このタイムアウトを超えると接続が閉じられ、新しく開かれた接続に置き換えられます。デフォルトは-1です。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.logging_name"></span><strong>logging_name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.logging_name">¶</a> -- &amp;quot;sqlalchemy.pool &amp;quot;ロガー内で生成されたロギングレコードの&amp;quot;name &amp;quot;フィールド内で使用される文字列識別子。デフォルトではオブジェクトのIDの16進文字列になります。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.echo"></span><strong>echo</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.echo">¶</a> -- Trueの場合、プールから引き出され、プールから取得された接続は、プールサイズ情報と同様に標準出力に記録されます。エコー処理は、&amp;quot;sqlalchemy.pool &amp;quot;名前空間のロギングを有効にすることでも実現できます。デフォルトはFalseです。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.use_threadlocal"></span><strong>use_threadlocal</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.use_threadlocal">¶</a> -- Trueに設定されている場合、同じアプリケーションスレッド内で：meth： <cite>connect`を繰り返し呼び出すと、同じ接続オブジェクトがプールからすでに取得され、まだ返されていない場合に返されます。デフォルトで個々のトランザクションを犠牲にしてわずかなパフォーマンス上の利点を提供します。 ：meth： `.Pool.unique_connection`メソッドは、フラグが設定されているときに、この動作を回避するための一貫性のある一意の接続を返すために提供されています。 ..警告::：paramref： `.Pool.use_threadlocal`フラグ**は、：meth：</cite> .Engine.connect`の動作**に影響しません。 ：meth： <cite>.Engine.connect`はスレッドローカルコンテキスト**を使わない：meth：</cite> .Pool.unique_connection`メソッドを使います。 ：meth： <cite>.Pool.connect`メソッドを参照する：class：</cite> .Connection`を生成するには、：meth： <cite>.Engine.contextual_connect`を使います。 ：meth： `.Engine.execute`やorm：class：</cite> .Session`などの他のSQLAlchemy接続システムは：meth： <cite>.Engine.contextual_connect`を内部的に使用しているので、これらの関数は：paramref： `.Pool.use_threadlocal`の設定です。 .. seealso :: ref： `threadlocal_strategy</cite>  -  &amp;quot; threadlocal &amp;quot;エンジン戦略の詳細を含んでいます：class：` .Engine <cite>：and：class：</cite> .Connection`オブジェクトを直接呼び出します。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.reset_on_return"></span><strong>reset_on_return</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.reset_on_return">¶</a> -- 接続がプールに返されるときに、接続にかかる手順を決定します。 reset_on_returnには、次のいずれかの値を指定できます。* `` &amp;quot;rollback &amp;quot; ``  - 接続上でrollback（）を呼び出し、ロックとトランザクションリソースを解放します。これがデフォルト値です。大部分のユースケースでは、この値を設定したままにする必要があります。 * `` True``  -  &amp;#39;rollback&amp;#39;と同じですが、下位互換性のためにここにあります。 * `` &amp;quot;commit &amp;quot; ``  - 接続上でcommit（）を呼び出し、ロックとトランザクションリソースを解放します。ここでのコミットは、Microsoft SQL Serverなど、コミットが発行された場合にクエリプランをキャッシュするデータベースにとって望ましい場合があります。ただし、トランザクションに存在するデータ変更が無条件にコミットされるため、この値は「ロールバック」よりも危険です。 * `` None``  - 接続時に何もしません。この設定は、通常、トランザクションのサポートがまったくないデータベース、つまりMySQL MyISAMでのみ行われます。このバックエンドで使用すると、&amp;quot;ロールバック&amp;quot;呼び出しがMySQLでまだ高価であるため、パフォーマンスを向上させることができます。 <a href="#id1"><span class="problematic" id="id2">**</span></a>強くお勧めします**この設定は、class： <cite>.QueuePool`のような永続的なプールと一緒にトランザクションをサポートしているデータベースには使用しないでください。プール。この設定は、class： `.NullPool`の場合、または使用中の接続プールが接続ライフサイクルを維持するために使用されていない特別な状況の場合に適切です。 * `</cite> False``  -  Noneと同じですが、下位互換性のためにここにあります。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.events"></span><strong>events</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.events">¶</a> -- 構築時に：func： <cite>.event.listen`に渡される</cite> <cite>（callable、target）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>の2つのタプルのリストです。ダイアグラムレベルのリスナーが適用される前に：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.create_engine`によってイベントリスナーを割り当てることができるように、ここで提供されています。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.listeners"></span><strong>listeners</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.listeners">¶</a> -- 推奨されていません。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.interfaces.PoolListener`のようなオブジェクトや、DB-API接続が作成されたときにイベントを受け取り、プールにチェックインしてチェックインしたコールバックの辞書。これは、func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.event.listen`に取って代わられています。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.dialect"></span><strong>dialect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.dialect">¶</a> -- DBAPI接続でrollback（）、close（）、またはcommit（）を呼び出す作業を処理する <cite>：class：</cite> .Dialect`を使用します。省略すると、組み込みの&amp;quot;スタブ&amp;quot;の方言が使われます。 ：func： <cite>〜.create_engine`を使用するアプリケーションは、エンジン作成戦略によって処理されるので、このパラメータを使用しないでください。 .. versionadded :: 1.1  -  `</cite> dialect``は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`のパブリックパラメータになりました。</li>
<li><span class="target" id="sqlalchemy.pool.SingletonThreadPool.params.pre_ping"></span><strong>pre_ping</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool.SingletonThreadPool.params.pre_ping">¶</a> -- Trueの場合、プールはチェックアウト時に接続上に&amp;quot;ping &amp;quot;（通常は&amp;quot;SELECT 1 &amp;quot;、dialect特有です）を出して、接続が生きているかどうかをテストします。そうでない場合、接続は透過的に再接続され、成功すると、そのタイムスタンプより前に確立された他のすべてのプールされた接続は無効になります。切断エラーを解釈するためにダイアレクトも渡される必要があります。 .. versionadded :: 1.2</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool.AssertionPool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">AssertionPool</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.AssertionPool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.pool.base.Pool</span></code></p>
<p>A：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`は、任意の与えられた時間に最大で1つのチェックアウトされた接続を可能にします。</p>
<p>一度に複数の接続がチェックアウトされた場合、例外が発生します。必要以上の接続を使用しているコードをデバッグするのに便利です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AssertionPool`は、元の接続がチェックアウトされた場所のトレースバックも記録し、発生したアサーションエラーでこれを報告します。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool.NullPool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">NullPool</code><span class="sig-paren">(</span><em>creator</em>, <em>recycle=-1</em>, <em>echo=None</em>, <em>use_threadlocal=False</em>, <em>logging_name=None</em>, <em>reset_on_return=True</em>, <em>listeners=None</em>, <em>events=None</em>, <em>dialect=None</em>, <em>pre_ping=False</em>, <em>_dispatch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.NullPool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.pool.base.Pool</span></code></p>
<p>接続をプールしないプール。</p>
<p>その代わりに、文字通りオープン/クローズされた各接続ごとの基礎となるDB-API接続をオープンおよびクローズします。</p>
<p>永続的に保持される接続がないため、このプール実装では、「リサイクル」や接続無効化などの再接続関連の機能はサポートされていません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.NullPool`は、ファイルベースのデータベースが使われるときに自動的にSQliteの方言によって使われます。参照：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>sqlite_toplevel`を参照してください。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool.StaticPool">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">StaticPool</code><span class="sig-paren">(</span><em>creator</em>, <em>recycle=-1</em>, <em>echo=None</em>, <em>use_threadlocal=False</em>, <em>logging_name=None</em>, <em>reset_on_return=True</em>, <em>listeners=None</em>, <em>events=None</em>, <em>dialect=None</em>, <em>pre_ping=False</em>, <em>_dispatch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool.StaticPool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.pool.base.Pool</span></code></p>
<p>完全に1つの接続のプール。すべての要求に使用されます。</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>リサイクル &amp;#39;や接続無効化（自動再接続をサポートするためにも使用される）などの再接続関連の機能は、このプール実装では現在サポートされていませんが、将来のリリースで実装される可能性があります。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool._ConnectionFairy">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">_ConnectionFairy</code><span class="sig-paren">(</span><em>dbapi_connection</em>, <em>connection_record</em>, <em>echo</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPI接続をプロキシし、逆参照時リターンをサポートします。</p>
<p>これは：class： <cite>.Pool`実装によって使用される内部オブジェクトで、class：</cite> .Pool`によって提供されるDBAPI接続にコンテキスト管理を提供します。</p>
<p>&amp;quot;fairy &amp;quot;という名前は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>._ConnectionFairy`オブジェクトの存続期間が一時的であるという事実からインスピレーションを受けています。これは、プールからチェックアウトされている特定のDBAPI接続の長さだけ持続します。透明なプロキシは、ほとんど目に見えません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：クラス： <cite>._ConnectionRecord</cite></p>
</div>
<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionFairy._connection_record">
<code class="descname">_connection_record</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy._connection_record" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPI接続に関連付けられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>._ConnectionRecord`オブジェクトへの参照です。</p>
<p>これは現在、変更される可能性のある内部アクセサーです。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionFairy.connection">
<code class="descname">connection</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>追跡中の実際のDBAPI接続への参照。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool._ConnectionFairy.cursor">
<code class="descname">cursor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.cursor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>基になる接続の新しいDBAPIカーソルを返します。</p>
<p>このメソッドは、 `` connection.cursor（） `` DBAPIメソッドのプロキシです。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool._ConnectionFairy.detach">
<code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.detach" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この接続をプールから切り離します。</p>
<p>これは、接続が閉じられたときにプールに返されなくなり、代わりに文字通り閉じられることを意味します。含まれているConnectionRecordは、DB-API接続から分離され、次に使用するときに新しい接続を作成します。</p>
<p>分離された接続がプールの知識と制御から削除されるため、Pool実装によって課せられた全体的な接続制限制約は、分離後に違反する可能性があることに注意してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionFairy.info">
<code class="descname">info</code><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ConnectionFairy`によって参照される基礎となるDBAPI接続に関連付けられた情報辞書。ユーザー定義のデータを接続に関連付けることができます。</p>
<p>ここでのデータは、接続プールに戻された後のものも含めてDBAPI接続に沿って続き、後続の：class： <cite>._ConnectionFairy`のインスタンスで再び使用されます。それは：attr： `._ConnectionRecord.info`と：attr：</cite> .Connection.info`アクセサで共有されます。</p>
<p>特定のDBAPI接続に関連付けられているディクショナリは、接続自体が破棄されると破棄されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool._ConnectionFairy.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><em>e=None</em>, <em>soft=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.invalidate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この接続を無効にします。</p>
<p>このメソッドは直接呼び出すことができ、また：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.invalidate`メソッドの結果として呼び出されます。呼び出されると、DBAPI接続は直ちにクローズされ、プールによってそれ以上使用されなくなると破棄されます。無効化のメカニズムは：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>._ConnectionRecord.invalidate`内部メソッドを介して行われます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.pool._ConnectionFairy.invalidate.params.e"></span><strong>e</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool._ConnectionFairy.invalidate.params.e">¶</a> -- 無効化の理由を示す例外オブジェクト。</li>
<li><span class="target" id="sqlalchemy.pool._ConnectionFairy.invalidate.params.soft"></span><strong>soft</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool._ConnectionFairy.invalidate.params.soft">¶</a> -- Trueの場合、接続は閉じられません。代わりに、この接続は次のチェックアウト時にリサイクルされます。 .. versionadded :: 1.0.3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pool_connection_invalidation</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionFairy.is_valid">
<code class="descname">is_valid</code><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.is_valid" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>._ConnectionFairy`がまだアクティブなDBAPI接続を参照していればTrueを返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionFairy.record_info">
<code class="descname">record_info</code><a class="headerlink" href="#sqlalchemy.pool._ConnectionFairy.record_info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <cite>.ConnectionFairy`によって参照される：class：</cite> ._ConnectionRecordコンテナに関連付けられた情報辞書。</p>
<p>：attr： <cite>._ConnectionFairy.info`ディクショナリーとは異なり、この辞書の有効期間は、：class：</cite> ._ConnectionRecord`の有効期間内に切断されたり、無効にされたりする接続全体で永続的です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.pool._ConnectionRecord">
<em class="property">class </em><code class="descclassname">sqlalchemy.pool.</code><code class="descname">_ConnectionRecord</code><span class="sig-paren">(</span><em>pool</em>, <em>connect=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Pool`によって参照される個々のDBAPI接続を維持する内部オブジェクトです。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>._ConnectionRecord`オブジェクトは、そのDBAPI接続がチェックアウトされているかどうかに関係なく、常に特定のDBAPI接続に存在します。これは：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>._ConnectionFairy`とは対照的です。これはチェックアウトされている間にDBAPI接続へのパブリックファサードだけです。</p>
<p>A：class： <cite>._ConnectionRecord`は単一のDBAPI接続より長いスパンに対して存在する可能性があります。たとえば、：meth： `._ConnectionRecord.invalidate`メソッドが呼び出された場合、この：class：</cite> ._ConnectionRecord`に関連付けられたDBAPI接続は破棄されますが、：class： <cite>._ConnectionRecord`を再び使用することができます。この場合、：class： `.Pool</cite> nextがこのレコードを使用すると、新しいDBAPI接続が生成されます。</p>
<p>：class： <cite>._ConnectionRecord`は、：meth：</cite> .PoolEvents.connect`と：meth： <cite>.PoolEvents.checkout`を含む接続プールイベントと共に提供されます：class：</cite> ._ConnectionRecord`はまだ内部オブジェクトのままですそのAPIと内部が変更される可能性があります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：クラス： <cite>._ConnectionFairy</cite></p>
</div>
<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionRecord.connection">
<code class="descname">connection</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.pool._ConnectionRecord.connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>追跡中の実際のDBAPI接続への参照。</p>
<p>class： <cite>._ConnectionRecord`が無効とマークされている場合は</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>None``となります。所有しているプールがこの：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>._ConnectionRecord`を呼び出して再接続すると、新しいDBAPI接続がそれを置き換える可能性があります。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionRecord.info">
<code class="descname">info</code><a class="headerlink" href="#sqlalchemy.pool._ConnectionRecord.info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DBAPI接続に関連付けられた `` .info``ディクショナリ。</p>
<p>この辞書は、：attr： <cite>._ConnectionFairy.info`と：attr：</cite> .Connection.info &amp;#39;アクセサで共有されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このディクショナリの有効期間はDBAPI接続自体にリンクされています。つまり、DBAPI接続がクローズまたは無効になるたびに**破棄されます**。 ：attr： <cite>._ConnectionRecord.record_info`ディクショナリは：class：</cite> ._ConnectionRecord`コンテナの存続期間を通して永続的です。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.pool._ConnectionRecord.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><em>e=None</em>, <em>soft=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.pool._ConnectionRecord.invalidate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これによって保持されているDBAPI接続を無効にします：class： <cite>._ConnectionRecord</cite>。</p>
<p>このメソッドは、：meth： <cite>._ConnectionFairy.invalidate`メソッドまたは：meth：</cite> .Connection.invalidate`メソッドが呼び出されたときや、いわゆる「自動無効化」条件が呼び出されたときなど、すべての接続無効化に対して呼び出されます発生する。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.pool._ConnectionRecord.invalidate.params.e"></span><strong>e</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool._ConnectionRecord.invalidate.params.e">¶</a> -- 無効化の理由を示す例外オブジェクト。</li>
<li><span class="target" id="sqlalchemy.pool._ConnectionRecord.invalidate.params.soft"></span><strong>soft</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.pool._ConnectionRecord.invalidate.params.soft">¶</a> -- Trueの場合、接続は閉じられません。代わりに、この接続は次のチェックアウト時にリサイクルされます。 .. versionadded :: 1.0.3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pool_connection_invalidation</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.pool._ConnectionRecord.record_info">
<code class="descname">record_info</code><a class="headerlink" href="#sqlalchemy.pool._ConnectionRecord.record_info" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続レコード自体に関連付けられた&amp;quot;info&amp;quot;ディクショナリ。</p>
<p>DBAPI接続の寿命にリンクしている：attr： <cite>._ConnectionRecord.info`ディクショナリとは異なり、このディクショナリは：class：</cite> ._ConnectionRecord`コンテナ自体の寿命にリンクしており、 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>._ConnectionRecord`です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="connections.html" title="previous chapter">エンジンと接続の操作</a>
        Next:
        <a href="events.html" title="next chapter">コアイベント</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    セッション/クエリ
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="よくある質問" href="index.html" />
        <link rel="next" title="エラーメッセージ" href="../errors.html" />
        <link rel="prev" title="パフォーマンス" href="performance.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="よくある質問">よくある質問</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="connections.html">接続/エンジン</a></span></li>
<li><span class="link-container first"><a class="reference external" href="metadata_schema.html">メタデータ/スキーマ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="sqlexpressions.html">SQL式</a></span></li>
<li><span class="link-container first"><a class="reference external" href="ormconfiguration.html">ORM設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="performance.html">パフォーマンス</a></span></li>
<li class="selected"><span class="link-container first"><strong>セッション/クエリ</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere">セッションでデータを再ロードしていますが、他の場所でコミットした変更は表示されません</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar">&amp;quot;このセッションのトランザクションは、フラッシュ中の以前の例外のためにロールバックされました。</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#but-why-does-flush-insist-on-issuing-a-rollback">しかし、なぜflush（）はROLLBACKを発行することを主張しているのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again">しかし、なぜROLLBACKへの1回の自動呼び出しでは十分ではありませんか？なぜ私はもう一度ROLLBACKする必要がありますか？</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query">すべてのクエリに特定のフィルタを追加するクエリを作成するにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not">私はOuter Joinに対するマッピングを作成しましたが、クエリが行を返す間はオブジェクトは返されません。何故なの？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join">JOIN / OUTER JOINを作成するために `` joinedload（） ``や `` lazy = False``を使用しています.SQLAlchemyはWHERE、ORDER BY、LIMITなどを追加しようとすると正しいクエリを構築しません（OUTER）JOINに依存する）</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#query-has-no-len-why-not">クエリに `` __len __（） ``はありません。どうしてですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-use-textual-sql-with-orm-queries">ORMクエリでテキストSQLを使用するにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection">私は `` Session.delete（myobject） ``と呼びますが、親コレクションからは削除されません！</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#why-isn-t-my-init-called-when-i-load-objects">オブジェクトをロードするときに私の `` __init __（） ``が呼び出されないのはなぜですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm">SAのORMでON DELETE CASCADEを使用するにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7">私はインスタンスの&amp;quot;foo_id &amp;quot;属性を&amp;quot;7 &amp;quot;に設定しますが、&amp;quot;foo &amp;quot;属性は &amp;quot;` None``です -  Fooにid＃7をロードしてはいけませんか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-walk-all-objects-that-are-related-to-a-given-object">特定のオブジェクトに関連するすべてのオブジェクトをどのように歩くのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword">キーワードのクエリを実行せずに、そのキーワードを含む行への参照を取得せずに、一意のキーワード（または他の種類のオブジェクト）のみを自動的に持つ方法はありますか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#why-does-post-update-emit-update-in-addition-to-the-first-update">post_updateが最初のUPDATEに加えてUPDATEを発行するのはなぜですか？</a></span></li>
</ul>
</li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="sessions-queries">
<h1>セッション/クエリ<a class="headerlink" href="#sessions-queries" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents faq local topic" id="id1">
<ul class="simple">
<li><a class="reference internal" href="#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere" id="id2">セッションでデータを再ロードしていますが、他の場所でコミットした変更は表示されません</a></li>
<li><a class="reference internal" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar" id="id3">&amp;quot;このセッションのトランザクションは、フラッシュ中の以前の例外のためにロールバックされました。</a><ul>
<li><a class="reference internal" href="#but-why-does-flush-insist-on-issuing-a-rollback" id="id4">しかし、なぜflush（）はROLLBACKを発行することを主張しているのですか？</a></li>
<li><a class="reference internal" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again" id="id5">しかし、なぜROLLBACKへの1回の自動呼び出しでは十分ではありませんか？なぜ私はもう一度ROLLBACKする必要がありますか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query" id="id6">すべてのクエリに特定のフィルタを追加するクエリを作成するにはどうすればよいですか？</a></li>
<li><a class="reference internal" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not" id="id7">私はOuter Joinに対するマッピングを作成しましたが、クエリが行を返す間はオブジェクトは返されません。何故なの？</a></li>
<li><a class="reference internal" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join" id="id8">JOIN / OUTER JOINを作成するために `` joinedload（） ``や `` lazy = False``を使用しています.SQLAlchemyはWHERE、ORDER BY、LIMITなどを追加しようとすると正しいクエリを構築しません（OUTER）JOINに依存する）</a></li>
<li><a class="reference internal" href="#query-has-no-len-why-not" id="id9">クエリに `` __len __（） ``はありません。どうしてですか？</a></li>
<li><a class="reference internal" href="#how-do-i-use-textual-sql-with-orm-queries" id="id10">ORMクエリでテキストSQLを使用するにはどうすればよいですか？</a></li>
<li><a class="reference internal" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection" id="id11">私は `` Session.delete（myobject） ``と呼びますが、親コレクションからは削除されません！</a></li>
<li><a class="reference internal" href="#why-isn-t-my-init-called-when-i-load-objects" id="id12">オブジェクトをロードするときに私の `` __init __（） ``が呼び出されないのはなぜですか？</a></li>
<li><a class="reference internal" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm" id="id13">SAのORMでON DELETE CASCADEを使用するにはどうすればよいですか？</a></li>
<li><a class="reference internal" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7" id="id14">私はインスタンスの&amp;quot;foo_id &amp;quot;属性を&amp;quot;7 &amp;quot;に設定しますが、&amp;quot;foo &amp;quot;属性は &amp;quot;` None``です -  Fooにid＃7をロードしてはいけませんか？</a></li>
<li><a class="reference internal" href="#how-do-i-walk-all-objects-that-are-related-to-a-given-object" id="id15">特定のオブジェクトに関連するすべてのオブジェクトをどのように歩くのですか？</a></li>
<li><a class="reference internal" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword" id="id16">キーワードのクエリを実行せずに、そのキーワードを含む行への参照を取得せずに、一意のキーワード（または他の種類のオブジェクト）のみを自動的に持つ方法はありますか？</a></li>
<li><a class="reference internal" href="#why-does-post-update-emit-update-in-addition-to-the-first-update" id="id17">post_updateが最初のUPDATEに加えてUPDATEを発行するのはなぜですか？</a></li>
</ul>
</div>
<div class="section" id="i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere">
<h2>セッションでデータを再ロードしていますが、他の場所でコミットした変更は表示されません<a class="headerlink" href="#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この振る舞いに関する主な問題は、セッションが、トランザクションが*シリアライズ可能な*分離状態にあるかのように動作することです。現実的に言えば、セッションがトランザクションの範囲内で既に読み取られたデータを変更しないことを意味します。</p>
<p>「分離レベル」という用語が不慣れな場合は、まずこのリンクを読む必要があります。</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>分離レベル&lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29">https://en.wikipedia.org/wiki/Isolation_%28database_systems%29</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_</p>
<p>簡単に言えば、シリアライズ可能な分離レベルは、一般に、トランザクション内の一連の行を選択すると、そのSELECTを再発行するたびに同じデータ*を返すことを意味します。次の低い隔離レベルである &amp;quot;反復可能な読み取り&amp;quot;の場合は、新しく追加された行が表示されます（削除された行は表示されません）が、既にロードされている行については、変更を参照してください。 &amp;quot;read committed &amp;quot;のような低い隔離レベルにある場合にのみ、データの行がその値を変更するのを見ることが可能になります。</p>
<p>SQLAlchemy ORMを使用する際の分離レベルの制御については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_transaction_isolation`を参照してください。</p>
<p>劇的に物事を簡素化するために、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`自体は、完全に分離されたトランザクションの観点から動作し、あなたが指示しない限り、既に読み込まれているマップされた属性を上書きしません。すでに進行中のトランザクションで既にロードしたデータを再読み込みしようとするユースケースは、多くの場合効果がない*珍しい*ユースケースです。したがって、これは例外ではなくノルムです。この例外内で動作するには、進行中のトランザクションのコンテキスト内で特定のデータを再ロードできるようにするためのいくつかのメソッドが用意されています。</p>
<p>私たちが：class： <cite>.Session`について話すとき、&amp;quot;トランザクション&amp;quot;が意味することを理解するために、あなたの：class：</cite> .Session`はトランザクション内でのみ動作するようになっています。これの概要は：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>unitofwork_transaction`です。</p>
<p>分離レベルが何であるかを把握したら、分離レベルが十分低いレベルに設定されているので、行を再選択すると、新しいデータがクラス： <cite>.Session</cite> 、どうやって見ますか？</p>
<p>最も一般的なものから最も少ないものへの3つの方法：</p>
<ol class="arabic simple">
<li>私たちは単にトランザクションを終了し、次のアクセス時に：class： <cite>.Session`を呼び出して新しいものを開始します：meth：</cite> .Session.commit`（：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`がless- &amp;quot;autocommit &amp;quot;モードを使用すると、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session.begin`も呼び出されます）。アプリケーションやユースケースの大部分は、<a href="#id5"><span class="problematic" id="id6">**</span></a>短命トランザクションのベストプラクティスの中核であるこのパターンに固執しているため、他のトランザクションのデータを見ることができないという問題はありません* <a href="#id7"><span class="problematic" id="id8">*</span></a>。これに関するいくつかの考え方については：ref： <a href="#id9"><span class="problematic" id="id10">`</span></a>session_faq_whentocreate`を参照してください。</li>
<li>クラス： <cite>.Session`は、すでに読み込んだ行を：meth：</cite> .Session.expire_all`または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.expire`を使って次に問い合わせるときに読み込みます。クラス： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session.refresh`を使用してオブジェクト上で直ちに実行します。詳しくは：ref： <a href="#id5"><span class="problematic" id="id6">`</span></a>session_expire`を参照してください。</li>
<li>クエリー全体を実行することができます。クエリーは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.populate_existing`を使って行を読み込んだときにすでにロードされているオブジェクトを確実に上書きするように設定します。</li>
</ol>
<p>ただし、新しいトランザクション**を開始しない限り、ORMは分離レベルが再現可能な読取り以上であれば行の変更を認識できません**。</p>
</div>
<div class="section" id="this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar">
<h2>&amp;quot;このセッションのトランザクションは、フラッシュ中の以前の例外のためにロールバックされました。<a class="headerlink" href="#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これは、：meth： <cite>.Session.flush`が例外を発生させ、トランザクションをロールバックしますが、</cite> Session`のさらなるコマンドが：meth： <cite>.Session.rollback`を明示的に呼び出さずに呼び出されたときに発生するエラーです。または：meth： `.Session.close</cite>。</p>
<p>これは通常：meth： <cite>.Session.flush`または：meth：</cite> .Session.commit`に例外をキャッチし、例外を適切に処理しないアプリケーションに対応します。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">(</span><span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite://&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">()</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()()</span>

<span class="c1"># constraint violation</span>
<span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">([</span><span class="n">Foo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Foo</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># ignore error</span>
    <span class="k">pass</span>

<span class="c1"># continue using session without rolling back</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`の使い方は、次のような構造体に収まる必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">use</span> <span class="n">session</span><span class="o">&gt;</span>
    <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
   <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
   <span class="k">raise</span>
<span class="k">finally</span><span class="p">:</span>
   <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># optional, depends on use case</span></pre></div>
</div>
<p>多くのことが、フラッシュ以外にtry / except内で失敗を引き起こす可能性があります。接続とトランザクションのリソースが明確な境界を持つように、セッション操作には常に何らかの&amp;quot;フレーミング&amp;quot;があるべきです。そうでなければ、アプリケーションは制御下にあるリソースの使用を本当に持っていません。これは、あなたのアプリケーション全体にtry / exceptブロックを置く必要があると言っているのではなく、これはひどい考えです。セッション操作の周りに&amp;quot;フレーミング&amp;quot;が1つ（またはいくつか）あるようにアプリケーションを設計するべきです。</p>
<p>：class： <cite>.Session`の使い方を整理する方法の詳細については、ref：</cite> session_faq_whentocreate`を参照してください。</p>
<div class="section" id="but-why-does-flush-insist-on-issuing-a-rollback">
<h3>しかし、なぜflush（）はROLLBACKを発行することを主張しているのですか？<a class="headerlink" href="#but-why-does-flush-insist-on-issuing-a-rollback" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.flush`が部分的に完了してからロールバックしないと良いでしょうが、内部の簿記をいつでも停止してデータベースにフラッシュされたものと正確に一致します。理論的には可能ですが、多くのデータベース操作ではROLLBACKが必要な場合が多いため、拡張の有用性は大幅に低下します。特にPostgresは、一度失敗したトランザクションは、トランザクションが続行されないようにしています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">=&gt;</span> <span class="n">create</span> <span class="n">table</span> <span class="n">foo</span><span class="p">(</span><span class="nb">id</span> <span class="n">integer</span> <span class="n">primary</span> <span class="n">key</span><span class="p">);</span>
<span class="n">NOTICE</span><span class="p">:</span>  <span class="n">CREATE</span> <span class="n">TABLE</span> <span class="o">/</span> <span class="n">PRIMARY</span> <span class="n">KEY</span> <span class="n">will</span> <span class="n">create</span> <span class="n">implicit</span> <span class="n">index</span> <span class="s2">&quot;foo_pkey&quot;</span> <span class="k">for</span> <span class="n">table</span> <span class="s2">&quot;foo&quot;</span>
<span class="n">CREATE</span> <span class="n">TABLE</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">begin</span><span class="p">;</span>
<span class="n">BEGIN</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">insert</span> <span class="n">into</span> <span class="n">foo</span> <span class="n">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">INSERT</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">commit</span><span class="p">;</span>
<span class="n">COMMIT</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">begin</span><span class="p">;</span>
<span class="n">BEGIN</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">insert</span> <span class="n">into</span> <span class="n">foo</span> <span class="n">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ERROR</span><span class="p">:</span>  <span class="n">duplicate</span> <span class="n">key</span> <span class="n">value</span> <span class="n">violates</span> <span class="n">unique</span> <span class="n">constraint</span> <span class="s2">&quot;foo_pkey&quot;</span>
<span class="n">test</span><span class="o">=&gt;</span> <span class="n">insert</span> <span class="n">into</span> <span class="n">foo</span> <span class="n">values</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">ERROR</span><span class="p">:</span>  <span class="n">current</span> <span class="n">transaction</span> <span class="ow">is</span> <span class="n">aborted</span><span class="p">,</span> <span class="n">commands</span> <span class="n">ignored</span> <span class="n">until</span> <span class="n">end</span> <span class="n">of</span> <span class="n">transaction</span> <span class="n">block</span></pre></div>
</div>
<p>両方の問題を解決するSQLAlchemyが提供するものは、meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.begin_nested`を介して、SAVEPOINTのサポートです。 ：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session.begin_nested`を使用すると、トランザクション内で失敗する可能性のある操作をフレーム化し、その後、そのトランザクションの前にそのトランザクションを維持しながらロールバックすることができます。</p>
</div>
<div class="section" id="but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again">
<h3>しかし、なぜROLLBACKへの1回の自動呼び出しでは十分ではありませんか？なぜ私はもう一度ROLLBACKする必要がありますか？<a class="headerlink" href="#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これはやはり：class： <cite>.Session`の一貫したインターフェースを提供し、どのコンテキストが使用されているかを推測するのを拒否します。たとえば、：class： `.Session`は、複数のレベルの中で上記の&amp;quot;フレーミング&amp;quot;をサポートします。例えば、これを行ったデコレータ `</cite> &#64;with_session（） <a href="#id1"><span class="problematic" id="id2">``</span></a>があるとします：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">with_session</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
       <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
       <span class="k">try</span><span class="p">:</span>
           <span class="n">ret</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
           <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
           <span class="k">return</span> <span class="n">ret</span>
       <span class="k">except</span><span class="p">:</span>
           <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
           <span class="k">raise</span>
   <span class="k">return</span> <span class="n">go</span></pre></div>
</div>
<p>上記のデコレータは、すでに存在しない場合はトランザクションを開始し、作成者の場合はトランザクションをコミットします。 &amp;quot;subtransactions &amp;quot;フラグは、：meth： <cite>.Session.begin`が既に囲み関数によって呼び出されている場合、カウンタがインクリメントされている以外は何も起こらないことを意味します。このカウンタは、：meth：</cite> .Session.commit`が呼び出され、ゼロに戻ったときだけ、実際のCOMMITが実行されます。これは、この使用パターンを許可します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@with_session</span>
<span class="k">def</span> <span class="nf">one</span><span class="p">():</span>
   <span class="c1"># do stuff</span>
   <span class="n">two</span><span class="p">()</span>


<span class="nd">@with_session</span>
<span class="k">def</span> <span class="nf">two</span><span class="p">():</span>
   <span class="c1"># etc.</span>

<span class="n">one</span><span class="p">()</span>

<span class="n">two</span><span class="p">()</span></pre></div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>（） <a href="#id3"><span class="problematic" id="id4">``</span></a>は `` two（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を呼び出すことができ、 `` two（） <a href="#id7"><span class="problematic" id="id8">``</span></a>はそれ自身で呼び出すことができ、 `` &#64; with_session``デコレータは適切な&amp;quot;フレーミングトランザクションの境界は最も外側のコールレベルにとどまります。あなたが見ることができるように、 `` two（） <a href="#id9"><span class="problematic" id="id10">``</span></a>が例外をスローして `` rollback（） <a href="#id11"><span class="problematic" id="id12">``</span></a>を発行する `` flush（） <a href="#id13"><span class="problematic" id="id14">``</span></a>を呼び出すと、<a href="#id15"><span class="problematic" id="id16">*</span></a>常にロールバック（） <a href="#id17"><span class="problematic" id="id18">``</span></a>とデコレータの2つのレベルに対応する可能性があります。 `` flush（） <a href="#id19"><span class="problematic" id="id20">``</span></a>が `` rollback（） <a href="#id21"><span class="problematic" id="id22">``</span></a>をスタックの一番上まで押し出し、残りの <a href="#id23"><span class="problematic" id="id24">``</span></a>ロールバック（） <a href="#id25"><span class="problematic" id="id26">``</span></a>の呼び出しが間違っていると言った場合、静かな行動が続いている。正しく書かれていない囲みメソッドは例外を抑制し、何も間違っていないと仮定して `` commit（） <a href="#id27"><span class="problematic" id="id28">``</span></a>を呼び出すと、サイレントエラー状態になります。人々がこのエラーを実際に受け取る主な理由は、クリーンな &amp;quot;フレーミング&amp;quot;コードを書かなかったためであり、他の問題が残っていたからでしょう。</p>
<p>上記のユースケースがちょっとエキゾチックであると思うなら、SAVEPOINTをしたいならば同じ種類のものが出てくるでしょう。あなたは `` begin_nested（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を何回か呼び出すかもしれないし、 `` commit（） `` / ` <cite>rollback（）</cite> <cite>の呼び出しは、それぞれ最新の</cite> <cite>begin_nested（）</cite> <cite>を解決します。 `</cite> rollback（） <a href="#id3"><span class="problematic" id="id4">``</span></a>や `` commit（） <a href="#id5"><span class="problematic" id="id6">``</span></a>の意味は、それが呼び出されているブロックに依存しており、 `` rollback（） `` / `` commit（） <a href="#id7"><span class="problematic" id="id8">``</span></a>どのような順序であっても、その振る舞いを決定するネスティングのレベルです。</p>
<p>上記のどちらの場合でも、 `` flush（） <a href="#id1"><span class="problematic" id="id2">``</span></a>がトランザクションブロックのネストを壊した場合、シナリオに応じて、&amp;quot;マジック&amp;quot;から静かな失敗まで、コードフローの中断までどこでも可能です。</p>
<p>`` commit（） <a href="#id1"><span class="problematic" id="id2">``</span></a>や `` rollback（） <cite>を呼び出すと、トランザクションは外部トランザクション状態に関係なく起動されるように、</cite> <cite>flush（）</cite> <cite>自身のサブトランザクションを行います。 `失敗時 - しかし、</cite> <cite>rollback（）</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>はそれ自身のサブトランザクションに対応しています - トランザクションの外部&amp;quot;フレーミング&amp;quot;をどのように扱うかを推測したくはありません。サブトランザクションと実際のSAVEPOINTの任意の組み合わせを使用します。 &amp;quot;フレーム&amp;quot;の開始/終了の仕事は、 &amp;quot;flush（）&amp;quot;の外部のコードと一貫して保持されており、これが最も一貫したアプローチであると判断しました。</p>
</div>
</div>
<div class="section" id="how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query">
<h2>すべてのクエリに特定のフィルタを追加するクエリを作成するにはどうすればよいですか？<a class="headerlink" href="#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>PreFilteredQueryのレシピを参照してください。 &lt;<a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/PreFilteredQuery">http://www.sqlalchemy.org/trac/wiki/UsageRecipes/PreFilteredQuery</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_。</p>
</div>
<div class="section" id="i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not">
<h2>私はOuter Joinに対するマッピングを作成しましたが、クエリが行を返す間はオブジェクトは返されません。何故なの？<a class="headerlink" href="#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>主キーは両方のテーブルのコンポジットなので、外部結合によって戻された行には主キーの一部としてNULLが含まれることがあります。 ：class： <cite>.Query`オブジェクトは、受け入れ可能な主キーを持たない入力行を無視します。 ：func： `.mapper`の</cite> <cite>allow_partial_pks``フラグの設定に基づいて、値に少なくとも1つの非NULL値がある場合、または値にNULL値がない場合は主キーが受け入れられます。 `</cite> allow_partial_pks``：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.mapper`を参照してください。</p>
</div>
<div class="section" id="i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join">
<h2>JOIN / OUTER JOINを作成するために `` joinedload（） <a href="#id1"><span class="problematic" id="id2">``</span></a>や `` lazy = False``を使用しています.SQLAlchemyはWHERE、ORDER BY、LIMITなどを追加しようとすると正しいクエリを構築しません（OUTER）JOINに依存する）<a class="headerlink" href="#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>結合されたeagerローディングによって生成された結合は、関連するコレクションを完全にロードするためにのみ使用され、クエリの主な結果に影響を与えないように設計されています。彼らは匿名でエイリアス化されているため、直接参照することはできません。</p>
<p>このbeahviorの詳細は：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>zen_of_eager_loading`を参照してください。</p>
</div>
<div class="section" id="query-has-no-len-why-not">
<h2>クエリに `` __len __（） <a href="#id1"><span class="problematic" id="id2">``</span></a>はありません。どうしてですか？<a class="headerlink" href="#query-has-no-len-why-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>オブジェクトに適用されるPythonの `` __len __（） <a href="#id1"><span class="problematic" id="id2">``</span></a>マジックメソッドは、 `` len（） <a href="#id3"><span class="problematic" id="id4">``</span></a>組み込み関数を使ってコレクションの長さを判断することを可能にします。 SQLクエリオブジェクトは、 `` __len __（） <a href="#id5"><span class="problematic" id="id6">``</span></a>を：meth： <a href="#id7"><span class="problematic" id="id8">`</span></a>.Query.count`メソッドにリンクすることは直感的です。これはSELECT COUNTを送出します。これが不可能な理由は、クエリをリストとして評価すると、1つではなく2つのSQL呼び出しが発生するためです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Iterates</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LEN!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ITER!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="nb">list</span><span class="p">(</span><span class="n">Iterates</span><span class="p">())</span></pre></div>
</div>
<p>出力：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ITER!
LEN!</pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-textual-sql-with-orm-queries">
<h2>ORMクエリでテキストSQLを使用するにはどうすればよいですか？<a class="headerlink" href="#how-do-i-use-textual-sql-with-orm-queries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>見る：</p>
<ul class="simple">
<li>：ref： <cite>orm_tutorial_literal_sql</cite>  - アドホックテキストブロック：class：` .Query`</li>
<li>：ref： <cite>session_sql_expressions</cite>  - ：class：` .Session`とテキストSQLを直接使用します。</li>
</ul>
</div>
<div class="section" id="i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection">
<h2>私は `` Session.delete（myobject） <a href="#id1"><span class="problematic" id="id2">``</span></a>と呼びますが、親コレクションからは削除されません！<a class="headerlink" href="#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この動作の説明については：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_deleting_from_collections`を参照してください。</p>
</div>
<div class="section" id="why-isn-t-my-init-called-when-i-load-objects">
<h2>オブジェクトをロードするときに私の `` __init __（） <a href="#id1"><span class="problematic" id="id2">``</span></a>が呼び出されないのはなぜですか？<a class="headerlink" href="#why-isn-t-my-init-called-when-i-load-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この動作の説明については：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>mapping_constructors`を参照してください。</p>
</div>
<div class="section" id="how-do-i-use-on-delete-cascade-with-sa-s-orm">
<h2>SAのORMでON DELETE CASCADEを使用するにはどうすればよいですか？<a class="headerlink" href="#how-do-i-use-on-delete-cascade-with-sa-s-orm" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyは、現在：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`にロードされている依存行に対して、常にUPDATEまたはDELETE文を発行します。ロードされていない行については、デフォルトでSELECT文を発行してそれらの行をロードし、それらの行を更新/削除します。つまり、ON DELETE CASCADEが構成されていないとみなします。 ON DELETE CASCADEと協力するようにSQLAlchemyを設定するには、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>passive_deletes`を参照してください。</p>
</div>
<div class="section" id="i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7">
<h2>私はインスタンスの&amp;quot;foo_id &amp;quot;属性を&amp;quot;7 &amp;quot;に設定しますが、&amp;quot;foo &amp;quot;属性は &amp;quot;` None``です -  Fooにid＃7をロードしてはいけませんか？<a class="headerlink" href="#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ORMは、外部キー属性の変更に起因する関係の即時の集団をサポートするような方法で構築されているのではなく、逆の働きをするように設計されています。外部キー属性は、オブジェクト関係を自然に設定します。したがって、 `` o.foo``を設定するための推奨される方法は、これを行うことです - それを設定する！:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span>
<span class="n">Session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>もちろん、外部キー属性の操作は完全に合法です。しかし、外部キー属性を新しい値に設定しても、それが関与している：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`の&amp;quot; expire &amp;quot;イベントは発生しません。これは、以下のシーケンスのために：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">o</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="kc">None</span>  <span class="c1"># accessing an un-set attribute sets it to None</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span></pre></div>
</div>
<p>`` o.foo``は最初にアクセスしたときに `` None``に初期化されます。 `` o.foo_id = 7``を設定すると、保留中の&amp;quot;7 &amp;quot;の値を持ちますが、フラッシュは発生していません - したがって `` o.foo``は `` None``です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># attribute is already set to None, has not been</span>
<span class="c1"># reconciled with o.foo_id = 7 yet</span>
<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="kc">None</span></pre></div>
</div>
<p>`` o.foo``が外部キーに基づいてロードするためには、突然変異は通常、新しい外部キー値をフラッシュしてすべての状態を期限切れにするコミット後に自然に達成されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># expires all attributes</span>

<span class="n">foo_7</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c1"># o.foo lazyloads on access</span></pre></div>
</div>
<p>最小限の操作で属性を個別に期限切れにすることができます。これは：term： <cite>persistent`オブジェクトに対して：meth：</cite> .Session.expire` ::を使用して実行できます</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">o</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">Session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">])</span>  <span class="c1"># object must be persistent for this</span>

<span class="n">foo_7</span> <span class="o">=</span> <span class="n">Session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c1"># o.foo lazyloads on access</span></pre></div>
</div>
<p>オブジェクトが永続的ではなく、：class： <cite>.Session`に存在する場合、それは：term：</cite> pending`と呼ばれます。これは、オブジェクトの行がまだデータベースにINSERTされていないことを意味します。このようなオブジェクトの場合、 `` foo_id``は行が挿入されるまで意味を持ちません。そうでなければまだ行はありません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">new_obj</span><span class="o">.</span><span class="n">foo_id</span> <span class="o">=</span> <span class="mi">7</span>

<span class="n">Session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>

<span class="c1"># accessing an un-set attribute sets it to None</span>
<span class="k">assert</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="kc">None</span>

<span class="n">Session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>  <span class="c1"># emits INSERT</span>

<span class="c1"># expire this because we already set .foo to None</span>
<span class="n">Session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">])</span>

<span class="k">assert</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="n">foo_7</span>  <span class="c1"># now it loads</span></pre></div>
</div>
<div class="topic">
<p class="topic-title first">Attribute loading for non-persistent objects</p>
<p>func： <cite>.relationship`でフラグ</cite> <cite>load_on_pending``を使用すると、上の&amp;quot; pending &amp;quot;の動作の変種があります。このフラグが設定されると、INSERTが進む前に `</cite> new_obj.foo``のために遅延ローダが出力します。これの別の変形は、：meth： <cite>.Session.enable_relationship_loading`メソッドを使用することです。このメソッドは、多対1の関係が以下のようにロードするようにオブジェクトをa：class：</cite> .Session`にアタッチすることができますどちらのテクニックも**一般的な使用には推奨されていません**; ORMの通常のオブジェクト状態の再利用を伴うユーザーが遭遇する特定のプログラミングシナリオに合うように追加されました。</p>
</div>
<p>レシピ <a href="#id1"><span class="problematic" id="id2">`</span></a>ExpireRelationshipOnFKChange &lt;<a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange">http://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_には、SQLAlchemyイベントを使用して、多対1の関係で外部キー属性の設定を調整する例があります。</p>
</div>
<div class="section" id="how-do-i-walk-all-objects-that-are-related-to-a-given-object">
<span id="faq-walk-objects"></span><h2>特定のオブジェクトに関連するすべてのオブジェクトをどのように歩くのですか？<a class="headerlink" href="#how-do-i-walk-all-objects-that-are-related-to-a-given-object" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>それに関連する他のオブジェクトを持つオブジェクトは、マッパーの間に設定された：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`コンストラクトに対応します。このコードフラグメントは、すべてのオブジェクトを繰り返し処理し、サイクルも修正します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>


<span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">deque</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>

    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">deque</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">deque</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">obj</span>
        <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">relationship</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">relationships</span><span class="p">:</span>
            <span class="n">related</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">relationship</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">relationship</span><span class="o">.</span><span class="n">uselist</span><span class="p">:</span>
                <span class="n">deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">related</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">related</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">deque</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">related</span><span class="p">)</span></pre></div>
</div>
<p>この機能は次のように示すことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;a.id&#39;</span><span class="p">))</span>
    <span class="n">c_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;c.id&#39;</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;bs&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="n">a1</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">bs</span><span class="o">=</span><span class="p">[</span><span class="n">B</span><span class="p">(),</span> <span class="n">B</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">C</span><span class="p">())])</span>


<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="n">a1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></pre></div>
</div>
<p>出力：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x10303b190</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">B</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x103025210</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">B</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x10303b0d0</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">C</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x103025490</span><span class="o">&gt;</span></pre></div>
</div>
</div>
<div class="section" id="is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword">
<h2>キーワードのクエリを実行せずに、そのキーワードを含む行への参照を取得せずに、一意のキーワード（または他の種類のオブジェクト）のみを自動的に持つ方法はありますか？<a class="headerlink" href="#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>人々がドキュメントの多対多の例を読むと、同じ `` Keyword``を2回作成するとDBに2回置かれます。これはやや不便です。</p>
<p>この <a href="#id1"><span class="problematic" id="id2">`</span></a>UniqueObject &lt;<a class="reference external" href="http://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject">http://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_このレシピに対処するためのレシピが作成されました。</p>
</div>
<div class="section" id="why-does-post-update-emit-update-in-addition-to-the-first-update">
<span id="faq-post-update-update"></span><h2>post_updateが最初のUPDATEに加えてUPDATEを発行するのはなぜですか？<a class="headerlink" href="#why-does-post-update-emit-update-in-addition-to-the-first-update" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>post_update`に記載されているpost_update機能は、通常、ターゲットに対して発行されるINSERT / UPDATE / DELETEに加えて、特定のリレーションバインドされた外部キーへの変更に応じてUPDATE文が発行される行。このUPDATE文の主な目的は、その行のINSERTまたはDELETEとペアにして、相互に依存する外部キーを使用してサイクルを中断するために外部キー参照をポストセットまたは事前設定解除できるようにすることですが、現在は、ターゲット行自体がUPDATEの対象となるときに発行される2番目のUPDATEとしてバンドルされています。この場合、post_updateによって発行されるUPDATEは通常は不要*であり、多くの場合無駄に見えます。</p>
<p>しかし、この &amp;quot;UPDATE / UPDATE&amp;quot;動作を削除しようとするいくつかの研究では、作業単位プロセスの大きな変更は、post_updateの実装全体だけでなく、post_updateに関連しない領域これは動作するためには、非post_update側で操作の順序を逆にする必要があり、参照される主キー値のUPDATEを正しく処理するなどの他のケースに影響を与える可能性があります（ticket：概念の証明のために「1063」）。</p>
<p>答えは、&amp;quot;post_update &amp;quot;が相互に依存する2つの外部キーの間のサイクルを壊し、このサイクルを分割することがターゲットテーブルのINSERT / DELETEに限定されるようにするために、UPDATEステートメントの順序が自由化され、他の縁の場合に破損につながる。</p>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="performance.html" title="previous chapter">パフォーマンス</a>
        Next:
        <a href="../errors.html" title="next chapter">エラーメッセージ</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



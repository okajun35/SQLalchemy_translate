<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    接続/エンジン
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="よくある質問" href="index.html" />
        <link rel="next" title="メタデータ/スキーマ" href="metadata_schema.html" />
        <link rel="prev" title="よくある質問" href="index.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="よくある質問">よくある質問</a>
        </h3>

        <ul>
<li class="selected"><span class="link-container first"><strong>接続/エンジン</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-configure-logging">どのようにログを設定するのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-pool-database-connections-are-my-connections-pooled">データベース接続をプールするにはどうすればいいですか？私の接続はプールされていますか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-pass-custom-connect-arguments-to-my-database-api">データベースAPIにカスタム接続引数を渡すにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#mysql-server-has-gone-away">&amp;quot;MySQLサーバーがなくなった</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically">&amp;quot;コマンドが同期していない;このコマンドを現在実行できません&amp;quot; / &amp;quot;この結果オブジェクトは行を返しません。</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#why-does-sqlalchemy-issue-so-many-rollbacks">なぜSQLAlchemyは非常に多くのROLLBACKを発行しますか？</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#i-m-on-myisam-how-do-i-turn-it-off">私はMyISAMにいます - どうすればいいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits">SQL Serverを使用しています。これらのROLLBACKをCOMMITに変換するにはどうすればよいですか？</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working">SQLiteデータベースで複数の接続を使用しています（通常はトランザクション操作をテストします）、テストプログラムが動作していません。</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine">エンジンを使用している場合、未処理のDBAPI接続を取得するにはどうすればよいですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork">Pythonのマルチプロセッシング、またはos.fork（）でエンジン/接続/セッションを使用するにはどうすればよいですか？</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="metadata_schema.html">メタデータ/スキーマ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="sqlexpressions.html">SQL式</a></span></li>
<li><span class="link-container first"><a class="reference external" href="ormconfiguration.html">ORM設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="performance.html">パフォーマンス</a></span></li>
<li><span class="link-container first"><a class="reference external" href="sessions.html">セッション/クエリ</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="connections-engines">
<h1>接続/エンジン<a class="headerlink" href="#connections-engines" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents faq local topic" id="id1">
<ul class="simple">
<li><a class="reference internal" href="#how-do-i-configure-logging" id="id2">どのようにログを設定するのですか？</a></li>
<li><a class="reference internal" href="#how-do-i-pool-database-connections-are-my-connections-pooled" id="id3">データベース接続をプールするにはどうすればいいですか？私の接続はプールされていますか？</a></li>
<li><a class="reference internal" href="#how-do-i-pass-custom-connect-arguments-to-my-database-api" id="id4">データベースAPIにカスタム接続引数を渡すにはどうすればよいですか？</a></li>
<li><a class="reference internal" href="#mysql-server-has-gone-away" id="id5">&amp;quot;MySQLサーバーがなくなった</a></li>
<li><a class="reference internal" href="#commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically" id="id6">&amp;quot;コマンドが同期していない;このコマンドを現在実行できません&amp;quot; / &amp;quot;この結果オブジェクトは行を返しません。</a></li>
<li><a class="reference internal" href="#why-does-sqlalchemy-issue-so-many-rollbacks" id="id7">なぜSQLAlchemyは非常に多くのROLLBACKを発行しますか？</a><ul>
<li><a class="reference internal" href="#i-m-on-myisam-how-do-i-turn-it-off" id="id8">私はMyISAMにいます - どうすればいいですか？</a></li>
<li><a class="reference internal" href="#i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits" id="id9">SQL Serverを使用しています。これらのROLLBACKをCOMMITに変換するにはどうすればよいですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working" id="id10">SQLiteデータベースで複数の接続を使用しています（通常はトランザクション操作をテストします）、テストプログラムが動作していません。</a></li>
<li><a class="reference internal" href="#how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine" id="id11">エンジンを使用している場合、未処理のDBAPI接続を取得するにはどうすればよいですか？</a></li>
<li><a class="reference internal" href="#how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork" id="id12">Pythonのマルチプロセッシング、またはos.fork（）でエンジン/接続/セッションを使用するにはどうすればよいですか？</a></li>
</ul>
</div>
<div class="section" id="how-do-i-configure-logging">
<h2>どのようにログを設定するのですか？<a class="headerlink" href="#how-do-i-configure-logging" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>参照：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>dbengine_logging`を参照してください。</p>
</div>
<div class="section" id="how-do-i-pool-database-connections-are-my-connections-pooled">
<h2>データベース接続をプールするにはどうすればいいですか？私の接続はプールされていますか？<a class="headerlink" href="#how-do-i-pool-database-connections-are-my-connections-pooled" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ほとんどの場合、SQLAlchemyはアプリケーションレベルの接続プーリングを自動的に実行します。 SQLiteを除いて、：class： <cite>.Engine`オブジェクトは接続のソースとして：class：</cite> .QueuePool`を参照します。</p>
<p>詳細は、ref： <cite>engines_toplevel`と：ref：</cite> pooling_toplevel`を参照してください。</p>
</div>
<div class="section" id="how-do-i-pass-custom-connect-arguments-to-my-database-api">
<h2>データベースAPIにカスタム接続引数を渡すにはどうすればよいですか？<a class="headerlink" href="#how-do-i-pass-custom-connect-arguments-to-my-database-api" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>.create_engine`呼び出しは、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>connect_args``キーワード引数を介して直接的に追加の引数を受け取ります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql://scott:tiger@localhost/test&quot;</span><span class="p">,</span>
                    <span class="n">connect_args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;encoding&quot;</span><span class="p">:</span> <span class="s2">&quot;utf8&quot;</span><span class="p">})</span></pre></div>
</div>
<p>基本的な文字列と整数の引数については、通常、URLのクエリ文字列で指定することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;mysql://scott:tiger@localhost/test?encoding=utf8&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>custom_dbapi_args</cite></p>
</div>
</div>
<div class="section" id="mysql-server-has-gone-away">
<h2>&amp;quot;MySQLサーバーがなくなった<a class="headerlink" href="#mysql-server-has-gone-away" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このエラーの主な原因は、MySQL接続がタイムアウトしてサーバーによって閉じられていることです。 MySQLサーバは、アイドル状態の接続をデフォルトで8時間閉鎖します。これに対処するために、直ちに設定することは：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.create_engine.pool_recycle`設定を有効にすることです。これにより、設定された秒数よりも古い接続が破棄され、次の接続時に新しい接続に置き換えられますチェックアウトされた。</p>
<p>データベースの再起動やネットワークの問題による一時的な接続喪失に対処するより一般的なケースでは、プール内の接続は、より一般化された切断検出テクニックに対応してリサイクルされる可能性があります。セクション：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>pool_disconnects`は、&amp;quot;悲観的な&amp;quot;（例：プレping）と&amp;quot;楽観的&amp;quot;（例：優雅な回復）の両方のテクニックについての背景を提供します。現代のSQLAlchemyは、「悲観的な」アプローチを支持する傾向があります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pool_disconnects</cite></p>
</div>
</div>
<div class="section" id="commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically">
<span id="mysql-sync-errors"></span><h2>&amp;quot;コマンドが同期していない;このコマンドを現在実行できません&amp;quot; / &amp;quot;この結果オブジェクトは行を返しません。<a class="headerlink" href="#commands-out-of-sync-you-can-t-run-this-command-now-this-result-object-does-not-return-rows-it-has-been-closed-automatically" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>MySQLドライバにはかなりの種類の障害モードがあり、それによってサーバへの接続状態が無効な状態になります。通常、接続を再度使用すると、これら2つのエラーメッセージのいずれかが発生します。理由は、サーバーの状態がクライアント・ライブラリーが予期しないものに変更されたためです。そのため、クライアント・ライブラリーが接続で新しいステートメントを発行すると、サーバーは期待どおりに応答しません。</p>
<p>SQLAlchemyでは、データベース接続がプールされているため、接続でメッセージが同期しなくなる問題がより重要になります。操作が失敗した場合、接続自体が使用不可能な状態になった場合、接続プールに戻った場合、再度チェックアウトすると誤動作します。この問題の軽減策は、そのような障害モードが発生したときに接続が**無効化され**、MySQLへのデータベース接続が破棄されることです。この無効化は多くの既知の障害モードで自動的に発生し、また：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.invalidate`メソッドを介して明示的に呼び出すこともできます。</p>
<p>このカテゴリには、 `` with session.begin_nested（）： <a href="#id1"><span class="problematic" id="id2">``</span></a>などのコンテキストマネージャが、エラーが発生したときにトランザクションをロールバックしたいという第2のクラスの失敗モードもあります。しかし、接続のいくつかの障害モードでは、ロールバック自体（リリースSAVEPOINT操作でもあり得る）も失敗し、誤ったスタックトレースを引き起こします。</p>
<p>もともと、このエラーの原因はかなり単純でしたが、それはマルチスレッドプログラムが複数のスレッドからの単一の接続でコマンドを呼び出すことを意味していました。これは、使用されている唯一のドライバであった元の&amp;quot;MySQLdb &amp;quot;ネイティブCドライバに適用されます。しかし、PyMySQLやMySQL-connector-Pythonのような純粋なPythonドライバの導入や、gevent / eventlet、マルチプロセッシング（しばしばCelery）などのツールの使用の増加とともに、この問題を引き起こすことが知られていますが、その中にはSQLAlchemyのバージョン間で改善されているものもあれば、避けられないものもあります。</p>
<ul>
<li><p class="first"><strong>スレッド間の接続の共有</strong>  - これが、この種のエラーが発生した元の理由です。プログラムは2つ以上のスレッドで同時に同じ接続を使用しました。これは、複数のメッセージセットが接続上で混在していることを意味し、クライアントがもはや解釈する方法を知らない状態にサーバー側セッションを置きます。しかし、今日は通常、他の原因が考えられます。</p>
</li>
<li><p class="first"><strong>プロセス間の接続のためのファイルハンドルの共有</strong>  - これは通常、プログラムが `` os.fork（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を使用して新しいプロセスを生成し、親プロセスに存在するTCP接続が1つのプロセスに共有されるまたはそれ以上の子プロセス。複数のプロセスが本質的に同じファイルハンドルにメッセージを発信しているので、サーバーはインターリーブされたメッセージを受信し、接続の状態を解除します。</p>
<p>このシナリオは、プログラムがPythonの&amp;quot;マルチプロセッシング&amp;quot;モジュールを使用し、親プロセスで作成された：class： <cite>.Engine`を使用すると非常に簡単に発生します。 Celeryのようなツールを使うときは、&amp;quot;マルチプロセッシング&amp;quot;が使われているのが一般的です。正しいアプローチは、新しい：class： `.Engine`が子プロセスが最初に起動するときに生成され、親プロセスから来たclass：</cite> .Engine`を破棄するか、親プロセスから継承された：class： <cite>.Engine`は、：meth：</cite> .Engine.dispose`を呼び出すことで、内部接続プールを持つことができます。</p>
</li>
<li><p class="first">PythonのネットワーキングAPIをmonkeypatchesするgeventやeventletのようなライブラリを使うとき、PyMySQLのようなライブラリは、このモデルに対して明示的に開発されていなくても非同期操作モードで動作するようになりました。一般的な問題は、アプリケーションのタイムアウトロジックのために、greenthreadが中断されることです。この結果、 `` GreenletExit``例外が発生し、純粋なPython MySQLドライバは、サーバからの応答を受け取っていたか、そうでなければ接続の状態をリセットする準備ができている可能性があります。例外がすべての作業を短くすると、クライアントとサーバーの間の会話が同期しなくなり、その後の接続の使用が失敗する可能性があります。バージョン1.1.0のSQLAlchemyは、データベース操作が、いわゆる &amp;quot;終了例外&amp;quot;によって中断されたかのように、これを防ぐ方法を知っています。これには、 &amp;quot;GreenletExit&amp;quot;とPythonの &amp;quot;BaseException&amp;quot; <cite>それは</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Exception``のサブクラスでもないので、接続は無効になります。</p>
</li>
<li><p class="first">** Rollbacks / SAVEPOINTリリースの失敗**  - いくつかのクラスのエラーは、トランザクションが「SAVEPOINT」ブロックで動作しているときだけでなく、そのコンテキスト内でも接続を使用できないようにします。このような場合、接続の失敗によりSAVEPOINTは存在しなくなりましたが、SQLAlchemyまたはアプリケーションがこのセーブポイントを &amp;quot;ロールバック&amp;quot;しようとすると、&amp;quot;RELEASE SAVEPOINT &amp;quot;操作は失敗します。 &amp;quot;セーブポイントが存在しません&amp;quot;のようなメッセージです。この場合、Python 3では、エラーの最終的な &amp;quot;原因&amp;quot;も表示される一連の例外出力があります。 Python 2では、&amp;quot;連鎖&amp;quot;例外はありませんが、SQLAlchemyの最近のバージョンでは、元のエラーの原因を示す警告を出そうとしますが、ROLLBACKの失敗である即時のエラーをスローします。</p>
</li>
</ul>
</div>
<div class="section" id="why-does-sqlalchemy-issue-so-many-rollbacks">
<h2>なぜSQLAlchemyは非常に多くのROLLBACKを発行しますか？<a class="headerlink" href="#why-does-sqlalchemy-issue-so-many-rollbacks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLAlchemyは現在、DBAPI接続が&amp;quot;非自動コミット&amp;quot;モードであると想定しています。これはPythonデータベースAPIのデフォルトの動作です。つまり、トランザクションが常に進行中であることが前提です。接続プールは、接続が返されたときに `` connection.rollback（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を発行します。これは、接続に残っているトランザクションリソースがすべて解放されるようにするためです。 PostgreSQLやMSSQLのようなテーブルリソースが積極的にロックされているデータベースでは、使用されなくなった接続内で行やテーブルがロックされないようにすることが重要です。それ以外の場合は、アプリケーションがハングアップする可能しかし、ロックだけでなく、MySQLを含むInnoDBを含むあらゆる種類のトランザクション分離を持つデータベースでも同様に重要です。古いトランザクション内にまだ存在する接続は、そのデータがすでに分離内で照会されていた場合は失効したデータを返します。 MySQLで古いデータが表示される理由については、http：//dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.htmlを参照してください。</p>
<div class="section" id="i-m-on-myisam-how-do-i-turn-it-off">
<h3>私はMyISAMにいます - どうすればいいですか？<a class="headerlink" href="#i-m-on-myisam-how-do-i-turn-it-off" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>接続プールの接続戻り動作の動作は、 `` reset_on_return``</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.pool</span> <span class="k">import</span> <span class="n">QueuePool</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mysql://scott:tiger@localhost/myisam_database&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">QueuePool</span><span class="p">(</span><span class="n">reset_on_return</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></pre></div>
</div>
</div>
<div class="section" id="i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits">
<h3>SQL Serverを使用しています。これらのROLLBACKをCOMMITに変換するにはどうすればよいですか？<a class="headerlink" href="#i-m-on-sql-server-how-do-i-turn-those-rollbacks-into-commits" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>`` reset_on_return``は `` True`````````````````````````````````````````に加えて `` commit````、 `` rollback``を受け入れます。 `` commit``に設定すると、プールに接続が返されるたびにCOMMITが発生します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;mssql://scott:tiger@mydsn&#39;</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">QueuePool</span><span class="p">(</span><span class="n">reset_on_return</span><span class="o">=</span><span class="s1">&#39;commit&#39;</span><span class="p">))</span></pre></div>
</div>
</div>
</div>
<div class="section" id="i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working">
<h2>SQLiteデータベースで複数の接続を使用しています（通常はトランザクション操作をテストします）、テストプログラムが動作していません。<a class="headerlink" href="#i-am-using-multiple-connections-with-a-sqlite-database-typically-to-test-transaction-operation-and-my-test-program-is-not-working" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SQLiteの <a href="#id1"><span class="problematic" id="id2">``</span></a>：memory： <a href="#id3"><span class="problematic" id="id4">``</span></a>データベース、またはバージョン0.7より前のバージョンのSQLAlchemyを使用している場合、デフォルトの接続プールは：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.SingletonThreadPool`です。スレッドごとに1つのSQLite接続を維持します。したがって、同じスレッドで使用されている2つの接続は、実際には同じSQLite接続になります。 ：memory：データベースを使用せずに、：class： <a href="#id7"><span class="problematic" id="id8">`</span></a>.NullPool`を使用してください。これは、現在のSQLAlchemyバージョンの非メモリデータベースのデフォルトです。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>pysqlite_threading_pooling</cite>  -  PySQLiteの動作に関する情報です。</p>
</div>
</div>
<div class="section" id="how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine">
<h2>エンジンを使用している場合、未処理のDBAPI接続を取得するにはどうすればよいですか？<a class="headerlink" href="#how-do-i-get-at-the-raw-dbapi-connection-when-using-an-engine" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>通常のSAエンジンレベルのConnectionでは、：class： <cite>.Connection`の：attr：</cite> .Connection.connection`属性を使用してDBAPI接続のプールプロキシバージョンを取得できます。実際のDBAPI接続には：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ConnectionFairy.connection`属性を呼び出すことができますが、プールされていないDBAPI接続にはアクセスする必要がありません。すべてのメソッドは、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">connection</span><span class="o">.&lt;</span><span class="n">do</span> <span class="n">DBAPI</span> <span class="n">things</span><span class="o">&gt;</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DBAPI</span> <span class="n">specific</span> <span class="n">arguments</span><span class="o">..&gt;</span><span class="p">)</span></pre></div>
</div>
<p>プールに戻す前に、分離レベル設定または接続の他の操作固有の設定を通常に戻す必要があります。</p>
<p>設定を元に戻す代わりに、：class： <cite>.Connection`またはプロキシ接続のどちらかで：meth：</cite> .Connection.detach`メソッドを呼び出すことができます。閉じられ、破棄されたとき：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.close`が呼び出される:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># detaches the DBAPI connection from the connection pool</span>
<span class="n">conn</span><span class="o">.</span><span class="n">connection</span><span class="o">.&lt;</span><span class="n">go</span> <span class="n">nuts</span><span class="o">&gt;</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># connection is closed for real, the pool replaces it with a new connection</span></pre></div>
</div>
</div>
<div class="section" id="how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork">
<h2>Pythonのマルチプロセッシング、またはos.fork（）でエンジン/接続/セッションを使用するにはどうすればよいですか？<a class="headerlink" href="#how-do-i-use-engines-connections-sessions-with-python-multiprocessing-or-os-fork" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>複数のPythonプロセスの重要な目標は、データベース接続がプロセス間で共有されないようにすることです。ドライバやOSの仕様によっては、動作しない接続から複数のプロセスで同時に使用されるソケット接続に至るまでの問題があり、メッセージングが壊れています（後者の場合が一般的です）。</p>
<p>SQLAlchemy：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`オブジェクトは、既存のデータベース接続の接続プールを参照します。したがって、このオブジェクトが子プロセスに複製されるとき、目標はデータベース接続が引き継がれないようにすることです。これには3つの一般的なアプローチがあります：</p>
<ol class="arabic">
<li><p class="first">：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.NullPool`を使用してプールを無効にします。これは：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Engine`が何度も何らかの接続を使用するのを防ぐ最もシンプルなワンショットシステムです。</p>
</li>
<li><p class="first">`` .Engine``を新しいプロセスの中に入れたらすぐに：meth： <cite>.Engine.dispose</cite>：class：` .Engine`を呼び出してください。 Pythonのマルチプロセッシングでは、 `` multiprocessing.Pool``のような構造体には、これを実行できる場所である &amp;quot;初期化子&amp;quot;フックが含まれています。そうでなければ、 `` os.fork（） <a href="#id1"><span class="problematic" id="id2">``</span></a>のどこか、または `` Process``オブジェクトが子のforkを開始するところで、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Engine.dispose`を一回呼び出すことで残りの接続が確実にフラッシュされます。</p>
</li>
<li><p class="first">イベントハンドラは、プロセス境界で共有される接続をテストし、無効にする接続プールに適用できます。これは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">exc</span>

<span class="k">def</span> <span class="nf">add_engine_pidguard</span><span class="p">(</span><span class="n">engine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add multiprocessing guards.</span>

<span class="sd">    Forces a connection to be reconnected if it is detected</span>
<span class="sd">    as having been shared to a sub-process.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;connect&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">):</span>
        <span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>

    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="s2">&quot;checkout&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">checkout</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">,</span> <span class="n">connection_proxy</span><span class="p">):</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">:</span>
            <span class="c1"># substitute log.debug() or similar here as desired</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Parent process </span><span class="si">%(orig)s</span><span class="s2"> forked (</span><span class="si">%(newproc)s</span><span class="s2">) with an open &quot;</span>
                <span class="s2">&quot;database connection, &quot;</span>
                <span class="s2">&quot;which is being discarded and recreated.&quot;</span> <span class="o">%</span>
                <span class="p">{</span><span class="s2">&quot;newproc&quot;</span><span class="p">:</span> <span class="n">pid</span><span class="p">,</span> <span class="s2">&quot;orig&quot;</span><span class="p">:</span> <span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]})</span>
            <span class="n">connection_record</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection_proxy</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">DisconnectionError</span><span class="p">(</span>
                <span class="s2">&quot;Connection record belongs to pid </span><span class="si">%s</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;attempting to check out in pid </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">connection_record</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">],</span> <span class="n">pid</span><span class="p">)</span>
            <span class="p">)</span></pre></div>
</div>
<p>これらのイベントは、作成されるとすぐに：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Engine`に適用されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>

<span class="n">add_engine_pidguard</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span></pre></div>
</div>
</li>
</ol>
<p>上記の戦略は：class： <cite>.Engine`がプロセス間で共有されるケースに対応します。しかし、transaction-active：class： `.Session`や：class：</cite> .Connection`が共有されている場合は、このための自動修正はありません。アプリケーションは新しい子プロセスがORM：class： <cite>.Session`オブジェクトだけでなく、新しい：class：</cite> .Connection`オブジェクトとトランザクションを開始するようにする必要があります。 a：class： <cite>.Session`オブジェクトの場合、これは技術的にはセッションが現在トランザクションにバインドされている場合にのみ必要ですが、class：</cite> .Session`のスコープはいずれの場合でも単一の呼び出し（グローバルオブジェクトではなく、プロセスやスレッド間で共有されていないなど）。</p>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="index.html" title="previous chapter">よくある質問</a>
        Next:
        <a href="metadata_schema.html" title="next chapter">メタデータ/スキーマ</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



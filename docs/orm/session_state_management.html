<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    状態管理
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="セッションの使用" href="session.html" />
        <link rel="next" title="カスケード" href="cascades.html" />
        <link rel="prev" title="セッションの基礎" href="session_basics.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="session_basics.html">セッションの基礎</a></span></li>
<li class="selected"><span class="link-container first"><strong>状態管理</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#quickie-intro-to-object-states">Quickieオブジェクトの状態の紹介</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#getting-the-current-state-of-an-object">オブジェクトの現在の状態を取得する</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#session-attributes">セッション属性</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#session-referencing-behavior">セッション参照動作</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#merging">マージ</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#merge-tips">マージのヒント</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#expunging">絶滅</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#refreshing-expiring">リフレッシュ/期限切れ</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#what-actually-loads">実際に何が読み込まれるか</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#when-to-expire-or-refresh">期限切れまたは更新する時期</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="cascades.html">カスケード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_transaction.html">トランザクションと接続管理</a></span></li>
<li><span class="link-container first"><a class="reference external" href="persistence_techniques.html">追加の永続化手法</a></span></li>
<li><span class="link-container first"><a class="reference external" href="contextual.html">コンテキスト/スレッドローカルセッション</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_events.html">イベントによるオブジェクトおよびセッションの変更の追跡</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session_api.html">セッションAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="state-management">
<h1>状態管理<a class="headerlink" href="#state-management" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="quickie-intro-to-object-states">
<span id="session-object-states"></span><h2>Quickieオブジェクトの状態の紹介<a class="headerlink" href="#quickie-intro-to-object-states" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インスタンスがセッション内で持つことができる状態を知ることは役に立ちます：</p>
<ul>
<li><p class="first">** Transient **  - セッションになく、データベースに保存されていないインスタンス。つまり、データベースのアイデンティティーはありません。そのようなオブジェクトがORMに持つ唯一の関係は、そのクラスに関連する `` mapper（） <a href="#id1"><span class="problematic" id="id2">``</span></a>があるということです。</p>
</li>
<li><p class="first"><strong>保留中</strong>  - あなたが：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.add`を一時インスタンスにすると、保留状態になります。まだ実際にデータベースにフラッシュされていませんでしたが、次のフラッシュが発生した時点になります。</p>
</li>
<li><p class="first">** Persistent **  - セッションに存在し、データベースにレコードを持つインスタンス。保留中のインスタンスが永続的になるようにフラッシュするか、データベースに既存のインスタンスを照会するか（または永続インスタンスを他のセッションからローカルセッションに移動する）、永続インスタンスを取得します。</p>
</li>
<li><p class="first">** Deleted **  - フラッシュ内で削除されたが、トランザクションがまだ完了していないインスタンス。この状態のオブジェクトは本質的に&amp;quot;保留中&amp;quot;状態の反対側にあります。セッションのトランザクションがコミットされると、オブジェクトは分離状態に移行します。あるいは、セッションのトランザクションがロールバックされると、削除されたオブジェクトは*戻って*永続状態に移動します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.1 で変更: </span>「削除された」状態は、「永続的」状態とは異なる新たに追加されたセッションオブジェクト状態である。</p>
</div>
</li>
<li><p class="first">** Detached **  - データベース内のレコードに対応する、または以前に対応したインスタンスですが、現在どのセッションにも存在しません。切り離されたオブジェクトにはデータベースIDマーカーが含まれますが、セッションに関連付けられていないため、このデータベースIDが実際にターゲットデータベースに存在するかどうかは不明です。デタッチされたオブジェクトは、以前は&amp;quot;期限切れ&amp;quot;とマークされていたアンロードされた属性または属性をロードする能力を持たないことを除いて、通常は安全に使用できます。</p>
</li>
</ul>
<p>すべての可能な状態遷移への深い浸透については、各遷移をプログラムで追跡する方法と同様に、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>session_lifecycle_events`節を参照してください。</p>
<div class="section" id="getting-the-current-state-of-an-object">
<h3>オブジェクトの現在の状態を取得する<a class="headerlink" href="#getting-the-current-state-of-an-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マッピングされたオブジェクトの実際の状態は、いつでも：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.inspect`システムを使って見ることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">my_object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insp</span><span class="o">.</span><span class="n">persistent</span>
<span class="go">True</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：attr： <cite>.InstanceState.transient</cite></p>
<p>：attr： <cite>.InstanceState.pending</cite></p>
<p>：attr： <cite>.InstanceState.persistent</cite></p>
<p>：attr： <cite>.InstanceState.deleted</cite></p>
<p class="last">：attr： <cite>.InstanceState.detached</cite></p>
</div>
</div>
</div>
<div class="section" id="session-attributes">
<span id="id1"></span><h2>セッション属性<a class="headerlink" href="#session-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session`自体は、セットのようなコレクションのように動作します。存在するすべてのアイテムは、イテレータインタフェースを使用してアクセスできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></pre></div>
</div>
<p>そして存在は、通常の&amp;quot;contains &amp;quot;セマンティクスを使ってテストされるかもしれません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object is present&quot;</span><span class="p">)</span></pre></div>
</div>
<p>セッションでは、新しく作成された（つまり保留中の）オブジェクト、最後にロードまたは保存された（つまり「ダーティー」なので）変更されたすべてのオブジェクト、および削除済みとしてマークされたすべてのオブジェクトも追跡しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># pending objects recently added to the Session</span>
<span class="n">session</span><span class="o">.</span><span class="n">new</span>

<span class="c1"># persistent objects which currently have changes detected</span>
<span class="c1"># (this collection is now created on the fly each time the property is called)</span>
<span class="n">session</span><span class="o">.</span><span class="n">dirty</span>

<span class="c1"># persistent objects that have been marked as deleted via session.delete(obj)</span>
<span class="n">session</span><span class="o">.</span><span class="n">deleted</span>

<span class="c1"># dictionary of all persistent objects, keyed on their</span>
<span class="c1"># identity key</span>
<span class="n">session</span><span class="o">.</span><span class="n">identity_map</span></pre></div>
</div>
<p>（ドキュメント：：attr： <cite>.Session.new</cite>、：attr：` .Session.dirty`、：attr： <cite>.Session.deleted</cite>、：attr：` .Session.identity_map`）。</p>
</div>
<div class="section" id="session-referencing-behavior">
<span id="id2"></span><h2>セッション参照動作<a class="headerlink" href="#session-referencing-behavior" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>セッション内のオブジェクトは弱く参照されます*。これは、外部アプリケーションで参照解除されると、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session`内から範囲外になり、Pythonインタプリタによってガベージコレクションが行われることを意味します。これには例外として、保留中のオブジェクト、削除済みとしてマークされたオブジェクト、または保留中の変更がある永続オブジェクトが含まれます。フルフラッシュの後、これらのコレクションはすべて空であり、すべてのオブジェクトは再び弱参照されます。</p>
<p>：class： <cite>.Session`のオブジェクトを強く参照させるには、通常は単純なアプローチが必要です。外部的に管理される強力な参照動作の例としては、主キーにキーされたローカル・ディクショナリにオブジェクトをロードすること、または参照する必要がある期間のリストまたはセットにオブジェクトをロードすることが挙げられます。これらのコレクションは、必要に応じて：class： `.Session`に関連付けることができます。それらを：attr：</cite> .Session.info`ディクショナリに配置します。</p>
<p>イベントベースのアプローチも実現可能です。 ：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>persistent`状態のままであるすべてのオブジェクトに対して&amp;quot;強い参照&amp;quot;動作を提供する簡単なレシピは次のとおりです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">strong_reference_session</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;pending_to_persistent&quot;</span><span class="p">)</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;deleted_to_persistent&quot;</span><span class="p">)</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;detached_to_persistent&quot;</span><span class="p">)</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;loaded_as_persistent&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strong_ref_object</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;refs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sess</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">sess</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">refs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]</span>

        <span class="n">refs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>


    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;persistent_to_detached&quot;</span><span class="p">)</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;persistent_to_deleted&quot;</span><span class="p">)</span>
    <span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;persistent_to_transient&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">deref_object</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span></pre></div>
</div>
<p>上記のように、：meth： <cite>.SessionEvents.pending_to_persistent</cite>、：meth：` .SessionEvents.detached_to_persistent`、：meth： <cite>.SessionEvents.deleted_to_persistent`と：meth：</cite> .SessionEvents.loaded_as_persistent`イベントをインターセプトして傍受しますオブジェクトは：term： <cite>persistent`遷移を入力し、：meth：</cite> .SessionEvents.persistent_to_detached`と：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SessionEvents.persistent_to_deleted`は、オブジェクトが永続状態を離れるときにオブジェクトを傍受するためにフックします。</p>
<p>上記の関数はper-：class： <cite>.Session</cite> basisで強い参照動作を提供するために：class：` .Session`のいずれかを呼び出すことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>

<span class="n">my_session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">strong_reference_session</span><span class="p">(</span><span class="n">my_session</span><span class="p">)</span></pre></div>
</div>
<p>また、どのクラスでも呼び出すことができます：class： <cite>.sessionmaker</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>

<span class="n">maker</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>
<span class="n">strong_reference_session</span><span class="p">(</span><span class="n">maker</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="merging">
<span id="unitofwork-merging"></span><h2>マージ<a class="headerlink" href="#merging" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜。Session.merge`は、外部オブジェクトからセッション内の新しいインスタンスまたは既存のインスタンスに状態を転送します。また、着信データをデータベースの状態と照合して、次のフラッシュに適用される履歴ストリームを生成するか、または変更履歴を生成せずに、またはデータベースにアクセスすることなく簡単な状態の「転送」を行うことができます。使用方法は次のとおりです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">merged_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">existing_object</span><span class="p">)</span></pre></div>
</div>
<p>インスタンスが指定されると、次の手順に従います。</p>
<ul>
<li><p class="first">インスタンスの主キーを調べます。存在する場合は、そのインスタンスをローカルIDマップに配置しようとします。 `` load = True``フラグがデフォルトのまま残っている場合、ローカルに存在しない場合には、この主キーのデータベースもチェックします。</p>
</li>
<li><p class="first">指定されたインスタンスに主キーがない場合、または主キーが指定されたインスタンスが見つからない場合、新しいインスタンスが作成されます。</p>
</li>
<li><p class="first">指定されたインスタンスの状態は、配置された/新たに作成されたインスタンスにコピーされます。ソースインスタンスに存在する属性の場合、値はターゲットインスタンスに転送されます。ソースに存在しないマップされた属性の場合、属性はターゲットインスタンスで期限切れになり、既存の値は破棄されます。</p>
<p>`` load = True``フラグがデフォルトのまま残っている場合、このコピープロセスはイベントを送出し、ソースオブジェクトに存在する各属性のターゲットオブジェクトのアンロードされたコレクションをロードします。データベース。 `` load``が `` False``として渡された場合、入ってくるデータは履歴を生成せずに直接 &amp;quot;刻印&amp;quot;されます。</p>
</li>
<li><p class="first">操作は、 `` merge``カスケード（参照：ref： <cite>unitofwork_cascades</cite>）で示されているように、関連するオブジェクトやコレクションにカスケードされます。</p>
</li>
<li><p class="first">新しいインスタンスが返されます。</p>
</li>
</ul>
<p>：meth： <cite>〜.Session.merge`を使って、与えられた&amp;quot; source &amp;quot;インスタンスは変更されず、target：class：</cite> .Session`にも関連付けられず、残りの任意の数とマージされたままです：クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`オブジェクト。 ：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Session.merge`は、元のオブジェクトや現在のセッションの関連付けを気にせずにオブジェクト構造体の状態を取得し、その状態を新しいセッションにコピーするのに便利です。いくつかの例があります：</p>
<ul>
<li><p class="first">ファイルからオブジェクト構造体を読み込んでデータベースに保存したいアプリケーションは、ファイルを解析し、構造体を構築し、それをデータベースに保存するために：meth： <cite>〜。Session.merge`を使用します。ファイル内のデータは、構造の各要素の主キーを作成するために使用されます。後でファイルが変更されたときに、同じプロセスを再実行することができます。これは、わずかに異なるオブジェクト構造を生成し、再び `</cite> merge &amp;#39;&amp;#39;することができます。：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.session.Session <a href="#id3"><span class="problematic" id="id4">`</span></a>はそれらの変更を反映するためにデータベースを自動的に更新し、プライマリキーでデータベースから各オブジェクトを読み込み、与えられた新しい状態で状態を更新します。</p>
</li>
<li><p class="first">アプリケーションは、複数の：class： <cite>.Session`オブジェクトによって同時に共有されるメモリ内キャッシュにオブジェクトを格納しています。 ：meth： `〜.Session.merge`は、オブジェクトをキャッシュから取り出してそれを要求するclass：</cite> .Session`のそれぞれにローカルコピーを作成するたびに使用されます。キャッシュされたオブジェクトは切り離されたままです。その状態だけがindividual：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session`オブジェクトのローカルにコピーされます。</p>
<p>キャッシングの使用例では、 `` load = False``フラグを使用してオブジェクトの状態をデータベースと照合するオーバーヘッドを除去するのが一般的です。 ：meth： <cite>〜。Session.merge`と呼ばれる一括バージョンもあります：meth：</cite>〜.Query.merge_result`これはcache-extended：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトで動作するように設計されていますセクション：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>examples_caching`を参照してください。</p>
</li>
<li><p class="first">アプリケーションは、一連のオブジェクトの状態を、ワーカースレッドまたは他の並行システムによって維持される：class： <cite>.Session`に転送することを望んでいます。 ：meth： `〜.Session.merge`は、この新しい：class：</cite> .Session`に配置される各オブジェクトのコピーを作成します。操作の終わりに、親スレッド/プロセスは、それが開始したオブジェクトを維持し、スレッド/ワーカーはそれらのオブジェクトのローカルコピーを進めることができます。</p>
<p>&amp;quot;スレッド間/プロセス間の転送&amp;quot;ユースケースでは、データが転送される際にオーバヘッドや冗長なSQLクエリを避けるために、アプリケーションは `` load = False``フラグも使用することができます。</p>
</li>
</ul>
<div class="section" id="merge-tips">
<h3>マージのヒント<a class="headerlink" href="#merge-tips" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜。Session.merge`は多くの目的のために非常に便利なメソッドです。ただし、一時的/分離状態のオブジェクトと永続的なオブジェクトの複雑な境界線、および状態の自動転送を処理します。多くのシナリオでは、オブジェクトの状態をより慎重に検討する必要があります。通常、マージの一般的な問題は、渡されるオブジェクトに関するいくつかの予想外の状態を含みます：meth： `〜。Session.merge</cite>。</p>
<p>UserオブジェクトとAddressオブジェクトの標準的な例を使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></pre></div>
</div>
<p>1つの `` Address``を持つ `` User``オブジェクトが既に永続的であると仮定してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="p">[</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s1">&#39;ed@ed.com&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
<p>セッションの外にあるオブジェクトである `` a1``を作成し、既存の `` Address``の上にマージします：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">existing_a1</span> <span class="o">=</span> <span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">existing_a1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></pre></div>
</div>
<p>私たちがこれを言ったら驚きが起こります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="go">sqlalchemy.orm.exc.FlushError: New instance &lt;Address at 0x1298f50&gt;</span>
<span class="go">with identity key (&lt;class &#39;__main__.Address&#39;&gt;, (1,)) conflicts with</span>
<span class="go">persistent instance &lt;Address at 0x12a25d0&gt;</span></pre></div>
</div>
<p>何故ですか ？カスケードには注意を払っていませんでした。永続オブジェクトへの `` a1.user``の割り当ては、 `` User.addresses``のバックリファレンスにカスケードされ、 `` a1``オブジェクトが追加されたかのように保留状態になりました。セッションで2つの `` Address``オブジェクトがあります：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">existing_a1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="ow">is</span> <span class="n">existing_a1</span>
<span class="go">False</span></pre></div>
</div>
<p>上記で、私たちの `` a1``は既にセッション中に保留中です。後続の：meth： <cite>〜。Session.merge`オペレーションは本質的に何もしません。カスケードは：func： `.relationship`の：paramref：</cite>〜.relationship.cascade`オプションで設定することができますが、この場合、 `` save-update``カスケードを `` User.addressesその関係は非常に便利です。ここでの解決策は、通常、ターゲットセッションですでに永続しているオブジェクトに `` a1.user``を割り当てないことです。</p>
<p>：func： <cite>.relationship`の</cite> <cite>cascade_backrefs = False``オプションは、</cite> <cite>a1.user = u1``割り当てによって</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Address``がセッションに追加されないようにします。</p>
<p>カスケード演算の詳細は：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>unitofwork_cascades`を参照してください。</p>
<p>予期しない状態の別の例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">existing_a1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="n">u1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="go">sqlalchemy.exc.IntegrityError: (IntegrityError) address.user_id</span>
<span class="go">may not be NULL</span></pre></div>
</div>
<p>ここでは、a1.userにアクセスしました。このデフォルト値は `` None``を返しました。このアクセスの結果、オブジェクト `` a1``の `` __dict__``に配置されました。通常、この操作は変更イベントを作成しないので、フラッシュ中に `` user_id``属性が優先されます。しかし、 `` Address``オブジェクトをセッションにマージすると、操作は次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">existing_a1</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">existing_a1</span><span class="o">.</span><span class="n">id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">existing_a1</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">u1</span><span class="o">.</span><span class="n">id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">existing_a1</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="kc">None</span></pre></div>
</div>
<p>上記の場合、 `` user_id``と `` user``の両方に割り当てられ、両方の変更イベントが発行されます。 `` user``の関連付けが優先され、 `` user_id``にNoneが適用され、失敗します。</p>
<p>ほとんど：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜。Session.merge`の問題は最初にチェックすることで調べることができます - セッション中のオブジェクトが早すぎますか？</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">existing_a1</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">a1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">session</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></pre></div>
</div>
<p>それとも、私たちが望んでいないオブジェクト上の状態はありますか？ `` __dict__``を調べることは簡単な方法です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">existing_a1</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{&#39;_sa_instance_state&#39;: &lt;sqlalchemy.orm.state.InstanceState object at 0x1298d10&gt;,</span>
<span class="go">    &#39;user_id&#39;: 1,</span>
<span class="go">    &#39;id&#39;: 1,</span>
<span class="go">    &#39;user&#39;: None}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># we don&#39;t want user=None merged, remove it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a1</span><span class="o">.</span><span class="n">user</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># success</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></pre></div>
</div>
</div>
</div>
<div class="section" id="expunging">
<h2>絶滅<a class="headerlink" href="#expunging" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Expungeは、Sessionからオブジェクトを削除し、永続インスタンスを分離状態に、保留インスタンスを一時状態に送信します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">expunge</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span></pre></div>
</div>
<p>すべての項目を削除するには、meth： <cite>〜.Session.expunge_all`を呼び出します（このメソッドは以前は</cite> <cite>clear（）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>でした）。</p>
</div>
<div class="section" id="refreshing-expiring">
<span id="session-expire"></span><h2>リフレッシュ/期限切れ<a class="headerlink" href="#refreshing-expiring" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>Expiring`は、一連のオブジェクト属性内に保持されているデータベース持続データが消去され、その属性が次にアクセスされるときにデータベースからそのデータをリフレッシュするSQLクエリが発行されることを意味します。</p>
<p>データの有効期限について話すとき、私たちは通常、用語：永続的な状態にあるオブジェクトについて話しています。たとえば、次のようにオブジェクトをロードするとします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;user1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></pre></div>
</div>
<p>上記の `` User``オブジェクトは永続的であり、一連の属性を持っています。私たちが `` __dict__``を調べると、状態が読み込まれていることがわかります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{</span>
<span class="go">  &#39;id&#39;: 1, &#39;name&#39;: u&#39;user1&#39;,</span>
<span class="go">  &#39;_sa_instance_state&#39;: &lt;...&gt;,</span>
<span class="go">}</span></pre></div>
</div>
<p>ここで、 `` id``と `` name``はデータベースの列を参照します。 `` _sa_instance_state``はSQLAlchemyによって内部的に使われる非データベース永続化された値です（これはインスタンスの：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.InstanceState`を参照していますが、このセクションには直接関係しませんが、それにアクセスするには：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.inspect`関数を使うべきです）。</p>
<p>この時点で、 `` User``オブジェクトの状態は、ロードされたデータベース行の状態と一致します。しかし、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>。Session.expire`のようなメソッドを使ってオブジェクトを期限切れにすると、状態が削除されていることがわかります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{&#39;_sa_instance_state&#39;: &lt;...&gt;}</span></pre></div>
</div>
<p>内部の &amp;quot;状態&amp;quot;は依然としてハングしますが、 &amp;quot;id&amp;quot;と &amp;quot;name&amp;quot;列に対応する値はなくなっています。これらの列の1つにアクセスしてSQLを見ていると、次のようになります。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<div class='show_sql'>SELECT user.id AS user_id, user.name AS user_name
FROM user
WHERE user.id = ?
(1,)
</div><span class="n">user1</span></pre></div>
</div>
<p>上記のように、期限切れの属性 `` user.name``にアクセスすると、ORMは、このユーザが参照するユーザ行に対してSELECTを発行することにより、データベースから最新の状態を取得するために：term： <cite>lazy load`を開始しました。その後、 `</cite> __dict__``が再び生成されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{</span>
<span class="go">  &#39;id&#39;: 1, &#39;name&#39;: u&#39;user1&#39;,</span>
<span class="go">  &#39;_sa_instance_state&#39;: &lt;...&gt;,</span>
<span class="go">}</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">SQLAlchemyがオブジェクト属性で何をするのかを見るために `` __dict__``の中を覗いていますが、<a href="#id1"><span class="problematic" id="id2">**</span></a>少なくとも <cite>__dict__`の内容を**これらの属性まで直接変更してはいけませんSQLAlchemy ORMが維持している（SQLAの領域外の他の属性は問題ありません）。これは、SQLAlchemyがオブジェクトに対して行った変更を追跡するためにSQLAlchemyが：term： `descriptors`を使用し、</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>__dict__``を直接変更すると、ORMは変更したものを追跡できなくなるからです。</p>
</div>
<p>：meth： <cite>〜.Session.expire`と：meth：</cite>〜.Session.refresh`のもう一つの重要な振る舞いは、オブジェクト上のフラッシュされていないすべての変更が破棄されることです。つまり、 `` User``の属性を変更する場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;user2&#39;</span></pre></div>
</div>
<p>しかし、最初に：meth： <cite>〜.Session.flush`を呼び出さずに：meth：</cite>〜。Session.expire`を呼び出すと、保留中の `` &amp;#39;user2```の値は破棄されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;user1&#39;</span></pre></div>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.expire`メソッドは、インスタンスのORMでマップされたすべての属性を&amp;quot; expired &amp;quot;としてマークするために使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># expire all ORM-mapped attributes on obj1</span>
<span class="n">session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span></pre></div>
</div>
<p>また、文字列属性名のリストを渡すこともできます。これは、期限切れとマークされる特定の属性を参照しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># expire only attributes obj1.attr1, obj1.attr2</span>
<span class="n">session</span><span class="o">.</span><span class="n">expire</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;attr1&#39;</span><span class="p">,</span> <span class="s1">&#39;attr2&#39;</span><span class="p">])</span></pre></div>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.refresh`メソッドは似たようなインターフェースを持っていますが、期限切れではなく、直ちにオブジェクトの行に対する即時SELECTを出します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># reload all attributes on obj1</span>
<span class="n">session</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>〜.Session.refresh`は文字列属性名のリストも受け付けますが、：meth：</cite>〜.Session.expire`と違って、少なくとも一つの名前が列マップ属性の名前であると期待します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># reload obj1.attr1, obj1.attr2</span>
<span class="n">session</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;attr1&#39;</span><span class="p">,</span> <span class="s1">&#39;attr2&#39;</span><span class="p">])</span></pre></div>
</div>
<p>：meth： <cite>.Session.expire_all`メソッドは：class：</cite> .Session`内に含まれる全てのオブジェクトに対して：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>。Session.expire`を本質的に呼び出すことを可能にします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">expire_all</span><span class="p">()</span></pre></div>
</div>
<div class="section" id="what-actually-loads">
<h3>実際に何が読み込まれるか<a class="headerlink" href="#what-actually-loads" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>〜.Session.expire`とマークされたオブジェクトまたは：meth：</cite>〜.Session.refresh`でロードされたオブジェクトが、以下を含むいくつかの要因に基づいて変化するときに放出されるSELECTステートメント：</p>
<ul class="simple">
<li>期限切れ属性のロードは、<a href="#id1"><span class="problematic" id="id2">**</span></a>列マップされた属性**のみからトリガーされます。 ：func： <cite>.relationship</cite>  - マップされた属性を含む任意の種類の属性を期限切れとマークすることができますが、expired：func：` .relationship`属性にアクセスすると、標準的な関係指向のLazy読み込み中。カラム指向の属性は、期限切れになってもこの操作の一部としてロードされず、カラム指向の属性にアクセスするとロードされます。</li>
<li>：func： <cite>.relationship</cite>-マップされた属性は、アクセスされている期限切れの列ベースの属性に応じてロードされません。</li>
<li>リレーションシップに関して、：meth： <cite>〜.Session.refresh`は、カラムマッピングされていない属性に関して：meth：</cite>〜。Session.expire`よりも制限的です。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.refresh`を呼び出し、リレーションシップマップされた属性のみを含む名前のリストを渡すと、実際にはエラーが発生します。いずれの場合でも、非eager-loading：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.relationship`属性は、リフレッシュ操作には含まれません。</li>
<li>：paramref： <cite>〜.relationship.lazy`パラメータを介して&amp;quot; eager loading &amp;quot;として設定された：func：</cite> .relationship`属性は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session.refresh`の場合にロードされます。名前が指定されている場合、またはリフレッシュされる属性のリストにその名前が含まれている場合</li>
<li>属性：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.deferred`で設定された属性は、期限切れ属性のロード中またはリフレッシュ中に通常ロードされません。 ：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.deferred`は、直接アクセスされたとき、またはそのグループのアンロードされた属性がアクセスされる遅延属性の&amp;quot; group &amp;quot;の一部である場合、それ自身でロードします。</li>
<li>アクセス時にロードされる期限切れの属性の場合、継承継承テーブルのマッピングでは、通常はアンロードされた属性が存在するテーブルのみが含まれるSELECTが生成されます。ここでのアクションは、親テーブルまたは子テーブルのみをロードするのに十分なほど洗練されています。たとえば、元々期限切れになっていた列のサブセットがこれらのテーブルの一方または他方を含む場合です。</li>
<li>継承 - 継承テーブルマッピングで：meth： <cite>〜.Session.refresh`が使用された場合、ターゲットオブジェクトのクラスで：meth：</cite> .Session.query`が使用されたときに生成されるSELECTは似ています。これは、通常、マッピングの一部として設定されているすべてのテーブルです。</li>
</ul>
</div>
<div class="section" id="when-to-expire-or-refresh">
<h3>期限切れまたは更新する時期<a class="headerlink" href="#when-to-expire-or-refresh" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <cite>.Session`は、セッションが参照するトランザクションが終了するたびに自動的に満了機能を使います。つまり、：meth： `.Session.commit`または：meth：</cite> .Session.rollback`が呼び出されると、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`内のすべてのオブジェクトが、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>。Session.expire_all`メソッド。その根拠は、トランザクションの終了は、データベースの現在の状態が何であるかを知るために利用可能なコンテキストが存在しない境界点であり、他のトランザクションがそれに影響を及ぼす可能性があるためです。新しいトランザクションが開始されたときだけ、データベースの現在の状態に再度アクセスすることができます。この時点で、いくつかの変更が発生している可能性があります。</p>
<div class="sidebar">
<p class="first sidebar-title">Transaction Isolation</p>
<p class="last">もちろん、ほとんどのデータベースでは、同じ行のデータを含めても、一度に複数のトランザクションを処理することができます。リレーショナルデータベースが同じテーブルや行を含む複数のトランザクションを処理するとき、これはデータベースの：term： <a href="#id1"><span class="problematic" id="id2">`</span></a>isolation`アスペクトが有効になるときです。異なるデータベースの分離動作はかなり異なり、1つのデータベースでも（いわゆる：term： <a href="#id3"><span class="problematic" id="id4">`</span></a>分離レベル &amp;#39;の設定によって）異なる方法で動作するように構成できます。その意味で、：class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Session`は、同じSELECT文が2回目に放出されたときに、すでに持っているデータを確実に返すか、新しいデータを返すかを完全に予測することはできません。したがって、トランザクションの範囲内で、特定の行を変更するためにSQL式が発行されていることがわかっていない限り、明示的に指示されない限り行をリフレッシュする必要はありません。</p>
</div>
<p>：meth： <cite>.Session.expire`メソッドと：meth：</cite> .Session.refresh`メソッドは、オブジェクトがデータベースからデータを再ロードすることを強制したい場合に使用されます。データの現在の状態が失効している可能性があります。これには以下の理由が考えられます。</p>
<ul class="simple">
<li>：meth： <cite>.Table.update`コンストラクトが：meth：</cite> .Session.execute`メソッドを使用して生成された場合など、ORMのオブジェクト処理の範囲外でトランザクション内にいくつかのSQLが送出されました。</li>
<li>アプリケーションが並行トランザクションで変更されていることがわかっているデータを取得しようとしている場合に、このアイソレーションルールが実際にこのデータを表示できることも知られています。</li>
</ul>
<p>2番目の箇条書きは重要な注意点がありますが、実際には隔離ルールがこのデータを見ることができるということも知られています。これは、別のデータベース接続で起こったUPDATEがまだここに見えないローカル;多くの場合、そうではありません。これは、進行中のトランザクション間のデータを表示するために、：meth： <cite>.expire`または：meth：</cite> .refresh`を使用する場合、効果的な分離動作を理解することが不可欠です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>。Session.expire</cite></p>
<p>：meth： <cite>.Session.expire_all</cite></p>
<p>：meth： <cite>.Session.refresh</cite></p>
<p>：term： <cite>isolation</cite>  -  Wikipediaへのリンクを含む隔離の用語解説。</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">`</span></a>SQLAlchemyセッションの詳細&lt;<a class="reference external" href="http://techspot.zzzeek.org/2012/11/14/pycon-canada-the-sqlalchemy-session-in-depth/">http://techspot.zzzeek.org/2012/11/14/pycon-canada-the-sqlalchemy-session-in-depth/</a>&gt; <a href="#id3"><span class="problematic" id="id4">`</span></a>_  - ビデオ+スライドで、データの有効期限の役割を含むオブジェクトライフサイクルの詳細な議論が行われます。</p>
</div>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="session_basics.html" title="previous chapter">セッションの基礎</a>
        Next:
        <a href="cascades.html" title="next chapter">カスケード</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



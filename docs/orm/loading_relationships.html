<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    関係の読み込み手法
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="オブジェクトの読み込み" href="loading_objects.html" />
        <link rel="next" title="継承階層のロード" href="inheritance_loading.html" />
        <link rel="prev" title="列の読み込み" href="loading_columns.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="loading_columns.html">列の読み込み</a></span></li>
<li class="selected"><span class="link-container first"><strong>関係の読み込み手法</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#configuring-loader-strategies-at-mapping-time">マッピング時のローダー戦略の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#controlling-loading-via-options">オプションによる読み込みの制御</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#lazy-loading">レイジーロード</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#preventing-unwanted-lazy-loads-using-raiseload">raiseloadを使用して不要な遅延ロードを防止する</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#joined-eager-loading">参加したEager Loading</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#joined-eager-loading-and-result-set-batching">eager loadingとresult set batchingに参加しました</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#the-zen-of-joined-eager-loading">結合されたEager Loadingの禅</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#subquery-eager-loading">サブクエリのEager Loading</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#the-importance-of-ordering">注文の重要性</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#select-in-loading">INロードを選択</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#what-kind-of-loading-to-use">どのようなローディングを使用するのですか？</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#polymorphic-eager-loading">多形Eager Loading</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#wildcard-loading-strategies">ワイルドカード読み込み方針</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#per-entity-wildcard-loading-strategies">エンティティごとのワイルドカード読み込み方法</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#routing-explicit-joins-statements-into-eagerly-loaded-collections">明示的な結合/ステートメントを熱心に読み込まれたコレクションにルーティングする</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#using-contains-eager-to-load-a-custom-filtered-collection-result">contains_eager（）を使用してカスタムフィルタリングされたコレクションの結果をロードする</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#advanced-usage-with-arbitrary-statements">任意のステートメントによる高度な使用</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#creating-custom-load-rules">カスタムロードルールの作成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#relationship-loader-api">リレーションシップローダーAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="inheritance_loading.html">継承階層のロード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="constructors.html">コンストラクタとオブジェクトの初期化</a></span></li>
<li><span class="link-container first"><a class="reference external" href="query.html">クエリAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="relationship-loading-techniques">
<span id="loading-toplevel"></span><h1>関係の読み込み手法<a class="headerlink" href="#relationship-loading-techniques" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>SQLAlchemyの大きな部分は、クエリの際に関連オブジェクトがどのように読み込まれるかを幅広く制御しています。 &amp;quot;関連オブジェクト&amp;quot;では、func： <cite>.relationship`を使用してマッパー上で設定されたコレクションまたはスカラー関連を参照します。この動作は、：func： `.relationship`関数への：paramref：</cite> .relationship.lazy`パラメータの使用や、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトでのオプションの使用によって、マッパー構築時に設定することができます。</p>
<p>関係のロードは3つのカテゴリに分類されます。 <strong>怠惰な**ローディング、**熱心な**ローディング、</strong> <strong>ローディング</strong>。レイジーローディングとは、最初に関連オブジェクトがロードされていないクエリからオブジェクトが返されることを指します。指定されたコレクションまたは参照が最初に特定のオブジェクトでアクセスされると、要求されたコレクションがロードされるように追加のSELECTステートメントが発行されます。</p>
<p>熱心な読み込みとは、関連するコレクションまたはスカラー参照がすでに読み込まれているクエリから返されたオブジェクトを指します。 ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`は、関連する行を同時にロードするJOINで通常発生するSELECT文を拡張するか、コレクションまたはスカラー参照を一度に読み込むためにプライマリ文の後に追加のSELECT文を発行することによって、これを実現します。</p>
<p>&amp;quot;No &amp;quot;ロードとは、属性が空であり、ロードされていないこと、またはアクセス時にエラーが発生して、不要な遅延ロードを防ぐために、特定の関係でロードを無効にすることを指します。</p>
<p>関係ロードの主要な形式は次のとおりです。</p>
<ul class="simple">
<li>** lazy loading **  -  `` lazy = &amp;#39;&amp;#39; select&amp;#39;``または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.lazyload`オプションを介して利用可能です。これは属性参照時にSELECT文を発行して関連参照を遅延ロードするロードの形式です一度に1つのオブジェクトに適用されます。遅延ロードは、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>lazy_loading`で詳しく説明しています。</li>
<li><strong>結合されたローディング</strong>  -  `` lazy = &amp;#39;joined&amp;#39;``または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.joinedload`オプションを介して利用可能なこのローディング形式は、関連するローが同じにロードされるようにJOINを与えられたSELECT文に適用します結果セット。結合されたeagerローディングの詳細は、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>joined_eager_loading`を参照してください。</li>
<li><strong>サブクエリの読み込み</strong>  -  `` lazy = &amp;#39;&amp;#39; subquery&amp;#39;``または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.subqueryload`オプションを介して利用できるこのローディング形式は、サブクエリの内部に埋め込まれた元のクエリを再記述する2番目のSELECT文を発行します関連するテーブルにサブクエリしてロードされるJOINは、関連するコレクション/スカラー参照のすべてのメンバーを一度にロードします。サブクエリの読み込みは、ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>subquery_eager_loading`で詳しく説明しています。</li>
<li>** IN INローディング**  -  `` lazy = &amp;#39;selectin&amp;#39;``または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.selectinload`オプションを介して利用可能です。このローディング形式は、次の（またはそれ以上の）SELECT文を発行します。親オブジェクトをIN句に変換します。これにより、関連するコレクション/スカラー参照のすべてのメンバーがプライマリキーによって一度に読み込まれます。 INロードの詳細は：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>selectin_eager_loading`を参照してください。</li>
<li>** loading raise **  -  `` lazy = &amp;#39;raise&amp;#39;``、 `` lazy =&amp;#39; raise_on_sql&amp;#39;``、または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.raiseload`オプションを介して利用可能ですが、この形式の読み込みは同時にトリガされます通常は遅延ロードが発生しますが、アプリケーションから不要な遅延ロードを防ぐためにORM例外が発生します。ローディングを開始する方法は、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>prevent_lazy_with_raiseload`です。</li>
<li>** no loading **  -  `` lazy = &amp;#39;noload&amp;#39;``または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.noload`オプションで利用できます。この読み込みスタイルは、属性を読み込まない、または読み込み効果を持たない空の属性に変換します。 &amp;quot;noload &amp;quot;は非常に珍しいローダーオプションです。</li>
</ul>
<div class="section" id="configuring-loader-strategies-at-mapping-time">
<h2>マッピング時のローダー戦略の設定<a class="headerlink" href="#configuring-loader-strategies-at-mapping-time" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>特定のリレーションシップに対するローダー戦略は、マップされた型のオブジェクトがロードされるすべてのケースで、変更するクエリレベルのオプションがない場合に、マッピング時に構成することができます。これは、：paramref： <cite>.relationship.lazy`パラメータを使って設定されます：func：</cite> .relationship`;このパラメータの一般的な値には、 `` select``、 `` joined``、 `` subquery``、および `` selectin``があります。</p>
<p>たとえば、親オブジェクトが照会されたときに結合されたeagerローディングを使用するように関係を構成するには、次のようにします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Child&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;joined&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記では、 `` Parent``オブジェクトのコレクションがロードされるたびに、 `` Parent``の各オブジェクトは `` Parent``オブジェクトのクエリにJOINを追加した行を使って、 `` 。このロードスタイルの背景については、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>joined_eager_loading`を参照してください。</p>
<p>：paramref： <cite>.relationship.lazy`引数のデフォルト値は</cite> <cite>&amp;quot; select &amp;quot;</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>です。これは遅延ロードを示します。さらなる背景については：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>lazy_loading`を参照してください。</p>
</div>
<div class="section" id="controlling-loading-via-options">
<span id="relationship-loader-options"></span><h2>オプションによる読み込みの制御<a class="headerlink" href="#controlling-loading-via-options" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ローディング戦略を構成するもう1つの、もっと一般的な方法は、特定の属性に対してクエリごとにそれらを設定することです。ローダーオプションを使用してリレーションシップロードを非常に詳細に制御できます。最も一般的なのは：func： <cite>〜sqlalchemy.orm.joinedload</cite>、：func：<cite>〜sqlalchemy.orm.subqueryload</cite>、：func： <cite>〜sqlalchemy.orm.selectinload`と：func：</cite>〜sqlalchemy.orm.lazyload <a href="#id1"><span class="problematic" id="id2">`</span></a>。このオプションは、親に対する属性の文字列名を受け入れるか、またはより細かくするためにクラスバインド属性を直接受け入れることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># set children to load lazily</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># same, using class-bound attribute</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">lazyload</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">children</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># set children to load eagerly with a join</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>ローダオプションは**メソッド連鎖**を使用して&amp;quot;連鎖&amp;quot;することもできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">.</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">Child</span><span class="o">.</span><span class="n">subelements</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>連鎖されたローダオプションは、ロードされたコレクションに適用することができます。つまり、コレクションまたは関連付けがアクセス時に遅延ロードされると、指定されたオプションが有効になります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">.</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">Child</span><span class="o">.</span><span class="n">subelements</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上記の場合、クエリは `` children``コレクションがロードされていない `` Parent``オブジェクトを返します。特定の `` Parent``オブジェクトの `` children``コレクションが最初にアクセスされると、関連するオブジェクトを遅延ロードしますが、 `` children``の各メンバの `` subelementments``コレクションにさらに熱心な読み込みを適用します`。</p>
<p>メソッド連鎖を使用すると、パス内の各リンクのローダスタイルが明示的に記述されます。特定の属性の既存のローダースタイルを変更せずにパスをナビゲートするには、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.defaultload`メソッド/関数を使用することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">defaultload</span><span class="p">(</span><span class="s2">&quot;atob&quot;</span><span class="p">)</span><span class="o">.</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="s2">&quot;btoc&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>オブジェクトの遅延ロードされたコレクションに適用されるローダオプションは、特定のオブジェクトインスタンスに対して**スティッキー**の**です。つまり、メモリ内に存在する限り、特定のオブジェクトによってロードされたコレクションに保持されます。たとえば、前述の例を考えます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">.</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">Child</span><span class="o">.</span><span class="n">subelements</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上記のクエリでロードされた特定の `` Parent``オブジェクトの `` children``コレクションが（class： <cite>.Session`オブジェクトのトランザクションがコミットまたはロールバックされたとき、または：meth：`のように）期限切れの場合。 Session.expire_all`が使用されている）、 `</cite> Parent.children``コレクションが次回アクセスされたときに再び読み込まれると、 `` Child.subelements``コレクションはサブクエリeager loadingを使って再度ロードされます。上記の `` Parent``オブジェクトが別のオプションセットを指定した後続のクエリからアクセスされたとしても、それは削除されません。既存のオブジェクトを削除せずにリロードするオプションを変更するには、 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.populate_existing`メソッド:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># change the options on Parent objects that were already loaded</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">populate_existing</span><span class="p">()</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">.</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Child</span><span class="o">.</span><span class="n">subelements</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>上記のオブジェクトが：class： <cite>.Session`から完全に消去された場合、ガベージコレクションや：meth：</cite> .Session.expunge_all`が使用された場合など、&amp;quot;sticky &amp;quot;オプションもなくなります。新たに作成されたオブジェクトは、再度読み込まれた場合に新しいオプションを使用します。</p>
<p class="last">SQLAlchemyの将来のリリースでは、既にロードされているオブジェクトのローダオプションを操作するための代替手段が追加される可能性があります。</p>
</div>
</div>
<div class="section" id="lazy-loading">
<span id="id1"></span><h2>レイジーロード<a class="headerlink" href="#lazy-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>デフォルトでは、すべてのオブジェクト間の関係は**遅延読み込み**です。 a：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.relationship`に関連するスカラー属性またはコレクション属性には、属性が初めてアクセスされたときにトリガされるトリガが含まれます。通常、このトリガーは、関連するオブジェクトをロードするために、アクセスポイントでSQLコールを発行します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span><span class="o">.</span><span class="n">addresses</span>
<div class='show_sql'>SELECT
    addresses.id AS addresses_id,
    addresses.email_address AS addresses_email_address,
    addresses.user_id AS addresses_user_id
FROM addresses
WHERE ? = addresses.user_id
[5]
</div><span class="p">[</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Address</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;j25@yahoo.com&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">]</span></pre></div>
</div>
<p>SQLが発行されない1つのケースは、関連オブジェクトが主キーだけで識別され、そのオブジェクトがcurrent：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session`にすでに存在する場合、単純な多対1の関係です。この理由から、レイジーローディングは、関連するコレクションでは高価になる可能性がありますが、比較的少数の可能なターゲットオブジェクトに対して単純な多対1のオブジェクトをたくさん読み込んでいる場合、遅延読み込みはこれらを参照できる可能性があります親オブジェクトと同数のSELECT文を発行することなく、ローカルにオブジェクトを作成できます。</p>
<p>属性アクセス時にロードするこのデフォルトの動作は、&amp;quot;lazy &amp;quot;または&amp;quot;select &amp;quot;ローディングと呼ばれます。&amp;quot;SELECT &amp;quot;という名前は属性が最初になるとアクセスされました。</p>
<p>Lazyローディングは、通常は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.lazyload`ローダーオプションを使用して他の方法で設定されている特定の属性に対して有効にすることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">lazyload</span>

<span class="c1"># force lazy loading for an attribute that is set to</span>
<span class="c1"># load some other way normally</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">lazyload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span></pre></div>
</div>
<div class="section" id="preventing-unwanted-lazy-loads-using-raiseload">
<span id="prevent-lazy-with-raiseload"></span><h3>raiseloadを使用して不要な遅延ロードを防止する<a class="headerlink" href="#preventing-unwanted-lazy-loads-using-raiseload" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <cite>.lazyload`戦略は、オブジェクトリレーショナルマッピングで参照される最も一般的な問題の1つであるエフェクトを生成します。 ：term： `N plus one problem</cite>：ロードされたN個のオブジェクトに対して、遅延ロードされた属性にアクセスすると、N + 1個のSELECT文が発行されることを意味します。 SQLAlchemyでは、N + 1問題の通常の緩和策は、非常に能力のある熱心な負荷システムを使用することです。しかし、積極的な読み込みでは、読み込まれる属性を：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`で指定する必要があります。 lazyローディングが望ましくない、熱心にロードされなかった他の属性にアクセスする可能性のあるコードの問題は、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.raiseload`戦略を使って解決できます。このローダー戦略は、レイジーローディングの動作を有益なエラーに置き換えます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">raiseload</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">raiseload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span></pre></div>
</div>
<p>上記のクエリから読み込まれた `` User``オブジェクトには `` .addresses``コレクションがロードされません。後でこの属性にアクセスしようとしたコードがあると、ORM例外が発生します。</p>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.raiseload`は、すべてのリレーションシップがこの戦略を使用すべきであることを示すために、ワイルドカードという指定子とともに使用することができます。たとえば、熱心な負荷として1つの属性のみを設定し、残りのすべてをraise ::として設定するには、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">),</span> <span class="n">raiseload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上記のワイルドカードは、 `` items``だけでなく `` Order``だけでなく、 `` Item``オブジェクトのすべての関係にも適用されます。 `` Order``オブジェクトのみに対して：func： <cite>.raiseload`を設定するには、class：</cite> .orm.Load` ::でフルパスを指定してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Load</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">),</span> <span class="n">Load</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">raiseload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>逆に、 `` Item``オブジェクトだけのためにraiseを設定するには:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">raiseload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>wildcard_loader_strategies</cite></p>
</div>
</div>
</div>
<div class="section" id="joined-eager-loading">
<span id="id2"></span><h2>参加したEager Loading<a class="headerlink" href="#joined-eager-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>結合された熱心な負荷は、ORMにおける熱心な負荷の最も基本的なスタイルです。これは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`によって生成されたSELECT文にJOIN（デフォルトでLEFT OUTER結合）を接続し、親のものと同じ結果セットからターゲットスカラ/コレクションを移入することによって機能します。</p>
<p>マッピングレベルでは、次のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;joined&quot;</span><span class="p">)</span></pre></div>
</div>
<p>結合されたeagerローディングは、通常、マッピングのデフォルトローディングオプションではなく、特に多対1参照ではなくコレクションに使用されるときに、クエリのオプションとして適用されます。これは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.joinedload`ローダーオプションを使用して実現されます：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    addresses_1.id AS addresses_1_id,
    addresses_1.email_address AS addresses_1_email_address,
    addresses_1.user_id AS addresses_1_user_id,
    users.id AS users_id, users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
LEFT OUTER JOIN addresses AS addresses_1
    ON users.id = addresses_1.user_id
WHERE users.name = ?
[&#39;jack&#39;]</div></pre></div>
</div>
<p>デフォルトで発行されるJOINは、LEFT OUTER JOINで、関連する行を参照しないリードオブジェクトを許可します。参照する外部キーがNOT NULLである関連オブジェクトへの多対1の参照などの要素を持つことが保証されている属性の場合、内部結合を使用するとより効率的にクエリを実行できます。これは：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship.innerjoin`フラグを使ってマッピングレベルで利用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;users.id&#39;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;joined&quot;</span><span class="p">,</span> <span class="n">innerjoin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>クエリオプションレベルで、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.joinedload.innerjoin`フラグを使用して：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">innerjoin</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></pre></div>
</div>
<p>JOINは、OUTER JOINを含むチェーンに適用されたときに、右にネストします。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
<span class="o">...</span>     <span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>
<span class="o">...</span>     <span class="n">joinedload</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">widgets</span><span class="p">,</span> <span class="n">innerjoin</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    widgets_1.id AS widgets_1_id,
    widgets_1.name AS widgets_1_name,
    addresses_1.id AS addresses_1_id,
    addresses_1.email_address AS addresses_1_email_address,
    addresses_1.user_id AS addresses_1_user_id,
    users.id AS users_id, users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
LEFT OUTER JOIN (
    addresses AS addresses_1 JOIN widgets AS widgets_1 ON
    addresses_1.widget_id = widgets_1.id
) ON users.id = addresses_1.user_id</div></pre></div>
</div>
<p>SQLiteの古いバージョンでは、上記のネストされた右のJOINは、ネストされたサブクエリとしてレンダリングされる可能性があります。古いバージョンのSQLAlchemyは、すべての場合において、右ネストされた結合をサブクエリに変換します。</p>
<div class="section" id="joined-eager-loading-and-result-set-batching">
<h3>eager loadingとresult set batchingに参加しました<a class="headerlink" href="#joined-eager-loading-and-result-set-batching" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コレクションに適用すると結合されたeagerローディングの中心的な概念は、：class： <cite>.Query`オブジェクトが、照会される先頭のエンティティに対して行を重複除外しなければならないということです。上記のように、読み込んだ `</cite> User``オブジェクトが3つの `` Address``オブジェクトを参照すると、SQL文の結果には3つの行があります。まだ：class： <cite>.Query`はただ一つの</cite> <cite>User``オブジェクトしか返しません。前の行にロードされたばかりの `</cite> User``オブジェクトのために追加の行が受け取られると、新しい `` Address``オブジェクトを参照する追加の列は、その `` User.addresses``コレクション内の追加結果に導かれます特定のオブジェクト。</p>
<p>このプロセスは非常にトランスペアレントですが、結合されたeagerローディングは、コレクション読み込みに使用されるときは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`メソッドによって提供される&amp;quot;バッチ処理された&amp;quot;クエリ結果と互換性がありません。スカラー参照のために使用される結合されたeagerローディングは、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query.yield_per`と互換性があります。 ：meth： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Query.yield_per`メソッドは、コレクションベースのeagerローダーが参加している場合に例外がスローされます。</p>
<p>任意の大きなセットの結果データを使用して問合せを行うには、WHERE句を使用する行のサブセットを参照する複数のSELECT文（ウィンドウ処理など）を指定します。または、データベースドライバが複数の同時カーソル（SQLite、Postgresqlドライバ、サポートされていないもの）をサポートしていれば、** &amp;quot;select IN &amp;quot; eager loadingを使用することを検討してください。<strong>は</strong> meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`と互換性があります。 MySQLドライバまたはSQL Server ODBCドライバ）。</p>
</div>
<div class="section" id="the-zen-of-joined-eager-loading">
<span id="zen-of-eager-loading"></span><h3>結合されたEager Loadingの禅<a class="headerlink" href="#the-zen-of-joined-eager-loading" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>結合されたeager loadingは：meth： <cite>.Query.join`の使用に多くの類似点を持つように思われるので、いつ、どのように使用すべきかについて混乱を生むことがよくあります。それは、：meth： `.Query.join`がクエリの結果を変更するために使用されるのに対し、：func：</cite> .joinedload`は、照会し、代わりにレンダリングされた結合の効果を隠して、関連するオブジェクトのみが存在することを可能にする。</p>
<p>ローダ・ストラテジの背後にある考え方は、特定の問合せにロード・スキームのセットを適用できることです。<a href="#id1"><span class="problematic" id="id2">*</span></a>結果は変更されません。<a href="#id3"><span class="problematic" id="id4">*</span></a>関連オブジェクトおよびコレクションを完全にロードするために必要なSQL文の数のみが変更されます。すべての遅延ロードを使用して特定のクエリが開始される可能性があります。コンテキストで使用した後は、特定の属性やコレクションが常にアクセスされ、これらのローダー戦略を変更する方が効率的であることが明らかになります。戦略は他の変更を加えずに変更することができますが、結果は同じままですが、発行されるSQL文の数は少なくなります。理論的には（実際にはかなり）、class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Query`はローダー戦略の変更に基づいて、異なるプライマリオブジェクトや関連オブジェクトをロードすることはできません。</p>
<p>どのように：func： <cite>joinedload`は特に、何らかの形で返されたエンティティ行に影響を与えないというこの結果が、クエリに追加する結合の匿名エイリアスを作成し、クエリ。たとえば、以下のクエリは：func： `.joinedload`を使用して</cite> <cite>users``から</cite> <cite>addresses``までLEFT OUTER JOINを作成しますが、</cite> <cite>Address.email_address``に対して</cite> <cite>ORDER BY``を追加しますが有効でない - クエリで `</cite> Address``エンティティの名前が指定されていません：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    addresses_1.id AS addresses_1_id,
    addresses_1.email_address AS addresses_1_email_address,
    addresses_1.user_id AS addresses_1_user_id,
    users.id AS users_id,
    users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
LEFT OUTER JOIN addresses AS addresses_1
    ON users.id = addresses_1.user_id
WHERE users.name = ?
ORDER BY addresses.email_address   &lt;-- this part is wrong !
[&#39;jack&#39;]</div></pre></div>
</div>
<p>上記の `` ORDER BY addresses.email_address``は `` addresses``がFROMリストにないので有効ではありません。 `` User``レコードと電子メールアドレスで注文をロードする正しい方法は：meth： <cite>.Query.join</cite>：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>
SELECT
    users.id AS users_id,
    users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
JOIN addresses ON users.id = addresses.user_id
WHERE users.name = ?
ORDER BY addresses.email_address
[&#39;jack&#39;]</div></pre></div>
</div>
<p>上記の文はもちろん、前のものと同じではありません。つまり、 `` addresses``の列は結果にまったく含まれません。 ：func： <cite>.joinedload`を追加して、2つの結合が存在するようにします.1つは、私たちが注文しているものです。もう1つは、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>User.addresses``コレクションの内容を読み込むために匿名で使用されます。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    addresses_1.id AS addresses_1_id,
    addresses_1.email_address AS addresses_1_email_address,
    addresses_1.user_id AS addresses_1_user_id,
    users.id AS users_id, users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users JOIN addresses
    ON users.id = addresses.user_id
LEFT OUTER JOIN addresses AS addresses_1
    ON users.id = addresses_1.user_id
WHERE users.name = ?
ORDER BY addresses.email_address
[&#39;jack&#39;]</div></pre></div>
</div>
<p>上で見てきたのは、：meth： <cite>.Query.join`の使用法は、それ以降のクエリの基準で使用したいJOIN節を供給することです。func：</cite> .joinedload`の使用法は、その結果の `` User``ごとに `` User.addresses``コレクションを読み込みます。この場合、2つの結合はおそらく冗長であるように見えます。順序付けだけでなくコレクションのロードにも1つのJOINを使用したい場合は、以下の：ref： <cite>contains_eager`で説明されている：func：</cite> .contains_eager`オプションを使用します。しかし、理由を知るには：func： <cite>joinedload`は、特定の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Address``に対してフィルタリング**を行ったかどうかを考えます：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;someaddress@foo.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    addresses_1.id AS addresses_1_id,
    addresses_1.email_address AS addresses_1_email_address,
    addresses_1.user_id AS addresses_1_user_id,
    users.id AS users_id, users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users JOIN addresses
    ON users.id = addresses.user_id
LEFT OUTER JOIN addresses AS addresses_1
    ON users.id = addresses_1.user_id
WHERE users.name = ? AND addresses.email_address = ?
[&#39;jack&#39;, &#39;someaddress@foo.com&#39;]</div></pre></div>
</div>
<p>上では、2つのJOINが非常に異なる役割を持つことがわかります。一つは `` User``と `` Address``が `` Address.email_address == &amp;#39;someaddress &#64; foo.com&amp;#39;``のところで結ばれた行とまったく同じ行にマッチします。他のLEFT OUTER JOINは `` User``に関連する <a href="#id1"><span class="problematic" id="id2">``</span></a>すべての `` Address``行と一致し、 `` User.addresses``コレクションを生成するためにのみ使用されます。戻ってきた。</p>
<p>：func： <cite>.joinedload`の使用法を別のスタイルのロードに変更することで、私たちが望む実際の</cite> <cite>User``行を検索するために使用されるSQLと完全に独立してコレクションをロードする方法を変更できます。以下のように変更します：func： `.joinedload</cite> into：func：` .subqueryload`：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;someaddress@foo.com&#39;</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    users.id AS users_id,
    users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
JOIN addresses ON users.id = addresses.user_id
WHERE
    users.name = ?
    AND addresses.email_address = ?
[&#39;jack&#39;, &#39;someaddress@foo.com&#39;]

# ... subqueryload() emits a SELECT in order
# to load all address records ...</div></pre></div>
</div>
<p>結合されたeagerローディングを使用する場合、DISTINCT、LIMIT、OFFSETまたは同等のものを使用する場合など、ジョインの外部に戻された行に影響を与える修飾子がクエリに含まれる場合、完了した文は最初にサブクエリ内にラップされ、結合されたeager loadingがサブクエリに適用されます。 SQLAlchemyの積極的なロードは、クエリの形式に関係なく、クエリの最終結果、コレクションや関連オブジェクトのロード方法のみに影響しないことを絶対に保証するために、さらに1マイル、さらに10マイル以上移動します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>contains_eager</cite>  - を使う：func：` .contains_eager`</p>
</div>
</div>
</div>
<div class="section" id="subquery-eager-loading">
<span id="id3"></span><h2>サブクエリのEager Loading<a class="headerlink" href="#subquery-eager-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>サブクエリーロード熱負荷は、結合熱負荷の場合と同じ方法で構成されています。 ：paramref： <cite>.relationship.lazy`パラメータの場合、</cite> <cite>&amp;quot;サブクエリ&amp;quot;を</cite> <cite>&amp;#39;&amp;#39;に結合するように指定し、オプションとして：func：</cite> .subqueryload <cite>オプションの代わりに：func：</cite> .joinedload`オプションを使用します。</p>
<p>サブクエリ・ロードの操作は、ロードする各リレーションシップの2番目のSELECT文を、すべての結果オブジェクトにわたって一度に発行することです。このSELECT文は、返されるプライマリオブジェクトのプライマリキーの同じリストを取得し、すべてのコレクションメンバの合計にリンクして一度にロードするために、サブクエリの内部にラップされた元のSELECT文を参照します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jack&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    users.id AS users_id,
    users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
WHERE users.name = ?
(&#39;jack&#39;,)
SELECT
    addresses.id AS addresses_id,
    addresses.email_address AS addresses_email_address,
    addresses.user_id AS addresses_user_id,
    anon_1.users_id AS anon_1_users_id
FROM (
    SELECT users.id AS users_id
    FROM users
    WHERE users.name = ?) AS anon_1
JOIN addresses ON anon_1.users_id = addresses.user_id
ORDER BY anon_1.users_id, addresses.id
(&#39;jack&#39;,)</div></pre></div>
</div>
<p>subqueryload戦略には、コレクションをロードする領域で結合されたeagerのロードよりも多くの利点があります。第1に、元のクエリは、まったく変更せずに進めることができます。特にLEFT OUTER JOINを導入すると効率が低下する可能性があります。第2に、多くのコレクションが多数のJOINを含む単一の問合せを生成せずに積極的にロードされることを可能にします。各リレーションシップは完全に別のクエリでロードされます。最後に、追加のクエリは、リードオブジェクトではなくコレクションアイテムをロードするだけで済むため、すべてのケースで内部JOINを使用してクエリの効率を上げることができます。</p>
<p>subqueryloadの短所には、元のクエリの複雑さが関係クエリに転送されることが含まれます。このクエリは、サブクエリを組み合わせると、一部のバックエンド（特にMySQL）でかなり遅いクエリが生成される可能性があります。さらに、subqueryload戦略はすべてのコレクションの全内容を一度に読み込むことしかできないため、collectionとscalarの両方の関係のために：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`によって提供される&amp;quot;バッチ&amp;quot;読み込みと互換性がありません。</p>
<p>func： <cite>.selectinload`によって提供される新しいロードスタイルは：func：</cite> .subqueryload`のこれらの制限を解決します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>selectin_eager_loading</cite></p>
</div>
<div class="section" id="the-importance-of-ordering">
<span id="subqueryload-ordering"></span><h3>注文の重要性<a class="headerlink" href="#the-importance-of-ordering" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>.Query.first</cite>、：meth：` .Query.limit`、または：meth： <cite>.Query.offsetのような制限修飾子と組み合わせて：func：</cite> .subqueryload`を使用するクエリです。 <cite>〜** always ** include：meth：</cite> .Query.order_by`を主キーのような一意の列に含めるべきです：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.subqueryload`によって生成された追加のクエリは、親クエリそれがなければ、内側のクエリが間違った行を返す可能性があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># incorrect, no ORDER BY</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># incorrect if User.name is not unique</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># correct</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>faq_subqueryload_limit_sort</cite>  - 詳細な例</p>
</div>
</div>
</div>
<div class="section" id="select-in-loading">
<span id="selectin-eager-loading"></span><h2>INロードを選択<a class="headerlink" href="#select-in-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>選択INロードはサブクエリeagerローディングと似ていますが、発行されるSELECT文はサブクエリeagerローディングよりもはるかに単純な構造です。さらに、INロードを選択すると、ロード結果のサブセットに一度に適用されるので、結合されたサブクエリロードとは異なり、データベースドライバが同時カーソルをサポートする場合は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`を使用した結果のバッチ処理と互換性があります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<p>&amp;quot;select IN &amp;quot; eager loadingは：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship.lazy`のselectin &amp;quot; <a href="#id3"><span class="problematic" id="id4">``</span></a>引数を使用するか、：func： <a href="#id5"><span class="problematic" id="id6">`</span></a>.selectinload`ローダーオプションを使用して提供されます。このロードスタイルは、関連する関連付けをロードするために、IN句の内部の親オブジェクトの主キー値を参照するSELECTを発行します。</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
<span class="o">...</span> <span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="s1">&#39;addresses&#39;</span><span class="p">))</span><span class="o">.</span>\
<span class="o">...</span> <span class="nb">filter</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    users.id AS users_id,
    users.name AS users_name,
    users.fullname AS users_fullname,
    users.password AS users_password
FROM users
WHERE users.name = ? OR users.name = ?
(&#39;jack&#39;, &#39;ed&#39;)
SELECT
    users_1.id AS users_1_id,
    addresses.id AS addresses_id,
    addresses.email_address AS addresses_email_address,
    addresses.user_id AS addresses_user_id
FROM users AS users_1
JOIN addresses ON users_1.id = addresses.user_id
WHERE users_1.id IN (?, ?)
ORDER BY users_1.id, addresses.id
(5, 7)</div></pre></div>
</div>
<p>上記の2番目のSELECTは、 `` users_1.idn（5,7） <a href="#id1"><span class="problematic" id="id2">``</span></a>を参照しています。ここで、&amp;quot;5 &amp;quot;と&amp;quot;7 &amp;quot;は前回読み込まれた2つの `` User``オブジェクト;一群のオブジェクトが完全にロードされた後で、それらの主キー値が第2のSELECTの `` IN``節に注入されます。</p>
<p>&amp;quot;Select IN &amp;quot;ローディングは、1.2シリーズのSQLAlchemyに追加された熱心なローディングの最新のフォームです。この種の読み込みには以下のことが含まれます。</p>
<ul>
<li><p class="first">&amp;quot;selectin &amp;quot;ローダー戦略によって生成されたSELECTステートメントは、&amp;quot;サブクエリ&amp;quot;とは異なり、副問合せを必要とせず、元の問合せのパフォーマンス上の制限も継承しません。ルックアップは単純な主キー検索であり、高性能でなければなりません。</p>
</li>
<li><p class="first">：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>subqueryload_ordering`で説明されているsubqueryloadの特別な注文要件は、selectinの読み込みにも適用されません。 selectinは常に親の主キーに直接リンクしており、間違った結果を返すことはできません。</p>
</li>
<li><p class="first">&amp;quot;selectin &amp;quot;ローディングは、結合されたサブクエリローディングとは異なり、ロードされた直近の親オブジェクトに関してSELECTを送出し、チェインの先頭にあるオブジェクトの元の型ではありません。だから、多くのレベルを深く読み込めば、&amp;quot;selectin &amp;quot;ローディングはステートメント内でまったく1つのJOINを使います。サブクエリ・ロードは、常に元の親までの複数のJOINを参照します。</p>
</li>
<li><p class="first">&amp;quot;selectin &amp;quot;ロードは、元のクエリとは独立した、予測可能な構造のSELECT文を生成します。したがって、キャッシュされたクエリを処理するための：meth： <cite>.ColumnOperators.in_`という新機能を利用すると、selectinローダは生成された：mod：</cite> sqlalchemy.ext.baked`拡張を完全に利用します内部関数呼び出しオーバーヘッドを大幅に削減します。</p>
</li>
<li><p class="first">主キーがSQLステートメントの大きなIN式に表示されるため、この方法では一度に最大500の親主キー値のみを照会します。 Oracleなどの一部のデータベースでは、IN式の大きさにハード制限があり、全体的にSQL文字列のサイズを任意に大きくすべきではありません。したがって、大きな結果セットの場合、&amp;quot;selectin &amp;quot;ローディングは返された500個の親ローごとにSELECTを送出します。これらのSELECT文は、&amp;quot;baked &amp;quot;クエリのためPythonのオーバーヘッドが最小限に抑えられ、プライマリキーに対して直接問合せを行うため、SQLオーバーヘッドが最小限に抑えられます。</p>
</li>
<li><p class="first">&amp;quot;selectin &amp;quot;ローディングは、データベースドライバが同時のカーソルをサポートしていれば、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`によって提供される&amp;quot;バッチ処理&amp;quot;機能と連携して動作する唯一の熱心なローディングです。特定の結果オブジェクトに対して関連する項目だけを照会するので、&amp;quot;selectin &amp;quot;の読み込みでは、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query.yield_per`で使用すると、メモリー使用量の上限がある任意の大きさの結果セットに対して積極的に読み込まれます。</p>
<p>同時のカーソルをサポートする現在のデータベースドライバには、SQLite、Postgresqlなどがあります。 MySQLドライバのmysqlclientとpymysqlは、現在のところ**同時カーソルをサポートしておらず、SQL ServerのODBCドライバもサポートしていません。</p>
</li>
<li><p class="first">&amp;quot;selectin &amp;quot;の読み込みはINに依存するため、複合主キーを使用したマッピングではINの &amp;quot;タプル&amp;quot;形式を使用する必要があります。この形式は `` WHERE（table.column_a、table.column_b）IN（ ？、？）、（？、？）、（？、？）） <a href="#id1"><span class="problematic" id="id2">``</span></a>。この構文は、すべてのデータベースでサポートされているわけではありません。現代のPostgreSQLとMySQLのバージョンでのみサポートされていることが知られています。したがって、** selectinの読み込みは、複合主キー**のプラットフォームに依存しません。 SQLAlchemyには、この構文をサポートするプラットフォームを事前にチェックする特別なロジックはありません。サポートしていないプラットフォーム（SQLiteなど）に対して実行すると、データベースはエラーをただちに返します。 SQLAlchemyがSQLを実行するだけの利点は、SQLiteなどのデータベースがこの構文をサポートし始めると、SQLAlchemyを変更することなく動作することです。</p>
</li>
</ul>
<p>一般に、&amp;quot;selectin &amp;quot;ローディングは、おそらく&amp;quot;サブクエリ&amp;quot;の読み込みよりも優れています。コンポジット主キーのシンタックス要件を保存し、大きな結果セットに対しては多くのSELECT文を発行する可能性があります。いつものように、開発者は、開発中のアプリケーションによって生成されたステートメントや結果を見て、効率的に動作することを確認する時間を費やす必要があります。</p>
</div>
<div class="section" id="what-kind-of-loading-to-use">
<span id="what-kind-of-loading"></span><h2>どのようなローディングを使用するのですか？<a class="headerlink" href="#what-kind-of-loading-to-use" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>どのタイプのロードを使用するのかは、SQL実行の数、SQLの複雑さ、フェッチされるデータの量のトレードオフを最適化するのが一般的です。コレクションを参照するfunc： <cite>〜sqlalchemy.orm.relationship`とスカラ多対1参照を参照するa：func：</cite>〜sqlalchemy.orm.relationship`の2つの例を考えてみましょう。</p>
<ul class="simple">
<li>1対多コレクション</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>デフォルトの遅延ロードを使用する場合、100個のオブジェクトをロードしてそれぞれのコレクションにアクセスすると、合計101個のSQL文が発行されますが、通常、各ステートメントは結合なしの単純なSELECTになります。</li>
<li>結合ロードを使用すると、100個のオブジェクトとそのコレクションのロードにより、1つのSQLステートメントだけが出力されます。ただし、フェッチされる行の総数は、すべてのコレクションのサイズの合計と、空のコレクションを持つ各親オブジェクトの1つの余分な行に等しくなります。 SQLAlchemyは主キーの列以外の列を再フェッチしませんが、ほとんどのDBAPI（いくつかの例外を除いて）は完全なデータを送信しますいずれの場合も、ワイヤを介した各親のクライアント接続への接続。したがって、結合されたeagerローディングは、コレクションのサイズが比較的小さい場合にのみ意味を持ちます。 LEFT OUTER JOINは、INNER結合と比較してパフォーマンスが向上します。</li>
<li>副問合せのロードを使用すると、100個のオブジェクトのロードによって2つのSQL文が生成されます。 2番目のステートメントは、すべてのコレクションのサイズの合計と等しい合計行数をフェッチします。 INNER JOINが使用され、最小限の親列が要求され、主キーのみが要求されます。サブクエリのロードは、コレクションが大きい場合に意味があります。</li>
<li>ジョイントまたはサブクエリのローディングで複数レベルの深さを使用すると、コレクション内のコレクションをロードすると、デカルト形式でフェッチされた行の総数が増えます。結合されたサブクエリ読み込みとロードの両方が常に元の親クラスから結合します。コレクションを4レベル深くロードすると、親に4つのJOINがあります。一方、selectinの読み込みは常に、直接の親テーブルへのJOINを1つだけ持ちます。</li>
<li>selectinの読み込みを使用すると、100個のオブジェクトの読み込みで2つのSQL文が出力され、2番目のSQL文は読み込まれたオブジェクトの100個の主キーを参照します。 selectinの読み込みでは、多くとも500個の主キー値が単一のSELECTステートメントにレンダリングされます。したがって、500を超える鉛回収の場合、選択された500個のオブジェクトの各バッチに対してSELECTステートメントが発行されます。</li>
<li>selectinの読み込みに複数の深さの深さを使用しても、結合されたサブクエリの読み込みには&amp;quot;デカルト&amp;quot;という問題は発生しません。セレクチンロードのクエリは、パフォーマンスの特性が最も高く、行数が最も少なくなります。唯一の注意点は、リード結果のサイズに応じて複数のSELECTが発行される可能性があることです。</li>
<li>selectinの読み込みは、（コレクションを使用しているとき）結合されたもの（サブクエリの熱意的な読み込み）（あらゆる種類の関係）とは異なり、適切なデータベースドライバを仮定して：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`によって提供される結果セットのバッチングと互換性があります。大きな結果セットのバッチ処理を可能にする。</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>多対1参照</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>デフォルトの遅延ロードを使用する場合、100個のオブジェクトのロードは、コレクションの場合には101個ものSQL文を出力するようになります。ただし、多対1参照がターゲットの主キーへの単純な外部キー参照である場合、各参照は、現在のアイデンティティマップで最初に：meth： <cite>.Queryを使用してチェックされるという点で、重大な例外があります.get</cite>。したがって、オブジェクトのコレクションが比較的小さなターゲットオブジェクトのセットを参照している場合、または可能なターゲットオブジェクトのフルセットが既にセッションにロードされ、強く参照されている場合、デフォルトの <a href="#id1"><span class="problematic" id="id2">`</span></a>lazy = &amp;#39;select&amp;#39;`を使用するのはbyはるかに効率的な方法です。</li>
<li>結合されたロードを使用すると、100個のオブジェクトのロードによってSQL文が1つだけ出力されます。結合はLEFT OUTER JOINになり、すべての場合に合計行数は100になります。それぞれの親が絶対に子を持っていることがわかっている場合（つまり、外部キー参照がNOT NULLの場合）、結合ロードは次のように構成できます：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.relationship.innerjoin`は通常「True」に設定されます：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.relationship`内にあります。すでにロードされていない可能性のあるターゲット参照が多数存在するオブジェクトのロードの場合、INNER JOINを使用したローディングの結合は非常に効率的です。</li>
<li>サブクエリ・ローディングは、すべての子オブジェクトに対して2番目のロードを発行するため、100個のオブジェクトがロードされると、2つのSQL文が発行されます。ただし、サブクエリのロードではすべての場合にINNER JOINを使用できますが、ジョインされたロードでは外部キーがNOT NULLである必要がある場合を除いて、ジョインされたロードよりも利点はあまりありません。</li>
<li>Selectinの読み込みでは、すべての子オブジェクトに対して2番目の読み込みも行われます（前述のように、結果が大きければ500行ごとにSELECTを出す）ので、100オブジェクトの読み込みでは2つのSQL文が出力されます。クエリ自体はまだ親テーブルにJOINしなければならないので、多対1のロードを選択するにはあまり利点がありません。すべてのケースでINNER JOINを使用するために節約されたロードを保存します。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="polymorphic-eager-loading">
<h2>多形Eager Loading<a class="headerlink" href="#polymorphic-eager-loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>e-wager-loadベースでのポリゴンオプションの指定がサポートされています。 ：meth： <cite>.PropComparator.of_type`メソッドの例は、：func：</cite> .orm.with_polymorphic`関数と一緒に参照してください：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>eagerloading_polymorphic_subtypes`を参照してください。</p>
</div>
<div class="section" id="wildcard-loading-strategies">
<span id="wildcard-loader-strategies"></span><h2>ワイルドカード読み込み方針<a class="headerlink" href="#wildcard-loading-strategies" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <cite>.joinedload</cite>、：func：` .subqueryload`、：func： <cite>.lazyload</cite>、：func：` .selectinload`、：func： <cite>.noload</cite>、および：func：` .raiseload` ：func： <cite>.relationship`のデフォルトスタイルを設定するために使用することができます：func：</cite> .relationship`  - ：class： <cite>.Query`で指定されていないすべての属性に影響を与えます。この機能は、文字列 `</cite> &amp;#39;*&amp;#39; <a href="#id1"><span class="problematic" id="id2">``</span></a>をこれらのオプションのいずれかに引数として渡すことで利用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上記の `` lazyload（ &amp;#39;*&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>オプションは `` lazy``を使用するものを除き、全ての `` lazy``の設定に優先します：func： <cite>.relationship`は、 ``スタイルの読み込み。 `</cite> lazy = &amp;#39;joined&amp;#39; <a href="#id3"><span class="problematic" id="id4">``</span></a>や `` lazy = &amp;#39;subquery&amp;#39;``を指定したリレーションシップがある場合、 `` lazyload（&amp;#39; * &amp;#39;） <a href="#id5"><span class="problematic" id="id6">``</span></a>を使用すると、それらのリレーションシップに一方的に <a href="#id7"><span class="problematic" id="id8">``</span></a>&amp;#39; selectロードする。例えば、各属性にアクセスするときにSELECTステートメントを発行する。</p>
<p>このオプションは、func： <cite>.eagerload</cite>、：func：` .subqueryload`など、クエリに記述されたローダーオプションに代わるものではありません。以下のクエリは `` widget``の関係のために結合された読み込みを使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">),</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">widget</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>複数の `` &amp;#39;*&amp;#39; <a href="#id1"><span class="problematic" id="id2">``</span></a>オプションが渡された場合、最後に渡されたオプションが優先されます。</p>
<div class="section" id="per-entity-wildcard-loading-strategies">
<h3>エンティティごとのワイルドカード読み込み方法<a class="headerlink" href="#per-entity-wildcard-loading-strategies" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ワイルドカードローダー戦略の変種は、エンティティ単位で戦略を設定する能力です。例えば、 `` User``と `` Address``を問い合わせる場合、 `` Address``のすべてのリレーションシップに <cite>：class：</cite> .Load`オブジェクトを最初に適用して遅延読み込みを使用するよう指示し、 `` * <a href="#id1"><span class="problematic" id="id2">``</span></a>を連鎖オプションとして使う:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">Load</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上記のように、 `` Address``のすべての関係は遅延ロードに設定されます。</p>
</div>
</div>
<div class="section" id="routing-explicit-joins-statements-into-eagerly-loaded-collections">
<span id="contains-eager"></span><span id="joinedload-and-join"></span><h2>明示的な結合/ステートメントを熱心に読み込まれたコレクションにルーティングする<a class="headerlink" href="#routing-explicit-joins-statements-into-eagerly-loaded-collections" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.joinedload（）`の動​​作は、匿名エイリアスをターゲットとして自動的に結合が作成され、その結果がロードされたオブジェクトのコレクションとスカラー参照にルーティングされるようなものです。クエリーには、特定のコレクションまたはスカラー参照を表す必要な結合がすでに含まれている場合が多く、結合ロード機能によって追加された結合は冗長ですが、まだコレクション/参照に移入したいと思うことがあります。</p>
<p>このSQLAlchemyは：func： <cite>〜sqlalchemy.orm.contains_eager（）`オプションを提供します。このオプションは、：func： `〜sqlalchemy.orm.joinedload（）`オプションと同じ方法で使用されますが、：class： `〜sqlalchemy.orm.query.Query`が適切な結合を明示的に指定することを前提としています。以下では、 `</cite> User``と `` Address``の間の結合を指定し、これをさらに `` User.addresses``の読み込みの基礎として確立します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>

    <span class="c1"># ...</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span></pre></div>
</div>
<p>文の&amp;quot;eager &amp;quot;部分が&amp;quot;aliased &amp;quot;であれば、：func： <cite>〜sqlalchemy.orm.contains_eager`への</cite> <cite>alias``キーワード引数を使用してそれを示すことができます。これは：func： `.aliased`または：class：</cite> .Alias`構造体への参照として送信されます：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="c1"># use an alias of the Address entity</span>
<span class="n">adalias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>

<span class="c1"># construct a Query object which expects the &quot;addresses&quot; results</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">outerjoin</span><span class="p">(</span><span class="n">adalias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">adalias</span><span class="p">))</span>

<span class="c1"># get results normally</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<div class='show_sql'>SELECT
    users.user_id AS users_user_id,
    users.user_name AS users_user_name,
    adalias.address_id AS adalias_address_id,
    adalias.user_id AS adalias_user_id,
    adalias.email_address AS adalias_email_address,
    (...other columns...)
FROM users
LEFT OUTER JOIN email_addresses AS email_addresses_1
ON users.user_id = email_addresses_1.user_id</div></pre></div>
</div>
<p>：func： <cite>.contains_eager`への引数として与えられたパスは、開始エンティティからのフルパスである必要があります。たとえば、 `</cite> Users-&amp;gt; orders-&amp;gt; Order-&amp;gt; items-&amp;gt; Item``をロードしている場合、文字列のバージョンは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">contains_eager</span><span class="p">(</span><span class="s1">&#39;orders&#39;</span><span class="p">)</span><span class="o">.</span>
    <span class="n">contains_eager</span><span class="p">(</span><span class="s1">&#39;items&#39;</span><span class="p">))</span></pre></div>
</div>
<p>または、クラスにバインドされた記述子を使用する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span><span class="o">.</span>
    <span class="n">contains_eager</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">))</span></pre></div>
</div>
<div class="section" id="using-contains-eager-to-load-a-custom-filtered-collection-result">
<h3>contains_eager（）を使用してカスタムフィルタリングされたコレクションの結果をロードする<a class="headerlink" href="#using-contains-eager-to-load-a-custom-filtered-collection-result" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.contains_eager`を使用すると、<a href="#id3"><span class="problematic" id="id4">*</span></a>私たちはコレクションを生成するために使用されるSQLを構築しています。このことから、コレクションやスカラー属性の要素のサブセットをロードするようにSQLを記述することで、コレクションに格納する値を**変更する**ことができます。</p>
<p>例として、 `` User``オブジェクトを読み込み、 `` .addresses``コレクションに特定のアドレスだけを熱心にロードすることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
            <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span><span class="o">.</span>\
            <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span></pre></div>
</div>
<p>上記のクエリは `` email``フィールドに部分文字列 `` &amp;#39;ed``を含む少なくとも `` Address``オブジェクトを含む `` User``オブジェクトのみを読み込みます。 `` User.addresses``コレクションには、これらの `` Address``エントリだけが**含まれ、実際にコレクションに関連付けられている他の `` Address``エントリは含まれません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>オブジェクトのサブセットのみをコレクションにロードすると、そのコレクションは実際にデータベースに存在するものを表しなくなることに注意してください。このコレクションにエントリを追加しようとすると、すでにデータベースに存在するがローカルにロードされていないエントリと競合する可能性があります。</p>
<p>さらに、オブジェクトまたは属性が期限切れになると、<a href="#id1"><span class="problematic" id="id2">**</span></a>コレクションは通常**完全にリロードされます。この満了は、：meth： <cite>.Session.commit</cite>、：meth：` .Session.rollback`メソッドがデフォルトのセッション設定、または：meth： <cite>.Session.expire_all`または：meth：</cite>。Session .expire`メソッドが使用されます。</p>
<p>これらの理由から、オブジェクトと関連するオブジェクトのカスタムセットが必要な場合は、人工的にコレクションを変更するのではなく、タプル内の別々のフィールドを返すことをお勧めします。</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
            <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span></pre></div>
</div>
</div>
</div>
<div class="section" id="advanced-usage-with-arbitrary-statements">
<h3>任意のステートメントによる高度な使用<a class="headerlink" href="#advanced-usage-with-arbitrary-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>`` alias``引数は、任意の組の任意の名前を表現してステートメントにマッチさせることができるので、より創造的に使用することができます。以下はa：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`にリンクされ、一連の列オブジェクトを文字列SQL文にリンクします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># label the columns of the addresses table</span>
<span class="n">eager_columns</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
    <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">address_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">),</span>
    <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;a2&#39;</span><span class="p">),</span>
    <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;a3&#39;</span><span class="p">)</span>
<span class="p">])</span>

<span class="c1"># select from a raw SQL statement which uses those label names for the</span>
<span class="c1"># addresses table.  contains_eager() matches them up.</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">from_statement</span><span class="p">(</span><span class="s2">&quot;select users.*, addresses.address_id as a1, &quot;</span>
            <span class="s2">&quot;addresses.email_address as a2, &quot;</span>
            <span class="s2">&quot;addresses.user_id as a3 &quot;</span>
            <span class="s2">&quot;from users left outer join &quot;</span>
            <span class="s2">&quot;addresses on users.user_id=addresses.user_id&quot;</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">eager_columns</span><span class="p">))</span></pre></div>
</div>
</div>
</div>
<div class="section" id="creating-custom-load-rules">
<h2>カスタムロードルールの作成<a class="headerlink" href="#creating-custom-load-rules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">これは高度な技術です！大きな注意とテストを適用する必要があります。</p>
</div>
<p>ORMには、属性の値がローカルで使用可能なさまざまなエッジケースがありますが、ORM自体にはこれに関する認識がありません。また、ユーザー定義の負荷属性システムが望ましい場合もあります。ユーザ定義ローディングシステムのユースケースをサポートするために、主要な関数func： <cite>.attributes.set_committed_value`が提供されています。この関数は基本的にPythonの `</cite> setattr（） <a href="#id1"><span class="problematic" id="id2">``</span></a>関数と同等ですが、ターゲットオブジェクトに適用すると、フラッシュタイムの変更を判断するためのSQLAlchemyの&amp;quot;属性ヒストリー&amp;quot;システムはバイパスされます。属性は、ORMがデータベースからその方法でロードしたのと同じ方法で割り当てられます。</p>
<p>：func： <cite>.attributes.set_committed_value`の使用は：meth：</cite> .InstanceEvents.load`と呼ばれる別のキーイベントと組み合わされて、オブジェクトがロードされたときに属性集団動作を生成することができます。 1つのそのような例は、双方向の「1対1」の場合であり、1対1の「多対1」側の読み込みは、多対多の側にあります。 SQLAlchemy ORMは、関連するオブジェクトをロードするときには、バック・アウトーフを考慮せず、1対1という別の&amp;quot;1対多&amp;quot;を1行と見なします。</p>
<p>与えられた次のマッピング:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span><span class="p">,</span> <span class="n">backref</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;b.id&#39;</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;B&quot;</span><span class="p">,</span>
        <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">uselist</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;joined&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>`` A``行を照会し、 `` aba``を要求すると、特別なSELECT</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">a</span>
<span class="go">SELECT a.id AS a_id, a.b_id AS a_b_id</span>
<span class="go">FROM a</span>
<span class="go">WHERE ? = a.b_id</span></pre></div>
</div>
<p>`` ba``は `` a1``と同じ値なので、このSELECTは冗長です。私たちにこれを設定するためのロードルールを作成することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">attributes</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s2">&quot;load&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load_b</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">set_committed_value</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></pre></div>
</div>
<p>今、 `` A``を問い合わせると、積極的に参加している人から `` Ab``を、イベントからは `` Aba``を取得します：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go">a1 = s.query(A).first()</span>
<div class='show_sql'>SELECT
    a.id AS a_id,
    a.b_id AS a_b_id,
    b_1.id AS b_1_id
FROM a
LEFT OUTER JOIN b AS b_1 ON b_1.id = a.b_id
 LIMIT ? OFFSET ?
(1, 0)
</div><span class="go">assert a1.b.a is a1</span></pre></div>
</div>
</div>
<div class="section" id="relationship-loader-api">
<h2>リレーションシップローダーAPI<a class="headerlink" href="#relationship-loader-api" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="sqlalchemy.orm.contains_alias">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">contains_alias</code><span class="sig-paren">(</span><em>alias</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.contains_alias" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メインテーブルがエイリアス化されたことを：class： <cite>.Query`に示すclass：</cite> .MapperOption`を返します。</p>
<p>ごくまれに、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.contains_eager`が、親テーブルのエイリアスとなるユーザ定義のSELECT文と一緒に使用されている場合に適合することはめったにありません。例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># define an aliased UNION called &#39;ulist&#39;</span>
<span class="n">ulist</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">union</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">))</span><span class="o">.</span>\
                <span class="n">alias</span><span class="p">(</span><span class="s1">&#39;ulist&#39;</span><span class="p">)</span>

<span class="c1"># add on an eager load of &quot;addresses&quot;</span>
<span class="n">statement</span> <span class="o">=</span> <span class="n">ulist</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">apply_labels</span><span class="p">()</span>

<span class="c1"># create query, indicating &quot;ulist&quot; will be an</span>
<span class="c1"># alias for the main table, &quot;addresses&quot;</span>
<span class="c1"># property should be eager loaded</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
                        <span class="n">contains_alias</span><span class="p">(</span><span class="n">ulist</span><span class="p">),</span>
                        <span class="n">contains_eager</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>

<span class="c1"># then get results via the statement</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.contains_alias.params.alias"></span><strong>alias</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.contains_alias.params.alias">¶</a> -- はエイリアスの文字列名、またはエイリアスを表す：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.sql.expression.Alias`オブジェクトです。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.contains_eager">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">contains_eager</code><span class="sig-paren">(</span><em>*keys</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.contains_eager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された属性を、クエリで手動で記述された列から積極的に読み込む必要があることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>このオプションは、必要な行をロードする明示的な結合、すなわち:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">user</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">user</span><span class="p">))</span></pre></div>
</div>
<p>上記のクエリは `` Order``エンティティから関連する `` User``エンティティに参加し、返された `` Order``オブジェクトは `` Order.user``属性が事前設定されています。</p>
<p>：func： <cite>.contains_eager`は、エイリアスの文字列名である</cite> alias`引数、：func： <cite>〜sqlalchemy.sql.expression.alias`構文、または：func：</cite>〜sqlalchemy.orm 。熱心に読み込まれた行がエイリアステーブルから来る場合は、これを使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">((</span><span class="n">user_alias</span><span class="p">,</span> <span class="n">Order</span><span class="o">.</span><span class="n">user</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">user_alias</span><span class="p">))</span></pre></div>
</div>
<p>継承されたサブクラスと組み合わせて：func： <cite>.contains_eager`を使用する場合、適切にパスを設定するために：meth：</cite> .RelationshipProperty.of_type`修飾子も使用する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Company</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">outerjoin</span><span class="p">(</span><span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Manager</span><span class="p">))</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span>
        <span class="n">contains_eager</span><span class="p">(</span>
            <span class="n">Company</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">Manager</span><span class="p">),</span>
            <span class="n">alias</span><span class="o">=</span><span class="n">Manager</span><span class="p">)</span>
    <span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>contains_eager</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.defaultload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">defaultload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.defaultload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトのローダスタイルを使用してロードする属性を指定します。</p>
<p>このメソッドは、チェーンに沿ったリンクのローダースタイルを変更せずに、他のローダーオプションを属性チェーンにさらにリンクするために使用されます。たとえば、エレメントのエレメントに対して結合eagerローディングを設定するには、次のようにします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">defaultload</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">someattribute</span><span class="p">)</span><span class="o">.</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">MyOtherClass</span><span class="o">.</span><span class="n">someotherattribute</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>：func： <cite>.defaultload`は関連するクラス、つまり：func：</cite> .defer`と：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.undefer`の列レベルオプションを設定するのにも便利です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">defaultload</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">someattribute</span><span class="p">)</span><span class="o">.</span>
    <span class="n">defer</span><span class="p">(</span><span class="s2">&quot;some_column&quot;</span><span class="p">)</span><span class="o">.</span>
    <span class="n">undefer</span><span class="p">(</span><span class="s2">&quot;some_other_column&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>relationship_loader_options</cite></p>
<p class="last">：ref： <cite>deferred_loading_w_multiple</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.eagerload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">eagerload</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.eagerload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>joinedload（）`の同義語です。</p>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.eagerload_all">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">eagerload_all</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.eagerload_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>func： <a href="#id1"><span class="problematic" id="id2">`</span></a>joinedload_all（）`の同義語です。</p>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.immediateload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">immediateload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.immediateload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された属性は、属性ごとのSELECT文を使用して即時ロードを使用してロードする必要があることを示します。</p>
<p>：func： <cite>.immediateload`オプションは、一般的に：func：</cite> .selectinload`オプションよりも優先されます。これは、ロードされたすべてのオブジェクトに対してSELECTを発行することによって、より効率的に同じタスクを実行します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>selectin_eager_loading</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.joinedload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">joinedload</code><span class="sig-paren">(</span><em>*keys</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.joinedload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された属性が結合されたeager loadingを使用してロードされるべきであることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># joined-load the &quot;orders&quot; collection on &quot;User&quot;</span>
<span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>

<span class="c1"># joined-load Order.items and then Item.keywords</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">joinedload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span>

<span class="c1"># lazily load Order.items, but when Items are loaded,</span>
<span class="c1"># joined-load the keywords collection</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">joinedload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.joinedload.params.innerjoin"></span><strong>innerjoin</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.joinedload.params.innerjoin">¶</a> -- `` True``の場合は、結合されたeager loadが、デフォルトのleft join :: query（Order）.options（joinedload（Order.user、innerjoin = True））の代わりに内部結合を使用する必要があることを示します。いくつかの要素がOUTERとINNERである場合、右ネストされた結合がそれらをリンクするために使用されます:: query（A）.options（joinedload（A.bs、innerjoin = False）。joinedload（B.cs、innerjoin = True））上記のクエリは、&amp;quot;outer &amp;quot; joinとB.csを介して &amp;quot;inner &amp;quot; joinを介してA.bsをリンクすると、結合を &amp;quot;LEFT OUTER JOIN（b JOIN c）&amp;quot;としてレンダリングします。古いバージョンのSQLite（&amp;lt;3.7.16）を使用する場合、この形式のJOINは完全なサブクエリを使用するように変換されますが、この構文は直接サポートされていないためです。 `` innerjoin``フラグは、 `` &amp;quot;unested &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>という言葉で記述することもできます。これは、結合がLEFT OUTER JOINに左にリンクされている場合を除いて、INNER JOINを使用する必要があることを示します。この場合、LEFT OUTER JOINとしてレンダリングされます。例えば、 `` A.bs``がouterjoin :: query（A）.options（joinedload（A.bs）。joinedload（B.cs、innerjoin = &amp;quot;unnested &amp;quot;））であると仮定すると、 LEFT OUTER JOIN（b JOIN c）ではなく、&amp;quot;LEFT OUTER JOIN B LEFT OUTER JOIN &amp;quot;としてください。 .. note :: &amp;quot;unnested &amp;quot;フラグは、多対多関連テーブルからレンダリングされたJOINに影響しません。例えば、paramref： <cite>.relationship.secondary`でターゲットに設定されたテーブル表;結果の正確さのために、これらの結合は常にINNERであるため、OUTER結合にリンクされている場合は右にネストされます。 .. versionchanged :: 1.0.0 `</cite> innerjoin = True``は `` innerjoin = &amp;#39;がネストされた&amp;quot;` <cite>を意味するのに対して、0.9では</cite> <cite>innerjoin = &amp;quot;はネストされていない&amp;quot;</cite> <cite>を意味します。 1.0より前の &amp;quot;unnested&amp;quot;の内部結合動作を実現するには、 `</cite> innerjoin = &amp;quot;unested &amp;quot; <a href="#id3"><span class="problematic" id="id4">``</span></a>の値を使用します。参考文献：ref： <a href="#id5"><span class="problematic" id="id6">`</span></a>migration_3008`を参照してください。</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.joinedload`によって生成される結合は**匿名でエイリアス化されています**。結合が進む基準は変更できません。また、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`は、順序を含めてこれらの結合を何ら参照することはできません。詳細は：ref： <a href="#id5"><span class="problematic" id="id6">`</span></a>zen_of_eager_loading`を参照してください。</p>
<p class="last">明示的に使用可能な特定のSQL JOINを生成するには、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.join`を使用します。明示的なJOINとコレクションの読み込みを組み合わせるには、func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.orm.contains_eager`を使います。 ：ref： <a href="#id5"><span class="problematic" id="id6">`</span></a>contains_eager`を参照してください。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>joined_eager_loading</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.joinedload_all">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">joinedload_all</code><span class="sig-paren">(</span><em>*keys</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.joinedload_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.joinedload`のスタンドアロンの&amp;quot; all &amp;quot;オプションを生成します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.9.0 で撤廃: </span>&amp;quot;_ all（）&amp;quot;スタイルは、メソッド連鎖に置き換えられます。例えば：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">joinedload</span><span class="p">(</span><span class="s2">&quot;someattribute&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">joinedload</span><span class="p">(</span><span class="s2">&quot;anotherattribute&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.lazyload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">lazyload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.lazyload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された属性が&amp;quot;lazy &amp;quot;ローディングを使用してロードされるべきであることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>lazy_loading</cite></p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.orm.Load">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.</code><code class="descname">Load</code><span class="sig-paren">(</span><em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.Load" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.Generative</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.interfaces.MapperOption</span></code></p>
<p>さまざまなマップされた属性のロード方法に影響を与えるために：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`の状態を変更するローダーオプションを表します。</p>
<p>：class： <cite>.Load`オブジェクトは、ほとんどの場合、func：</cite> .joinedload`、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.defer`などのようなクエリオプションを使用すると暗黙のうちに暗黙的に使用されます。しかし、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Load`オブジェクトも直接使用することができ、場合によっては便利です。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`を直接使用するには、ターゲットとしてマップされたクラスを引数としてインスタンス化します。このスタイルは、複数のエンティティを持つ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`を扱うときに便利です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myopt</span> <span class="o">=</span> <span class="n">Load</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">joinedload</span><span class="p">(</span><span class="s2">&quot;widgets&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記の `` myopt``は：meth： <cite>.Query.options`で使用できるようになりました。ここで</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>MyClass``エンティティにのみ有効です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">MyOtherClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">myopt</span><span class="p">)</span></pre></div>
</div>
<p>class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`はパブリックAPIとして便利です：特定のクラスに対してのみ有効な&amp;quot;ワイルドカード&amp;quot;オプションを指定する場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">Load</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上では、 `` Order``のすべてのリレーションシップは遅延ロードされますが、それらの子孫オブジェクトの他のアトリビュートは通常のローダー戦略を使用してロードされます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>loading_toplevel</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.noload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">noload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.noload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたリレーションシップ属性をアンロードしたままにする必要があることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>：func： <cite>.orm.noload`はfunc：</cite> .relationship`属性に適用されます。列ベースの属性については、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.defer`を参照してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>loading_toplevel</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.raiseload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">raiseload</code><span class="sig-paren">(</span><em>*keys</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.raiseload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたリレーションシップ属性が遅延ロードを禁止する必要があることを示します。</p>
<p>：func： <cite>.orm.raiseload`で設定された関係属性は、アクセス時に：exc：</cite>〜sqlalchemy.exc.InvalidRequestError`を送出します。これが便利な典型的な方法は、アプリケーションが、特定のコンテキストでアクセスされたすべてのリレーションシップ属性が、熱心なロードによって既にロードされていることを確認しようとするときです。怠惰な負荷が発生していないことを確実にするためにSQLログを読み取る必要はなく、この戦略によって即座に発生させることができます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.raiseload.params.sql_only"></span><strong>sql_only</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.raiseload.params.sql_only">¶</a> -- Trueの場合、レイジーロードによってSQLが生成されるが、アイデンティティマップのみをチェックしている場合や、キーがないために関連する値がNoneであると判断されない場合にのみ発生します。 Falseの場合、戦略はlazyloadのすべての種類に対して発生します。</td>
</tr>
</tbody>
</table>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>：func： <cite>.orm.raiseload`は：func：</cite> .relationship`属性にのみ適用されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>prevent_lazy_with_raiseload</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.selectinload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">selectinload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.selectinload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SELECT IN eager loadingを使用して、指定された属性をロードする必要があることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># selectin-load the &quot;orders&quot; collection on &quot;User&quot;</span>
<span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>

<span class="c1"># selectin-load Order.items and then Item.keywords</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectinload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">selectinload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span>

<span class="c1"># lazily load Order.items, but when Items are loaded,</span>
<span class="c1"># selectin-load the keywords collection</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">selectinload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>selectin_eager_loading</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.selectinload_all">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">selectinload_all</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.selectinload_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.selectinload`のスタンドアロンの&amp;quot; all &amp;quot;オプションを生成します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.9.0 で撤廃: </span>&amp;quot;_ all（）&amp;quot;スタイルは、メソッド連鎖に置き換えられます。例えば：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">selectinload</span><span class="p">(</span><span class="s2">&quot;someattribute&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">selectinload</span><span class="p">(</span><span class="s2">&quot;anotherattribute&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.subqueryload">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">subqueryload</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.subqueryload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された属性がサブクエリeager loadingを使用してロードされる必要があることを示します。</p>
<p>この関数は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`インターフェースの一部であり、メソッド連鎖操作とスタンドアロン操作の両方をサポートしています。</p>
<p>例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># subquery-load the &quot;orders&quot; collection on &quot;User&quot;</span>
<span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">))</span>

<span class="c1"># subquery-load Order.items and then Item.keywords</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span>

<span class="c1"># lazily load Order.items, but when Items are loaded,</span>
<span class="c1"># subquery-load the keywords collection</span>
<span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">lazyload</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span><span class="n">subqueryload</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">))</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：ref： <cite>loading_toplevel</cite></p>
<p class="last">：ref： <cite>subquery_eager_loading</cite></p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.subqueryload_all">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">subqueryload_all</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.subqueryload_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.subqueryload`のスタンドアロンの&amp;quot; all &amp;quot;オプションを生成します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.9.0 で撤廃: </span>&amp;quot;_ all（）&amp;quot;スタイルは、メソッド連鎖に置き換えられます。例えば：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span>
    <span class="n">subqueryload</span><span class="p">(</span><span class="s2">&quot;someattribute&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">subqueryload</span><span class="p">(</span><span class="s2">&quot;anotherattribute&quot;</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
</div>
</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="loading_columns.html" title="previous chapter">列の読み込み</a>
        Next:
        <a href="inheritance_loading.html" title="next chapter">継承階層のロード</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



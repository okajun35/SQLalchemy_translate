<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    リレーションシップの参加方法のコンフィグレーション
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="関係の設定" href="relationships.html" />
        <link rel="next" title="コレクションの構成とテクニック" href="collections.html" />
        <link rel="prev" title="バックリファレンスとの関係のリンク" href="backref.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="basic_relationships.html">基本的な関係パターン</a></span></li>
<li><span class="link-container first"><a class="reference external" href="self_referential.html">隣接関係リストの関係</a></span></li>
<li><span class="link-container first"><a class="reference external" href="backref.html">バックリファレンスとの関係のリンク</a></span></li>
<li class="selected"><span class="link-container first"><strong>リレーションシップの参加方法のコンフィグレーション</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#handling-multiple-join-paths">複数の結合パスの処理</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#specifying-alternate-join-conditions">代替結合条件の指定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#creating-custom-foreign-conditions">カスタム外来の作成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#using-custom-operators-in-join-conditions">結合条件でカスタム演算子を使用する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#overlapping-foreign-keys">重複する外部キー</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#non-relational-comparisons-materialized-path">非リレーショナル比較/マテリアライズド・パス</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#self-referential-many-to-many-relationship">自己参照多対多リレーションシップ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#composite-secondary-joins">コンポジット&amp;quot;セカンダリ&amp;quot;の結合</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#relationship-to-non-primary-mapper">非プライマリマッパーとの関係</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#row-limited-relationships-with-window-functions">ウィンドウ関数との行限定関係</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#building-query-enabled-properties">クエリが有効なプロパティの構築</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="collections.html">コレクションの構成とテクニック</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationship_persistence.html">特別な関係の永続パターン</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationship_api.html">リレーションシップAPI</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="configuring-how-relationship-joins">
<span id="relationship-configure-joins"></span><h1>リレーションシップの参加方法のコンフィグレーション<a class="headerlink" href="#configuring-how-relationship-joins" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`は通常、2つのテーブル間の外部キーの関係を調べて、どちらのカラムを比較すべきかを判断することによって、2つのテーブル間の結合を作成します。この動作をカスタマイズする必要があるさまざまな状況があります。</p>
<div class="section" id="handling-multiple-join-paths">
<span id="relationship-foreign-keys"></span><h2>複数の結合パスの処理<a class="headerlink" href="#handling-multiple-join-paths" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>対処する最も一般的な状況の1つは、2つのテーブルの間に複数の外部キーパスがある場合です。</p>
<p>`` Address``クラスへの2つの外部キーを含む `` Customer``クラスを考えてみましょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;customer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="n">billing_address_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;address.id&quot;</span><span class="p">))</span>
    <span class="n">shipping_address_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;address.id&quot;</span><span class="p">))</span>

    <span class="n">billing_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">)</span>
    <span class="n">shipping_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">street</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">city</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="nb">zip</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span></pre></div>
</div>
<p>上記のマッピングは、それを使用しようとすると、エラー:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">exc</span><span class="o">.</span><span class="n">AmbiguousForeignKeysError</span><span class="p">:</span> <span class="n">Could</span> <span class="ow">not</span> <span class="n">determine</span> <span class="n">join</span>
<span class="n">condition</span> <span class="n">between</span> <span class="n">parent</span><span class="o">/</span><span class="n">child</span> <span class="n">tables</span> <span class="n">on</span> <span class="n">relationship</span>
<span class="n">Customer</span><span class="o">.</span><span class="n">billing_address</span> <span class="o">-</span> <span class="n">there</span> <span class="n">are</span> <span class="n">multiple</span> <span class="n">foreign</span> <span class="n">key</span>
<span class="n">paths</span> <span class="n">linking</span> <span class="n">the</span> <span class="n">tables</span><span class="o">.</span>  <span class="n">Specify</span> <span class="n">the</span> <span class="s1">&#39;foreign_keys&#39;</span> <span class="n">argument</span><span class="p">,</span>
<span class="n">providing</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">those</span> <span class="n">columns</span> <span class="n">which</span> <span class="n">should</span> <span class="n">be</span>
<span class="n">counted</span> <span class="k">as</span> <span class="n">containing</span> <span class="n">a</span> <span class="n">foreign</span> <span class="n">key</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">table</span><span class="o">.</span></pre></div>
</div>
<p>上記のメッセージはかなり長いです。次のような潜在的なメッセージがあります。func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`が返ることができます。これは、さまざまな共通の設定上の問題を検出するために慎重に調整されています。ほとんどの場合、あいまいさやその他の不足している情報を解決するために必要な追加設定が必要です。</p>
<p>この場合、メッセージは外部キー列を考慮する必要があるそれぞれについて指示することにより、それぞれ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`を修飾することを希望し、適切な形式は次のとおりです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;customer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="n">billing_address_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;address.id&quot;</span><span class="p">))</span>
    <span class="n">shipping_address_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;address.id&quot;</span><span class="p">))</span>

    <span class="n">billing_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="p">[</span><span class="n">billing_address_id</span><span class="p">])</span>
    <span class="n">shipping_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="p">[</span><span class="n">shipping_address_id</span><span class="p">])</span></pre></div>
</div>
<p>上記では、foreign_keys`引数を指定しています。これは：class： <cite>.Column`またはclass：</cite> .Column`オブジェクトのリストで、これらの列は&amp;quot;foreign &amp;quot;とみなされます。つまり、親テーブルを参照する値を含む列。 `` Customer``オブジェクトから `` Customer.billing_address``関係をロードすると、 `` billing_address_id``にある値を使用してロードされる `` Address``の行を識別します。同様に、 `` shipping_address_id``は `` shipping_address``関係のために使われます。 2つの列のリンケージは、永続性の際にも役割を果たします。新たに生成されたちょうど挿入された `` Address``オブジェクトの主キーは、フラッシュ中に関連する `` Customer``オブジェクトの適切な外部キー列にコピーされます。</p>
<p>Declarativeで `` foreign_keys``を指定するときは、文字列名を使用して指定することもできますが、リストを使用する場合、<strong>リストは文字列</strong> ::の一部です</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">billing_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="s2">&quot;[Customer.billing_address_id]&quot;</span><span class="p">)</span></pre></div>
</div>
<p>この特定の例では、リストは必要ではありません：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Column`必要なもの:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">billing_address</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="s2">&quot;Customer.billing_address_id&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.8 で変更: </span>：func： <cite>.relationship`は、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>foreign_keys``引数のみに基づいて、外部キーターゲット間のあいまいさを解決できます。この状況では：paramref： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.relationship.primaryjoin`引数は必要ありません。</p>
</div>
</div>
<div class="section" id="specifying-alternate-join-conditions">
<span id="relationship-primaryjoin"></span><h2>代替結合条件の指定<a class="headerlink" href="#specifying-alternate-join-conditions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>結合を構築するときの：func： <cite>.relationship`のデフォルトの動作は、一方の主キー列の値を他方の外部キー参照列の値と等しくすることです。 paramref： `〜.relationship.primaryjoin`の引数だけでなく、：paramref：</cite>〜.relationship.secondaryjoin`引数を使って、この基準を変更して、 &amp;quot;テーブルが使用されます。</p>
<p>下記の例では、 `` User``クラスと住所を格納する `` Address``クラスを使用して、 `` boston_addresses``という関係を作成します。 &amp;quot;ボストン&amp;quot;の都市を指定する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">boston_addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span>
                    <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(User.id==Address.user_id, &quot;</span>
                        <span class="s2">&quot;Address.city==&#39;Boston&#39;)&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>

    <span class="n">street</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">city</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="nb">zip</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span></pre></div>
</div>
<p>この文字列のSQL式では、：func： <cite>.and_`結合構文を使用して、結合条件の2つの異なる述語を確立しました。これは、</cite> <cite>User.id``と</cite> <cite>Address.user_id``列を`</cite> Address``の行を単に `` city = &amp;#39;Boston&amp;#39;``に制限するだけです。 Declarativeを使用する場合、func： <cite>.and_`のような基本的なSQL関数は、評価されたstring：func：</cite> .relationship`引数の名前空間で自動的に使用できます。</p>
<p>：paramref： <cite>〜.relationship.primaryjoin`で使用するカスタム条件は、SQLAlchemyがSQLをレンダリングしてこの関係をロードまたは表現するときにのみ重要です。つまり、属性単位の遅延読み込みを実行するために、またはクエリ時に：meth： `.Query.join`などのように結合が構築されたとき、またはeager &amp;quot;joined &amp;quot;または&amp;quot;subquery &amp;quot;スタイルの読み込みです。メモリ内のオブジェクトが操作されている場合、 `</cite> css``属性の値に関係なく、 `` boston_addresses``コレクションに必要な `` Address``オブジェクトを置くことができます。属性が期限切れになり、基準が適用されるデータベースから再ロードされるまで、オブジェクトはコレクション内に残ります。フラッシュが発生すると、 `` boston_addresses``の中のオブジェクトは、プライマリキー `` user.id``カラムの値をそれぞれの外部キーを保持する `` address.user_id``カラムに代入して無条件でフラッシュされます行。フラッシュ処理では、プライマリキー値を参照する外部キー値に同期させるだけでよいため、 `` city``の基準はここでは何の効果もありません。</p>
</div>
<div class="section" id="creating-custom-foreign-conditions">
<span id="relationship-custom-foreign"></span><h2>カスタム外来の作成<a class="headerlink" href="#creating-custom-foreign-conditions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プライマリ結合条件のもう1つの要素は、&amp;quot;foreign &amp;quot;とみなされる列がどのように決定されるかです。通常、class： <cite>.Column`オブジェクトのいくつかのサブセットは：class：</cite> .ForeignKey`を指定します。そうでなければ、join条件に関連する：class： <cite>.ForeignKeyConstraint`の一部です。 ：func： `.relationship`は、この外部キーステータスを調べ、この関係のデータをどのようにロードして保持するかを決定します。ただし、：paramref： `〜.relationship.primaryjoin`引数を使用して、&amp;quot;スキーマ&amp;quot;レベルの外部キーを含まない結合条件を作成できます。 paramref： `〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.foreign_keys`と：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.relationship.remote_side`を明示的に組み合わせて、このような結合を確立することができます。</p>
<p>以下では、 `` HostEntry``というクラスが、 `` content``という文字列を `` INET``と呼ばれるPostgreSQL型の `` ip_address``列に対応させて自分自身に結合します。結合の片側を他の::の型にキャストするために：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.cast`を使う必要があります：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">cast</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="n">INET</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">HostEntry</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;host_entry&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ip_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">INET</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="c1"># relationship() using explicit foreign_keys, remote_side</span>
    <span class="n">parent_host</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;HostEntry&quot;</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="n">ip_address</span> <span class="o">==</span> <span class="n">cast</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">INET</span><span class="p">),</span>
                        <span class="n">foreign_keys</span><span class="o">=</span><span class="n">content</span><span class="p">,</span>
                        <span class="n">remote_side</span><span class="o">=</span><span class="n">ip_address</span>
                    <span class="p">)</span></pre></div>
</div>
<p>上記の関係は、::のような結合を生成します</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">host_entry</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">host_entry</span><span class="o">.</span><span class="n">ip_address</span><span class="p">,</span> <span class="n">host_entry</span><span class="o">.</span><span class="n">content</span>
<span class="n">FROM</span> <span class="n">host_entry</span> <span class="n">JOIN</span> <span class="n">host_entry</span> <span class="n">AS</span> <span class="n">host_entry_1</span>
<span class="n">ON</span> <span class="n">host_entry_1</span><span class="o">.</span><span class="n">ip_address</span> <span class="o">=</span> <span class="n">CAST</span><span class="p">(</span><span class="n">host_entry</span><span class="o">.</span><span class="n">content</span> <span class="n">AS</span> <span class="n">INET</span><span class="p">)</span></pre></div>
</div>
<p>上記の別の構文は、：paramref： <cite>〜.relationship.primaryjoin`式の中で、：func：</cite> .foreign`と：func： <cite>.remote</cite>：term：` annotations`をインラインで使用することです。この構文は、以下のような注釈を表します。func： <cite>.relationship`は通常：paramref：</cite>〜.relationship.foreign_keys`と：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.relationship.remote_side`引数を指定して結合条件に適用されます。これらの関数は、明示的な結合条件が存在する場合にはより簡潔であり、さらに、その列が複数回指定されているか複雑なSQL式内にあるかに関係なく、&amp;quot;foreign &amp;quot;または&amp;quot;remote ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">foreign</span><span class="p">,</span> <span class="n">remote</span>

<span class="k">class</span> <span class="nc">HostEntry</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;host_entry&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ip_address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">INET</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="c1"># relationship() using explicit foreign() and remote() annotations</span>
    <span class="c1"># in lieu of separate arguments</span>
    <span class="n">parent_host</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;HostEntry&quot;</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="n">remote</span><span class="p">(</span><span class="n">ip_address</span><span class="p">)</span> <span class="o">==</span> \
                                <span class="n">cast</span><span class="p">(</span><span class="n">foreign</span><span class="p">(</span><span class="n">content</span><span class="p">),</span> <span class="n">INET</span><span class="p">),</span>
                    <span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="using-custom-operators-in-join-conditions">
<span id="relationship-custom-operator"></span><h2>結合条件でカスタム演算子を使用する<a class="headerlink" href="#using-custom-operators-in-join-conditions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関係のもう1つの使用例は、class： <cite>.postgresql.INET`と：class：`のような型で結合するときに、PostgreSQLの&amp;quot;が&amp;quot; &amp;quot;&amp;lt;&amp;lt; &amp;lt;&amp;lt;</cite> <cite>演算子の中に含まれるようなカスタム演算子の使用です。 postgresql.CIDR</cite>。カスタム演算子では、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Operators.op`関数を使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inet_column</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">)(</span><span class="n">cidr_column</span><span class="p">)</span></pre></div>
</div>
<p>しかし、この演算子を使って：paramref： <cite>〜.relationship.primaryjoin`を構築すると、：func：</cite> .relationship`はさらに情報が必要になります。なぜなら、私たちのprimaryjoin条件を調べると、特に**比較**のために使われる演算子が検索され、これは通常、 `` == <a href="#id1"><span class="problematic" id="id2">``</span></a>、 `` &amp;lt;``などの既知の比較演算子を含む固定リストです。したがって、カスタムオペレータがこのシステムに参加するには、：paramref： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Operators.op.is_comparison`パラメータを使用して比較演算子として登録する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inet_column</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">,</span> <span class="n">is_comparison</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">cidr_column</span><span class="p">)</span></pre></div>
</div>
<p>完全な例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IPA</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;ip_address&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v4address</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">INET</span><span class="p">)</span>

    <span class="n">network</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Network&quot;</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;IPA.v4address.op(&#39;&lt;&lt;&#39;, is_comparison=True)&quot;</span>
                            <span class="s2">&quot;(foreign(Network.v4representation))&quot;</span><span class="p">,</span>
                        <span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
<span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;network&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v4representation</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">CIDR</span><span class="p">)</span></pre></div>
</div>
<p>上記のように、:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">IPA</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">IPA</span><span class="o">.</span><span class="n">network</span><span class="p">)</span></pre></div>
</div>
<p>レンダリングする:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">ip_address</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="n">ip_address_id</span><span class="p">,</span> <span class="n">ip_address</span><span class="o">.</span><span class="n">v4address</span> <span class="n">AS</span> <span class="n">ip_address_v4address</span>
<span class="n">FROM</span> <span class="n">ip_address</span> <span class="n">JOIN</span> <span class="n">network</span> <span class="n">ON</span> <span class="n">ip_address</span><span class="o">.</span><span class="n">v4address</span> <span class="o">&lt;&lt;</span> <span class="n">network</span><span class="o">.</span><span class="n">v4representation</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.2 で追加: </span>- Added the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.operators.Operators.op.params.is_comparison" title="sqlalchemy.sql.operators.Operators.op"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Operators.op.is_comparison</span></code></a>
flag to assist in the creation of <a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> constructs using
custom operators.</p>
</div>
</div>
<div class="section" id="overlapping-foreign-keys">
<span id="relationship-overlapping-foreignkeys"></span><h2>重複する外部キー<a class="headerlink" href="#overlapping-foreign-keys" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>外部キー制約を使用して参照される複数の列の対象となるように、複合外部キーが使用される場合、まれなシナリオが発生する可能性があります。</p>
<p>`` Writer``オブジェクトと `` Article``オブジェクトの両方によって参照される `` Magazine``オブジェクトのような（確かに複雑な）マッピングを考えてみましょう。両方; 「Article」を「Writer」とすると、「Article.magazine_id」は2つの別個の関係に関係する。 `` Article.magazine``と `` Article.writer``</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Magazine</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;magazine&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;article&#39;</span>

    <span class="n">article_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>
    <span class="n">magazine_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;magazine.id&#39;</span><span class="p">))</span>
    <span class="n">writer_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">()</span>

    <span class="n">magazine</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Magazine&quot;</span><span class="p">)</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Writer&quot;</span><span class="p">)</span>

    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s1">&#39;article_id&#39;</span><span class="p">,</span> <span class="s1">&#39;magazine_id&#39;</span><span class="p">),</span>
        <span class="n">ForeignKeyConstraint</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;writer_id&#39;</span><span class="p">,</span> <span class="s1">&#39;magazine_id&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;writer.id&#39;</span><span class="p">,</span> <span class="s1">&#39;writer.magazine_id&#39;</span><span class="p">]</span>
        <span class="p">),</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Writer</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;writer&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">magazine_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;magazine.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">magazine</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Magazine&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記のマッピングが設定されると、この警告が表示されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SAWarning</span><span class="p">:</span> <span class="n">relationship</span> <span class="s1">&#39;Article.writer&#39;</span> <span class="n">will</span> <span class="n">copy</span> <span class="n">column</span>
<span class="n">writer</span><span class="o">.</span><span class="n">magazine_id</span> <span class="n">to</span> <span class="n">column</span> <span class="n">article</span><span class="o">.</span><span class="n">magazine_id</span><span class="p">,</span>
<span class="n">which</span> <span class="n">conflicts</span> <span class="k">with</span> <span class="n">relationship</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="s1">&#39;Article.magazine&#39;</span>
<span class="p">(</span><span class="n">copies</span> <span class="n">magazine</span><span class="o">.</span><span class="n">id</span> <span class="n">to</span> <span class="n">article</span><span class="o">.</span><span class="n">magazine_id</span><span class="p">)</span><span class="o">.</span> <span class="n">Consider</span> <span class="n">applying</span>
<span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span> <span class="n">to</span> <span class="n">read</span><span class="o">-</span><span class="n">only</span> <span class="n">relationships</span><span class="p">,</span> <span class="ow">or</span> <span class="n">provide</span> <span class="n">a</span> <span class="n">primaryjoin</span>
<span class="n">condition</span> <span class="n">marking</span> <span class="n">writable</span> <span class="n">columns</span> <span class="k">with</span> <span class="n">the</span> <span class="n">foreign</span><span class="p">()</span> <span class="n">annotation</span><span class="o">.</span></pre></div>
</div>
<p>これは、 `` Article.magazine_id``が2つの異なる外部キー制約の対象であるという事実から始まります。 `` Magazine.id``をソース列として直接参照するだけでなく、 `` Writer``へのコンポジットキーのコンテキストで `` Writer.magazine_id``をソース列として参照します。特定の「雑誌」と「雑誌」を関連づけ、「雑誌」と関連した「作家」と「雑誌」を関連付けると、ORMは`Article.magazine_id``を非決定的に上書きし、私たちが参照する雑誌を静かに変更します。 `` Article``から `` Writer``の関連付けを解除すると、この列にNULLを配置しようと試みることもあります。警告は、これが事実であることを私たちに知らせます。</p>
<p>これを解決するには、次の3つの機能すべてを含めるために、「Article」の動作を打破する必要があります。</p>
<ol class="arabic simple">
<li><cite>Article.magazine`の関係にのみ保存されているデータに基づいて、</cite> <cite>Article.magazine_id``に</cite> <cite>Article``が最初に書きます。これは</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Magazine.id``からコピーされた値です。</li>
<li>`` Article``は `` Article.writer_id``に `` Article.writer``の関係で保持されたデータの代わりに `` Writer.id``列に書き込むことができます。 `` Writer.magazine_id``列は `` Article.magazine_id``に書き込まれるべきではありません。最終的に `` Magazine.id``から供給されるからです。</li>
<li>`` Article``は `` Article.magazine_id``を読み込む際に考慮します。ただし、この関係に代わって*書くのではありません。</li>
</ol>
<p>＃1と＃2だけを取得するには、 `` Article.writer``の&amp;quot;foreign keys &amp;quot;として `` Article.writer_id``のみを指定できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">writer</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Writer&quot;</span><span class="p">,</span> <span class="n">foreign_keys</span><span class="o">=</span><span class="s1">&#39;Article.writer_id&#39;</span><span class="p">)</span></pre></div>
</div>
<p>しかし、これは `` Article.writer``が `` Writer``に対して照会する際に `` Article.magazine_id``を考慮しないという効果があります：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">article</span><span class="p">.</span><span class="n">article_id</span> <span class="k">AS</span> <span class="n">article_article_id</span><span class="p">,</span>
    <span class="n">article</span><span class="p">.</span><span class="n">magazine_id</span> <span class="k">AS</span> <span class="n">article_magazine_id</span><span class="p">,</span>
    <span class="n">article</span><span class="p">.</span><span class="n">writer_id</span> <span class="k">AS</span> <span class="n">article_writer_id</span>
<span class="k">FROM</span> <span class="n">article</span>
<span class="k">JOIN</span> <span class="n">writer</span> <span class="k">ON</span> <span class="n">writer</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">article</span><span class="p">.</span><span class="n">writer_id</span></pre></div>
</div>
<p>したがって、＃1、＃2、＃3のすべてを得るためには、paramref： <cite>〜.relationship.primaryjoin`を：paramref ： `〜.relationship.foreign_keys`引数、またはより簡潔に：func：</cite>〜.orm.foreign`でアノテーションを付けることによって：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="n">writer</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="s2">&quot;Writer&quot;</span><span class="p">,</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(Writer.id == foreign(Article.writer_id), &quot;</span>
                    <span class="s2">&quot;Writer.magazine_id == Article.magazine_id)&quot;</span><span class="p">)</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.0.0 で変更: </span>ORMは、複数の関係から同時に列が同期ターゲットとして使用されたときに警告を出します。</p>
</div>
</div>
<div class="section" id="non-relational-comparisons-materialized-path">
<h2>非リレーショナル比較/マテリアライズド・パス<a class="headerlink" href="#non-relational-comparisons-materialized-path" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">このセクションでは、実験的な特徴について詳しく説明します。</p>
</div>
<p>カスタム式を使用すると、通常のプライマリ/外部キーモデルに従わない非定型の結合条件を生成できます。このような例の1つがマテリアライズド・パス・パターンです。ここでは、ツリー構造を生成するためにパス・トークンを重複させるために文字列を比較します。</p>
<p>：func： <cite>.foreign`と：func：</cite> .remote`を注意深く使用することで、初歩的なマテリアライズドパスシステムを効果的に生成する関係を構築できます。基本的に、：func： <cite>.foreign`と：func：</cite> .remote`が比較式の*同じ側にある場合、その関係は&amp;quot;1対多&amp;quot;とみなされます。彼らが*異なる*側にいるとき、その関係は&amp;quot;many to one &amp;quot;とみなされます。ここで使用する比較のために、コレクションを扱うので、 &amp;quot;one to many &amp;quot;と設定するようにしてください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Element</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;element&#39;</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">descendants</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s1">&#39;Element&#39;</span><span class="p">,</span>
                           <span class="n">primaryjoin</span><span class="o">=</span>
                                <span class="n">remote</span><span class="p">(</span><span class="n">foreign</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="o">.</span><span class="n">like</span><span class="p">(</span>
                                        <span class="n">path</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s1">&#39;/%&#39;</span><span class="p">)),</span>
                           <span class="n">viewonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">order_by</span><span class="o">=</span><span class="n">path</span><span class="p">)</span></pre></div>
</div>
<p>上の例では、パス属性が `` &amp;quot;/ foo / bar2 &amp;quot; <a href="#id1"><span class="problematic" id="id2">``</span></a>である `` Element``オブジェクトが与えられた場合、次のように `` Element.descendants``のロードを求めます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">element</span><span class="o">.</span><span class="n">path</span> <span class="n">AS</span> <span class="n">element_path</span>
<span class="n">FROM</span> <span class="n">element</span>
<span class="n">WHERE</span> <span class="n">element</span><span class="o">.</span><span class="n">path</span> <span class="n">LIKE</span> <span class="p">(</span><span class="s1">&#39;/foo/bar2&#39;</span> <span class="o">||</span> <span class="s1">&#39;/%&#39;</span><span class="p">)</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">element</span><span class="o">.</span><span class="n">path</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.5 で追加: </span>primaryjoin条件内での単一列比較、および比較演算子として：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ColumnOperators.like`を使用するprimaryjoin条件のサポートが追加されました。</p>
</div>
</div>
<div class="section" id="self-referential-many-to-many-relationship">
<span id="self-referential-many-to-many"></span><h2>自己参照多対多リレーションシップ<a class="headerlink" href="#self-referential-many-to-many-relationship" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>多対多リレーションシップは、paramref： <cite>〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.secondaryjoin`のいずれかまたは両方でカスタマイズできます。後者は、多対多の参照を指定する関係で重要です：paramref： <cite>〜.relationship.secondary`引数を使用します。 paramref： `〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.secondaryjoin`の使用を含む一般的な状況は、以下に示すように、クラスから多対多の関係を確立するときです：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="n">node_to_node</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;node_to_node&quot;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;left_node_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;node.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;right_node_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;node.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;node&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">right_nodes</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">,</span>
                        <span class="n">secondary</span><span class="o">=</span><span class="n">node_to_node</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="nb">id</span><span class="o">==</span><span class="n">node_to_node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">left_node_id</span><span class="p">,</span>
                        <span class="n">secondaryjoin</span><span class="o">=</span><span class="nb">id</span><span class="o">==</span><span class="n">node_to_node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">right_node_id</span><span class="p">,</span>
                        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;left_nodes&quot;</span>
    <span class="p">)</span></pre></div>
</div>
<p>上記の場合、SQLAlchemyは、 `` right_nodes``と `` left_nodes``の関係のどちらに接続すべきかを自動的に知ることができません。 ：paramref： <cite>〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.secondaryjoin`引数は、アソシエーションテーブルへの参加方法を確立します。上記のDeclarativeフォームでは、 `` Node``クラスに対応するPythonブロック内でこれらの条件を宣言しているので、 `` id``変数は、私たちが望む：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Column`オブジェクトとして直接利用できますに参加。</p>
<p>あるいは、：paramref： <cite>〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.secondaryjoin`引数を文字列で定義することができます。これは、設定にNode.id <a href="#id1"><span class="problematic" id="id2">``</span></a>列オブジェクトがまだ利用可能であるか、または `` node_to_node``テーブルがおそらく利用可能ではありません。宣言的な文字列の中のplain：class： <cite>.Table`オブジェクトを参照するとき、：class：</cite> .MetaData` ::に存在するように、テーブルの文字列名を使用します</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;node&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">right_nodes</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">,</span>
                        <span class="n">secondary</span><span class="o">=</span><span class="s2">&quot;node_to_node&quot;</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;Node.id==node_to_node.c.left_node_id&quot;</span><span class="p">,</span>
                        <span class="n">secondaryjoin</span><span class="o">=</span><span class="s2">&quot;Node.id==node_to_node.c.right_node_id&quot;</span><span class="p">,</span>
                        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;left_nodes&quot;</span>
    <span class="p">)</span></pre></div>
</div>
<p>古典的なマッピング状況は似ていますが、 `` node_to_node``は `` node.c.id``に結合できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">MetaData</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">relationship</span><span class="p">,</span> <span class="n">mapper</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="n">node_to_node</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;node_to_node&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;left_node_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;node.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;right_node_id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;node.id&quot;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">node</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">mapper</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;right_nodes&#39;</span><span class="p">:</span><span class="n">relationship</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span>
                        <span class="n">secondary</span><span class="o">=</span><span class="n">node_to_node</span><span class="p">,</span>
                        <span class="n">primaryjoin</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">node_to_node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">left_node_id</span><span class="p">,</span>
                        <span class="n">secondaryjoin</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">node_to_node</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">right_node_id</span><span class="p">,</span>
                        <span class="n">backref</span><span class="o">=</span><span class="s2">&quot;left_nodes&quot;</span>
                    <span class="p">)})</span></pre></div>
</div>
<p>両方の例で、：paramref： <cite>〜.relationship.backref`キーワードは、</cite> <cite>left_nodes``バックリファレンスを指定します。 -  func：</cite> .relationship`は、逆方向の第2の関係を作成するとき、 ：paramref： <cite>〜.relationship.primaryjoin`と：paramref：</cite>〜.relationship.secondaryjoin`引数です。</p>
</div>
<div class="section" id="composite-secondary-joins">
<span id="composite-secondary-join"></span><h2>コンポジット&amp;quot;セカンダリ&amp;quot;の結合<a class="headerlink" href="#composite-secondary-joins" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このセクションでは、SQLAlchemyの新機能と実験的機能を紹介します。</p>
</div>
<p>時には、2つのテーブルの間に：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship &amp;#39;を構築しようとするとき、それらに参加するために2つか3つ以上のテーブルが必要になることがあります。これは：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.relationship`の領域であり、可能なものの境界を突き止めようとするものであり、多くの場合、これらのエキゾチックなユースケースの究極の解決策は、SQLAlchemyのメーリングリストで叩かれる必要があります。</p>
<p>より最近のバージョンのSQLAlchemyでは：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.relationship.secondary`パラメータは、複数のテーブルからなる複合ターゲットを提供するために、これらのケースのいくつかで使用できます。以下はそのような結合条件の例です（バージョン0.9.2が少なくとも機能するために必要です）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;b.id&#39;</span><span class="p">))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span>
                <span class="n">secondary</span><span class="o">=</span><span class="s2">&quot;join(B, D, B.d_id == D.id).&quot;</span>
                            <span class="s2">&quot;join(C, C.d_id == D.id)&quot;</span><span class="p">,</span>
                <span class="n">primaryjoin</span><span class="o">=</span><span class="s2">&quot;and_(A.b_id == B.id, A.id == C.a_id)&quot;</span><span class="p">,</span>
                <span class="n">secondaryjoin</span><span class="o">=</span><span class="s2">&quot;D.id == B.d_id&quot;</span><span class="p">,</span>
                <span class="n">uselist</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">d_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;d.id&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;a.id&#39;</span><span class="p">))</span>
    <span class="n">d_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;d.id&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>上記の例では、paramref： <cite>〜.relationship.secondary</cite>、：paramref：<cite>〜.relationship.primaryjoin</cite>、および：paramref： <cite>〜.relationship.secondaryjoin`の3つを、それぞれを参照する宣言的スタイルで提供します。テーブル名は `</cite> a``、 `` b``、 `` c``、 `` d``です。 `` A``から `` D``への問い合わせは次のようになります：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<div class='show_sql'>SELECT a.id AS a_id, a.b_id AS a_b_id
FROM a JOIN (
    b AS b_1 JOIN d AS d_1 ON b_1.d_id = d_1.id
        JOIN c AS c_1 ON c_1.d_id = d_1.id)
    ON a.b_id = b_1.id AND a.id = c_1.a_id JOIN d ON d.id = b_1.d_id</div></pre></div>
</div>
<p>上記の例では、複数のテーブルを&amp;quot;セカンダリ&amp;quot;コンテナにまとめることができるので、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`のために&amp;quot;シンプル&amp;quot;を維持しながら多くのテーブルに参加することができます。 &amp;quot;left &amp;quot;と&amp;quot;right sideの両方に&amp;quot; one &amp;quot;というテーブルがあり、複雑さは真ん中に保持されています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.2 で追加: </span>join：eager joinとlazy loadingのサポートを含む：paramref： <cite>〜.relationship.secondary`引数のターゲットとしてa：func：</cite> .join（） <a href="#id1"><span class="problematic" id="id2">`</span></a>構造体を直接使用できるようにサポートが改善されました。宣言内でのサポートとして、クラス名をターゲットとする結合などの複雑な条件を指定します。</p>
</div>
</div>
<div class="section" id="relationship-to-non-primary-mapper">
<span id="relationship-non-primary-mapper"></span><h2>非プライマリマッパーとの関係<a class="headerlink" href="#relationship-to-non-primary-mapper" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前のセクションでは、join条件内に追加のテーブルを配置するために、paramref： <cite>.relationship.secondary`を使用する方法を示しました。この手法でも十分ではない複雑な結合ケースが1つあります。任意の数の「C」、「D」などを使用して「A」から「B」に参加しようとすると、 A``と `</cite> B`` <em>直接</em>。この場合、 `` A``から `` B``への結合は、中間テーブルが特別な処理を必要とするかもしれないので、複雑な：paramref： <cite>.relationship.primaryjoin`条件では表現するのが難しいかもしれません。 `</cite> A-&amp;gt; secondary-&amp;gt; B``パターンは `` A``と `` B``の間の直接参照をサポートしていないので、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.relationship.secondary`オブジェクトでは表現できません。この**高度な**ケースが発生すると、関係のターゲットとして2番目のマッピングを作成することに頼ることができます。ここでは、この結合に必要なすべての追加テーブルを含むクラスへのマッピングを行うためにfunc： <a href="#id3"><span class="problematic" id="id4">`</span></a>.mapper`を使用します。このマッパーをクラスのための&amp;quot;代替&amp;quot;マッピングとして生成するために、：paramref： <a href="#id5"><span class="problematic" id="id6">`</span></a>〜.mapper.non_primary`フラグを使用します。</p>
<p>以下は `` A``から `` B``への簡単な結合でfunc： <cite>.relationship`を示していますが、primaryjoin条件には</cite> <cite>C``と</cite> <cite>D``という2つの追加エンティティが追加されています。同時に `</cite> A``と `` B``の両方の行と並んでいる行を持たなければなりません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;b.id&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;a.id&#39;</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">c_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;c.id&#39;</span><span class="p">))</span>
    <span class="n">b_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;b.id&#39;</span><span class="p">))</span>

<span class="c1"># 1. set up the join() as a variable, so we can refer</span>
<span class="c1"># to it in the mapping multiple times.</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">b_id</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">D</span><span class="o">.</span><span class="n">c_id</span><span class="p">)</span>

<span class="c1"># 2. Create a new mapper() to B, with non_primary=True.</span>
<span class="c1"># Columns in the join with the same name must be</span>
<span class="c1"># disambiguated within the mapping, using named properties.</span>
<span class="n">B_viacd</span> <span class="o">=</span> <span class="n">mapper</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">non_primary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">&quot;b_id&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">j</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b_id</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">d_b_id</span><span class="p">],</span>
    <span class="s2">&quot;d_id&quot;</span><span class="p">:</span> <span class="n">j</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">d_id</span>
    <span class="p">})</span>

<span class="n">A</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">B_viacd</span><span class="p">,</span> <span class="n">primaryjoin</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">b_id</span> <span class="o">==</span> <span class="n">B_viacd</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b_id</span><span class="p">)</span></pre></div>
</div>
<p>上記の場合、 `` B``のプライマリでないマッパーは、クエリを実行するときに追加の列に対して出力します。これらは無視することができます：</p>
<div class="highlight-python+sql notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<div class='show_sql'>SELECT a.id AS a_id, a.b_id AS a_b_id
FROM a JOIN (b JOIN d ON d.b_id = b.id JOIN c ON c.id = d.c_id) ON a.b_id = b.id</div></pre></div>
</div>
</div>
<div class="section" id="row-limited-relationships-with-window-functions">
<h2>ウィンドウ関数との行限定関係<a class="headerlink" href="#row-limited-relationships-with-window-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>非プライマリマッパーの別の興味深い使用例は、関係が任意のフォームの特殊なSELECTに結合する必要がある状況です。 1つのシナリオは、関係のために戻される行数を制限するなど、ウィンドウ関数の使用が必要な場合です。下の例は、各コレクションの最初の10個のアイテムを読み込む非プライマリマッパー関係を示しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;a.id&quot;</span><span class="p">))</span>

<span class="n">partition</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span>
    <span class="n">B</span><span class="p">,</span>
    <span class="n">func</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span>
        <span class="n">order_by</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">a_id</span>
    <span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="p">])</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>

<span class="n">partitioned_b</span> <span class="o">=</span> <span class="n">mapper</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">non_primary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">A</span><span class="o">.</span><span class="n">partitioned_bs</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
    <span class="n">partitioned_b</span><span class="p">,</span>
    <span class="n">primaryjoin</span><span class="o">=</span><span class="n">and_</span><span class="p">(</span><span class="n">partitioned_b</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">a_id</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">partitioned_b</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">)</span></pre></div>
</div>
<p>上記の `` partitioned_bs``の関係は、func： <cite>.selectinload</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">partitioned_bs</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">partitioned_bs</span><span class="p">)</span>   <span class="c1"># &lt;-- will be no more than ten objects</span></pre></div>
</div>
<p>上記の場合、&amp;quot;selectinload &amp;quot;クエリは以下のようになります：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">a_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">a_1_id</span><span class="p">,</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">anon_1_id</span><span class="p">,</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">a_id</span> <span class="k">AS</span> <span class="n">anon_1_a_id</span><span class="p">,</span>
    <span class="n">anon_1</span><span class="p">.</span><span class="k">data</span> <span class="k">AS</span> <span class="n">anon_1_data</span><span class="p">,</span> <span class="n">anon_1</span><span class="p">.</span><span class="k">index</span> <span class="k">AS</span> <span class="n">anon_1_index</span>
<span class="k">FROM</span> <span class="n">a</span> <span class="k">AS</span> <span class="n">a_1</span>
<span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">a_id</span> <span class="k">AS</span> <span class="n">a_id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">data</span> <span class="k">AS</span> <span class="k">data</span><span class="p">,</span>
    <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">b</span><span class="p">.</span><span class="n">a_id</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AS</span> <span class="k">index</span>
    <span class="k">FROM</span> <span class="n">b</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">ON</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">a_id</span> <span class="o">=</span> <span class="n">a_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">anon_1</span><span class="p">.</span><span class="k">index</span> <span class="o">&lt;</span> <span class="o">%</span><span class="p">(</span><span class="n">index_1</span><span class="p">)</span><span class="n">s</span>
<span class="k">WHERE</span> <span class="n">a_1</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span> <span class="p">...</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">collection</span> <span class="p">...)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">a_1</span><span class="p">.</span><span class="n">id</span></pre></div>
</div>
<p>上の&amp;quot;a &amp;quot;の一致する主キーごとに、最初の10個の &amp;quot;bs&amp;quot;が&amp;quot;b.id &amp;quot;の順序で取得されます。 &amp;quot;a_id &amp;quot;を分割することで、&amp;quot;行番号&amp;quot;が親&amp;quot;a_id &amp;quot;に対してローカルであることが保証されます。</p>
<p>このようなマッピングには、通常、永続操作のための&amp;quot;A &amp;quot;から&amp;quot;B &amp;quot;への&amp;quot;plain &amp;quot;関係も含まれ、&amp;quot;A 必要である。</p>
</div>
<div class="section" id="building-query-enabled-properties">
<h2>クエリが有効なプロパティの構築<a class="headerlink" href="#building-query-enabled-properties" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>非常に野心的なカスタム結合条件は、直接永続化できず、場合によっては正しくロードされないこともあります。方程式の永続部分を削除するには、：func： <cite>〜sqlalchemy.orm.relationship`のフラグ：paramref：</cite>〜.relationship.viewonly`を使用します。これは、読み取り専用の属性として設定されますコレクションはflush（）で無視されます）。しかし、極端な場合には、次のように：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`と一緒に通常のPythonプロパティを使用することを検討してください：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_addresses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">object_session</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">with_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_addresses</span><span class="p">)</span></pre></div>
</div>
</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="backref.html" title="previous chapter">バックリファレンスとの関係のリンク</a>
        Next:
        <a href="collections.html" title="next chapter">コレクションの構成とテクニック</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    突然変異の追跡
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
        <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../../index.html" />
        <link rel="up" title="ORM拡張" href="index.html" />
        <link rel="next" title="オーダーリスト" href="orderinglist.html" />
        <link rel="prev" title="宣言的API" href="declarative/api.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../../contents.html">Contents</a> |
                <a href="../../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="../tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="index.html">ORM拡張</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="associationproxy.html">アソシエーションプロキシ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="automap.html">オートマップ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="baked.html">焼いたクエリ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="declarative/index.html">宣言的</a></span></li>
<li class="selected"><span class="link-container first"><strong>突然変異の追跡</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#establishing-mutability-on-scalar-column-values">スカラの列値の変更可能性の確立</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#supporting-pickling">支持酸洗い</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#receiving-events">イベントを受け取る</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#establishing-mutability-on-composites">コンポジットへの変更可能性の確立</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#coercing-mutable-composites">変更可能なコンポジットの強制</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#id1">支持酸洗い</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#api-reference">APIリファレンス</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="orderinglist.html">オーダーリスト</a></span></li>
<li><span class="link-container first"><a class="reference external" href="horizontal_shard.html">水平シャーディング</a></span></li>
<li><span class="link-container first"><a class="reference external" href="hybrid.html">ハイブリッド属性</a></span></li>
<li><span class="link-container first"><a class="reference external" href="indexable.html">インデックス作成可能</a></span></li>
<li><span class="link-container first"><a class="reference external" href="instrumentation.html">代替クラスの計装</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="../examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.ext.mutable">
<span id="mutation-tracking"></span><span id="mutable-toplevel"></span><h1>突然変異の追跡<a class="headerlink" href="#module-sqlalchemy.ext.mutable" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>親オブジェクトの所有に関するORM変更イベントに伝播されるスカラー値のインプレース変更の追跡をサポートします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7 で追加: </span>：mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.ext.mutable`は、SQLAlchemyの従来のアプローチをスカラー値のインプレース変異に置き換えます。 ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>07_migration_mutation_extension`を参照してください。</p>
</div>
<div class="section" id="establishing-mutability-on-scalar-column-values">
<span id="mutable-scalars"></span><h2>スカラの列値の変更可能性の確立<a class="headerlink" href="#establishing-mutability-on-scalar-column-values" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>&amp;quot;可変&amp;quot;構造の典型的な例は、Python辞書です。 ：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>types_toplevel`で紹介されている例に続いて、永続化される前にPython辞書をJSON文字列にマーシャリングするカスタムタイプから始めます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">TypeDecorator</span><span class="p">,</span> <span class="n">VARCHAR</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">JSONEncodedDict</span><span class="p">(</span><span class="n">TypeDecorator</span><span class="p">):</span>
    <span class="s2">&quot;Represents an immutable structure as a json-encoded string.&quot;</span>

    <span class="n">impl</span> <span class="o">=</span> <span class="n">VARCHAR</span>

    <span class="k">def</span> <span class="nf">process_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">process_result_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dialect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
<p>`` json``の使用法は、例の目的に過ぎません。 ：mod： <cite>sqlalchemy.ext.mutable`拡張は、class：</cite> .PickleType`、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.postgresql.ARRAY`など、ターゲットのPython型が変更可能な任意の型で使用できます。</p>
<p>：mod： <cite>sqlalchemy.ext.mutable`拡張を使用する場合、値自体はそれを参照するすべての親を追跡します。以下に、class： `.MutableDict`ディクショナリオブジェクトの簡単なバージョンを示します。このオブジェクトは：class：</cite> .Mutable` mixinをプレーンなPythonディクショナリに適用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.mutable</span> <span class="k">import</span> <span class="n">Mutable</span>

<span class="k">class</span> <span class="nc">MutableDict</span><span class="p">(</span><span class="n">Mutable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&quot;Convert plain dictionaries to MutableDict.&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">MutableDict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">MutableDict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># this call will raise ValueError</span>
            <span class="k">return</span> <span class="n">Mutable</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&quot;Detect dictionary set events and emit change events.&quot;</span>

        <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="s2">&quot;Detect dictionary del events and emit change events.&quot;</span>

        <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span></pre></div>
</div>
<p>上記のディクショナリクラスでは、Pythonに組み込まれた `` dict``をサブクラス化して `` __setitem__``を通してすべての突然変異イベントをルーティングするdictサブクラスを生成するアプローチをとっています。このアプローチには、 `` UserDict.UserDict``や `` collections.MutableMapping``のサブクラス化などのバリエーションがあります。この例にとって重要な部分は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mutable.changed`メソッドは、データ構造のインプレース変更が行われるたびに呼び出されるということです。</p>
<p>`` MutableDict``のインスタンスではない値（ `` json``モジュールで返されたプレーンな辞書など）を、 `` json``モジュールに変換するために使われる：meth： <cite>.Mutable.coerce`メソッドも再定義します。適切なタイプ。このメソッドの定義はオプションです。 `</cite> MutableDict``のインスタンスを常に返すように `` JSONEncodedDict``を作成し、すべての呼び出しコードが明示的に `` MutableDict``を明示的に使用するようにすることもできます。 ：meth： <cite>.Mutable.coerce`がオーバーライドされていない場合、親オブジェクトに適用され、変更可能な型のインスタンスでない値は、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>ValueError``を送出します。</p>
<p>私たちの新しい `` MutableDict``型はクラスメソッドを提供しています：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Mutable.as_mutable`これは、型と関連付けるためにカラムメタデータ内で使用できます。このメソッドは、指定された型オブジェクトまたはクラスを取得し、この型の今後のすべてのマッピングを検出し、イベントリスニングインストゥルメンテーションをマップされた属性に適用するリスナーを関連付けます。のような、古典的なテーブルのメタデータ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span>

<span class="n">my_data</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;my_data&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">MutableDict</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>上記：:: meth： <cite>〜.Mutable.as_mutable`は、型オブジェクトがすでにインスタンスではない場合には、</cite> <cite>JSONEncodedDict``のインスタンスを返します。これは、この型に対してマップされた属性をインターセプトします。以下では、 `</cite> my_data``テーブルに対して単純なマッピングを確立します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">mapper</span>

<span class="k">class</span> <span class="nc">MyDataClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># associates mutation listeners with MyDataClass.data</span>
<span class="n">mapper</span><span class="p">(</span><span class="n">MyDataClass</span><span class="p">,</span> <span class="n">my_data</span><span class="p">)</span></pre></div>
</div>
<p>`` MyDataClass.data``メンバに、その値が変更されたことが通知されます。</p>
<p>declarative ::を使用すると使用方法に違いはありません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">MyDataClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;my_data&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">MutableDict</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">))</span></pre></div>
</div>
<p>`` MyDataClass.data``メンバのインプレースの変更は、その属性を親オブジェクトの&amp;quot;dirty &amp;quot;としてフラグを立てます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">MyDataClass</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;value1&#39;</span><span class="p">:</span><span class="s1">&#39;foo&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;value1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">m1</span> <span class="ow">in</span> <span class="n">sess</span><span class="o">.</span><span class="n">dirty</span>
<span class="go">True</span></pre></div>
</div>
<p>`` MutableDict``は、 `` JSONEncodedDict``のすべての将来のインスタンスに、：meth： <cite>〜.Mutable.associate_with`を使って1つのステップで関連付けることができます。これは：meth： `〜.Mutable.as_mutable`に似ていますが、それは個別に宣言する必要はなく、無条件にすべてのマッピングで</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>MutableDict``のすべての出現を傍受します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MutableDict</span><span class="o">.</span><span class="n">associate_with</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDataClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;my_data&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">)</span></pre></div>
</div>
<div class="section" id="supporting-pickling">
<h3>支持酸洗い<a class="headerlink" href="#supporting-pickling" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：mod： <cite>sqlalchemy.ext.mutable`拡張のキーは値オブジェクトに</cite> <cite>weakref.WeakKeyDictionary``を置くことに依存しています。これは親のマップされたオブジェクトのマッピングをそれらが存在する属性名にキーして格納しますこの値に関連付けられます。 `</cite> WeakKeyDictionary``オブジェクトは弱点と関数のコールバックを含んでいるため、picklableではありません。私たちの場合、これは良いことです。なぜなら、このディクショナリをpicklableにすると、親の文脈の外で自分自身でpickleされる値オブジェクトのために、大きすぎるpickleサイズにつながる可能性があるからです。ここでの開発者の責任は、pickleストリームから：meth： <cite>〜MutableBase._parents`コレクションを除外する</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>__getstate__``メソッドを提供することだけです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMutableType</span><span class="p">(</span><span class="n">Mutable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_parents&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></pre></div>
</div>
<p>私たちの辞書の例では、dict自体の内容を返す必要があります（また、それらを__setstate__に復元する必要があります）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MutableDict</span><span class="p">(</span><span class="n">Mutable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="c1"># ....</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></pre></div>
</div>
<p>mutable valueオブジェクトがpickleの一部でもある1つ以上の親オブジェクトに添付されているときにpickleされる場合、：class： <cite>.Mutable</cite> mixinは：attr：` .Mutable._parents <a href="#id1"><span class="problematic" id="id2">`</span></a>各値オブジェクトのコレクションは、所有する親自体がunpickleされているので。</p>
</div>
<div class="section" id="receiving-events">
<h3>イベントを受け取る<a class="headerlink" href="#receiving-events" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AttributeEvents.modified`イベントハンドラは、変更可能なスカラが変更イベントを発行したときにイベントを受け取るために使用されます。このイベントハンドラは、：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.attributes.flag_modified`関数が変更可能な拡張モジュール内から呼び出されたときに呼び出されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="k">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">MyDataClass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;my_data&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">MutableDict</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(</span><span class="n">JSONEncodedDict</span><span class="p">))</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">MyDataClass</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;modified&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">modified_json</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;json value modified:&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></pre></div>
</div>
</div>
</div>
<div class="section" id="establishing-mutability-on-composites">
<span id="mutable-composites"></span><h2>コンポジットへの変更可能性の確立<a class="headerlink" href="#establishing-mutability-on-composites" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コンポジットは、単一のスカラーアトリビュートに、基本となるマップされたテーブルの1つまたは複数のカラムからの情報を表すオブジェクト値を割り当てることを可能にする特別なORM機能です。通常の例は、幾何学的な&amp;quot;point &amp;quot;の例であり、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>mapper_composite`に導入されています。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>：func： <cite>.orm.composite`の内部は大幅に単純化され、インプレース突然変異の検出はもはやデフォルトでは有効になっていません。その代わりに、ユーザー定義の値はそれ自身の変更を検出し、それを所有するすべての親に伝搬する必要があります。 ：mod： `sqlalchemy.ext.mutable`拡張はhelperクラスを提供します：class：</cite> .MutableComposite`は、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mutable`クラスのわずかなバリエーションです。</p>
</div>
<p>：class： <cite>.Mutable`の場合と同様に、ユーザ定義の複合クラスは：class：</cite> .MutableComposite`をmixinとしてサブクラス化し、：meth： <cite>.MutableComposite.changed `メソッド。複合クラスの場合、検出は通常Python記述子（すなわち `</cite> &#64; property``）の使用を介して行われるか、特殊なPythonメソッド `` __setattr __（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を介して行われます。以下では：class： <cite>.MutableComposite`をサブクラス化するための：ref：</cite> mapper_composite`に導入された `` Point``クラスを拡張し、 `` __setattr__``を介して：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.MutableCompositeに属性セットイベントをルーティングします。変更されたメソッド:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.mutable</span> <span class="k">import</span> <span class="n">MutableComposite</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">MutableComposite</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&quot;Intercept set events&quot;</span>

        <span class="c1"># set the attribute</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># alert all parents to the change</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__composite_values__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="ow">and</span> \
            <span class="n">other</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></pre></div>
</div>
<p>：class： <cite>.MutableComposite`クラスはPythonのメタクラスを使って、</cite> <cite>Point``型を指定する：func：</cite> .orm.composite`の使用法のリスナーを自動的に確立します。以下、 `` Point``が `` Vertex``クラスにマップされると、 `` Point``オブジェクトからの変更イベントを `` Vertex.start``と `` Vertex`のそれぞれにルーティングするリスナが確立されます。 end``属性:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">composite</span><span class="p">,</span> <span class="n">mapper</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span>

<span class="n">vertices</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;y1&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;y2&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">Vertex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">mapper</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">composite</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y1</span><span class="p">),</span>
    <span class="s1">&#39;end&#39;</span><span class="p">:</span> <span class="n">composite</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y2</span><span class="p">)</span>
<span class="p">})</span></pre></div>
</div>
<p>`` Vertex.start``または `` Vertex.end``のメンバをインプレースで変更すると、その属性は親オブジェクトの&amp;quot;dirty &amp;quot;にフラグが立てられます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sess</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">sess</span><span class="o">.</span><span class="n">dirty</span>
<span class="go">True</span></pre></div>
</div>
<div class="section" id="coercing-mutable-composites">
<h3>変更可能なコンポジットの強制<a class="headerlink" href="#coercing-mutable-composites" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：meth： <cite>.MutableBase.coerce`メソッドは複合型でもサポートされています。 ：class： `.MutableComposite`の場合、：meth：</cite> .MutableBase.coerce`メソッドは、ロード操作ではなく、属性セット操作に対してのみ呼び出されます。 ：meth： <cite>.MutableBase.coerce`メソッドをオーバーライドすることは、カスタム複合型を使用するすべての属性に対して：func：</cite> .validates`検証ルーチンを使用することと本質的に同じです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">MutableComposite</span><span class="p">):</span>
    <span class="c1"># other Point methods</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tuple or Point expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.10,0.8.0b2 で追加: </span>：meth： <cite>.MutableBase.coerce`メソッドを、：class：</cite> .MutableComposite`のオブジェクトと組み合わせてサポートします。</p>
</div>
</div>
<div class="section" id="id1">
<h3>支持酸洗い<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：class： <cite>.Mutable`の場合と同じように、：class：</cite> .MutableComposite`ヘルパークラスは、pickableではない：meth： <cite>MutableBase._parents`属性で利用可能な</cite> <cite>weakref.WeakKeyDictionary``を使用します。 `</cite> Point``やその所有クラス `` Vertex``のインスタンスをピクルする必要がある場合、少なくとも <cite>_parents``ディクショナリを含まない</cite> <cite>__getstate__``を定義する必要があります。以下では、 `</cite> Point``クラスの最小限の形式をパッケージ化する `` __getstate__``と `` __setstate__``の両方を定義しています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">MutableComposite</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">state</span></pre></div>
</div>
<p>：class： <cite>.Mutable`と同様に、：class：</cite> .MutableComposite`は親のオブジェクト・リレーショナル状態のpicklingプロセスを補完して、：meth： <cite>MutableBase._parents`コレクションをすべて</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>Point``に復元しますオブジェクト。</p>
</div>
</div>
<div class="section" id="api-reference">
<h2>APIリファレンス<a class="headerlink" href="#api-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.ext.mutable.MutableBase">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">MutableBase</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableBase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共通の基本クラスは：class： <cite>.Mutable`と：class：</cite> .MutableComposite`です。</p>
<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.MutableBase._parents">
<code class="descname">_parents</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableBase._parents" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>parentの親オブジェクト - &amp;gt;属性名の辞書。</p>
<p>この属性は、いわゆる &amp;quot;memoized&amp;quot;プロパティです。最初にアクセスされたときに新しい `` weakref.WeakKeyDictionary``で自身を初期化し、その後のアクセス時に同じオブジェクトを返します。</p>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.MutableBase.coerce">
<em class="property">classmethod </em><code class="descname">coerce</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableBase.coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値が与えられたら、それをターゲットタイプに強制します。</p>
<p>着信データを特定のタイプに強制するカスタムサブクラスによってオーバーライドできます。</p>
<p>デフォルトでは、 `` ValueError``が発生します。</p>
<p>このメソッドは、親クラスが：class： <cite>.Mutable`型であるか、：class：</cite> .MutableComposite`型であるかによって異なるシナリオで呼び出されます。前者の場合、ORMローディング操作中だけでなく、属性セット操作も呼び出されます。後者の場合、属性セット操作中にのみ呼び出されます。 ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.composite`構造体は、ロード操作中に変換を処理します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.ext.mutable.MutableBase.coerce.params.key"></span><strong>key</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.mutable.MutableBase.coerce.params.key">¶</a> -- 設定されているORMでマップされた属性の文字列名。</li>
<li><span class="target" id="sqlalchemy.ext.mutable.MutableBase.coerce.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.mutable.MutableBase.coerce.params.value">¶</a> -- 入ってくる値。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">メソッドは強制的な値を返すか、強制が完了できない場合は `` ValueError``を送出します。</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.mutable.Mutable">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">Mutable</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable.MutableBase</span></code></a></p>
<p>親オブジェクトへの変更イベントの透過的伝搬を定義するMixin。</p>
<p>使用方法については、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>mutable_scalars`の例を参照してください。</p>
<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__eq__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self==value.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__init__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__le__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__lt__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">__ne__</span></code> <em>attribute of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></div>
<p>Return self!=value.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable._get_listen_keys">
<em class="property">classmethod </em><code class="descname">_get_listen_keys</code><span class="sig-paren">(</span><em>attribute</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable._get_listen_keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_listen_keys()</span></code> <em>method of</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableBase</span></code></a></div>
<p>記述子属性が与えられた場合、この属性の状態の変化を示す属性キーの `` set（） <a href="#id1"><span class="problematic" id="id2">``</span></a>を返します。</p>
<p>これは通常 `` set（[attribute.key]） <a href="#id1"><span class="problematic" id="id2">``</span></a>ですが、追加のキーを提供するためにオーバーライドできます。例えば：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.MutableComposite`は、コンポジット値を構成する列に関連付けられた属性キーでこのセットを補強します。</p>
<p>このコレクションは：meth： <cite>.InstanceEvents.refresh`と：meth：</cite> .InstanceEvents.refresh_flush`イベントをインターセプトする場合に参照されます。これらのイベントは、リフレッシュされた属性名のリストを渡します。リストをこのセットと比較して、アクションを取る必要があるかどうかを判断します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable._listen_on_attribute">
<em class="property">classmethod </em><code class="descname">_listen_on_attribute</code><span class="sig-paren">(</span><em>attribute</em>, <em>coerce</em>, <em>parent_cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable._listen_on_attribute" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-meth docutils literal notranslate"><span class="pre">_listen_on_attribute()</span></code> <em>method of</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableBase</span></code></a></div>
<p>指定されたマップされた記述子の突然変異リスナーとしてこの型を設定します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.ext.mutable.Mutable._parents">
<code class="descname">_parents</code><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable._parents" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase._parents" title="sqlalchemy.ext.mutable.MutableBase._parents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_parents</span></code></a> <em>attribute of</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableBase</span></code></a></div>
<p>parentの親オブジェクト - &amp;gt;属性名の辞書。</p>
<p>この属性は、いわゆる &amp;quot;memoized&amp;quot;プロパティです。最初にアクセスされたときに新しい `` weakref.WeakKeyDictionary``で自身を初期化し、その後のアクセス時に同じオブジェクトを返します。</p>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable.as_mutable">
<em class="property">classmethod </em><code class="descname">as_mutable</code><span class="sig-paren">(</span><em>sqltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.as_mutable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この可変Python型にSQL型を関連付けます。</p>
<p>これにより、指定された型に対してORMマッピングを検出し、これらのマッピングに突然変異イベントトラッカーを追加するリスナーが確立されます。</p>
<p>型は無条件にインスタンスとして返されるので、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.as_mutable`をinline</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">MyMutableType</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(</span><span class="n">PickleType</span><span class="p">))</span>
<span class="p">)</span></pre></div>
</div>
<p>クラスが指定されていても、返される型は常にインスタンスであり、その型インスタンスで特に宣言された列だけが追加の計装を受け取ることに注意してください。</p>
<p>ある特定の型のすべての出現に特定の変更可能な型を関連付けるには、：class： <cite>.Mutable`サブクラスの：meth：</cite> .Mutable.associate_with`クラスメソッドを使用して、グローバルな関連付けを確立します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">このメソッドによって確立されたリスナーは、すべてのマッパーにとって* global <a href="#id1"><span class="problematic" id="id2">*</span></a>であり、ガベージコレクションされません。特別な型ではなく、アプリケーションに永続的な型の場合にのみ：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.as_mutable`を使用してください。そうしないと、メモリ使用量が無限に増加します。</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable.associate_with">
<em class="property">classmethod </em><code class="descname">associate_with</code><span class="sig-paren">(</span><em>sqltype</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.associate_with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された型の今後マップされるすべての列にこのラッパーを関連付けます。</p>
<p>これは `` associate_with_attribute``を自動的に呼び出す便利なメソッドです。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">このメソッドによって確立されたリスナーは、すべてのマッパーにとって* global <a href="#id1"><span class="problematic" id="id2">*</span></a>であり、ガベージコレクションされません。アドホック型ではなく、アプリケーションに永続的な型の場合にのみ：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.associate_with`を使用してください。そうしないと、メモリ使用量が無限に増加します。</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable.associate_with_attribute">
<em class="property">classmethod </em><code class="descname">associate_with_attribute</code><span class="sig-paren">(</span><em>attribute</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.associate_with_attribute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたマップされた記述子の突然変異リスナーとしてこの型を設定します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.Mutable.changed">
<code class="descname">changed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.changed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスは、変更イベントが発生するたびにこのメソッドを呼び出す必要があります。</p>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.Mutable.coerce">
<em class="property">classmethod </em><code class="descname">coerce</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.Mutable.coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase.coerce" title="sqlalchemy.ext.mutable.MutableBase.coerce"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coerce()</span></code></a> <em>method of</em> <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableBase</span></code></a></div>
<p>値が与えられたら、それをターゲットタイプに強制します。</p>
<p>着信データを特定のタイプに強制するカスタムサブクラスによってオーバーライドできます。</p>
<p>デフォルトでは、 `` ValueError``が発生します。</p>
<p>このメソッドは、親クラスが：class： <cite>.Mutable`型であるか、：class：</cite> .MutableComposite`型であるかによって異なるシナリオで呼び出されます。前者の場合、ORMローディング操作中だけでなく、属性セット操作も呼び出されます。後者の場合、属性セット操作中にのみ呼び出されます。 ：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.composite`構造体は、ロード操作中に変換を処理します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.ext.mutable.Mutable.coerce.params.key"></span><strong>key</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.mutable.Mutable.coerce.params.key">¶</a> -- 設定されているORMでマップされた属性の文字列名。</li>
<li><span class="target" id="sqlalchemy.ext.mutable.Mutable.coerce.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.mutable.Mutable.coerce.params.value">¶</a> -- 入ってくる値。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">メソッドは強制的な値を返すか、強制が完了できない場合は `` ValueError``を送出します。</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.mutable.MutableComposite">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">MutableComposite</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableComposite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.ext.mutable.MutableBase" title="sqlalchemy.ext.mutable.MutableBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable.MutableBase</span></code></a></p>
<p>ミックスインは、SQLAlchemy &amp;quot;複合&amp;quot;オブジェクト上の変更イベントを所有する親または親への透過的な伝播を定義します。</p>
<p>使用法については、：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>mutable_composites`の例を参照してください。</p>
<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableComposite.changed">
<code class="descname">changed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableComposite.changed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスは、変更イベントが発生するたびにこのメソッドを呼び出す必要があります。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.mutable.MutableDict">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">MutableDict</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.ext.mutable.Mutable" title="sqlalchemy.ext.mutable.Mutable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable.Mutable</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></p>
<p>クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mutable`を実装する辞書型。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableDict`オブジェクトは、値が追加または削除されたときを含めて、ディクショナリの内容が変更されたときに基本となるマッピングに変更イベントを送出するディクショナリを実装します。</p>
<p>注：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableDict`は辞書内の*値自体に可変トラッキングを適用しません**。したがって、JSON構造のような*再帰的な辞書構造の深い変更を追跡するユースケースのための十分な解決策ではありません。このユースケースをサポートするには、class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.MutableDict`のサブクラスを構築します。このクラスは、ディクショナリに配置された値を適切に調整して変更可能にし、イベントを親構造体に出力します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：クラス： <cite>.MutableList</cite></p>
<p class="last">：クラス： <cite>.MutableSet</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableDict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None.  Remove all items from D.<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.MutableDict.coerce">
<em class="property">classmethod </em><code class="descname">coerce</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プレーンディクショナリをこのクラスのインスタンスに変換します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableDict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableDict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.popitem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableDict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.setdefault" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableDict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableDict.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.mutable.MutableList">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">MutableList</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.ext.mutable.Mutable" title="sqlalchemy.ext.mutable.Mutable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable.Mutable</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></p>
<p>クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mutable`を実装するリスト型です。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableList`オブジェクトは、値が追加または削除されたときを含め、リストの内容が変更されたときに基本となるマッピングに変更イベントを送出するリストを実装します。</p>
<p>注意：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableList`はリスト内の*値自体に変更可能なトラッキングを適用しません**。したがって、JSON構造のような*再帰的*可変構造への深い変更を追跡するというユースケースのための十分な解決策ではありません。このユースケースをサポートするには、class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.MutableList`のサブクラスを構築します。サブクラスは、ディクショナリに配置された値に適切な値を与えて、それらも&amp;quot;変更可能 &amp;quot;になるようにし、イベントを親構造体に出力します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：クラス： <cite>.MutableDict</cite></p>
<p class="last">：クラス： <cite>.MutableSet</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span> &#x2192; None -- append object to end<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.append" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None -- remove all items from L<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.MutableList.coerce">
<em class="property">classmethod </em><code class="descname">coerce</code><span class="sig-paren">(</span><em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プレーンリストをこのクラスのインスタンスに変換します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span> &#x2192; None -- extend list by appending elements from the iterable<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.extend" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.insert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>L.insert(index, object) -- insert object before index</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="optional">[</span><em>index</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; item -- remove and return item at index (default last).<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Raises IndexError if list is empty or index is out of range.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span> &#x2192; None -- remove first occurrence of value.<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.remove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Raises ValueError if the value is not present.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.reverse" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>L.reverse() -- reverse <em>IN PLACE</em></p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableList.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span> &#x2192; None -- stable sort *IN PLACE*<a class="headerlink" href="#sqlalchemy.ext.mutable.MutableList.sort" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.mutable.MutableSet">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.mutable.</code><code class="descname">MutableSet</code><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sqlalchemy.ext.mutable.Mutable" title="sqlalchemy.ext.mutable.Mutable"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.ext.mutable.Mutable</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></p>
<p>クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mutable`を実装するセット型。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableSet`オブジェクトは、値が追加または削除されたときを含め、セットの内容が変更されたときに基本となるマッピングに変更イベントを送出するセットを実装します。</p>
<p>注：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MutableSet`は、セット内の*値自体に可変トラッキングを適用しません**。したがって、<a href="#id3"><span class="problematic" id="id4">*</span></a>再帰的*可変構造への深い変更を追跡するユースケースのための十分な解決策ではありません。このユースケースをサポートするには、class： <a href="#id5"><span class="problematic" id="id6">`</span></a>.MutableSet`のサブクラスを構築し、ディクショナリに配置された値に適切な値を与えて、それらも&amp;quot;変更可能 &amp;quot;になるようにし、イベントを親構造体に出力します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：クラス： <cite>.MutableDict</cite></p>
<p class="last">：クラス： <cite>.MutableList</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Add an element to a set.</p>
<p>This has no effect if the element is already present.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Remove all elements from this set.</p>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.mutable.MutableSet.coerce">
<em class="property">classmethod </em><code class="descname">coerce</code><span class="sig-paren">(</span><em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.coerce" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プレーンセットをこのクラスのインスタンスに変換します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Remove all elements of another set from this set.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.discard" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Remove an element from a set if it is a member.</p>
<p>If the element is not a member, do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.intersection_update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Update a set with the intersection of itself and another.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Remove and return an arbitrary set element.
Raises KeyError if the set is empty.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.remove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Remove an element from a set; it must be a member.</p>
<p>If the element is not a member, raise a KeyError.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.symmetric_difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Update a set with the symmetric difference of itself and another.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.ext.mutable.MutableSet.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.mutable.MutableSet.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Update a set with the union of itself and others.</p>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="declarative/api.html" title="previous chapter">宣言的API</a>
        Next:
        <a href="orderinglist.html" title="next chapter">オーダーリスト</a>

    <div id="docs-copyright">
        &copy; <a href="../../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../../_static/init.js"></script>


    </body>
</html>



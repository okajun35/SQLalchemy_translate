<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    オートマップ
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
        <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../../index.html" />
        <link rel="up" title="ORM拡張" href="index.html" />
        <link rel="next" title="焼いたクエリ" href="baked.html" />
        <link rel="prev" title="アソシエーションプロキシ" href="associationproxy.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../../contents.html">Contents</a> |
                <a href="../../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="../index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="../tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../loading_objects.html">オブジェクトの読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="../extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="index.html">ORM拡張</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="associationproxy.html">アソシエーションプロキシ</a></span></li>
<li class="selected"><span class="link-container first"><strong>オートマップ</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#basic-use">基本的な使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#generating-mappings-from-an-existing-metadata">既存のメタデータからのマッピングの生成</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#specifying-classes-explicitly">クラスを明示的に指定する</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#overriding-naming-schemes">名前付けスキームのオーバーライド</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#relationship-detection">関係の検出</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#custom-relationship-arguments">カスタム関係の引数</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#many-to-many-relationships">多対多の関係</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#relationships-with-inheritance">継承との関係</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#handling-simple-naming-conflicts">単純な名前の競合の処理</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="#using-automap-with-explicit-declarations">明示的な宣言を伴うオートマップの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#api-reference">APIリファレンス</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="baked.html">焼いたクエリ</a></span></li>
<li><span class="link-container first"><a class="reference external" href="declarative/index.html">宣言的</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mutable.html">突然変異の追跡</a></span></li>
<li><span class="link-container first"><a class="reference external" href="orderinglist.html">オーダーリスト</a></span></li>
<li><span class="link-container first"><a class="reference external" href="horizontal_shard.html">水平シャーディング</a></span></li>
<li><span class="link-container first"><a class="reference external" href="hybrid.html">ハイブリッド属性</a></span></li>
<li><span class="link-container first"><a class="reference external" href="indexable.html">インデックス作成可能</a></span></li>
<li><span class="link-container first"><a class="reference external" href="instrumentation.html">代替クラスの計装</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="../examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="module-sqlalchemy.ext.automap">
<span id="automap"></span><span id="automap-toplevel"></span><h1>オートマップ<a class="headerlink" href="#module-sqlalchemy.ext.automap" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>：mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.ext.declarative`システムの拡張を定義します。システムは、データベーススキーマからマップされたクラスと関係を自動的に生成します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.1 で追加: </span>追加：mod： <cite>sqlalchemy.ext.automap</cite>。</p>
</div>
<p>：class： <cite>.AutomapBase`システムは、非常に有名な</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>SQLSoup &lt;<a class="reference external" href="https://sqlsoup.readthedocs.io/en/latest/">https://sqlsoup.readthedocs.io/en/latest/</a>&gt;また、既存のデータベースから迅速かつ素早く素早くオブジェクトモデルを生成することを解決しようとしています。問題をマッパー設定レベルで厳密に扱い、既存の宣言クラス技法と完全に統合することによって、クラス： <a href="#id3"><span class="problematic" id="id4">`</span></a>.AutomapBase`は、便宜的に自動生成アドホックマッピングの問題に十分に統合されたアプローチを提供しようとします。</p>
<div class="section" id="basic-use">
<h2>基本的な使用<a class="headerlink" href="#basic-use" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最も簡単な使用法は、既存のデータベースを新しいモデルに反映させることです。新しい：class： <cite>.AutomapBase`クラスを作成します：func：</cite> .automap_base`を使用して、宣言的な基本クラスを作成する方法と同様の方法で作成します。次に、生成された基本クラスに対して：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare`を呼び出し、スキーマを反映してマッピングを生成するよう要求します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Session</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="c1"># engine, suppose it has two tables &#39;user&#39; and &#39;address&#39; set up</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># reflect the tables</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># mapped classes are now created with names by default</span>
<span class="c1"># matching that of the table name.</span>
<span class="n">User</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>

<span class="c1"># rudimentary relationships are produced</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)))</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="c1"># collection-based relationships are by default named</span>
<span class="c1"># &quot;&lt;classname&gt;_collection&quot;</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span></pre></div>
</div>
<p>上記の：paramref： <cite>.AutomapBase.prepare.reflect`パラメータを渡している間：meth：</cite> .AutomapBase.prepare`を呼び出すと、：meth： <cite>.MetaData.reflect`メソッドがこの宣言的な基本クラスの &amp;#39; ：クラス： `.MetaData`コレクション; ：class： `.MetaData`の中で各**実行可能な**：class：</cite> .Table`は新しいマップされたクラスを自動的に生成します。さまざまなテーブルをリンクする：class： <cite>.ForeignKeyConstraint`オブジェクトは、クラス間で新しい双方向：func：</cite> .relationship`オブジェクトを生成するために使用されます。クラスとリレーションシップは、カスタマイズ可能なデフォルトの命名規則に従っています。この時点で、関連する `` User``と `` Address``クラスからなる私たちの基本的なマッピングは、従来の方法で使用する準備ができています。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a href="#id1"><span class="problematic" id="id2">**</span></a>実行可能**とは、マッピングされる表に対して主キーを指定する必要があることを意味します。さらに、テーブルが2つの他のテーブル間の純粋な関連テーブルであると検出された場合は、直接マップされず、代わりに2つの参照テーブルのマッピング間に多対多テーブルとして構成されます。</p>
</div>
</div>
<div class="section" id="generating-mappings-from-an-existing-metadata">
<h2>既存のメタデータからのマッピングの生成<a class="headerlink" href="#generating-mappings-from-an-existing-metadata" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>事前宣言された：class： <cite>.MetaData`オブジェクトを：func：</cite> .automap_base`に渡すことができます。このオブジェクトは、プログラムによって、シリアライズされたファイルから、あるいは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MetaData.reflect`を使って反映されるものから、どのような方法でも構築できます。以下では、リフレクションと明示的なテーブル宣言の組み合わせについて説明します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="c1"># produce our own MetaData object</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>

<span class="c1"># we can reflect it ourselves from a database, using options</span>
<span class="c1"># such as &#39;only&#39; to limit what tables we look at...</span>
<span class="n">metadata</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">])</span>

<span class="c1"># ... or just define our own Table objects with it (or combine both)</span>
<span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_order&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>
            <span class="p">)</span>

<span class="c1"># we can then produce a set of mappings from this MetaData.</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

<span class="c1"># calling prepare() just sets up mapped classes and relationships.</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapped classes are ready</span>
<span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">,</span> <span class="n">Order</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>\
    <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">user_order</span></pre></div>
</div>
</div>
<div class="section" id="specifying-classes-explicitly">
<h2>クラスを明示的に指定する<a class="headerlink" href="#specifying-classes-explicitly" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：mod： <cite>.sqlalchemy.ext.automap`拡張は：class：</cite> .DeferredReflection`クラスのような方法で明示的にクラスを定義できるようにします。 class： <cite>.AutomapBase`から継承したクラスは、通常の宣言的なクラスと同じように動作しますが、構築後すぐにはマッピングされず、代わりに：meth：</cite> .AutomapBase.prepare`を呼び出すときにマップされます。 ：meth： <cite>.AutomapBase.prepare`メソッドは、使用するテーブル名に基づいて確立したクラスを使用します。スキーマにテーブル `</cite> user``と `` address``が含まれている場合、使用するクラスの1つまたは両方を定義することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="c1"># pre-declare User for the &#39;user&#39; table</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="c1"># override schema elements like Columns</span>
    <span class="n">user_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>

    <span class="c1"># override relationships too, if desired.</span>
    <span class="c1"># we must use the same name that automap would use for the</span>
    <span class="c1"># relationship, and also must refer to the class name that automap will</span>
    <span class="c1"># generate for &quot;address&quot;</span>
    <span class="n">address_collection</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="n">collection_class</span><span class="o">=</span><span class="nb">set</span><span class="p">)</span>

<span class="c1"># reflect</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># we still have Address generated from the tablename &quot;address&quot;,</span>
<span class="c1"># but User is the same as Base.classes.User now</span>

<span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">address_collection</span><span class="p">)</span>

<span class="c1"># the backref is still there:</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user</span><span class="p">)</span></pre></div>
</div>
<p>上の、より複雑な詳細の1つは、automapが作成した：func： <cite>.relationship`オブジェクトのうちの1つをオーバーライドすることを示したことです。これを行うために、我々は名前がautomapが通常生成するものと一致するようにする必要がありました。関係名は `</cite> User.address_collection``であり、automapの観点から参照されるクラスの名前は ` `` Address``と呼ばれています。</p>
</div>
<div class="section" id="overriding-naming-schemes">
<h2>名前付けスキームのオーバーライド<a class="headerlink" href="#overriding-naming-schemes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：mod： <cite>.sqlalchemy.ext.automap`は、スキーマに基づいてマップされたクラスと関係名を生成することを任されています。つまり、これらの名前の決定方法に決定点があります。これらの3つの決定ポイントは、：meth： `.AutomapBase.prepare`メソッドに渡すことができる関数を使って提供され、func：</cite> .classname_for_table`、：func： <cite>.name_for_scalar_relationship</cite>、：func：` .name_for_collection_relationship`。これらの関数のいずれかまたはすべては、以下の例のように提供されています。ここでは、クラス名には &amp;quot;camel case&amp;quot;スキームを使用し、コレクション名には &amp;quot;Multipleizer&amp;quot; &lt;<a class="reference external" href="https://pypi.python.org/pypi/inflect">https://pypi.python.org/pypi/inflect</a>&gt; <a href="#id1"><span class="problematic" id="id2">`</span></a>_パッケージ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inflect</span>

<span class="k">def</span> <span class="nf">camelize_classname</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">tablename</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
    <span class="s2">&quot;Produce a &#39;camelized&#39; class name, e.g. &quot;</span>
    <span class="s2">&quot;&#39;words_and_underscores&#39; -&gt; &#39;WordsAndUnderscores&#39;&quot;</span>

    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">tablename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> \
            <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_([a-z])&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">tablename</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

<span class="n">_pluralizer</span> <span class="o">=</span> <span class="n">inflect</span><span class="o">.</span><span class="n">engine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pluralize_collection</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="s2">&quot;Produce an &#39;uncamelized&#39;, &#39;pluralized&#39; class name, e.g. &quot;</span>
    <span class="s2">&quot;&#39;SomeTerm&#39; -&gt; &#39;some_terms&#39;&quot;</span>

    <span class="n">referred_name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">uncamelized</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[A-Z]&#39;</span><span class="p">,</span>
                         <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                         <span class="n">referred_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">pluralized</span> <span class="o">=</span> <span class="n">_pluralizer</span><span class="o">.</span><span class="n">plural</span><span class="p">(</span><span class="n">uncamelized</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pluralized</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">classname_for_table</span><span class="o">=</span><span class="n">camelize_classname</span><span class="p">,</span>
            <span class="n">name_for_collection_relationship</span><span class="o">=</span><span class="n">pluralize_collection</span>
    <span class="p">)</span></pre></div>
</div>
<p>上記のマッピングから、クラス `` User``と `` Address``があります。ここで `` User``から `` Address``までのコレクションは `` User.addresses``と呼ばれます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">addresses</span><span class="o">=</span><span class="p">[</span><span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s2">&quot;foo@bar.com&quot;</span><span class="p">)])</span></pre></div>
</div>
</div>
<div class="section" id="relationship-detection">
<h2>関係の検出<a class="headerlink" href="#relationship-detection" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>automapが達成することの大部分は、外部キーに基づいた：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`構造の生成です。これが多対1および多対1の関係で機能するメカニズムは次のとおりです。</p>
<ol class="arabic">
<li><p class="first">与えられた：class： <cite>.Table`は特定のクラスにマップされることが知られています：class：</cite> .ForeignKeyConstraint`オブジェクト。</p>
</li>
<li><p class="first">それぞれ：class： <cite>.ForeignKeyConstraint`から、存在するremote：class：</cite> .Table`オブジェクトは、それがマッピングされるクラスまでマッチします。存在しない場合はスキップされます。</p>
</li>
<li><p class="first">私たちが調べている：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.ForeignKeyConstraint`は、直接マッピングされたクラスからの参照に対応しているので、関係は、参照されるクラスを参照する多対1として設定されます。このクラスを参照する参照されたクラスに、対応する一対多のバックリファレンスが作成されます。</p>
</li>
<li><p class="first">：class： <cite>.ForeignKeyConstraint`の一部であるカラムのいずれかがヌル入力可能でない場合（例えば、</cite> <cite>ヌル可能= False`</cite>）、` <cite>all、deleteのキーワード引数：paramref：</cite>〜.relationship.cascade` -orphan``がキーワード引数に追加され、関係またはバックリファレンスに渡されます。 ：class： <cite>.ForeignKeyConstraint`が次のことを報告している場合：paramref：</cite> .ForeignKeyConstraint.ondelete`がnullでない場合は `` CASCADE``に設定され、NULLのセットの場合は `` SET NULL``に設定されます。 ： <cite>〜.relationship.passive_deletes`フラグは、関係キーワード引数のセットで</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>True``に設定されます。すべてのバックエンドがON DELETEの反映をサポートするわけではないことに注意してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加: </span>- automap will detect non-nullable foreign key
constraints when producing a one-to-many relationship and establish
a default cascade of <code class="docutils literal notranslate"><span class="pre">all,</span> <span class="pre">delete-orphan</span></code> if so; additionally,
if the constraint specifies <a class="reference internal" href="../../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.ondelete" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">ForeignKeyConstraint.ondelete</span></code></a>
of <code class="docutils literal notranslate"><span class="pre">CASCADE</span></code> for non-nullable or <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">NULL</span></code> for nullable columns,
the <code class="docutils literal notranslate"><span class="pre">passive_deletes=True</span></code> option is also added.</p>
</div>
</li>
<li><p class="first">関係の名前は：paramref： <cite>.AutomapBase.prepare.name_for_scalar_relationship`と：paramref：</cite> .AutomapBase.prepare.name_for_collection_relationship`呼び出し可能関数を使用して決定されます。デフォルトの関係の命名は、<a href="#id1"><span class="problematic" id="id2">**</span></a>実際のクラス名**から名前を導出することに注意することが重要です。特定のクラスに宣言することによって明示的な名前を与えた場合、または代替のクラス命名スキームを指定した場合、その名前から関係名が導出されます。</p>
</li>
<li><p class="first">クラスは、これらの名前に一致する既存のマップされたプロパティを調べられます。一方が検出され、他方が検出されない場合、：class： <cite>.AutomapBase`は、欠落している側に関係を作成しようとします。：paramref：</cite> .relationship.back_populates`パラメータを使用して、相手側との新たな関係。</p>
</li>
<li><p class="first">通常、どちらの側にも関係がない場合、：meth： <cite>.AutomapBase.prepare`は&amp;quot; many-to-one &amp;quot;側で：func：</cite> .relationship`を生成し、 ：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship.backref`パラメータ。</p>
</li>
<li><p class="first">：func： <cite>.relationship`とオプションで：func：</cite> .backref`の生成は、：paramref： <cite>.AutomapBase.prepare.generate_relationship`関数に渡されます。これはエンドユーザが提供することができます。 ：func： `.relationship`または：func：</cite> .backref`に渡された引数を増やしたり、これらの関数のカスタム実装を利用したりすることができます。</p>
</li>
</ol>
<div class="section" id="custom-relationship-arguments">
<h3>カスタム関係の引数<a class="headerlink" href="#custom-relationship-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.generate_relationship`フックを使って、関係にパラメータを追加できます。ほとんどの場合、既存の：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.automap.generate_relationship`関数を使用して、与えられたキーワード辞書を独自の引数で拡張した後にオブジェクトを返すことができます。</p>
<p>以下は、paramref： <cite>.relationship.cascade`と：paramref：</cite> .relationship.passive_deletes`オプションをすべての一対多関係に沿って送る方法の例です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">generate_relationship</span>

<span class="k">def</span> <span class="nf">_gen_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span>
                                <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">interfaces</span><span class="o">.</span><span class="n">ONETOMANY</span><span class="p">:</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;cascade&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all, delete-orphan&#39;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;passive_deletes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># make use of the built-in function to actually return</span>
    <span class="c1"># the result.</span>
    <span class="k">return</span> <span class="n">generate_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">return_fn</span><span class="p">,</span>
                                 <span class="n">attrname</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">create_engine</span>

<span class="c1"># automap base</span>
<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s2">&quot;sqlite:///mydatabase.db&quot;</span><span class="p">)</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">generate_relationship</span><span class="o">=</span><span class="n">_gen_relationship</span><span class="p">)</span></pre></div>
</div>
</div>
<div class="section" id="many-to-many-relationships">
<h3>多対多の関係<a class="headerlink" href="#many-to-many-relationships" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：mod： <cite>.sqlalchemy.ext.automap`は多対多の関係を生成します。例えば、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>secondary``引数を含むものです。これらの製造方法は以下の通りである。</p>
<ol class="arabic simple">
<li>与えられた：class： <cite>.Table`は：class：</cite> .ForeignKeyConstraint`オブジェクトのために検査され、マップされたクラスがそれに割り当てられます。</li>
<li>テーブルに2つの厳密に2つの：class： <cite>.ForeignKeyConstraint`オブジェクトが含まれ、このテーブル内のすべてのカラムがclass：</cite> .ForeignKeyConstraint`オブジェクトのメンバーである場合、テーブルは&amp;quot;セカンダリ&amp;quot;テーブルとみなされます**直接マップされません**。</li>
<li>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Table`が参照する2つ（または自己参照のための1つ）の外部テーブルは、それらがマッピングされるクラス（存在する場合）に一致します。</li>
<li>両側のマッピングされたクラスが見つかった場合、多対多双方向：func： <cite>.relationship</cite> /：func：` .backref`のペアが2つのクラスの間に作成されます。</li>
<li>多対多のオーバーライドロジックは、1対多/多対1のオーバーライドロジックと同じです。構造体を生成するために：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.generate_relationship`関数が呼び出され、既存の属性が維持されます。</li>
</ol>
</div>
<div class="section" id="relationships-with-inheritance">
<h3>継承との関係<a class="headerlink" href="#relationships-with-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>：mod： <a href="#id1"><span class="problematic" id="id2">`</span></a>.sqlalchemy.ext.automap`は、継承関係にある2つのクラス間の関係を生成しません。つまり、次の2つのクラスがあります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span> <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span> <span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
    <span class="p">}</span></pre></div>
</div>
<p>「エンジニア」から「従業員」までの外部キーは、関係ではなく、2つのクラス間の継承継承を確立するために使用されます。</p>
<p>つまり、automapは、サブクラスからスーパークラスにリンクする外部キーの*関係を生成しません。マッピングがサブクラスからスーパークラスへの実際の関係をも持っている場合、マッピングは明示的である必要があります。以下では、「エンジニア」から「従業員」までの2つの別個の外部キーがあるため、SQLAlchemyが推測できるものではないため、必要な関係と「継承条件」の両方を設定する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;employee&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;employee&#39;</span><span class="p">,</span> <span class="s1">&#39;polymorphic_on&#39;</span><span class="p">:</span><span class="nb">type</span>
    <span class="p">}</span>

<span class="k">class</span> <span class="nc">Engineer</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;engineer&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">),</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">favorite_employee_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;employee.id&#39;</span><span class="p">))</span>

    <span class="n">favorite_employee</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">Employee</span><span class="p">,</span>
                                     <span class="n">foreign_keys</span><span class="o">=</span><span class="n">favorite_employee_id</span><span class="p">)</span>

    <span class="n">__mapper_args__</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;polymorphic_identity&#39;</span><span class="p">:</span><span class="s1">&#39;engineer&#39;</span><span class="p">,</span>
        <span class="s1">&#39;inherit_condition&#39;</span><span class="p">:</span> <span class="nb">id</span> <span class="o">==</span> <span class="n">Employee</span><span class="o">.</span><span class="n">id</span>
    <span class="p">}</span></pre></div>
</div>
</div>
<div class="section" id="handling-simple-naming-conflicts">
<h3>単純な名前の競合の処理<a class="headerlink" href="#handling-simple-naming-conflicts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マッピング中に名前の競合が発生した場合、必要に応じて：func： <cite>.classname_for_table</cite>、：func：` .name_for_scalar_relationship`、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.name_for_collection_relationship`のいずれかをオーバーライドします。たとえば、automapが既存の列と多対1の関係を同じ名前で指定しようとしている場合、条件を選択することができます。与えられたスキーマ：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">table_a</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span>
<span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">table_b</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INTEGER</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">table_a</span> <span class="nb">INTEGER</span><span class="p">,</span>
    <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">table_a</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">table_a</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></pre></div>
</div>
<p>上記のスキーマは、 `` table_a``テーブルを `` table_a``という名前のクラスとして最初に自動マッピングします。 `` table_a``のような関連するクラスと同じ名前の `` table_b``のクラスへの関係を自動化します。この関係名は、マッピング列 `` table_b.table_a``と競合し、マッピング時にエラーを出します。</p>
<p>この競合は、次のようにアンダースコアを使用して解決できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">name_for_scalar_relationship</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">local_cls</span><span class="p">,</span> <span class="n">referred_cls</span><span class="p">,</span> <span class="n">constraint</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">local_table</span> <span class="o">=</span> <span class="n">local_cls</span><span class="o">.</span><span class="n">__table__</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">local_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">newname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Already detected name </span><span class="si">%s</span><span class="s2"> present.  using </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">newname</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">newname</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name_for_scalar_relationship</span><span class="o">=</span><span class="n">name_for_scalar_relationship</span><span class="p">)</span></pre></div>
</div>
<p>また、列側の名前を変更することもできます。マップされた列は、ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>mapper_column_distinct_names`で説明されている手法を使用して、列を明示的に新しい名前に割り当てることによって変更できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">TableB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;table_b&#39;</span>
    <span class="n">_table_a</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;table_a&#39;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;table_a.id&#39;</span><span class="p">))</span>

<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
</div>
</div>
<div class="section" id="using-automap-with-explicit-declarations">
<h2>明示的な宣言を伴うオートマップの使用<a class="headerlink" href="#using-automap-with-explicit-declarations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前述のように、automapはリフレクションに依存せず、：class： <cite>.Table`オブジェクトのコレクションを：class：</cite> .MetaData`コレクション内で使用することができます。このことから、automapは、テーブルのメタデータを完全に定義する他の完全なモデルを使って、欠けている関係を生成するためにも使用できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.ext.automap</span> <span class="k">import</span> <span class="n">automap_base</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;address&#39;</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>

<span class="c1"># produce relationships</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c1"># mapping is complete, with &quot;address_collection&quot; and</span>
<span class="c1"># &quot;user&quot; relationships</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="s1">&#39;u2&#39;</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">address_collection</span><span class="o">=</span><span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">a1</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="n">u1</span></pre></div>
</div>
<p>上では、ほとんどすべての `` User``と `` Address``マッピングが与えられているので、 `` Address.user_id``で定義した：class： <cite>.ForeignKey`は、双方向関係のペア</cite> <cite>Address.user``と`</cite> User.address_collection``がマップされたクラスに対して生成されます。</p>
<p>class： <cite>.AutomapBase`をサブクラス化するときは、：meth：</cite> .AutomapBase.prepare`メソッドが必要です。呼び出されなければ、宣言したクラスはマップされていない状態になります。</p>
</div>
<div class="section" id="api-reference">
<h2>APIリファレンス<a class="headerlink" href="#api-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="sqlalchemy.ext.automap.automap_base">
<code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">automap_base</code><span class="sig-paren">(</span><em>declarative_base=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.automap_base" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>宣言的なオートマップベースを作成します。</p>
<p>この関数は：class： <cite>.AutomapBase`クラスと：func：</cite> .declarative.declarative_base`によって生成される宣言ベースの生成物である新しい基本クラスを生成します。</p>
<p>`` declarative_base`以外のすべてのパラメータは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.declarative.declarative_base`関数に直接渡されるキーワード引数です。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.ext.automap.automap_base.params.declarative_base"></span><strong>declarative_base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.declarative_base">¶</a> -- func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.declarative.declarative_base`によって生成される既存のクラスです。これが渡されると、関数はもはや：func： <a href="#id3"><span class="problematic" id="id4">`</span></a>.declarative.declarative_base`自体を呼び出さなくなり、他のすべてのキーワード引数は無視されます。</li>
<li><span class="target" id="sqlalchemy.ext.automap.automap_base.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.automap_base.params.**kw">¶</a> -- キーワード引数は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.declarative.declarative_base`に渡されます。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.ext.automap.AutomapBase">
<em class="property">class </em><code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">AutomapBase</code><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&amp;quot;automap &amp;quot;スキーマの基本クラス。</p>
<p>：class： <cite>.AutomapBase`クラスは、：func：</cite> .declarative.declarative_base`関数によって生成される &amp;quot;宣言的なベース&amp;quot;クラスと比較できます。実際には：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase`クラスは、実際の宣言的な基底と共にmixinとして常に使用されます。</p>
<p>新しいサブクラス：class： <cite>.AutomapBase`は通常、：func：</cite> .automap_base`関数を使ってインスタンス化されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>automap_toplevel</cite></p>
</div>
<dl class="attribute">
<dt id="sqlalchemy.ext.automap.AutomapBase.classes">
<code class="descname">classes</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.classes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.util.Properties`のクラスのインスタンスです。</p>
<p>このオブジェクトはテーブル上の `` .c``コレクションのように動作します。クラスは与えられた名前の下に存在します。例えば：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">automap_base</span><span class="p">()</span>
<span class="n">Base</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">engine</span><span class="o">=</span><span class="n">some_engine</span><span class="p">,</span> <span class="n">reflect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">User</span><span class="p">,</span> <span class="n">Address</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">User</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">classes</span><span class="o">.</span><span class="n">Address</span></pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="sqlalchemy.ext.automap.AutomapBase.prepare">
<em class="property">classmethod </em><code class="descname">prepare</code><span class="sig-paren">(</span><em>engine=None</em>, <em>reflect=False</em>, <em>schema=None</em>, <em>classname_for_table=&lt;function classname_for_table&gt;</em>, <em>collection_class=&lt;class 'list'&gt;</em>, <em>name_for_scalar_relationship=&lt;function name_for_scalar_relationship&gt;</em>, <em>name_for_collection_relationship=&lt;function name_for_collection_relationship&gt;</em>, <em>generate_relationship=&lt;function generate_relationship&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.AutomapBase.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マッピングされたクラスと関係を：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MetaData`から抽出し、マッピングを実行します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.engine"></span><strong>engine</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.engine">¶</a> -- ：class： <cite>.Engine`または：class：</cite> .Connection`：指定されている場合、スキーマリフレクションを実行します。 ：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.reflect`引数がFalseの場合、このオブジェクトは使用されません。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect"></span><strong>reflect</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.reflect">¶</a> -- Trueの場合、：meth： <cite>.MetaData.reflect`メソッドは、class：</cite> .AutomapBase`に関連付けられた：class： <cite>.MetaData`で呼び出されます。存在する場合、リフレクションを実行するために：class： `.Engine</cite>：paramref：` .AutomapBase.prepare.engine`が使用されます。そうでなければ、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MetaData`は既にいくつかのエンジンにバインドされているはずです。そうでないと操作は失敗します。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table"></span><strong>classname_for_table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.classname_for_table">¶</a> -- テーブル名を指定すると、新しいクラス名を生成するために使用される呼び出し可能な関数です。デフォルトは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.classname_for_table`です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship"></span><strong>name_for_scalar_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_scalar_relationship">¶</a> -- スカラー関係の関係名を生成するために使用される呼び出し可能な関数。デフォルトは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.name_for_scalar_relationship`です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship"></span><strong>name_for_collection_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.name_for_collection_relationship">¶</a> -- コレクション指向の関係の関係名を生成するために使用されるコール可能な関数。デフォルトは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.name_for_collection_relationship`です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship"></span><strong>generate_relationship</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.generate_relationship">¶</a> -- func： <cite>.relationship`と：func：</cite> .backref`構造体を実際に生成するために使用される呼び出し可能な関数です。デフォルトは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.generate_relationship`です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class"></span><strong>collection_class</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.collection_class">¶</a> -- コレクションを表すnew：func： <cite>.relationship`オブジェクトが作成されたときに使用されるPythonコレクションクラスです。デフォルトは `</cite> list``です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.AutomapBase.prepare.params.schema"></span><strong>schema</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.AutomapBase.prepare.params.schema">¶</a> -- ：paramref： <cite>.AutomapBase.prepare.reflect`フラグと一緒に存在する場合は、：meth：</cite> .MetaData.reflect`に渡され、テーブルを反映させるべきプライマリスキーマを示します。省略すると、データベース接続で使用されているデフォルトのスキーマが使用されます。 .. versionadded :: 1.1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sqlalchemy.ext.automap.classname_for_table">
<code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">classname_for_table</code><span class="sig-paren">(</span><em>base</em>, <em>tablename</em>, <em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.classname_for_table" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>テーブルの名前を指定して、使用するクラス名を返します。</p>
<p>デフォルト実装は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">tablename</span><span class="p">)</span></pre></div>
</div>
<p>代替実装は、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.classname_for_table`パラメータを使用して指定できます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.base">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase`クラスは準備をしています。</li>
<li><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.tablename"></span><strong>tablename</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.tablename">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Table`の文字列名です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.classname_for_table.params.table"></span><strong>table</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.classname_for_table.params.table">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Table`オブジェクト自体です。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">文字列クラス名.. note :: Python 2では、クラス名**に使用される文字列は、非Unicodeオブジェクト、例えば `` str（） <a href="#id1"><span class="problematic" id="id2">``</span></a>オブジェクトでなければなりません。 ：class： <cite>.Table`の</cite> <cite>.name``属性は通常PythonのUnicodeサブクラスなので、非ASCII文字を考慮した上で、この名前に</cite> <cite>str（）</cite> <a href="#id3"><span class="problematic" id="id4">`</span></a>関数を適用する必要があります。</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.ext.automap.name_for_scalar_relationship">
<code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">name_for_scalar_relationship</code><span class="sig-paren">(</span><em>base</em>, <em>local_cls</em>, <em>referred_cls</em>, <em>constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_scalar_relationship" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つのクラスから別のクラスへの参照に使用する属性名を返します。</p>
<p>デフォルト実装は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></pre></div>
</div>
<p>代替実装は、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.name_for_scalar_relationship`パラメータを使用して指定できます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.base">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase`クラスは準備をしています。</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.local_cls">¶</a> -- ローカル側でマッピングされるクラス</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.referred_cls">¶</a> -- 参照側にマップされるクラス</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_scalar_relationship.params.constraint">¶</a> -- この関係を生成するために検査される：class： <cite>.ForeignKeyConstraint</cite>。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.ext.automap.name_for_collection_relationship">
<code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">name_for_collection_relationship</code><span class="sig-paren">(</span><em>base</em>, <em>local_cls</em>, <em>referred_cls</em>, <em>constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.name_for_collection_relationship" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コレクション参照のためにあるクラスから別のクラスへの参照に使用する属性名を返します。</p>
<p>デフォルト実装は:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">referred_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_collection&quot;</span></pre></div>
</div>
<p>代替実装は、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.name_for_collection_relationship`パラメータを使用して指定できます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.base">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase`クラスは準備をしています。</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.local_cls">¶</a> -- ローカル側でマッピングされるクラス</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.referred_cls">¶</a> -- 参照側にマップされるクラス</li>
<li><span class="target" id="sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint"></span><strong>constraint</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.name_for_collection_relationship.params.constraint">¶</a> -- この関係を生成するために検査される：class： <cite>.ForeignKeyConstraint</cite>。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.ext.automap.generate_relationship">
<code class="descclassname">sqlalchemy.ext.automap.</code><code class="descname">generate_relationship</code><span class="sig-paren">(</span><em>base</em>, <em>direction</em>, <em>return_fn</em>, <em>attrname</em>, <em>local_cls</em>, <em>referred_cls</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.ext.automap.generate_relationship" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つのマップされたクラスの代わりに：func： <cite>.relationship`または：func：</cite> .backref`を生成します。</p>
<p>この関数の別の実装は、：paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase.prepare.generate_relationship`パラメータを使用して指定できます。</p>
<p>この関数のデフォルトの実装は次のとおりです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">backref</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">attrname</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">return_fn</span> <span class="ow">is</span> <span class="n">relationship</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">return_fn</span><span class="p">(</span><span class="n">referred_cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown relationship function: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">return_fn</span><span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.base"></span><strong>base</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.base">¶</a> -- ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AutomapBase`クラスは準備をしています。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.direction"></span><strong>direction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.direction">¶</a> -- 関係の「方向」を示す。これはdata： <cite>.ONETOMANY</cite>、：data：` .MANYTOONE`、：data： <a href="#id1"><span class="problematic" id="id2">`</span></a>.MANYTOMANY`のいずれかになります。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.return_fn"></span><strong>return_fn</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.return_fn">¶</a> -- 関係を作成するためにデフォルトで使用される関数。これは、func： <cite>.relationship`または：func：</cite> .backref`です。 ：func： <cite>.backref`関数の結果は、新しい：func：</cite> .relationship`を2番目のステップで生成するために使用されるので、ユーザー定義の実装では、2つの関数を正しく区別することが重要です。使用中です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.attrname"></span><strong>attrname</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.attrname">¶</a> -- この関係が割り当てられる属性名：paramref： <cite>.generate_relationship.return_fn`の値が：func：</cite> .backref`関数である場合、この名前はバックリファレンスに割り当てられる名前です。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.local_cls"></span><strong>local_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.local_cls">¶</a> -- この関係またはバックレファレンスがローカルに存在する&amp;quot;ローカル&amp;quot;クラス。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.referred_cls"></span><strong>referred_cls</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.referred_cls">¶</a> -- 関係またはバックリファレンスが参照する&amp;quot;参照&amp;quot;クラス。</li>
<li><span class="target" id="sqlalchemy.ext.automap.generate_relationship.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.ext.automap.generate_relationship.params.**kw">¶</a> -- すべての追加のキーワード引数が関数に渡されます。</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">：paramref： <cite>.generate_relationship.return_fn`パラメータで指定されているように、：func：</cite> .relationship`または：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.backref`構造体です。</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="associationproxy.html" title="previous chapter">アソシエーションプロキシ</a>
        Next:
        <a href="baked.html" title="next chapter">焼いたクエリ</a>

    <div id="docs-copyright">
        &copy; <a href="../../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../../_static/init.js"></script>


    </body>
</html>



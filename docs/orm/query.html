<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    クエリAPI
 &mdash;
    SQLAlchemy 1.3 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.3 Documentation" href="../index.html" />
        <link rel="up" title="オブジェクトの読み込み" href="loading_objects.html" />
        <link rel="next" title="セッションの使用" href="session.html" />
        <link rel="prev" title="コンストラクタとオブジェクトの初期化" href="constructors.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.3.0b1</span>


        | Release Date: unreleased

    </div>

    <h1>SQLAlchemy 1.3 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.3 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">オブジェクトリレーショナルチュートリアル</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">マッパー設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">関係の設定</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">オブジェクトの読み込み</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="loading_columns.html">列の読み込み</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_relationships.html">関係の読み込み手法</a></span></li>
<li><span class="link-container first"><a class="reference external" href="inheritance_loading.html">継承階層のロード</a></span></li>
<li><span class="link-container first"><a class="reference external" href="constructors.html">コンストラクタとオブジェクトの初期化</a></span></li>
<li class="selected"><span class="link-container first"><strong>クエリAPI</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#the-query-object">クエリオブジェクト</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#orm-specific-query-constructs">ORM固有のクエリ構文</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="session.html">セッションの使用</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">イベントと内部</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM拡張</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORMの例</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<span class="target" id="module-sqlalchemy.orm"></span><div class="section" id="query-api">
<span id="query-api-toplevel"></span><h1>クエリAPI<a class="headerlink" href="#query-api" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このセクションでは、ORM：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトのAPIリファレンスを紹介します。このオブジェクトの使い方のウォークスルーについては、：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>ormtutorial_toplevel`を参照してください。</p>
<div class="section" id="the-query-object">
<h2>クエリオブジェクト<a class="headerlink" href="#the-query-object" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>：class： <cite>〜.Query`は、：meth：</cite>〜.Session.query`メソッドを使用して、与えられた：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Session`の観点から生成されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeMappedClass</span><span class="p">)</span></pre></div>
</div>
<p>以下は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトの完全なインターフェースです。</p>
<dl class="class">
<dt id="sqlalchemy.orm.query.Query">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.query.</code><code class="descname">Query</code><span class="sig-paren">(</span><em>entities</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ORMレベルのSQL構築オブジェクト。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`は、ORMによって生成されたすべてのSELECT文のソースです。これらは、エンドユーザのクエリ操作と関連するコレクションのロードなどの高水準な内部操作によって生成されます。これは、連続する呼び出しがnew：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`オブジェクトを返す生成的なインタフェースを備えています。これは、前者のコピーであり、それに関連する追加の基準とオプションがあります。</p>
<p>：class： <cite>.Query`オブジェクトは通常：class：</cite> .Session`の：meth： <cite>〜.Session.query`メソッドを使用して生成され、あまり一般的でない場合は：class：</cite> .Query`を直接インスタンス化します：meth： <cite>.Query.with_session`メソッドを使用してa：class：</cite> .Session`に関連付けます。</p>
<p>：class： <cite>.Query`の使い方については、：ref：</cite> ormtutorial_toplevel`を参照してください。</p>
<dl class="method">
<dt id="sqlalchemy.orm.query.Query.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>entities</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> directly.</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">Query</span><span class="p">([</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">],</span> <span class="n">session</span><span class="o">=</span><span class="n">some_session</span><span class="p">)</span></pre></div>
</div>
<p>The above is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">some_session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.query.Query.params.entities"></span><strong>entities</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.params.entities">¶</a> -- a sequence of entities and/or SQL expressions.</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.params.session">¶</a> -- a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> with which the <a class="reference internal" href="#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>
will be associated.   Optional; a <a class="reference internal" href="#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a> can be associated
with a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> generatively via the
<a class="reference internal" href="#sqlalchemy.orm.query.Query.with_session" title="sqlalchemy.orm.query.Query.with_session"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_session()</span></code></a> method as well.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.query()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.query.Query.with_session" title="sqlalchemy.orm.query.Query.with_session"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Query.with_session()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.add_column">
<code class="descname">add_column</code><span class="sig-paren">(</span><em>column</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.add_column" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>戻される結果列のリストに列式を追加します。</p>
<p>保留中の非推奨：：meth： <cite>.add_column`は：meth：</cite> .add_columns`に置き換えられます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.add_columns">
<code class="descname">add_columns</code><span class="sig-paren">(</span><em>*column</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.add_columns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>戻される結果列のリストに1つ以上の列式を追加します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.add_entity">
<code class="descname">add_entity</code><span class="sig-paren">(</span><em>entity</em>, <em>alias=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.add_entity" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返される結果列のリストにマッピングされたエンティティを追加します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.all">
<code class="descname">all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この `` Query``で表される結果をリストとして返します。</p>
<p>この結果、基本となるクエリが実行されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.as_scalar">
<code class="descname">as_scalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.as_scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`で表される完全なSELECT文を返し、スカラー副問い合わせに変換します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.sql.expression.SelectBase.as_scalar`に似ています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.6.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.autoflush">
<code class="descname">autoflush</code><span class="sig-paren">(</span><em>setting</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.autoflush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>特定の &amp;#39;autoflush&amp;#39;設定でクエリを返します。</p>
<p>autoflush = Falseのセッションは、クエリレベルでこのフラグがTrueに設定されていても自動フラッシュしません。したがって、このフラグは通常、特定のクエリに対して自動フラッシュを無効にするためにのみ使用されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Query.column_descriptions">
<code class="descname">column_descriptions</code><a class="headerlink" href="#sqlalchemy.orm.query.Query.column_descriptions" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`によって返される列に関するメタデータを返します。</p>
<p>形式は辞書のリストです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;user2&#39;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">user_alias</span><span class="p">)</span>

<span class="c1"># this expression:</span>
<span class="n">q</span><span class="o">.</span><span class="n">column_descriptions</span>

<span class="c1"># would return:</span>
<span class="p">[</span>
    <span class="p">{</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;User&#39;</span><span class="p">,</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="n">User</span><span class="p">,</span>
        <span class="s1">&#39;aliased&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;expr&#39;</span><span class="p">:</span><span class="n">User</span><span class="p">,</span>
        <span class="s1">&#39;entity&#39;</span><span class="p">:</span> <span class="n">User</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="n">Integer</span><span class="p">(),</span>
        <span class="s1">&#39;aliased&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;expr&#39;</span><span class="p">:</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="s1">&#39;entity&#39;</span><span class="p">:</span> <span class="n">User</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;user2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="n">User</span><span class="p">,</span>
        <span class="s1">&#39;aliased&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;expr&#39;</span><span class="p">:</span><span class="n">user_alias</span><span class="p">,</span>
        <span class="s1">&#39;entity&#39;</span><span class="p">:</span> <span class="n">user_alias</span>
    <span class="p">}</span>
<span class="p">]</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.correlate">
<code class="descname">correlate</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.correlate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたFROM句を囲む：class： <cite>.Query`または：func：</cite>〜.expression.select`のものに関連づけるa：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`構文を返します。</p>
<p>func： <cite>.aliased`構造体と：func：</cite> .mapper`構造体は引数として構築され、適切な式構造体に加えて、式構造体に分解されます。</p>
<p>相関引数は最終的に式構造に強制された後に：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Select.correlate`に渡されます。</p>
<p>相関引数は：meth： <cite>.Query.from_self`が使用されるときや、：meth：</cite> .Query.subquery`によって返されるサブクエリが別の：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.expressionに埋め込まれているときなどに有効です。選択構造。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.count">
<code class="descname">count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このQueryが返す行の数を返します。</p>
<p>これは、次のようにこのクエリのSQLを生成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">AS</span> <span class="n">count_1</span> <span class="n">FROM</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="o">&lt;</span><span class="n">rest</span> <span class="n">of</span> <span class="n">query</span> <span class="n">follows</span><span class="o">...&gt;</span>
<span class="p">)</span> <span class="n">AS</span> <span class="n">anon_1</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>上記スキームは0.7b3から新たに改良されました。</p>
</div>
<p>カウントする特定の列をきめ細かく制御するため、サブクエリの使用をスキップする、またはFROM句を制御する、または他の集約関数を使用するには、attr： <cite>〜sqlalchemy.sql.expression.func`式を：meth： `〜.Session.query</cite>、すなわち:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">func</span>

<span class="c1"># count User records, without</span>
<span class="c1"># using a subquery.</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>

<span class="c1"># return count of user &quot;id&quot; grouped</span>
<span class="c1"># by &quot;name&quot;</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">distinct</span>

<span class="c1"># count distinct &quot;name&quot; values</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">distinct</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.cte">
<code class="descname">cte</code><span class="sig-paren">(</span><em>name=None</em>, <em>recursive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.cte" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これによって表される完全なSELECT文を返します。class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`は共通テーブル式（CTE）として表されます。</p>
<p>パラメータと使用法は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SelectBase.cte`メソッドのものと同じです。詳細はその方法を参照してください。</p>
<p><cite>PostgreSQL WITH RECURSIVEの例です&lt;http://www.postgresql.org/docs/8.4/static/queries-with.html&gt; `_。この例では、 `</cite> included_pa​​rts``と `` incl_alias``のエイリアスがコア選択可能であることに注意してください。これは、 `` .c.``属性でカラムにアクセスすることを意味します。 `` parts_alias``オブジェクトは、 `` Part``エンティティの：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.aliased`インスタンスです。そのため、カラムマップされた属性は直接利用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">aliased</span>

<span class="k">class</span> <span class="nc">Part</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;part&#39;</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sub_part</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">quantity</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">)</span>

<span class="n">included_parts</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">Part</span><span class="o">.</span><span class="n">sub_part</span><span class="p">,</span>
                <span class="n">Part</span><span class="o">.</span><span class="n">part</span><span class="p">,</span>
                <span class="n">Part</span><span class="o">.</span><span class="n">quantity</span><span class="p">)</span><span class="o">.</span>\
                    <span class="nb">filter</span><span class="p">(</span><span class="n">Part</span><span class="o">.</span><span class="n">part</span><span class="o">==</span><span class="s2">&quot;our part&quot;</span><span class="p">)</span><span class="o">.</span>\
                    <span class="n">cte</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;included_parts&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">incl_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">included_parts</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pr&quot;</span><span class="p">)</span>
<span class="n">parts_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Part</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="n">included_parts</span> <span class="o">=</span> <span class="n">included_parts</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">parts_alias</span><span class="o">.</span><span class="n">sub_part</span><span class="p">,</span>
        <span class="n">parts_alias</span><span class="o">.</span><span class="n">part</span><span class="p">,</span>
        <span class="n">parts_alias</span><span class="o">.</span><span class="n">quantity</span><span class="p">)</span><span class="o">.</span>\
            <span class="nb">filter</span><span class="p">(</span><span class="n">parts_alias</span><span class="o">.</span><span class="n">part</span><span class="o">==</span><span class="n">incl_alias</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">sub_part</span><span class="p">)</span>
    <span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">included_parts</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">sub_part</span><span class="p">,</span>
        <span class="n">func</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">included_parts</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">quantity</span><span class="p">)</span><span class="o">.</span>
            <span class="n">label</span><span class="p">(</span><span class="s1">&#39;total_quantity&#39;</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span>\
    <span class="n">group_by</span><span class="p">(</span><span class="n">included_parts</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">sub_part</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.HasCTE.cte</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>synchronize_session='evaluate'</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.delete" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一括削除クエリを実行します。</p>
<p>このクエリで一致した行をデータベースから削除します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">delete</span><span class="p">(</span><span class="n">synchronize_session</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">delete</span><span class="p">(</span><span class="n">synchronize_session</span><span class="o">=</span><span class="s1">&#39;evaluate&#39;</span><span class="p">)</span></pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.delete`メソッドは、ORM単位作業の自動化を回避してより大きなパフォーマンスを実現する、一括操作です。 <strong>下記のすべての警告と警告をお読みください。</strong></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.delete.params.synchronize_session"></span><strong>synchronize_session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.delete.params.synchronize_session">¶</a> -- セッションから一致したオブジェクトを削除するための戦略を選択します。有効な値は次のとおりです： `` False``  - セッションを同期しません。このオプションは、セッションが期限切れになると最も効率的で信頼性が高くなります。通常、commit（）の後に実行されるか、expire_all（）を明示的に使用します。有効期限が切れる前に、オブジェクトはセッション中に残っている可能性があります。削除されたオブジェクトは、get（）またはすでに読み込まれたコレクションを介してアクセスされると混乱を招く可能性があります。 `` &amp;#39;fetch&amp;#39;``  - 削除の前に選択クエリを実行して、削除クエリと一致するオブジェクトを見つけ出し、セッションから削除する必要があります。一致したオブジェクトはセッションから削除されます。 `` &amp;#39;evaluate&amp;#39;``  - セッション内のオブジェクトに対してPythonのクエリの基準を直接評価します。基準の評価が実装されていない場合、エラーが発生します。エクスプレッションエバリュエーターは現在、データベースとPythonの異なる文字列照合を考慮していません。</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body">データベースの&amp;quot;行数&amp;quot;機能によって返された行の数が一致します。</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p><strong>一括クエリ削除の追加の警告</strong></p>
<ul class="last">
<li><p class="first">このメソッドは継承継承マッピング**では機能しません。<strong>複数テーブルの削除はSQL **でサポートされていないだけでなく、継承マッパーの**結合条件は自動的にはレンダリングされません</strong>。関連するテーブルが削除される方法と、これらのテーブル間の結合条件を明示的に含めるために、他の手段を介して最初に対応するには、複数のテーブルの削除に注意する必要があります。例えば ​​`` Engineer``クラスが `` Employee``をサブクラス化している場合、 `` Employee``テーブルに対するDELETEは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Employee</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;dilbert&#39;</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">delete</span><span class="p">()</span></pre></div>
</div>
<p>ただし、上記のSQLは、ON DELETE CASCADEルールがデータベースで処理されない限り、エンジニアテーブルから削除されません。</p>
<p>ショートストーリー、<a href="#id1"><span class="problematic" id="id2">**</span></a>これを実行可能にするための追加手順を講じていない限り、結合された継承マッピングにはこのメソッドを使用しないでください。</p>
</li>
<li><p class="first">多相識別WHERE条件は単一テーブルまたは結合テーブルの更新では** <a href="#id1"><span class="problematic" id="id2">**</span></a>含まれません。単一のテーブル継承の場合でも手動で**追加する必要があります。</p>
</li>
<li><p class="first">このメソッドはPythonの中で関係をカスケードしない**を提供していません - それはON DELETE CASCADE / SET NULL /などと仮定されます。それを必要とする任意の外部キー参照に対して構成されます。そうしないと、外部キー参照が強制されている場合、データベースは整合性違反を発生させる可能性があります。</p>
<p>DELETEの後、ON DELETEの影響を受けた：class： <cite>.Session`の従属オブジェクトは、現在の状態を含んでいないか、または削除されている可能性があります。この問題は：class： `.Session`が期限切れになると解決されます。これは通常：meth：</cite> .Session.commit`で発生するか、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.expire_all`を使用して強制できます。行が削除された有効期限の切れたオブジェクトにアクセスすると、その行を特定するためにSELECTが呼び出されます。行が見つからない場合は、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.exc.ObjectDeletedError`が発生します。</p>
</li>
<li><p class="first">`` &amp;#39;fetch``戦略は、追加のSELECT文を発行し、パフォーマンスを大幅に低下させます。</p>
</li>
<li><p class="first">`` &amp;#39;evaluate&amp;#39;``戦略は：class： <cite>.Session</cite>;内のすべての一致するオブジェクトのスキャンを実行します。 proceeding：meth： <cite>.Session.commit`呼び出しのように、：class：</cite> .Session`の内容が期限切れになっている場合、<a href="#id1"><span class="problematic" id="id2">**</span></a>これは一致するすべてのオブジェクト**に対してSELECTクエリを発行します。</p>
</li>
<li><p class="first">：meth： <cite>.MapperEvents.before_delete`と：meth：</cite> .MapperEvents.after_delete`イベント**はこのメソッドから呼び出されません**。代わりに、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SessionEvents.after_bulk_delete`メソッドは、エンティティ行の大量削除に作用するために提供されています。</p>
</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.update</cite></p>
<p class="last">：ref： <cite>inserts_and_updates</cite>  - コアSQLチュートリアル</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.distinct">
<code class="descname">distinct</code><span class="sig-paren">(</span><em>*expr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.distinct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クエリに `` DISTINCT``を適用し、新しく生成された `` Query``を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.distinct`呼び出しは、ORDER BY列がSELECTの一部であるデータベースバックエンドの一般的な必要性を満たすために、クエリのORDER BYの列をSELECT文のcolumns節に自動的に追加するロジックを含みますDISTINCTが使用されるときにリストします。これらの列*は：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`によって実際にフェッチされた列のリストには追加されませんが、結果には影響しません。ただし、：attr： <a href="#id5"><span class="problematic" id="id6">`</span></a>.Query.statement`アクセサを使用すると、列はパススルーされます。</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.distinct.params.*expr"></span><strong>*expr</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.distinct.params.*expr">¶</a> -- オプションの列式。存在する場合、PostgreSQLの方言は `` DISTINCT ON（ &lt;expressions&gt; ） <a href="#id1"><span class="problematic" id="id2">``</span></a>構造体です。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.enable_assertions">
<code class="descname">enable_assertions</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.enable_assertions" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アサーションが生成されるかどうかを制御します。</p>
<p>Falseに設定すると、filter（）が呼び出されたときにLIMIT / OFFSETが適用されていない、get（）が呼び出されたときに基準が存在しない、from_statement（）が呼び出されていないなど、 &amp;quot;はfilter（）/ order_by（）/ group_by（）などが呼び出されたときに存在します。このより許容されるモードは、カスタムQueryサブクラスによって、通常の使用パターンの外に基準または他の修飾子を指定するために使用されます。</p>
<p>使用パターンが確実に可能であるように注意する必要があります。 from_statement（）によって適用されるステートメントは、たとえばfilter（）またはorder_by（）によって設定された基準をオーバーライドします。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.enable_eagerloads">
<code class="descname">enable_eagerloads</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.enable_eagerloads" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>熱心な結合とサブクエリがレンダリングされるかどうかを制御します。</p>
<p>Func： <cite>〜sqlalchemy.orm.joinedload</cite>、：func：<cite>〜sqlalchemy.orm.subqueryload`オプション、またはマッパーレベルの `</cite> lazy = &amp;#39;joined&amp;#39; &amp;#39;に関わらず、返されたQueryはeager joinをレンダリングしません。 `` / `` lazy = &amp;#39;subquery&amp;#39;``の設定に従います。</p>
<p>これは、主にQueryのステートメントをサブクエリまたは他の選択可能なものにネストするとき、または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`を使用するときに使用されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.except_">
<code class="descname">except_</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.except_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つまたは複数のクエリに対してこのクエリのEXCEPTを生成します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.union`と同じように動作します。使用例については、その方法を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.except_all">
<code class="descname">except_all</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.except_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つまたは複数のクエリに対してこのクエリのすべてを除外します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.union`と同じように動作します。使用例については、その方法を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.execution_options">
<code class="descname">execution_options</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.execution_options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行中に有効になる非SQLオプションを設定します。</p>
<p>オプションは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Connection.execution_options`で受け入れられるオプションと同じです。</p>
<p>：meth： <cite>〜sqlalchemy.orm.query.Query.yield_per（）`メソッドが使用されている場合、 `</cite> stream_results``実行オプションは自動的に有効になります。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.exists">
<code class="descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.exists" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>EXISTS（SELECT 1 FROM ... WHERE ...）の形式のEXISTSサブクエリにクエリを変換する簡易メソッドです。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;fred&#39;</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span></pre></div>
</div>
<p>::と似たSQLを生成する</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">EXISTS</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="mi">1</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">WHERE</span> <span class="n">users</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">name_1</span>
<span class="p">)</span> <span class="n">AS</span> <span class="n">anon_1</span></pre></div>
</div>
<p>EXISTS構文は通常、WHERE句で使用されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span></pre></div>
</div>
<p>SQL Serverなどの一部のデータベースでは、EXISTS式をSELECTの列句に含めることはできません。存在に基づいて単純なブール値をWHEREとして選択するには、次のようにします：func： <cite>.literal</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">literal</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">literal</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>*criterion</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたフィルタリング基準をSQLの式を使ってthis：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`のコピーに適用します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;some name&#39;</span><span class="p">)</span></pre></div>
</div>
<p>複数の基準はカンマで区切って指定することができます。その効果は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.and_`関数を使用して結合されることです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;some name&#39;</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>この基準は、選択のWHERE句に適用可能なSQL式オブジェクトです。文字列式は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.text`構造体を介してSQL式構造体に強制変換されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.filter_by</cite>  - キーワード式をフィルタリングします。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.filter_by">
<code class="descname">filter_by</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.filter_by" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたフィルタリング基準を、キーワード表現を使ってthis：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`のコピーに適用します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;some name&#39;</span><span class="p">)</span></pre></div>
</div>
<p>複数の基準はカンマで区切って指定することができます。その効果は：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.and_`関数を使用して結合されることです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">filter_by</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;some name&#39;</span><span class="p">,</span> <span class="nb">id</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>キーワード式は、クエリのプライマリエンティティ、または：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.join`の呼び出しのターゲットであった最後のエンティティから抽出されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.filter</cite>  -  SQL式をフィルタリングします。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.first">
<code class="descname">first</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.first" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この `` Query``の最初の結果を返します。結果に行が含まれていない場合はNoneを返します。</p>
<p>first（）は生成されたSQL内で1の制限を適用し、サーバー側では1つのプライマリエンティティ行のみが生成されます（結合ロードされたコレクションが存在する場合、複数の結果行が含まれます）。</p>
<p>meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.first`を呼び出すと、基本となるクエリが実行されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.one</cite></p>
<p class="last">：meth： <cite>.Query.one_or_none</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.from_self">
<code class="descname">from_self</code><span class="sig-paren">(</span><em>*entities</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.from_self" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このQueryのSELECT文から選択するQueryを返します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.from_self`は基本的にSELECT文をそれ自身のSELECTに変換します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span></pre></div>
</div>
<p>与えられた：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.from_self`バージョン:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">from_self</span><span class="p">()</span></pre></div>
</div>
<p>このクエリは次のようにレンダリングされます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">anon_1_user_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">user_name</span> <span class="k">AS</span> <span class="n">anon_1_user_name</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span></pre></div>
</div>
<p>多くのケースがあります：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.from_self`が役に立ちます。簡単な例は上記のところですが、照会するユーザーオブジェクトのセットに行LIMITを適用し、その行限定セットに対して追加の結合を適用することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span><span class="o">.</span>\
    <span class="n">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">from_self</span><span class="p">()</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;q%&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上記のクエリは `` Address``エンティティに参加しますが、 `` User``クエリの最初の5つの結果に対してのみ行われます：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">anon_1_user_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">user_name</span> <span class="k">AS</span> <span class="n">anon_1_user_name</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span>
 <span class="k">LIMIT</span> <span class="p">:</span><span class="n">param_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">JOIN</span> <span class="n">address</span> <span class="k">ON</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">email_1</span></pre></div>
</div>
<p><strong>自動エイリアシング</strong></p>
<p>：meth： <cite>.Query.from_self`のもう一つの重要な振る舞いは、それらが外部で参照されているときにサブクエリ内のエンティティに**自動エイリアシング**を適用することです。上で、追加のエイリアシングを適用せずに `</cite> User``エンティティを参照し続けると、それらの参照はサブクエリの観点からなります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span><span class="o">.</span>\
    <span class="n">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">from_self</span><span class="p">()</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;q%&#39;</span><span class="p">))</span><span class="o">.</span>\
    <span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></pre></div>
</div>
<p>`` User.name``に対するORDER BYは、内側の副問い合わせに関して次のようにエイリアスされています：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">anon_1_user_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">user_name</span> <span class="k">AS</span> <span class="n">anon_1_user_name</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span>
 <span class="k">LIMIT</span> <span class="p">:</span><span class="n">param_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">JOIN</span> <span class="n">address</span> <span class="k">ON</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">email_1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_name</span></pre></div>
</div>
<p>自動エイリアシング機能は、<a href="#id1"><span class="problematic" id="id2">**</span></a>限定**の方法でのみ機能し、簡単なフィルタと順序付けが可能です。ジョインでエンティティを参照するなど、もっと野心的な構造は、明示的なサブクエリオブジェクトを使用することを推奨する必要があります。通常は、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query.subquery`メソッドを使用して明示的なサブクエリオブジェクトを生成します。特定の構造が期待どおりに動作するようにSQLを表示して、クエリの構造を常にテストしてください。</p>
<p><strong>エンティティの変更</strong></p>
<p>：meth： <cite>.Query.from_self`には、どの列が照会されているかを変更する機能も含まれています。この例では、内部クエリによって `</cite> User.id``を照会して、外部の `` Address``エンティティに参加できるようにしたいのですが、外部クエリで `` Address.email``列:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span><span class="o">.</span>\
    <span class="n">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">from_self</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;q%&#39;</span><span class="p">))</span></pre></div>
</div>
<p>収穫：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">AS</span> <span class="n">address_email</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span>
 <span class="k">LIMIT</span> <span class="p">:</span><span class="n">param_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">JOIN</span> <span class="n">address</span> <span class="k">ON</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">email_1</span></pre></div>
</div>
<p><strong>インナー/アウターコラムを探す</strong></p>
<p>サブクエリの内部から生成された列を参照する場合、それらがサブクエリ自体のcolumns節に存在することを確認する必要があります。これはSQLの一般的な側面です。たとえば、：func： <cite>.contains_eager`を使用してサブクエリ内の結合されたエンティティからロードする場合は、それらの列を追加する必要があります。以下は `</cite> Address``と `` User``を結合した後、サブクエリを示しています： `` User``カラムにアクセスするfunc： <cite>.contains_eager</cite>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;e%&#39;</span><span class="p">))</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">add_entity</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_self</span><span class="p">()</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span><span class="n">contains_eager</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">))</span></pre></div>
</div>
<p><strong>：meth： `.Query.from_self`を呼び出す前に</strong>：meth：` .Query.add_entity`を使います。** `` User``カラムは内側のサブクエリに存在します。外部で使用している：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.contains_eager`修飾子を使用して、以下を生成します。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">address_id</span> <span class="k">AS</span> <span class="n">anon_1_address_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">address_email</span> <span class="k">AS</span> <span class="n">anon_1_address_email</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">address_user_id</span> <span class="k">AS</span> <span class="n">anon_1_address_user_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">anon_1_user_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">user_name</span> <span class="k">AS</span> <span class="n">anon_1_user_name</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">address</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">address_id</span><span class="p">,</span>
    <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">AS</span> <span class="n">address_email</span><span class="p">,</span>
    <span class="n">address</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">address_user_id</span><span class="p">,</span>
    <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span>
    <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="n">address</span> <span class="k">JOIN</span> <span class="ss">&quot;user&quot;</span> <span class="k">ON</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span></pre></div>
</div>
<p>`` add_entity（User） <a href="#id1"><span class="problematic" id="id2">``</span></a>と呼ぶのではなく、 `` User``エンティティを読み込むために：func： <cite>.contains_eager`を依頼した場合、正しい結合をせずにテーブルを外部に追加することが強制されますcriteria  - 最後に `</cite> anon1、&amp;quot;user &amp;quot; <a href="#id3"><span class="problematic" id="id4">``</span></a>というフレーズに注目してください：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="c1">-- incorrect query</span>
<span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">address_id</span> <span class="k">AS</span> <span class="n">anon_1_address_id</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">address_email</span> <span class="k">AS</span> <span class="n">anon_1_address_email</span><span class="p">,</span>
       <span class="n">anon_1</span><span class="p">.</span><span class="n">address_user_id</span> <span class="k">AS</span> <span class="n">anon_1_address_user_id</span><span class="p">,</span>
       <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span>
       <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">address</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">address_id</span><span class="p">,</span>
    <span class="n">address</span><span class="p">.</span><span class="n">email</span> <span class="k">AS</span> <span class="n">address_email</span><span class="p">,</span>
    <span class="n">address</span><span class="p">.</span><span class="n">user_id</span> <span class="k">AS</span> <span class="n">address_user_id</span>
<span class="k">FROM</span> <span class="n">address</span> <span class="k">JOIN</span> <span class="ss">&quot;user&quot;</span> <span class="k">ON</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">LIKE</span> <span class="p">:</span><span class="n">name_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.from_self.params.*entities"></span><strong>*entities</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.from_self.params.*entities">¶</a> -- 選択されているものと置き換わるエンティティのオプションリスト。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.from_statement">
<code class="descname">from_statement</code><span class="sig-paren">(</span><em>statement</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.from_statement" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたSELECT文を実行し、結果を返します。</p>
<p>このメソッドは、内部ステートメントのコンパイルをすべてバイパスし、ステートメントは変更せずに実行されます。</p>
<p>この文は、通常、：func： <cite>〜.expression.text`または：func：</cite>〜.expression.select`のいずれかの構文であり、class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query <a href="#id3"><span class="problematic" id="id4">`</span></a>。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>orm_tutorial_literal_sql</cite>  -  ORMチュートリアルの使用例</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>ident</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された主キー識別子に基づいてインスタンスを返します。見つからなければ `` None``を返します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">some_object</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">VersionedFoo</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span></pre></div>
</div>
<p>：meth： <cite>〜.Query.get`は、所有する：class：</cite> .Session`のアイデンティティマップに直接アクセスできるという点で特別です。特定の主キー識別子がローカルIDマップに存在する場合、そのオブジェクトはこのコレクションから直接戻され、オブジェクトが完全に期限切れとマークされていない限り、SQLは発行されません。存在しない場合、オブジェクトの位置を特定するためにSELECTが実行されます。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.get`は、オブジェクトがアイデンティティマップに存在し、期限切れとマークされているかどうかをチェックします。オブジェクトがリフレッシュされ、行がまだ存在することを確認するためにSELECTが発行されます。そうでなければ、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜sqlalchemy.orm.exc.ObjectDeletedError`が送出されます。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.get`は、複数のインスタンスや個々の列構造ではなく、単一の主キー値に厳密に基づいて、単一のマップされたインスタンスを返すためにのみ使用されます。 originating：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`は、このようにして、すなわち追加のフィルタリング基準なしで単一のマップされたエンティティに対して構築されなければなりません。しかし、：meth： <a href="#id5"><span class="problematic" id="id6">`</span></a>〜.Query.options`を介してオプションをロードすることができますが、オブジェクトがまだローカルに存在しない場合に使用されます。</p>
<p>：func： <cite>.relationship`で設定された遅延ロード、多対1の属性は、単純な外部キーからプライマリキーの基準を使用して、：meth：</cite>〜.Queryと同等の操作も使用します。データベースを照会する前にローカルアイデンティティマップからターゲット値を検索するために「取得」します。関係ロードの詳細については、doc： <a href="#id1"><span class="problematic" id="id2">`</span></a>/ orm / loading_relationships`を参照してください。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.get.params.ident"></span><strong>ident</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.get.params.ident">¶</a> -- 主キーを表すスカラー値またはタプル値。複合主キーの場合、識別子の順序は、ほとんどの場合、mapped：class： <cite>.Table`オブジェクトの主キー列の順序に対応します。構築中に ``主キー `&amp;#39;引数が与えられた：func：</cite> .mapper`の場合、識別子の順序はこのコレクションに存在する要素に対応します。</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body">オブジェクトインスタンス、または `` None``です。</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.group_by">
<code class="descname">group_by</code><span class="sig-paren">(</span><em>*criterion</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.group_by" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クエリに1つ以上のGROUP BY条件を適用し、新しく生成された：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を返します。</p>
<p>全ての既存のGROUP BY設定は `` None``を渡すことで抑止できます - これはマッパーで設定されたGROUP BYも抑制します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.1 で追加: </span>GROUP BYは、ORDER BYと同じ方法でNoneを渡すことで取り消すことができます。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.having">
<code class="descname">having</code><span class="sig-paren">(</span><em>criterion</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.having" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HAVING基準をクエリに適用し、新しく生成された：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を返します。</p>
<p>：meth： <cite>〜.Query.having`は：meth：</cite>〜.Query.group_by`と一緒に使用されます。</p>
<p>HAVING基準により、COUNT、SUM、AVG、MAX、MINなどの集計関数でフィルタを使用することができます。たとえば、:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">having</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.instances">
<code class="descname">instances</code><span class="sig-paren">(</span><em>cursor</em>, <em>_Query__context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.instances" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>connection.execute（）によって返されるResultProxyカーソルがある場合、ORMの結果をイテレータとして返します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select * from users&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">u</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.intersect">
<code class="descname">intersect</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.intersect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つまたは複数のクエリに対してこのクエリのINTERSECTを生成します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.union`と同じように動作します。使用例については、その方法を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.intersect_all">
<code class="descname">intersect_all</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.intersect_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この問合せのINTERSECT ALLを1つ以上の問合せに対して生成します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.union`と同じように動作します。使用例については、その方法を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>*props</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この：class： <cite>.Query`オブジェクトの基準に対してSQL JOINを作成し、生成して新たに生成された：class：</cite> .Query`を返します。</p>
<p><strong>単純な関係の結合</strong></p>
<p>`` User``と `` Address``の2つのクラス間のマッピングを考えてみましょう。それぞれの `` User``に関連付けられた `` Address``オブジェクトのコレクションを表す `` User.addresses``という関係があります。 ：meth： <cite>〜.Query.join`の最も一般的な使い方は、この関係に沿ってJOINを作成することです。これは、どのようにするべきかの指標として</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>User.addresses``属性を使用します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span></pre></div>
</div>
<p>上記の場合、 `` User.addresses``に沿って：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`を呼び出すと、SQLは次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">user</span><span class="o">.*</span> <span class="n">FROM</span> <span class="n">user</span> <span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">user_id</span></pre></div>
</div>
<p>上記の例では、* on節*として：meth： <cite>〜.Query.join`に渡された</cite> <cite>User.addresses``を参照しています。つまり、JOINの&amp;quot; ON &amp;quot;部分構築する必要があります。上記のような単一エンティティクエリの場合（つまり、 `</cite> User``だけから選択することから始まり、他のものは選択しません）、その関係は文字列名:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`は、複数のon節引数を使用して、4つの関連するエンティティ間の結合が構築される場所のような、一連の結合を生成することもできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;orders&quot;</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">,</span> <span class="s2">&quot;keywords&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記は、meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`への3つの別々の呼び出しの省略形です。それぞれは明示的な属性を使用してソースエンティティを示します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">orders</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">Order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">keywords</span><span class="p">)</span></pre></div>
</div>
<p><strong>ターゲットエンティティへの結合または選択可能</strong></p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`の第2の形式は、マップされたエンティティまたはコア選択可能な構造体をターゲットとして許可します。この使用法では、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Query.join`は2つのエンティティ間の自然な外部キー関係に沿ってJOINを作成しようとします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span></pre></div>
</div>
<p>上記の：meth： <cite>〜.Query.join`の呼び出し形式は、2つのエンティティ間に外部キーがない場合、またはそれらの間に複数の外部キーリンケージがある場合にエラーを発生させます。上記の呼び出し形式では、：meth： `〜.Query.join`が自動的にon節を作成するために呼び出されます。ターゲットは任意のマップされたエンティティまたは選択可能です：class： `.Table</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">addresses_table</span><span class="p">)</span></pre></div>
</div>
<p>** ON句でターゲットに結合する**</p>
<p>3番目の呼び出し形式では、ON句だけでなくターゲットエンティティも明示的に渡すことができます。たとえば、2回目のエイリアスを使って、 `` Address``に2回参加したいとします。 ：func： <cite>〜sqlalchemy.orm.aliased`を使用して、</cite> <cite>Address``の別名を作成し、</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>target、onclause``形式でそれに結合します。これにより、エイリアスを明示的に指定することができますON句をどのように進めるべきかを指示する関係と一緒にターゲットを設定する:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">a_alias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;ed@foo.com&#39;</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">a_alias</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;ed@bar.com&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記の場合、生成されるSQLは次のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">user</span><span class="o">.*</span> <span class="n">FROM</span> <span class="n">user</span>
    <span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">user_id</span>
    <span class="n">JOIN</span> <span class="n">address</span> <span class="n">AS</span> <span class="n">address_1</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">address_1</span><span class="o">.</span><span class="n">user_id</span>
    <span class="n">WHERE</span> <span class="n">address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">=</span> <span class="p">:</span><span class="n">email_address_1</span>
    <span class="n">AND</span> <span class="n">address_1</span><span class="o">.</span><span class="n">email_address</span> <span class="o">=</span> <span class="p">:</span><span class="n">email_address_2</span></pre></div>
</div>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`という2つの引数を持つ呼び出し形式でも、SQL指向の&amp;quot; on clause &amp;quot;式で任意の結合を構成することができ、構成された関係にはまったく依存しません。 2つの引数をとるフォームを使用する場合、どのSQL式もON句として渡すことができます。これは、対象エンティティを何らかの方法で参照する必要があります。また、適用可能なソースエンティティ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.7 で変更: </span>SQLAlchemy 0.6以前では、：meth： <cite>〜.Query.join`の2つの引数形式は、</cite> <cite>query（User）.join（（Address、User.id == Address.user_id））タプルの使用を必要とします。 `</cite> 。この呼び出し形式は0.7以降で受け入れられますが、複数の結合条件が1つの：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`呼び出しに渡されない限り、これは必須ではありませんが、複数の呼び出し（これは必ずしもそうではなかった）。</p>
</div>
<p><strong>高度な参加とターゲット設定</strong></p>
<p>：meth： <cite>〜.Query.join`を使うとき、&amp;quot; target &amp;quot;が何になるかには多くの柔軟性があります。前述のように、：class： `.Table`構造体、および：func：</cite> .alias`や：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`構造体のような、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">addresses_q</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">])</span><span class="o">.</span>\
            <span class="n">where</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;@bar.com&quot;</span><span class="p">))</span><span class="o">.</span>\
            <span class="n">alias</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">join</span><span class="p">(</span><span class="n">addresses_q</span><span class="p">,</span> <span class="n">addresses_q</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="o">==</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>〜.Query.join`は、*：meth：</cite>〜sqlalchemy.orm.relationship`駆動のON句をターゲット選択可能に適合させる機能も備えています。以下では、 `` User``から `` Address``に対するサブクエリにJOINを構築し、 `` User.addresses``で表される関係を変更されたターゲットに適合させる:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">address_subq</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\
                <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">==</span> <span class="s1">&#39;ed@foo.com&#39;</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">subquery</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_subq</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span></pre></div>
</div>
<p>::と似たSQLを生成する</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">user</span><span class="o">.*</span> <span class="n">FROM</span> <span class="n">user</span>
    <span class="n">JOIN</span> <span class="p">(</span>
        <span class="n">SELECT</span> <span class="n">address</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="nb">id</span><span class="p">,</span>
                <span class="n">address</span><span class="o">.</span><span class="n">user_id</span> <span class="n">AS</span> <span class="n">user_id</span><span class="p">,</span>
                <span class="n">address</span><span class="o">.</span><span class="n">email_address</span> <span class="n">AS</span> <span class="n">email_address</span>
        <span class="n">FROM</span> <span class="n">address</span>
        <span class="n">WHERE</span> <span class="n">address</span><span class="o">.</span><span class="n">email_address</span> <span class="o">=</span> <span class="p">:</span><span class="n">email_address_1</span>
    <span class="p">)</span> <span class="n">AS</span> <span class="n">anon_1</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">anon_1</span><span class="o">.</span><span class="n">user_id</span></pre></div>
</div>
<p>上記の形式では、いつでも明示的なON句に戻ることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">address_subq</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">address_subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span></pre></div>
</div>
<p><strong>参加対象の制御</strong></p>
<p>：meth： <cite>〜.Query.join`はJOINの&amp;quot;右 &amp;quot;側を排他的に扱いますが、必要な場合には：meth：</cite>〜 .Query.select_from`。以下では、 `` Address``に対してクエリを作成しますが、 `` User``エンティティから最初に選択するようにclass： <cite>.Query`に指示することで、ON節として</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>User.addresses``を使用することができます： ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
                <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span></pre></div>
</div>
<p>次のようなSQLを生成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">address</span><span class="o">.*</span> <span class="n">FROM</span> <span class="n">user</span>
    <span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="o">.</span><span class="n">user_id</span>
    <span class="n">WHERE</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p><strong>匿名でエイリアスを作成する</strong></p>
<p>：meth： <cite>〜.Query.join`は</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>aliased = True``フラグを使って匿名エイリアスを構築できます。この機能は、クエリがアルゴリズム的に結合されている場合に便利です。たとえば、任意の深さに自己参照的にクエリを実行する場合などです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="n">aliased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>`` aliased = True``が使われるとき、実際の&amp;quot;エイリアス&amp;quot;構造は明示的に利用できません。このメソッドを使うには、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.filter`のようなメソッドが、入ってくるエンティティを最後のジョインポイントに適応させます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="n">aliased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;grandchild 1&#39;</span><span class="p">)</span></pre></div>
</div>
<p>自動エイリアシングを使用する場合、 `` from_joinpoint = True``引数はマルチノード結合を：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`への複数の呼び出しに分割して、途中の各パスをさらにフィルタリングできるようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="n">aliased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;child 1&#39;</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="n">aliased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">from_joinpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;grandchild 1&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記のフィルタリングエイリアスは、元の `` Node``エンティティにリセットすることができます：meth： <cite>〜.Query.reset_joinpoint</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Node</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="n">aliased</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;grandchild 1&#39;</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">reset_joinpoint</span><span class="p">()</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Node</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;parent 1)</span></pre></div>
</div>
<p>`` aliased = True``の例については、アルゴリズム的な結合を使ったXPathのようなクエリシステムを示すディストリビューションの例：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>examples_xmlpersistence`を参照してください。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.query.Query.join.params.*props"></span><strong>*props</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.join.params.*props">¶</a> -- &amp;quot;on節&amp;quot;を表すリレーションシップバインド属性または文字列リレーションシップ名、または単一のターゲットエンティティ、または <a href="#id1"><span class="problematic" id="id2">``</span></a>（target、onclause）の形式のタプルで構成される1つ以上の結合条件の集合。 <a href="#id3"><span class="problematic" id="id4">``</span></a>。 `` target、onclause``形式の特別な引数を2つ持つ呼び出し形式も受け入れられます。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.join.params.aliased"></span><strong>aliased=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.join.params.aliased">¶</a> -- Trueの場合、JOINターゲットに匿名でエイリアスを付ける必要があることを示します。それ以降の：meth： <cite>〜.Query.filter`などの呼び出しは、：meth：</cite>〜.Query.reset_joinpoint`が呼び出されるまで、着信基準をターゲット別名に適合させます。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.join.params.isouter"></span><strong>isouter=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.join.params.isouter">¶</a> -- Trueの場合、使用される結合は、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.outerjoin`メソッドが呼び出されたかのように、左外部結合になります。このフラグは、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>.FromClause.join`と他のCoreコンストラクトで受け入れられているものと同じフラグとの一貫性を維持するためのものです。 .. versionadded :: 1.0.0</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.join.params.full"></span><strong>full=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.join.params.full">¶</a> -- レンダリングFULL OUTER JOIN; 「isouter」を意味する。 .. versionadded :: 1.1</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.join.params.from_joinpoint"></span><strong>from_joinpoint=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.join.params.from_joinpoint">¶</a> -- `` aliased = True``を使用する場合、ここでTrueを設定すると、クエリの元のFROM句から戻ってくるのではなく、最も最近結合したターゲットからの結合になります。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>ORMチュートリアルの：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>ormtutorial_joins`を参照してください。</p>
<p>：ref： <cite>inheritance_toplevel`の詳細は：meth：</cite>〜.Query.join`を継承関係に使用します。</p>
<p class="last">：func： <cite>.orm.join</cite>  - ：meth：` .Query.join`によって内部的に使用されるスタンドアロンのORMレベルの結合関数。以前のSQLAlchemyのバージョンでは、ORMレベルの一次結合インターフェースでした。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.label" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`で表される完全なSELECT文を返します。指定された名前のラベルを持つスカラーサブクエリに変換されます。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>sqlalchemy.sql.expression.SelectBase.label`に似ています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.6.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Query.lazy_loaded_from">
<code class="descname">lazy_loaded_from</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.orm.query.Query.lazy_loaded_from" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An：class： <cite>.InstanceState`これは、遅延ロード操作のために：class：</cite> .Query`を使用しています。</p>
<p>これは、水平シャーディング拡張のような拡張機能、イベントハンドラとカスタムマッパーオプションを使用して、クエリがオブジェクトの関係を遅延ロードするために使用されているかどうかを判断するために使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.2.9 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.limit">
<code class="descname">limit</code><span class="sig-paren">(</span><em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.limit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クエリに `` LIMIT``を適用し、新しく生成された `` Query``を返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.merge_result">
<code class="descname">merge_result</code><span class="sig-paren">(</span><em>iterator</em>, <em>load=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.merge_result" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>結果をthis：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトのSessionにマージします。</p>
<p>これと同じ構造の：class： <cite>.Query`によって返されたイテレータが返された場合、すべてのマップされたインスタンスが：meth：</cite>。Session.merge`を使用してセッションにマージされた結果の同じイテレータを返します。これは、各値に対して明示的に：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>。Session.merge`を呼び出すよりもメソッドのオーバーヘッドが少なく、結果の行とマッピングされていない列の構造を保持しながら、すべてのマップされたインスタンスをマージする最適化されたメソッドです。</p>
<p>結果の構造は以下の列リストに基づいて決定されます：class： <cite>.Query</cite>  - これらが一致しない場合、チェックされていないエラーが発生します。</p>
<p>&amp;#39;load&amp;#39;引数は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.merge`と同じです。</p>
<p>：meth： <cite>〜.Query.merge_result`が使用されている例については、例：ref：</cite> examples_caching`のソースコードを参照してください。ここで、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.merge_result`は状態を効率的に復元しますターゲット：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Session`に戻るキャッシュ。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.offset">
<code class="descname">offset</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.offset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クエリに `` OFFSET``を適用し、新たに生成された `` Query``を返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.one">
<code class="descname">one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.one" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>結果を1つ返すか、例外を発生させます。</p>
<p>クエリが行を選択しない場合、 `` sqlalchemy.orm.exc.NoResultFound``を発生させます。複数のオブジェクトアイデンティティが返された場合、または完全なアイデンティティマップエンティティではなくスカラ値のみを返すクエリに対して複数の行が返された場合は、 `` sqlalchemy.orm.exc.MultipleResultsFound`を発生させます。</p>
<p>meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.one`を呼び出すと、基本となるクエリが実行されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.first</cite></p>
<p class="last">：meth： <cite>.Query.one_or_none</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.one_or_none">
<code class="descname">one_or_none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.one_or_none" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>多くとも1つの結果を返すか、例外を発生させます。</p>
<p>問合せが行を選択しない場合は `` None``を返します。複数のオブジェクトアイデンティティが返された場合、または完全なアイデンティティマップエンティティではなくスカラ値のみを返すクエリに対して複数の行が返された場合は、 `` sqlalchemy.orm.exc.MultipleResultsFound`を発生させます。</p>
<p>meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.one_or_none`を呼び出すと、基本となるクエリが実行されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.9 で追加: </span>追加：meth： <cite>.Query.one_or_none</cite></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.first</cite></p>
<p class="last">：meth： <cite>.Query.one</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.only_return_tuples">
<code class="descname">only_return_tuples</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.only_return_tuples" title="この定義へのパーマリンク">¶</a></dt>
<dd><dl class="docutils">
<dt>Trueに設定すると、クエリ結果は常にタプルになります。</dt>
<dd>特に単一要素クエリの場合デフォルトはFalseです。</dd>
</dl>
<p>。 .. versionadded :: 1.2.5</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.options">
<code class="descname">options</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたマッパーオプションのリストを適用して、新しいQueryオブジェクトを返します。</p>
<p>提供されるほとんどのオプションは、列とリレーションマップの属性のロード方法の変更に関するものです。リファレンスドキュメントについては、セクション：ref： <cite>deferred`と：doc：</cite> / orm / loading_relationships`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.order_by">
<code class="descname">order_by</code><span class="sig-paren">(</span><em>*criterion</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.order_by" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つ以上のORDER BY条件をクエリに適用し、新しく生成された `` Query``</p>
<p>すべての既存のORDER BY設定は、 `` None``を渡すことで抑止できます - これはマッパーで設定されたORDER BYも抑制します。</p>
<p>代わりに、Falseを渡すとORDER BYがリセットされ、さらにデフォルトのmapper.order_byが再び有効になります。注意mapper.order_byは非推奨です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.outerjoin">
<code class="descname">outerjoin</code><span class="sig-paren">(</span><em>*props</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.outerjoin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この `` Query``オブジェクトの基準に対して左外部結合を作成し、新しく生成された `` Query``を生成して生成します。</p>
<p>使用法は `` join（） <a href="#id1"><span class="problematic" id="id2">``</span></a>メソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.params">
<code class="descname">params</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>filter（）で指定された可能性のあるバインドパラメータの値を追加します。</p>
<p>パラメータは、** kwargsを使用して指定するか、オプションで単一の辞書を最初の位置引数として指定することができます。 ** kwargsは便利ですが、一部のパラメータ辞書にはユニコードキーが含まれているため、** kwargsは使用できません。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.populate_existing">
<code class="descname">populate_existing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.populate_existing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すべてのインスタンスがロードされたり、現在の：class： <cite>.Session`から再利用されると、すべてのインスタンスを期限切れにしてリフレッシュするa：class：</cite> .Query`を返します。</p>
<p>：meth： <cite>.populate_existing`は、ORMが正常に使用されているときの振る舞いを改善しません。 -  class：</cite> .Session`オブジェクトの通常のトランザクション保守動作とロールバックまたはコミット後のすべての属性の期限切れはオブジェクト状態を自動的に処理します。この方法は一般的な使用を意図したものではありません。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.prefix_with">
<code class="descname">prefix_with</code><span class="sig-paren">(</span><em>*prefixes</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.prefix_with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プレフィックスをクエリに適用し、新しく生成された `` Query``を返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.prefix_with.params.*prefixes"></span><strong>*prefixes</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.prefix_with.params.*prefixes">¶</a> -- オプションの接頭辞、通常は文字列で、カンマを使用しません。特に、MySQLのキーワードに便利です。</td>
</tr>
</tbody>
</table>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">prefix_with</span><span class="p">(</span><span class="s1">&#39;HIGH_PRIORITY&#39;</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">prefix_with</span><span class="p">(</span><span class="s1">&#39;SQL_SMALL_RESULT&#39;</span><span class="p">,</span> <span class="s1">&#39;ALL&#39;</span><span class="p">)</span></pre></div>
</div>
<p>レンダリングするだろう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">HIGH_PRIORITY</span> <span class="n">SQL_SMALL_RESULT</span> <span class="n">ALL</span> <span class="n">users</span><span class="o">.</span><span class="n">name</span> <span class="n">AS</span> <span class="n">users_name</span>
<span class="n">FROM</span> <span class="n">users</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.7 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.HasPrefixes.prefix_with</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.reset_joinpoint">
<code class="descname">reset_joinpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.reset_joinpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を返します。ここで&amp;quot; join point &amp;quot;はクエリのベースFROMエンティティにリセットされています。</p>
<p>このメソッドは、通常：meth： <cite>〜.Query.join`メソッドの</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>aliased = True``機能と組み合わせて使用​​されます。これがどのように使われているかについては、：meth： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Query.join`の例を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.scalar">
<code class="descname">scalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.scalar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の結果の最初の要素を返します。存在しない場合はNoneを返します。複数の行が返された場合、MultipleResultsFoundが発生します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="go">&lt;Item&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Item</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">Item</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">Parent</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="go">20</span></pre></div>
</div>
<p>この結果、基本となるクエリが実行されます。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.select_entity_from">
<code class="descname">select_entity_from</code><span class="sig-paren">(</span><em>from_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.select_entity_from" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これのFROM句を：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`にコアの選択可能なものに設定し、それを対応するマップされたエンティティのFROM句として置き換えます。</p>
<p>：meth： <cite>.Query.select_entity_from`メソッドは：func：</cite> .aliased`構造を明示的にクエリ全体に適用するユースケースへの代替アプローチを提供します。 ：func： <cite>.aliased`構造体を明示的に参照する代わりに、：meth：</cite> .Query.select_entity_from`は、エンティティのすべての発生を自動的に*選択可能なターゲットに適合させます。</p>
<p>：func： <cite>.aliased`の場合：SELECT文から</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>User``オブジェクトを選択するなど</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">User</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">select_stmt</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">user_alias</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">user_alias</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記では、 `` user_alias``オブジェクトを明示的にクエリ全体に適用します。 `` user_alias``が多くの場所で明示的に参照されない場合、：meth： <cite>.Query.select_entity_from`をクエリの開始時に使用して、既存の</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>User``エンティティを適合させることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">select_entity_from</span><span class="p">(</span><span class="n">select_stmt</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span></pre></div>
</div>
<p>上記のように、生成されたSQLは、WHERE句の場合でも、 `` User``エンティティが私たちのステートメントに適合していることを示します：</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">anon_1_id</span><span class="p">,</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">anon_1_name</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">WHERE</span> <span class="n">anon_1</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p>：meth： <cite>.Query.select_entity_from`メソッドは：meth：</cite> .Query.select_from`メソッドに似ています。これは、クエリのFROM句を設定する点です。相違点は、主エンティティを参照するクエリの他の部分にさらに適応を適用することです。上記の場合、代わりに：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.select_from`を使用した場合、生成されるSQLは次のようになります。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="c1">-- uses plain select_from(), not select_entity_from()</span>
<span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">user_id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">user_name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">name</span>
<span class="k">FROM</span> <span class="ss">&quot;user&quot;</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id_1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">anon_1</span>
<span class="k">WHERE</span> <span class="ss">&quot;user&quot;</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<p>：meth： <cite>.Query.select_entity_from`メソッドにテキスト形式のSQLを供給するために、：func：</cite> .text`構造体を利用することができます。しかし、：func： <cite>.text`構造体は、：meth：</cite> .TextClause.columns`メソッドを使って実現される、私たちのエンティティの列と整列する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text_stmt</span> <span class="o">=</span> <span class="n">text</span><span class="p">(</span><span class="s2">&quot;select id, name from user&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span>
    <span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">select_entity_from</span><span class="p">(</span><span class="n">text_stmt</span><span class="p">)</span></pre></div>
</div>
<p>：meth： <cite>.Query.select_entity_from`自体は：func：</cite> .aliased`オブジェクトを受け入れます。したがって、：func： <cite>.aliased`のような特別なオプションがparamref：</cite> .aliased.adapt_on_names`のように使用されます。 ：meth： <cite>.Query.select_entity_from`メソッドの適応サービスのスコープビュー `</cite> user_view``が `` user``から行を返すとします。このビューを：class： <cite>.Table`に反映させると、このビューは：class：</cite> .Table`とは関係がありませんが、名前の照合を使用して選択することができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user_view</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user_view&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                  <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<span class="n">user_view_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span>
    <span class="n">User</span><span class="p">,</span> <span class="n">user_view</span><span class="p">,</span> <span class="n">adapt_on_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">select_entity_from</span><span class="p">(</span><span class="n">user_view_alias</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 1.1.7 で変更: </span>：meth： <cite>.Query.select_entity_from`メソッドは：class：</cite> .FromClause`オブジェクトの代わりに：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.aliased`オブジェクトを受け入れるようになりました。</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.select_entity_from.params.from_obj"></span><strong>from_obj</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.select_entity_from.params.from_obj">¶</a> -- a：class： <cite>.FromClause`オブジェクトで、これはFROM句を置き換えます：class：</cite> .Query`。これは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.aliased`のインスタンスでもあります。</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.select_from</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.select_from">
<code class="descname">select_from</code><span class="sig-paren">(</span><em>*from_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.select_from" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これのFROM句を明示的に：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`に明示してください。</p>
<p>：meth： <cite>.Query.select_from`は、joinの&amp;quot; left &amp;quot;側から選択されるエンティティを制御するために、：meth：</cite> .Query.join`と組み合わせて使用​​されることがよくあります。</p>
<p>ここでエンティティまたは選択可能なオブジェクトは、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜.Query.join`への呼び出しの&amp;quot;左端&amp;quot;を効果的に置き換えます。ジョイントポイントが他に確立されていない場合、通常はデフォルトの&amp;quot;ジョインポイント&amp;quot;が一番左entity：：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>〜.Query`オブジェクトの選択対象のエンティティのリストです。</p>
<p>典型的な例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span></pre></div>
</div>
<p>::と同等のSQLを生成する</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">address</span><span class="o">.*</span> <span class="n">FROM</span> <span class="n">user</span>
<span class="n">JOIN</span> <span class="n">address</span> <span class="n">ON</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">address</span><span class="o">.</span><span class="n">user_id</span>
<span class="n">WHERE</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">:</span><span class="n">name_1</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.select_from.params.*from_obj"></span><strong>*from_obj</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.select_from.params.*from_obj">¶</a> -- FROM句に適用する1つまたは複数のエンティティのコレクション。エンティティは、クラス：class： <cite>.AliasedClass`オブジェクト、：class：</cite> .Mapper`オブジェクト、およびコア：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.FromClause`要素（サブクエリなど）にマッピングできます。</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.9 で変更: </span>このメソッドは、指定されたFROMオブジェクトを、一致するエンティティの選択元である選択肢に適用しなくなりました。 ：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select_entity_from`メソッドがこれを実現します。この動作の説明については、そのメソッドを参照してください。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>〜.Query.join</cite></p>
<p class="last">：meth： <cite>.Query.select_entity_from</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Query.selectable">
<code class="descname">selectable</code><a class="headerlink" href="#sqlalchemy.orm.query.Query.selectable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <cite>.Query`によって生成された：class：</cite> .Select`オブジェクトを返します。</p>
<p>func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.inspect`との互換性のために使用されます：これは:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">query</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span><span class="n">statement</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.slice" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたインデックスによって表される：class： <cite>.Query`の&amp;quot;スライス&amp;quot;を計算し、結果：class：</cite> .Query`を返します。</p>
<p>開始インデックスと終了インデックスは、Pythonの組み込み関数：func： <cite>range`関数の引数のように動作します。このメソッドは、 `</cite> LIMIT`` / `` OFFSET``を使ってクエリのスライスを得る代わりの方法を提供します。</p>
<p>例えば、 ：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></pre></div>
</div>
<p>レンダリングする</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">users_id</span><span class="p">,</span>
       <span class="n">users</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">users_name</span>
<span class="k">FROM</span> <span class="n">users</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
<span class="k">LIMIT</span> <span class="o">?</span> <span class="k">OFFSET</span> <span class="o">?</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.limit</cite></p>
<p class="last">：meth： <cite>.Query.offset</cite></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Query.statement">
<code class="descname">statement</code><a class="headerlink" href="#sqlalchemy.orm.query.Query.statement" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このQueryによって表される完全なSELECTステートメント。</p>
<p>デフォルトでは、with_labels（True）が最初に呼び出されない限り、文は構造体に適用される曖昧さのないラベルを持ちません。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.subquery">
<code class="descname">subquery</code><span class="sig-paren">(</span><em>name=None</em>, <em>with_labels=False</em>, <em>reduce_columns=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.subquery" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：class： <cite>.Alias`の中に埋め込まれた：class：</cite> .Query`で表される完全なSELECT文を返します。</p>
<p>クエリ内のEager JOIN生成は無効になります。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.query.Query.subquery.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.subquery.params.name">¶</a> -- エイリアスとして割り当てる文字列名。これは：meth： <cite>.FromClause.alias`に渡されます。 `</cite> None``の場合、コンパイル時に名前が確定的に生成されます。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.subquery.params.with_labels"></span><strong>with_labels</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.subquery.params.with_labels">¶</a> -- Trueの場合、：meth： <cite>.with_labels`が最初に：class：</cite> .Query`で呼び出され、すべての列に表修飾ラベルを適用します。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.subquery.params.reduce_columns"></span><strong>reduce_columns</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.subquery.params.reduce_columns">¶</a> -- Trueの場合、：meth： <cite>.Select.reduce_columns`が結果：func：</cite> .select`構文に対して呼び出され、外部キーまたはWHERE句の同値性を介して他のものを参照する同じ名前の列を削除します。 .. versionchanged :: 0.8 `` with_labels``と `` reduce_columns``キーワード引数が追加されました。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.suffix_with">
<code class="descname">suffix_with</code><span class="sig-paren">(</span><em>*suffixes</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.suffix_with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クエリにサフィックスを適用し、新しく生成された `` Query``を返します。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.suffix_with.params.*suffixes"></span><strong>*suffixes</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.suffix_with.params.*suffixes">¶</a> -- オプションの接尾辞、通常は文字列で、カンマは使用しません。</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.prefix_with</cite></p>
<p class="last">：meth： <cite>.HasSuffixes.suffix_with</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.union" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つまたは複数のクエリに対してこのクエリのUNIONを生成します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q1</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">foo</span><span class="o">==</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">bar</span><span class="o">==</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="n">q3</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span></pre></div>
</div>
<p>このメソッドは、複数のQueryオブジェクトを受け入れて、ネスティングのレベルを制御します。次のような一連の `` union（） <a href="#id1"><span class="problematic" id="id2">``</span></a>呼び出し：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>それぞれの `` union（） <a href="#id1"><span class="problematic" id="id2">``</span></a>にネストし、次のものを生成します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">X</span> <span class="n">UNION</span>
                <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">y</span><span class="p">)</span> <span class="n">UNION</span> <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">Z</span><span class="p">)</span></pre></div>
</div>
<p>一方、:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></pre></div>
</div>
<p>生成:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="p">(</span><span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">X</span> <span class="n">UNION</span> <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">y</span> <span class="n">UNION</span>
                <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">Z</span><span class="p">)</span></pre></div>
</div>
<p>多くのデータベースバックエンドでは、UNION、EXCEPTなどで呼び出されるクエリでORDER BYをレンダリングできないことに注意してください。マッパーで構成されたORDER BY節を含むすべてのORDER BY節を無効にするには、 `` query.order_by（None） `` ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトは、SELECTステートメント内でORDER BYをレンダリングしません。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.union_all">
<code class="descname">union_all</code><span class="sig-paren">(</span><em>*q</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.union_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つ以上のクエリに対してこのクエリのUNION ALLを生成します。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.union`と同じように動作します。使用例については、その方法を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>values</em>, <em>synchronize_session='evaluate'</em>, <em>update_args=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一括更新クエリを実行します。</p>
<p>データベース内のこのクエリで一致する行を更新します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">age</span><span class="p">:</span> <span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="mi">10</span><span class="p">},</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">update</span><span class="p">({</span><span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="n">User</span><span class="o">.</span><span class="n">age</span> <span class="o">-</span> <span class="mi">10</span><span class="p">},</span> <span class="n">synchronize_session</span><span class="o">=</span><span class="s1">&#39;evaluate&#39;</span><span class="p">)</span></pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.update`メソッドはORM作業単位自動化をバイパスして、パフォーマンスを向上させるための&amp;quot; bulk &amp;quot;操作です。 <strong>下記のすべての警告と警告をお読みください。</strong></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.query.Query.update.params.values"></span><strong>values</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.update.params.values">¶</a> -- 属性名または代替としてマップされた属性またはSQL式をキーとするリテラル値またはSQL式を値として持つ辞書。 if：ref： <cite>パラメータ順モード&lt;updates_order_parameters&gt; `が望ましい場合、値は2タプルのリストとして渡すことができます。これには、：paramref： `〜sqlalchemy.sql.expression.update.preserve_parameter_order`フラグが：paramref：</cite> .Query.update.update_args`ディクショナリにも渡されている必要があります。 .. versionchanged :: 1.0.0  - 値辞書の文字列名がマッピングされたエンティティに対して解決されるようになりました。これらの文字列は、マッパーレベルの変換を行わずにリテラル列名として渡されていました。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.update.params.synchronize_session"></span><strong>synchronize_session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.update.params.synchronize_session">¶</a> -- セッション内のオブジェクトの属性を更新する方法を選択します。有効な値は次のとおりです： `` False``  - セッションを同期しません。このオプションは、セッションが期限切れになると最も効率的で信頼性が高くなります。通常、commit（）の後に実行されるか、expire_all（）を明示的に使用します。期限切れになる前に、更新されたオブジェクトがセッションに残っていて、その属性の古い値が残っていると、結果が混乱する可能性があります。 `` &amp;#39;fetch&amp;#39;``  - 更新の前に選択クエリを実行して、更新クエリと一致するオブジェクトを見つけます。更新された属性は、一致するオブジェクトで期限切れになります。 `` &amp;#39;evaluate&amp;#39;``  - セッション内のオブジェクトに対してPythonのクエリの基準を直接評価します。基準の評価が実装されていない場合、例外が発生します。エクスプレッションエバリュエーターは現在、データベースとPythonの異なる文字列照合を考慮していません。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.update.params.update_args"></span><strong>update_args</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.update.params.update_args">¶</a> -- 省略可能な辞書が存在する場合、そのオブジェクトの `` ** kw``として基本的な：func： <cite>.update`構造体に渡されます。 `</cite> mysql_limit``のようなダイアレクト固有の引数だけでなく、paramref： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.sql.expression.update.preserve_parameter_order`のような他の特殊な引数も渡すことができます。 .. versionadded :: 1.0.0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">戻り値:</th><td class="field-body"><p class="first last">データベースの&amp;quot;行数&amp;quot;機能によって返された行の数が一致します。</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p><strong>一括クエリの更新に関する追加の警告</strong></p>
<ul class="last">
<li><p class="first">このメソッドは、Pythonのin-Pythonカスケード関係を提供していません**それを必要とする外部キー参照に対してON UPDATE CASCADEが構成されていると仮定します。そうしないと、外部キー参照が強制されている場合、データベースは整合性違反を発生させる可能性があります。</p>
<p>UPDATEの後、ON：更新CASCADEの影響を受けた：class： <cite>.Session`の従属オブジェクトに現在の状態が含まれないことがあります。この問題は：class： `.Session`が期限切れになると解決されます。これは通常：meth：</cite> .Session.commit`で発生するか、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Session.expire_all`を使って強制できます。</p>
</li>
<li><p class="first">`` &amp;#39;fetch``戦略は、追加のSELECT文を発行し、パフォーマンスを大幅に低下させます。</p>
</li>
<li><p class="first">`` &amp;#39;evaluate&amp;#39;``戦略は：class： <cite>.Session</cite>;内のすべての一致するオブジェクトのスキャンを実行します。 proceeding：meth： <cite>.Session.commit`呼び出しのように、：class：</cite> .Session`の内容が期限切れになっている場合、<a href="#id1"><span class="problematic" id="id2">**</span></a>これは一致するすべてのオブジェクト**に対してSELECTクエリを発行します。</p>
</li>
<li><p class="first">このメソッドは：ref： <cite>multi_table_updates`で詳述されているように、複数のテーブルの更新をサポートしています。この動作は、継承継承やその他の複数のテーブルマッピングの更新をサポートするために拡張されています。ただし、継承マッパーの**結合条件は自動的にはレンダリングされません**。これが通常自動的なマッピングであっても、これらのテーブル間の結合条件を明示的に含めるためには、複数テーブルの更新に注意する必要があります。例えば ​​`</cite> Engineer``クラスが `` Employee``をサブクラス化している場合、 `` Employee``ローカルテーブルに対する基準を使って `` Engineer``ローカルテーブルの更新は次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Engineer</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Engineer</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Employee</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Employee</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;dilbert&#39;</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">update</span><span class="p">({</span><span class="s2">&quot;engineer_type&quot;</span><span class="p">:</span> <span class="s2">&quot;programmer&quot;</span><span class="p">})</span></pre></div>
</div>
</li>
<li><p class="first">多相識別WHERE条件は単一または結合テーブルの更新に**含まれません**単一のテーブルの継承の場合でも**手動で**追加する必要があります。</p>
</li>
<li><p class="first">：meth： <cite>.MapperEvents.before_update`と：meth：</cite> .MapperEvents.after_update`イベント**はこのメソッドから呼び出されません**。代わりに、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.SessionEvents.after_bulk_update`メソッドは、エンティティ行の大量更新に作用するために提供されています。</p>
</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>：meth： <cite>.Query.delete</cite></p>
<p class="last">：ref： <cite>inserts_and_updates</cite>  - コアSQLチュートリアル</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>column</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された列式に対応するスカラー結果を返します。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.values">
<code class="descname">values</code><span class="sig-paren">(</span><em>*columns</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された列のリストに対応する結果タプルを返すイテレータを返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Query.whereclause">
<code class="descname">whereclause</code><a class="headerlink" href="#sqlalchemy.orm.query.Query.whereclause" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクエリの現在のWHERE条件を返すreadonly属性。</p>
<p>この戻り値は、SQL式の構文であり、基準が確立されていない場合は `` None``です。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_entities">
<code class="descname">with_entities</code><span class="sig-paren">(</span><em>*entities</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_entities" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を返し、SELECTリストを指定されたエンティティに置き換えます。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Users, filtered on some arbitrary criterion</span>
<span class="c1"># and then ordered by related email address</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="o">.</span>\
            <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span><span class="o">.</span>\
            <span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="p">)</span>

<span class="c1"># given *only* User.id==5, Address.email, and &#39;q&#39;, what</span>
<span class="c1"># would the *next* User in the result be ?</span>
<span class="n">subq</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">with_entities</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">order_by</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span>\
            <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span>\
            <span class="n">subquery</span><span class="p">()</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">subq</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email</span> <span class="o">&lt;</span> <span class="n">Address</span><span class="o">.</span><span class="n">email</span><span class="p">))</span><span class="o">.</span>\
            <span class="n">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.6.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_for_update">
<code class="descname">with_for_update</code><span class="sig-paren">(</span><em>read=False</em>, <em>nowait=False</em>, <em>of=None</em>, <em>skip_locked=False</em>, <em>key_share=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_for_update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>`` FOR UPDATE``節に指定されたオプションを使って、新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`を返します。</p>
<p>このメソッドの動作は：meth： <cite>.SelectBase.with_for_update`の動作と同じです。引数なしで呼び出されると、結果として得られる `</cite> SELECT``文には、 `` FOR UPDATE``節が追加されます。追加引数を指定すると、 `` FOR UPDATE NOWAIT`や `` LOCK IN SHARE MODE`のようなバックエンド固有のオプションが有効になります。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">with_for_update</span><span class="p">(</span><span class="n">nowait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">of</span><span class="o">=</span><span class="n">User</span><span class="p">)</span></pre></div>
</div>
<p>PostgreSQLのバックエンドに関する上記のクエリは、次のようにレンダリングされます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">users</span><span class="o">.</span><span class="n">id</span> <span class="n">AS</span> <span class="n">users_id</span> <span class="n">FROM</span> <span class="n">users</span> <span class="n">FOR</span> <span class="n">UPDATE</span> <span class="n">OF</span> <span class="n">users</span> <span class="n">NOWAIT</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加: </span>：meth： <cite>.Query.with_for_update`は：meth：</cite> .Query.with_lockmode`メソッドに取って代わるものです。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.GenerativeSelect.with_for_update</cite>  - 完全な引数と動作記述を持つコアレベルのメソッド。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_hint">
<code class="descname">with_hint</code><span class="sig-paren">(</span><em>selectable</em>, <em>text</em>, <em>dialect_name='*'</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_hint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたエンティティに対して索引付けまたはその他の実行コンテキストヒントを追加するか、これをclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`に選択できます。</p>
<p>機能は：meth： <cite>〜sqlalchemy.sql.expression.Select.with_hint`に直接渡され、</cite> <cite>selectable``は：class：</cite> .Table`、：class： <cite>.Alias</cite>、 ORMエンティティ/マップされたクラス/ etc</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.with_statement_hint</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_labels">
<code class="descname">with_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_labels" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Query.statementの戻り値に列ラベルを適用します。</p>
<p>このQueryの <a href="#id1"><span class="problematic" id="id2">`</span></a>ステートメント`アクセサは、フォーム内のすべてのカラムにラベルを適用するSELECT文を返す必要があることを示します&lt;tablename&gt; _ &lt;columnname&gt; ;これは、同じ名前を持つ複数の表から列を明確にするためによく使用されます。</p>
<p><a href="#id1"><span class="problematic" id="id2">`</span></a>Query`が実際に行をロードするためにSQLを発行するとき、常にカラムのラベリングが使用されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>：meth： <cite>.Query.with_labels`メソッドは*：attr：</cite> .Query.statement`の出力を適用します。<em>：</em>：<em>。</em> * <em>の結果行呼び出しシステムには</em> <a href="#id1"><span class="problematic" id="id2">*</span></a>例えば：meth： <cite>.Query.first</cite>、：meth：` .Query.all`など：meth： <cite>.Query.with_labels`を使用してクエリを実行するには、：attr：</cite> .Query.statement`を呼び出します。 using：meth： <cite>.Session.execute</cite></p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">with_labels</span><span class="p">()</span><span class="o">.</span><span class="n">statement</span><span class="p">)</span></pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_lockmode">
<code class="descname">with_lockmode</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_lockmode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい：class： <cite>.Query`オブジェクトを、指​​定した&amp;quot;ロックモード &amp;quot;で返します。これは基本的に</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>FOR UPDATE``節を参照します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 0.9.0 で撤廃: </span>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.with_for_update`に取って代わる。</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.query.Query.with_lockmode.params.mode"></span><strong>mode</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.with_lockmode.params.mode">¶</a> -- 所望のロックモードを表す文字列有効な値は次のとおりです：* `` None``  - ロックモードにならない* `` &amp;#39;update&amp;#39;``  -  `` FOR UPDATE``（標準SQL、ほとんどの方言でサポートされています）* <code class="docutils literal notranslate"><span class="pre">&amp;#39;</span> <span class="pre">update_nowait</span> <span class="pre">&amp;#39;</span></code> * `` &amp;#39;read&amp;#39;``  -  `` LOCK IN SHARE MODE``（MySQLの場合）、 `` FOR SHARE``（ `` MySQLの場合）&amp;#39; &amp;#39;に変換されます。 PostgreSQL用）</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.with_for_update</cite>  - ` <a href="#id1"><span class="problematic" id="id2">`</span></a>FOR UPDATE``節を指定するための改良されたAPIです。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_parent">
<code class="descname">with_parent</code><span class="sig-paren">(</span><em>instance</em>, <em>property=None</em>, <em>from_entity=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたインスタンスを子オブジェクトまたはコレクションに関連付けるフィルタリング基準を、その属性状態とestablished：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship（）`設定を使用して追加します。</p>
<p>このメソッドは：func： <cite>.with_parent`関数を使用して節を生成します。その結果は：meth：</cite> .Query.filter`に渡されます。</p>
<p>パラメータは：func： <cite>.with_parent`と同じですが、指定されたプロパティはNoneにすることができます。この場合、class：</cite> .Query`オブジェクトのターゲットマッパーに対して検索が実行されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.query.Query.with_parent.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.with_parent.params.instance">¶</a> -- いくつかの：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`を持つインスタンス。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.with_parent.params.property"></span><strong>property</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.with_parent.params.property">¶</a> -- 親/子関係を調整するためにインスタンスからどのような関係を使用するかを示すStringプロパティ名またはクラスバインド属性。</li>
<li><span class="target" id="sqlalchemy.orm.query.Query.with_parent.params.from_entity"></span><strong>from_entity</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Query.with_parent.params.from_entity">¶</a> -- 左辺として考慮するエンティティ。これは、デフォルトでは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`自体の&amp;quot; zero &amp;quot;エンティティになります。</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_polymorphic">
<code class="descname">with_polymorphic</code><span class="sig-paren">(</span><em>cls_or_mappers</em>, <em>selectable=None</em>, <em>polymorphic_on=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_polymorphic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスを継承する列をロードします。</p>
<p>：meth： <cite>.Query.with_polymorphic`は、クラス：</cite> .Query`で表されるマップされたクラスに変換を適用します。マップされたメインクラスは、：class： <cite>.Query`オブジェクトの最初の引数がフルクラス、つまり</cite> <cite>session.query（SomeClass）</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>であることを意味します。これらの変換では、FROM句に追加の表が存在するため、ロード時の効率とクエリ時にこれらの列を使用できるように、継承継承サブクラスの列をクエリで使用できるようになります。</p>
<p>このメソッドの使い方の詳細については、ドキュメンテーションのsection：ref： <a href="#id1"><span class="problematic" id="id2">`</span></a>with_polymorphic`を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.8 で変更: </span>：class： <cite>.Query`内の任意のカラムまたはクラスのセットに同等の機能を適用できるので、より柔軟で新しい関数func：</cite> .orm.with_polymorphic`は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.with_polymorphic`を置き換えます。 &amp;quot;ゼロマッパ&amp;quot;だけではありません。引数の説明については、この関数を参照してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_session">
<code class="descname">with_session</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_session" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた：class： <cite>.Session`を使う：class：</cite> .Query`を返します。</p>
<p>：class： <cite>.Query`オブジェクトは通常、：meth：</cite> .Session.query`メソッドを使ってインスタンス化されますが、必ず：class： <cite>.Query`を直接ビルドすることはできません：class：</cite>。Session <cite>。そのような：class： `.Query`オブジェクト、またはすでに：class：</cite> .Query`はすでに異なる：class： <cite>.Session`に関連付けられていますが、ターゲットセッションに関連する新しい：class：</cite> .Query`オブジェクトを生成できますこのメソッドを使用して:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Query</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">Query</span><span class="p">([</span><span class="n">MyClass</span><span class="p">])</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">with_session</span><span class="p">(</span><span class="n">my_session</span><span class="p">)</span><span class="o">.</span><span class="n">one</span><span class="p">()</span></pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_statement_hint">
<code class="descname">with_statement_hint</code><span class="sig-paren">(</span><em>text</em>, <em>dialect_name='*'</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_statement_hint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これに文のヒントを追加してください：class： <cite>.Select</cite>。</p>
<p>このメソッドは：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Select.with_hint`に似ていますが、個々のテーブルを必要とせず、ステートメント全体に適用されます。</p>
<p>この機能は：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Select.with_statement_hint`を呼び出します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 1.0.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.with_hint</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.with_transformation">
<code class="descname">with_transformation</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.with_transformation" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた関数によって変換された新しい：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトを返します。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filter_something</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transform</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">with_transformation</span><span class="p">(</span><span class="n">filter_something</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">5</span><span class="p">))</span></pre></div>
</div>
<p>これにより：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトに対してアドホックなレシピを作成することができます。 ：ref： <a href="#id3"><span class="problematic" id="id4">`</span></a>hybrid_transformers`の例を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.7.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Query.yield_per">
<code class="descname">yield_per</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Query.yield_per" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一度に `` count``行だけを返します。</p>
<p>このメソッドの目的は、非常に大きな結果セット（&amp;gt; 10K行）を取り出し、バッチ処理でサブコレクションを生成し、部分的にそれらを生成するときです。そのため、Pythonインタプリタは非常に大きな領域のメモリを宣言する必要はありません時間がかかり過度のメモリー使用につながります。行をバッファリングするDBAPI（ほとんどの場合）を使用していても、適切なyield-per設定（たとえば約1000）が使用されると、何十万行もフェッチすることによるパフォーマンスが2倍になることがあります。</p>
<p>：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.yield_per`メソッド**は、コレクションを使用しているときに、サブクエロイルロードを熱くロードするか、または結合ロードを熱心にロードする**互換性がありません。データベースドライバが複数の独立したカーソルをサポートしていれば**（pysqliteとpsycopg2は動作することが知られていますが、MySQLとSQL ServerのODBCドライバは動作しません）。</p>
<p>したがって、場合によっては、熱心な負荷を無条件に：meth： <cite>.Query.enable_eagerloads</cite> ::で無効にすると便利です</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Object</span><span class="p">)</span><span class="o">.</span><span class="n">yield_per</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">enable_eagerloads</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></pre></div>
</div>
<p>または、より選択的に：func： <cite>.lazyload</cite>;を使用します。アスタリスクを使用してデフォルトのローダースキームを指定するなど、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Object</span><span class="p">)</span><span class="o">.</span><span class="n">yield_per</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">options</span><span class="p">(</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">),</span> <span class="n">joinedload</span><span class="p">(</span><span class="n">Object</span><span class="o">.</span><span class="n">some_related</span><span class="p">))</span></pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>この方法は慎重に使用してください。同じインスタンスが複数の行のバッチに存在する場合、属性に対するエンドユーザーの変更は上書きされます。</p>
<p>特に、後で結果バッチで遭遇したときに、それらのコレクションが新しいロードに対してクリアされるため、熱心にロードされたコレクション（つまり、lazy = &amp;#39;joined&amp;#39;または &amp;#39;subquery&amp;#39;）でこの設定を使用することは通常不可能です。 &amp;#39;サブクエリ&amp;#39;ローディングの場合、すべての行の完全な結果がフェッチされます。これは一般的に：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.orm.query.Query.yield_per`の目的を無効にします。</p>
<p class="last">また、：meth： <cite>〜sqlalchemy.orm.query.Query.yield_per`は</cite> <cite>stream_results``実行オプションをTrueに設定しますが、現在のところmod：</cite>〜sqlalchemy.dialects.postgresql.psycopg2 <cite>、：mod：</cite>〜sqlalchemy.dialects.mysql.mysqldb`とmod： <a href="#id1"><span class="problematic" id="id2">`</span></a>〜sqlalchemy.dialects.mysql.pymysql`は、このクエリのすべての行をプリバッファするのではなく、サーバ側のカーソルを使って結果をストリームします。他のDBAPI <a href="#id3"><span class="problematic" id="id4">**</span></a>はすべての行**をプリバッファリングしてから使用可能にします。未処理のデータベース行のメモリ使用量は、ORMでマップされたオブジェクトのメモリ使用量よりもはるかに少ないですが、ベンチマーク時には引き続き考慮する必要があります。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.Query.enable_eagerloads</cite></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="orm-specific-query-constructs">
<h2>ORM固有のクエリ構文<a class="headerlink" href="#orm-specific-query-constructs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="sqlalchemy.orm.aliased">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">aliased</code><span class="sig-paren">(</span><em>element</em>, <em>alias=None</em>, <em>name=None</em>, <em>flat=False</em>, <em>adapt_on_names=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.aliased" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された要素のエイリアスを生成します。通常は：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedClass`インスタンスです。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">my_alias</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">my_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span></pre></div>
</div>
<p>：func： <cite>.aliased`関数は、マッピングされたクラスを新しい選択可能なものにアドホックマッピングするために使用されます。デフォルトでは、：meth： `.FromClause.alias`メソッドを使用して、通常マップされた選択可能なもの（通常は：class：</cite> .Table`）から選択可能なものが生成されます。しかし、：func： <cite>.aliased`を使ってクラスをnew：func：</cite> .select`ステートメントにリンクすることもできます。また、：func： <cite>.with_polymorphic`関数はfunc：</cite> .aliased`の変形です。これはいわゆる &amp;quot;多形選択可能&amp;quot;を指定することを意図しています。これは複数の継承継承サブクラスの和集合に相当します。一度。</p>
<p>便宜上、：func： <cite>.aliased`関数は、：class：</cite> .Table`や：func： <cite>.select`などのplain：class：</cite> .FromClause`構文も受け入れます。そのような場合、オブジェクトに対して：meth： <cite>.FromClause.alias`メソッドが呼び出され、new：class：</cite> .Alias`オブジェクトが返されます。この場合、返された：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Alias`はORMマップされません。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.aliased.params.element"></span><strong>element</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.aliased.params.element">¶</a> -- エイリアスする要素。通常はマップされたクラスですが、便宜上、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.FromClause`エレメントにすることもできます。</li>
<li><span class="target" id="sqlalchemy.orm.aliased.params.alias"></span><strong>alias</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.aliased.params.alias">¶</a> -- 要素をマップするオプションの選択可能な単位。これは通常、クラスがマップされる：class： <cite>.Table`に対応する：class：</cite> .Alias`オブジェクト、またはマッピングと互換性のある：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.select`構造体です。デフォルトでは、マップされたテーブルの単純な匿名エイリアスが生成されます。</li>
<li><span class="target" id="sqlalchemy.orm.aliased.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.aliased.params.name">¶</a> -- `` alias``パラメータで指定されていない場合、エイリアスに使用するオプションの文字列名。名前は、とりわけ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`オブジェクトによって返されるタプルを介してアクセス可能な属性名を形成します。</li>
<li><span class="target" id="sqlalchemy.orm.aliased.params.flat"></span><strong>flat</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.aliased.params.flat">¶</a> -- Boolean：は：meth： <cite>.FromClause.alias`呼び出しに渡され、class：</cite> .Join`オブジェクトのエイリアスには囲みSELECTが含まれません。これにより、多くの状況でより効率的なクエリにつながる可能性があります。ネストされたJOINに対するJOINは、この構文をサポートしていないバックエンド上のエイリアス化されたSELECTサブクエリに対するJOINとして書き換えられます。 .. versionadded :: 0.9.0 .. seealso :: meth： <cite>.Join.alias</cite></li>
<li><span class="target" id="sqlalchemy.orm.aliased.params.adapt_on_names"></span><strong>adapt_on_names</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.aliased.params.adapt_on_names">¶</a> -- Trueの場合、ORMエンティティのマッピングされた列を指定された選択可能なものにマッピングするときに、よりリベラルな&amp;quot;マッチング&amp;quot;が使用されます - 指定された選択可能なものが、エンティティの1つにこのためのユースケースは、集約関数を使用するような、派生した選択可能なものにエンティティを関連付ける場合です。class UnitPrice（Base）：__tablename__ = &amp;#39;unit_price&amp;#39; ... unit_id =列（整数）price =列（数値）aggregated_unit_price （UnitPrice.unice_price、adapt_on_names = True）上記の関数は以下のようになります：= Session.query（func.sum（UnitPrice.price）.label（ &amp;#39;price&amp;#39;））.group_by（UnitPrice.unit_id）.subquery（）aggregated_unit_price = aliased（UnitPrice、alias = aggregated_unit_price、adapt_on_names = True） `` .price``を参照する `` aggregated_unit_price``は `` func.sum（UnitPrice.price）.label（ &amp;#39;price&amp;#39;） <a href="#id1"><span class="problematic" id="id2">``</span></a>カラムを返します。 。通常、&amp;quot;price &amp;quot;関数は元のプロキシではないので、実際の `` UnitPrice.price``列には&amp;quot;列の対応&amp;quot;がありません。 .. versionadded :: 0.7.3</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.orm.util.AliasedClass">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.util.</code><code class="descname">AliasedClass</code><span class="sig-paren">(</span><em>cls</em>, <em>alias=None</em>, <em>name=None</em>, <em>flat=False</em>, <em>adapt_on_names=False</em>, <em>with_polymorphic_mappers=()</em>, <em>with_polymorphic_discriminator=None</em>, <em>base_alias=None</em>, <em>use_mapper_path=False</em>, <em>represents_outer_join=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.util.AliasedClass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Queryでの使用のためのマップされたクラスの&amp;quot;エイリアス&amp;quot;形式を表します。</p>
<p>a：func： <cite>sqlalchemy.sql.expression.alias`構造体のORMに相当するこのオブジェクトは、__getattr__体系を使用してマッピングされたクラスを模倣し、real：class：</cite>〜sqlalchemy.sql.expression.Alias`オブジェクトへの参照を保持します。</p>
<p>使用法は、：func： <cite>.orm.aliased`関数か、または：func：</cite> .orm.with_polymorphic`関数を介して行います。</p>
<p>使用例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># find all pairs of users with the same name</span>
<span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">user_alias</span><span class="p">)</span><span class="o">.</span>\
                <span class="n">join</span><span class="p">((</span><span class="n">user_alias</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">user_alias</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span>\
                <span class="nb">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">user_alias</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></pre></div>
</div>
<p>結果として得られるオブジェクトは：class： <cite>.AliasedClass`のインスタンスです。このオブジェクトは、元のマップされたクラスと同じ属性およびメソッドインタフェースを生成する属性スキームを実装しています。class： `.AliasedClass`は、ハイブリッド属性を含む元のクラスで動作する属性技法と互換性があります（ref： `hybrids_toplevel</cite>）。</p>
<p>：class： <cite>.AliasedClass`は、class：</cite> .Mapper`、エイリアスセレクト可能、その他の情報を調べることができます：func： <cite>.inspect</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="n">my_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>
<span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">my_alias</span><span class="p">)</span></pre></div>
</div>
<p>結果の検査オブジェクトは、：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedInsp`のインスタンスです。</p>
<p>参照：func： <cite>.aliased`と：func：</cite> .with_polymorphic`は構築引数の説明です。</p>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.orm.util.AliasedInsp">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.util.</code><code class="descname">AliasedInsp</code><span class="sig-paren">(</span><em>entity</em>, <em>mapper</em>, <em>selectable</em>, <em>name</em>, <em>with_polymorphic_mappers</em>, <em>polymorphic_on</em>, <em>_base_alias</em>, <em>_use_mapper_path</em>, <em>adapt_on_names</em>, <em>represents_outer_join</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.util.AliasedInsp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="internals.html#sqlalchemy.orm.base.InspectionAttr" title="sqlalchemy.orm.base.InspectionAttr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.base.InspectionAttr</span></code></a></p>
<p>an：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedClass`オブジェクトに対する検査インタフェースを提供します。</p>
<p>：class： <cite>.AliasedInsp`オブジェクトは：func：</cite> .inspect`関数を使って：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedClass`を返します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">aliased</span>

<span class="n">my_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">MyMappedClass</span><span class="p">)</span>
<span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">my_alias</span><span class="p">)</span></pre></div>
</div>
<p>属性：class： <cite>.AliasedInsp</cite> include：</p>
<ul class="simple">
<li>`` entity``  - ：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.AliasedClass`が表現されています。</li>
<li>`` mapper``：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Mapper`は基底のクラスをマッピングします。</li>
<li>class： <cite>.Table`または：class：</cite> .Select`構造体を最終的に表す `` Selectable``：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Alias`構造体です。</li>
<li>`` name``  - エイリアスの名前。クラス： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`から結果タプルに返されたときの属性名としても使用されます。</li>
<li>`` with_polymorphic_mappers``  - ：class： <cite>.AaasedClass`のselect構造体で表現されたすべてのマッパーを示すclass：</cite> .Mapper`オブジェクトのコレクションです。</li>
<li>`` polymorphic_on``  - ポリモーフィックなロードのための&amp;quot;discriminator &amp;quot;として使用される代替の列またはSQL式です。</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>inspection_toplevel</cite></p>
</div>
</dd></dl>

<dl class="class">
<dt id="sqlalchemy.orm.query.Bundle">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.query.</code><code class="descname">Bundle</code><span class="sig-paren">(</span><em>name</em>, <em>*exprs</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Bundle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="internals.html#sqlalchemy.orm.base.InspectionAttr" title="sqlalchemy.orm.base.InspectionAttr"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.base.InspectionAttr</span></code></a></p>
<p>1つの名前空間の下で：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`によって返されるSQL式のグループ化。</p>
<p>：class： <cite>.Bundle`は、本質的に、列指向の：class：</cite> .Query`オブジェクトによって返されたタプルベースの結果のネストを可能にします。また、単純なサブクラス化によって拡張できます。主な機能は、ORM IDマッピング・クラスを使用せずに、後処理およびカスタム戻り型を可能にする式のセットを戻す方法です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.9.0 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>bundles</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.query.Bundle.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name</em>, <em>*exprs</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Construct a new <a class="reference internal" href="#sqlalchemy.orm.query.Bundle" title="sqlalchemy.orm.query.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a>.</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bn</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s2">&quot;mybundle&quot;</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">bn</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">mybundle</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">mybundle</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.query.Bundle.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Bundle.params.name">¶</a> -- name of the bundle.</li>
<li><span class="target" id="sqlalchemy.orm.query.Bundle.params.*exprs"></span><strong>*exprs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Bundle.params.*exprs">¶</a> -- columns or SQL expressions comprising the bundle.</li>
<li><span class="target" id="sqlalchemy.orm.query.Bundle.params.single_entity"></span><strong>single_entity=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.query.Bundle.params.single_entity">¶</a> -- if True, rows for this <a class="reference internal" href="#sqlalchemy.orm.query.Bundle" title="sqlalchemy.orm.query.Bundle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bundle</span></code></a>
can be returned as a &quot;single entity&quot; outside of any enclosing tuple
in the same manner as a mapped entity.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Bundle.c">
<code class="descname">c</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.c" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：attr： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Bundle.columns`の別名です。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Bundle.columns">
<code class="descname">columns</code><em class="property"> = None</em><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.columns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Bundle`によって参照されるSQL式の名前空間。</p>
<blockquote>
<div><p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bn</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s2">&quot;mybundle&quot;</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span></pre></div>
</div>
<p>バンドルのネストもサポートされています:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b1</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">(</span><span class="s2">&quot;b1&quot;</span><span class="p">,</span>
        <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;b2&#39;</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">b</span><span class="p">),</span>
        <span class="n">Bundle</span><span class="p">(</span><span class="s1">&#39;b3&#39;</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">b3</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span></pre></div>
</div>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：attr： <cite>.Bundle.c</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Bundle.create_row_processor">
<code class="descname">create_row_processor</code><span class="sig-paren">(</span><em>query</em>, <em>procs</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.create_row_processor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このために &amp;quot;行処理&amp;quot;関数を生成する：class： <cite>.Bundle</cite>。</p>
<p>サブクラスによってオーバーライドされることがあります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>bundles</cite>  - サブクラス化の例を含んでいます。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.query.Bundle.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.label" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>this：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Bundle`のコピーに新しいラベルを渡します。</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.orm.query.Bundle.single_entity">
<code class="descname">single_entity</code><em class="property"> = False</em><a class="headerlink" href="#sqlalchemy.orm.query.Bundle.single_entity" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Trueの場合、単一のBundleに対するクエリは、キー付きタプル内の要素ではなく、単一のエンティティとして返されます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.util.KeyedTuple">
<em class="property">class </em><code class="descclassname">sqlalchemy.util.</code><code class="descname">KeyedTuple</code><a class="headerlink" href="#sqlalchemy.util.KeyedTuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.util._collections.AbstractKeyedTuple</span></code></p>
<p>ラベル付きの名前を追加する `` tuple``サブクラスです。</p>
<p>例えば：：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">KeyedTuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span><span class="o">.</span><span class="n">one</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span><span class="o">.</span><span class="n">two</span>
<span class="go">2</span></pre></div>
</div>
<p>複数のORMエンティティおよび/または列式を含む結果の行：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`は、このクラスを使用して行を返します。</p>
<p>：class： <cite>.KeyedTuple`は、Python標準ライブラリで提供されている</cite> <cite>collections.namedtuple（）</cite> <cite>構造と似た動作をしますが、非常に異なったアーキテクチャーです。 ：class： `.KeyedTuple`インスタンスは、</cite> <cite>collections.namedtuple（）</cite> <cite>とは異なり、新しい一連のキーを表現するためにカスタムサブタイプの作成に頼るのではなく、のキーの配置。 `</cite> collections.namedtuple（） <a href="#id1"><span class="problematic" id="id2">``</span></a>のサブタイプのアプローチは、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`オブジェクトのユースケースでは不要な、かなりの複雑さとパフォーマンスのオーバーヘッドをもたらします。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.8 で変更: </span>attr： <cite>.KeyedTuple._fields`と：meth：</cite> .KeyedTuple._asdict`を含む `` collections.namedtuple（） <a href="#id1"><span class="problematic" id="id2">``</span></a>との互換性メソッドが追加されました。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>ormtutorial_querying</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.util.KeyedTuple._asdict">
<code class="descname">_asdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.util.KeyedTuple._asdict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これを辞書としてclass： <a href="#id1"><span class="problematic" id="id2">`</span></a>.KeyedTuple`の内容を返します。</p>
<p>このメソッドは `` collections.namedtuple（） <a href="#id1"><span class="problematic" id="id2">``</span></a>との互換性を提供しますが、返される辞書は** not ** orderedです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlalchemy.util.KeyedTuple._fields">
<code class="descname">_fields</code><a class="headerlink" href="#sqlalchemy.util.KeyedTuple._fields" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このための文字列キー名のタプルを返します：class： <cite>.KeyedTuple</cite>。</p>
<p>このメソッドは、 `` collections.namedtuple（） <a href="#id1"><span class="problematic" id="id2">``</span></a>との互換性を提供します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 0.8 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：meth： <cite>.KeyedTuple.keys</cite></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.util.KeyedTuple.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.util.KeyedTuple.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="inherited-member docutils container">
<em>inherited from the</em> <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> <em>method of</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractKeyedTuple</span></code></div>
<p>このための文字列キー名のリストを返します：class： <cite>.KeyedTuple</cite>。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：attr： <cite>.KeyedTuple._fields</cite></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sqlalchemy.orm.strategy_options.Load">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.strategy_options.</code><code class="descname">Load</code><span class="sig-paren">(</span><em>entity</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.Generative</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sqlalchemy.orm.interfaces.MapperOption</span></code></p>
<p>さまざまなマップされた属性のロード方法に影響を与えるために：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`の状態を変更するローダーオプションを表します。</p>
<p>：class： <cite>.Load`オブジェクトは、ほとんどの場合、func：</cite> .joinedload`、：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.defer`などのようなクエリオプションを使用すると暗黙のうちに暗黙的に使用されます。しかし、：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Load`オブジェクトも直接使用することができ、場合によっては便利です。</p>
<p>：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`を直接使用するには、ターゲットとしてマップされたクラスを引数としてインスタンス化します。このスタイルは、複数のエンティティを持つ：class： <a href="#id3"><span class="problematic" id="id4">`</span></a>.Query`を扱うときに便利です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myopt</span> <span class="o">=</span> <span class="n">Load</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span><span class="o">.</span><span class="n">joinedload</span><span class="p">(</span><span class="s2">&quot;widgets&quot;</span><span class="p">)</span></pre></div>
</div>
<p>上記の `` myopt``は：meth： <cite>.Query.options`で使用できるようになりました。ここで</cite> <a href="#id1"><span class="problematic" id="id2">`</span></a>MyClass``エンティティにのみ有効です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">MyOtherClass</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">myopt</span><span class="p">)</span></pre></div>
</div>
<p>class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Load`はパブリックAPIとして便利です：特定のクラスに対してのみ有効な&amp;quot;ワイルドカード&amp;quot;オプションを指定する場合:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">Load</span><span class="p">(</span><span class="n">Order</span><span class="p">)</span><span class="o">.</span><span class="n">lazyload</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span></pre></div>
</div>
<p>上では、 `` Order``のすべてのリレーションシップは遅延ロードされますが、それらの子孫オブジェクトの他のアトリビュートは通常のローダー戦略を使用してロードされます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">：ref： <cite>loading_toplevel</cite></p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.baked_lazyload">
<code class="descname">baked_lazyload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.baked_lazyload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.baked_lazyload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.baked_lazyload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.contains_eager">
<code class="descname">contains_eager</code><span class="sig-paren">(</span><em>attr</em>, <em>alias=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.contains_eager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.contains_eager`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.contains_eager`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.defaultload">
<code class="descname">defaultload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.defaultload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.defaultload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.defaultload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.defer">
<code class="descname">defer</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.defer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.defer`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.defer`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.immediateload">
<code class="descname">immediateload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.immediateload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.immediateload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.immediateload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.joinedload">
<code class="descname">joinedload</code><span class="sig-paren">(</span><em>attr</em>, <em>innerjoin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.joinedload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しい：class： <cite>.Load`オブジェクトを生成します：：func：</cite> .orm.joinedload`オプションが適用されます。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.joinedload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.lazyload">
<code class="descname">lazyload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.lazyload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.lazyload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.lazyload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.load_only">
<code class="descname">load_only</code><span class="sig-paren">(</span><em>*attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.load_only" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.load_only`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.load_only`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.noload">
<code class="descname">noload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.noload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.noload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.noload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.process_query">
<code class="descname">process_query</code><span class="sig-paren">(</span><em>query</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.process_query" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Apply a modification to the given <a class="reference internal" href="#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal notranslate"><span class="pre">Query</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.process_query_conditionally">
<code class="descname">process_query_conditionally</code><span class="sig-paren">(</span><em>query</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.process_query_conditionally" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>same as process_query(), except that this option may not
apply to the given query.</p>
<p>This is typically used during a lazy load or scalar refresh
operation to propagate options stated in the original Query to the
new Query being used for the load.  It occurs for those options that
specify propagate_to_loaders=True.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.raiseload">
<code class="descname">raiseload</code><span class="sig-paren">(</span><em>attr</em>, <em>sql_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.raiseload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.raiseload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.raiseload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.selectin_polymorphic">
<code class="descname">selectin_polymorphic</code><span class="sig-paren">(</span><em>classes</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.selectin_polymorphic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.selectin_polymorphic`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.selectin_polymorphic`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.selectinload">
<code class="descname">selectinload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.selectinload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.selectinload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.selectinload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.subqueryload">
<code class="descname">subqueryload</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.subqueryload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.subqueryload`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.subqueryload`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.undefer">
<code class="descname">undefer</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.undefer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.undefer`オプションを適用して、新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例はfunc： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.undefer`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.undefer_group">
<code class="descname">undefer_group</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.undefer_group" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.undefer_group`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.undefer_group`を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.strategy_options.Load.with_expression">
<code class="descname">with_expression</code><span class="sig-paren">(</span><em>key</em>, <em>expression</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.strategy_options.Load.with_expression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>：func： <cite>.orm.with_expression`オプションが適用された新しい：class：</cite> .Load`オブジェクトを生成します。</p>
<p>使用例については、func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.with_expression`を参照してください。</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.join">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">join</code><span class="sig-paren">(</span><em>left</em>, <em>right</em>, <em>onclause=None</em>, <em>isouter=False</em>, <em>full=False</em>, <em>join_to_left=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>左節と右節の間で内部結合を作成します。</p>
<p>：func： <cite>.orm.join`は：func：</cite> .sql.expression.join（） <cite>によって提供されるコア結合インタフェースの拡張です。ここで、左と右の選択可能なものは次のようなコア選択可能オブジェクトだけではありません：class ： `.Table`だけでなく、マップされたクラスまたは：class：</cite> .AliasedClass`インスタンスも含みます。 &amp;quot;on &amp;quot;句は、SQL式、またはconfigured：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`を参照する属性または文字列名にすることができます。</p>
<p>：func： <cite>.orm.join`は、その機能が：meth：</cite> .Query.join`メソッドの中にカプセル化されているので、最近の使用法では一般的には必要ありません。 orm.join`それ自身。 ：class： <cite>.Query`を使って：func：</cite> .orm.join`を明示的に使用すると、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.select_from`メソッドの使用が含まれます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">join</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
    <span class="n">select_from</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span>\
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;foo@bar.com&#39;</span><span class="p">)</span></pre></div>
</div>
<p>現代のSQLAlchemyでは、上記の結合はより簡潔に:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span><span class="o">.</span>\
        <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;foo@bar.com&#39;</span><span class="p">)</span></pre></div>
</div>
<p>現代のORMレベル結合の使い方については、：meth： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query.join`を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 0.8.1 で変更: </span>- the <code class="docutils literal notranslate"><span class="pre">join_to_left</span></code> parameter
is no longer used, and is deprecated.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.outerjoin">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">outerjoin</code><span class="sig-paren">(</span><em>left</em>, <em>right</em>, <em>onclause=None</em>, <em>full=False</em>, <em>join_to_left=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.outerjoin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>左節と右節の間で左外部結合を作成します。</p>
<p>これは：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.orm.join`関数の&amp;quot;外部結合&amp;quot;バージョンで、OUTER JOINが生成される以外は同じ動作をします。その他の使用法の詳細については、その関数のドキュメントを参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="sqlalchemy.orm.with_parent">
<code class="descclassname">sqlalchemy.orm.</code><code class="descname">with_parent</code><span class="sig-paren">(</span><em>instance</em>, <em>prop</em>, <em>from_entity=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.with_parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>established：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship（）`設定を使用して、このクエリのプライマリエンティティを関連するインスタンスに関連付けるフィルタリング基準を作成します。</p>
<p>レンダリングされたSQLは、遅延ローダーがその属性の与えられた親から起動するときにレンダリングされるSQLと同じです。つまり、レンダリングで親テーブルへの結合をレンダリングする必要なしにPythonの親オブジェクトから適切な状態が取得されます。ステートメント。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.with_parent.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_parent.params.instance">¶</a> -- いくつかの：func： <a href="#id1"><span class="problematic" id="id2">`</span></a>.relationship`を持つインスタンス。</li>
<li><span class="target" id="sqlalchemy.orm.with_parent.params.property"></span><strong>property</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_parent.params.property">¶</a> -- 親/子関係を調整するためにインスタンスからどのような関係を使用するかを示すStringプロパティ名またはクラスバインド属性。</li>
<li><span class="target" id="sqlalchemy.orm.with_parent.params.from_entity"></span><strong>from_entity</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.with_parent.params.from_entity">¶</a> -- 左辺として考慮するエンティティ。これは、デフォルトでは：class： <a href="#id1"><span class="problematic" id="id2">`</span></a>.Query`自体の&amp;quot; zero &amp;quot;エンティティになります。 .. versionadded :: 1.2</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="constructors.html" title="previous chapter">コンストラクタとオブジェクトの初期化</a>
        Next:
        <a href="session.html" title="next chapter">セッションの使用</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2018, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.3.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


